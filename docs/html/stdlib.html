<link rel='stylesheet' href='stylesheet.css'>
<h1>Overview</h1>

<p>Upon startup, the parable language consists of one function and the functionality
exposed by the parser. The initial function is <em>define</em>. The standard libary is
provided to make Parable into a useful language.</p>

<h1>The Functions</h1>

<h2>define</h2>

<p><em>define</em> is used to attach a name to a pointer.</p>

<pre><code>pointer string --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>:n</h2>

<p>Convert a value to a number.</p>

<pre><code>value -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>:s</h2>

<p>Convert a value to a string.</p>

<pre><code>value -- string
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>:c</h2>

<p>Convert a value to a character.</p>

<pre><code>value -- character
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>:p</h2>

<p>Convert a value to a pointer.</p>

<pre><code>value -- pointer
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>:f</h2>

<p>Convert a value to a flag.</p>

<pre><code>value -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>type?</h2>

<p>Return a number indicating the type of the top value on the stack. This will
correspond to <em>NUMBER</em>, <em>CHARACTER</em>, <em>STRING</em>, <em>POINTER</em>, or <em>FLAG</em>.</p>

<pre><code>value -- value number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>+</h2>

<p>Add A to B, returning the result.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>-</h2>

<p>Subtract B from A, returning the result.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>*</h2>

<p>Multiply A by B, returning a result.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>/</h2>

<p>Divide A by B, returning the result.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>rem</h2>

<p>Divide A by B, returning the remainder.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>floor</h2>

<p>Return the largest integer value less than or equal to number.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>^</h2>

<p>math.pow(x, y)</p>

<p>Return A raised to the power of B.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>log</h2>

<p>Return the natural logarithm of number (to base e).</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>log10</h2>

<p>Return the base 10 logarithm of number.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>log<n></h2>

<p>Return the logarithm of a to the given base, calculated as log(a)/log(b)</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>shift</h2>

<p>Perform a bitwise shift of A by B bits. If B is negative, shift left, otherwise shift right.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>and</h2>

<p>Perform a bitwise AND operation on the two values provided.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>or</h2>

<p>Perform a bitwise OR operation on the two values provided.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>xor</h2>

<p>Perform a bitwise XOR operation on the two values provided.</p>

<pre><code>number:a number:b -- number:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>random</h2>

<p>Return a random number between zero and one.</p>

<pre><code>-- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>sqrt</h2>

<p>Calculate and return the square root of a number.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>&lt;</h2>

<p>Compare two values for less than. Returns a flag.</p>

<pre><code>number:a number:b -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>></h2>

<p>Compare two values for greater than. Returns a flag.</p>

<pre><code>number:a number:b -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h1>&lt;=</h1>

<p>Compare two values for less than or equal to. Returns a flag.</p>

<pre><code>number:a number:b -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>>=</h2>

<p>Compare two values for greater than or equal to. Returns a flag.</p>

<pre><code>number:a number:b -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>=</h2>

<p>Compare two values for equality. Returns a flag.</p>

<pre><code>value value -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>&lt;></h2>

<p>Compare two values for inequality. Returns a flag.</p>

<pre><code>value value -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>if</h2>

<p>If flag is true, execute pointer:true. Otherwise, execute pointer:false.</p>

<pre><code>flag pointer:true pointer:false --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>while-true</h2>

<p>Execute the code in pointer repeatedly, until the code returns a flag of <em>false</em>.
The code must return a flag after each execution cycle.</p>

<pre><code>pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>while-false</h2>

<p>Execute the code in pointer repeatedly, until the code returns a flag of <em>true</em>.
The code must return a flag after each execution cycle.</p>

<pre><code>pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>repeat</h2>

<p>Execute the code at pointer the specified number of times.</p>

<pre><code>number pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>invoke</h2>

<p>Execute the code at pointer.</p>

<pre><code>pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>dip</h2>

<p>Remove value from the stack, and execute pointer. After execution is complete,
restore the value to the stack.</p>

<pre><code>value pointer -- value
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>sip</h2>

<p>Execute pointer with a copy of value on the stack. Restores value to the stack
after execution completes.</p>

<pre><code>value pointer -- value
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>bi</h2>

<p>Apply each quotation to a copy of value.</p>

<pre><code>value pointer:a pointer:b -- ?
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>tri</h2>

<p>Apply each quotation to a copy of value.</p>

<pre><code>value pointer:a pointer:b pointer:c -- ?
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>copy</h2>

<p>Copy the contents of the source slice into the destination slice.</p>

<pre><code>pointer:source pointer:dest --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>fetch</h2>

<p>Fetch a value from the specified offset in a slice.</p>

<pre><code>pointer number:offset -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>store</h2>

<p>Store a value into a slice at a specified offset.</p>

<pre><code>value pointer number:offset --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>request</h2>

<p>Allocate a new slice and return a pointer to it.</p>

<pre><code>-- pointer
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>release</h2>

<p>Release an allocated slice. This will be reclaimed by the garbage collector.</p>

<pre><code>pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>collect-garbage</h2>

<p>Perform a garbage collection cycle.</p>

<pre><code>--
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>get-buffer-length</h2>

<p>Return the length of a slice.</p>

<pre><code>pointer -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>set-buffer-length</h2>

<p>Set the length of a slice to the specified size.</p>

<pre><code>number pointer --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>dup</h2>

<p>Duplicate the top value on the stack.</p>

<pre><code>value -- value value
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>drop</h2>

<p>Remove a value from the stack.</p>

<pre><code>value --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>swap</h2>

<p>Switch the positions of the top two items on the stack.</p>

<pre><code>value:a value:b -- value:b value:a
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>over</h2>

<p>Put a copy of the second item on the stack over the first item.</p>

<pre><code>value:a value:b -- value:a value:b value:a
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>tuck</h2>

<p>Put a copy of the first item on the stack under the second item.</p>

<pre><code>value:a value:b -- value:b value:a value:b
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>nip</h2>

<p>Remove the second item on the stack.</p>

<pre><code>value:a value:b -- value:b
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>depth</h2>

<p>Return the number of items on the stack.</p>

<pre><code>-- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>reset</h2>

<p>Remove all items from the stack.</p>

<pre><code>... --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>function-exists?</h2>

<p>Given a string containing a function name, returns <em>true</em> if the function 
exists or <em>false</em> if it does not.</p>

<pre><code>string -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>lookup-function</h2>

<p>Given a string, return a pointer to the or data under that name. If the function does not exist, returns a pointer to -1 (a guaranteed invalid slice).</p>

<pre><code>string -- pointer
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>hide-function</h2>

<p>Given a string, remove the header corresponding to the name. This does not remove the definition, just disassociates the name from the slice.</p>

<pre><code>string --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>find</h2>

<p>Find substring <em>needle</em> in string <em>haystack</em>. Returns the starting offset, or -1 if no match is found.</p>

<pre><code>string:haystack string:needle -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>subslice</h2>

<p>Return a new slice containing the contents of the slice at pointer, starting from the specified offset, and ending at (but not including) the ending offset.</p>

<pre><code>pointer number:start number:end -- pointer:result
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>numeric?</h2>

<p>Given a string, returns <strong>true</strong> if the string is a valid number, or <strong>false</strong> otherwise.</p>

<pre><code>string -- flag
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>to-uppercase</h2>

<p>Convert a CHARACTER or STRING to uppercase.</p>

<pre><code>value -- value
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>to-lowercase</h2>

<p>Convert a CHARACTER or STRING to lowercase.</p>

<pre><code>value -- value
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>report-error</h2>

<p>Add the specified string to the system error log.</p>

<pre><code>string --
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>sin</h2>

<p>Calculate the sine of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>cos</h2>

<p>Calculate the cosine of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>tan</h2>

<p>Calculate the tangent of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>asin</h2>

<p>Calculate the arcsine of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>acos</h2>

<p>Calculate the arccosine of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>atan</h2>

<p>Calculate the arctangent of a number, with the result in radians.</p>

<pre><code>number -- number
</code></pre>

<h2>atan2</h2>

<p>Return atan(y / x), in radians</p>

<pre><code>number:x number:y -- number
</code></pre>

<p>This is a primitive corresponding to a byte code.</p>

<h2>NUMBER</h2>

<p>Constant; value for the NUMBER data type.</p>

<pre><code>-- number
</code></pre>

<h2>STRING</h2>

<p>Constant; value for the STRING data type.</p>

<pre><code>-- number
</code></pre>

<h2>CHARACTER</h2>

<p>Constant; value for the CHARACTER data type.</p>

<pre><code>-- number
</code></pre>

<h2>POINTER</h2>

<p>Constant; value for the POINTER data type.</p>

<pre><code>-- number
</code></pre>

<h2>FLAG</h2>

<p>Constant; value for the FLAG data type.</p>

<pre><code>-- number
</code></pre>

<h2>bi*</h2>

<p>Apply pointer:a to value:a and pointer:b to value:b. Returns the results.</p>

<pre><code>value:a value:b pointer:a pointer:b -- ?
</code></pre>

<h2>tri*</h2>

<p>Apply pointer:a to value:a, pointer:b to value:b, and pointer:c to value:c. Returns the results.</p>

<pre><code>value:a value:b value:c pointer:a pointer:b pointer:c -- ?
</code></pre>

<h2>bi@</h2>

<p>Apply code at pointer to a value:a and value:b. Returns the results.</p>

<pre><code>value:a value:b pointer -- ?
</code></pre>

<h2>tri@</h2>

<p>Apply code at pointer to a value:a, value:b, and value:c. Returns the results.</p>

<pre><code>value:a value:b value:c pointer -- ?
</code></pre>

<h2>dup-pair</h2>

<p>Duplicate the top two values on the stack.</p>

<pre><code>value:a value:b -- value:a value:b value:a value:b
</code></pre>

<h2>drop-pair</h2>

<p>Drop two values off the stack.</p>

<pre><code>value value --
</code></pre>

<h2>true</h2>

<p>Return a true flag.</p>

<pre><code>-- flag
</code></pre>

<h2>false</h2>

<p>Return a false flag.</p>

<pre><code>-- flag
</code></pre>

<h2>not</h2>

<p>Invert the flag on the stack.</p>

<pre><code>flag -- flag
</code></pre>

<h2>if-true</h2>

<p>Execute the code at pointer if flag is true.</p>

<pre><code>flag pointer --
</code></pre>

<h2>if-false</h2>

<p>Execute the code at pointer if flag is false.</p>

<pre><code>flag pointer --
</code></pre>

<h2>zero?</h2>

<p>Returns <strong>true</strong> if the number is equal to zero, or <strong>false</strong> if not.</p>

<pre><code>number -- flag
</code></pre>

<h2>true?</h2>

<p>Returns <strong>true</strong> if the value can be converted to a <strong>true</strong> flag, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>false</h2>

<p>Returns <strong>true</strong> if the value can be converted to a <strong>false</strong> flag, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>even?</h2>

<p>Return <strong>true</strong> if number is even, or <strong>false</strong> otherwise.</p>

<pre><code>number -- flag
</code></pre>

<h2>odd?</h2>

<p>Return <strong>true</strong> if number is odd, or <strong>false</strong> otherwise.</p>

<pre><code>number -- flag
</code></pre>

<h2>negative?</h2>

<p>Return <strong>true</strong> if number is negative, or <strong>false</strong> otherwise.</p>

<pre><code>number -- flag
</code></pre>

<h2>positive?</h2>

<p>Return <strong>true</strong> if number is positive, or <strong>false</strong> otherwise.</p>

<pre><code>number -- flag
</code></pre>

<h2>if-character</h2>

<p>Execute the code in pointer if value is a CHARACTER</p>

<pre><code>value pointer --
</code></pre>

<h2>if-string</h2>

<p>Execute the code in pointer if value is a STRING</p>

<pre><code>value pointer --
</code></pre>

<h2>if-number</h2>

<p>Execute the code in pointer if value is a NUMBER</p>

<pre><code>value pointer --
</code></pre>

<h2>if-pointer</h2>

<p>Execute the code in pointer if value is a POINTER</p>

<pre><code>value pointer --
</code></pre>

<h2>if-flag</h2>

<p>Execute the code in pointer if value is a FLAG</p>

<pre><code>value pointer --
</code></pre>

<h2>between?</h2>

<p>Return <strong>true</strong> if A is between B and C, inclusive. Or <strong>false</strong> otherwise.</p>

<pre><code>number:a number:b number:c -- flag
</code></pre>

<h2>variable</h2>

<p>Create a simple named variable</p>

<pre><code>string --
</code></pre>

<h2>variable!</h2>

<p>Create a simple named variable with an initial value.</p>

<pre><code>value string --
</code></pre>

<h2>@</h2>

<p>Fetch the value stored in a simple variable.</p>

<pre><code>pointer -- number
</code></pre>

<h2>!</h2>

<p>Store value into a simple variable.</p>

<pre><code>value pointer --
</code></pre>

<h2>on</h2>

<p>Set a simple variable to a value of -1.</p>

<pre><code>pointer --
</code></pre>

<h2>off</h2>

<p>Set a simple variable to a value of 0.</p>

<pre><code>pointer --
</code></pre>

<h2>increment</h2>

<p>Increment the value of a simple variable by 1.</p>

<pre><code>pointer --
</code></pre>

<h2>decrement</h2>

<p>Decrement the value of a simple variable by 1.</p>

<pre><code>pointer --
</code></pre>

<h2>zero-out</h2>

<p>Set a slice to a length of zero and wipe out any stored values in the process.</p>

<pre><code>pointer --
</code></pre>

<h2>preserve</h2>

<p>Execute code in <em>pointer:code</em>, preserving and restoring the data in the <em>pointer:data</em>.</p>

<pre><code>pointer:data pointer:code --
</code></pre>

<h2>expand-range</h2>

<p>Return a numeric range starting with lower and ending with upper, inclusive. All values are placed on the stack.</p>

<pre><code>number:lower number:upper -- ...
</code></pre>

<h2>sum-range</h2>

<p>Add <em>number</em> values on the stack.</p>

<pre><code>... number -- number
</code></pre>

<h2>slice-length</h2>

<p>Return the length of a slice. Unlike <strong>get-slice-length</strong> this does not consume the pointer.</p>

<pre><code>pointer -- pointer number
</code></pre>

<h2>adjust-slice-length</h2>

<p>Adjust the length of a slice. You can use this to shrink or grow slices as needed.</p>

<pre><code>number pointer --
</code></pre>

<h2>invoke-and-count-items-returned</h2>

<p>Execute the code at pointer, and return the results of execution, and a value indicating the number of items returned (or consumed) as a result.</p>

<pre><code>pointer -- ? number
</code></pre>

<h2>invoke-and-count-items-returned-with-adjustment</h2>

<p>Execute the code at pointer, and return the results of execution, and a value indicating the number of items returned (or consumed) as a result. Adds <em>number</em> to the results.</p>

<pre><code>pointer number -- ? number
</code></pre>

<h2>drop-multiple</h2>

<p>Drop the specified number of values from the stack.</p>

<pre><code>... number -- ?
</code></pre>

<h2>hide-functions</h2>

<p>Execute code at pointer, and remove the function names it pushes to the stack.</p>

<pre><code>pointer --
</code></pre>

<h2>rename-function</h2>

<p>Remove the old header for a function and attach the new one to it.</p>

<pre><code>string:old string:new --
</code></pre>

<h2>variables</h2>

<p>Execute code at pointer, and create a simple variable for each name that it returns.</p>

<pre><code>pointer --
</code></pre>

<h2>string-contains?</h2>

<p>Returns <strong>true</strong> if value is found in the specified string, or <strong>false</strong> otherwise.</p>

<pre><code>value string -- flag
</code></pre>

<h2>digit?</h2>

<p>Return <strong>true</strong> if value is a numeric digit, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>symbol?</h2>

<p>Return <strong>true</strong> if value is an ASCII symbol, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>letter?</h2>

<p>Return <strong>true</strong> if value is a letter, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>alphanumeric?</h2>

<p>Return <strong>true</strong> if value is a letter or numeric digit, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>consonant?</h2>

<p>Return <strong>true</strong> if the value is a consonant, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>vowel?</h2>

<p>Return <strong>true</strong> if the value is a vowel, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>lowercase?</h2>

<p>Return <strong>true</strong> if the value is a lowercase character, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>uppercase?</h2>

<p>Return <strong>true</strong> if the value is an uppercase character, or <strong>false</strong> otherwise.</p>

<pre><code>value -- flag
</code></pre>

<h2>build-string</h2>

<p>Execute the code in the specified slice, and construct a string from the returned values.</p>

<pre><code>pointer -- string
</code></pre>

<h2>trim-left</h2>

<p>Trim leading white space from a string.</p>

<pre><code>string -- string
</code></pre>

<h2>trim-right</h2>

<p>Trim trailing white space from a string.</p>

<pre><code>string -- string
</code></pre>

<h2>trim</h2>

<p>Trim all leading and trailing white space from a string.</p>

<pre><code>string -- string
</code></pre>

<h2>abs</h2>

<p>Return the absolute value of a number.</p>

<pre><code>number -- number
</code></pre>

<h2>min</h2>

<p>Return the lesser of two numbers.</p>

<pre><code>number number -- number
</code></pre>

<h2>max</h2>

<p>Return the greater of two numbers.</p>

<pre><code>number number -- number
</code></pre>

<h2>factorial</h2>

<p>Return the factorial of a number.</p>

<pre><code>number -- number
</code></pre>

<h2>*CURRENT-BUFFER</h2>

<p>Variable.</p>

<p>Variable holding the current buffer slice number.</p>

<pre><code>-- pointer
</code></pre>

<h2>*BUFFER-OFFSET</h2>

<p>Variable.</p>

<p>Variable holding the current offset into the current buffer.</p>

<pre><code>-- pointer
</code></pre>

<h2>current-buffer</h2>

<p>Return a pointer to the current buffer.</p>

<pre><code>-- pointer
</code></pre>

<h2>buffer-position</h2>

<p>Returns the current buffer and offset pair.</p>

<pre><code>-- pointer number
</code></pre>

<h2>buffer-advance</h2>

<p>Increment the current buffer offset.</p>

<pre><code>--
</code></pre>

<h2>buffer-retreat</h2>

<p>Decrement the current buffer offset.</p>

<pre><code>--
</code></pre>

<h2>buffer-store-current</h2>

<p>Store a value into the current location in the buffer.</p>

<pre><code>value --
</code></pre>

<h2>buffer-fetch-current</h2>

<p>Fetch the value at the current location in the buffer.</p>

<pre><code>-- number
</code></pre>

<h2>buffer-store</h2>

<p>Store a value into the current location in the buffer, and then increment to the next offset.</p>

<pre><code>value --
</code></pre>

<h2>buffer-fetch</h2>

<p>Fetch a value from the current location in the buffer, and then increment to the next offset.</p>

<pre><code>-- number
</code></pre>

<h2>buffer-store-retreat</h2>

<p>Store a value into the current location in the buffer, and then decrement to the next offset.</p>

<pre><code>value --
</code></pre>

<h2>buffer-fetch-retreat</h2>

<p>Fetch a value from the current location in the buffer, and then decrement to the next offset.</p>

<pre><code>-- number
</code></pre>

<h2>set-buffer</h2>

<p>Set pointer as the active buffer.</p>

<pre><code>pointer --
</code></pre>

<h2>buffer-store-items</h2>

<p>Store the specified number of values into the buffer.</p>

<pre><code>... number --
</code></pre>

<h2>new-buffer</h2>

<p>Allocate a new buffer and set it as the active one.</p>

<pre><code>--
</code></pre>

<h2>preserve-buffer</h2>

<p>Execute the code at <em>pointer</em>, while preserving and restoring the current buffer and offset. (This
allows the code in the slice to allocate a new buffer, and restores the old settings when done.)</p>

<pre><code>pointer --
</code></pre>

<h2>named-buffer</h2>

<p>Create a new buffer, and attach a name to it.</p>

<pre><code>string --
</code></pre>

<h2>array-push</h2>

<p>Push a value to the end of an array.</p>

<pre><code>value pointer --
</code></pre>

<h2>array-pop</h2>

<p>Pop a value off of an array.</p>

<pre><code>pointer -- number
</code></pre>

<h2>array-length</h2>

<p>Return the length of an array.</p>

<pre><code>pointer -- number
</code></pre>

<h2>array-reduce</h2>

<p>Reduce an array to a single value.</p>

<pre><code>pointer:array number pointer:code -- number
</code></pre>

<p>Example:</p>

<pre><code>[ #1 #2 #3 ] array-from-quote
#0 [ + ] array-reduce
</code></pre>

<h2>array-from-quote<in-stack-order></h2>

<p>Execute code in slice, and return an array constructed from the values in it.</p>

<pre><code>pointer -- pointer
</code></pre>

<h2>array-reverse</h2>

<p>Reverse the order of values in an array.</p>

<pre><code>pointer -- pointer
</code></pre>

<h2>array-from-quote</h2>

<p>Execute code in slice, and return an array constructed from the values in it. Like <strong>array-from-pointer<in-stack-order></strong>, but
reverses the order of the elements.</p>

<pre><code>pointer -- pointer
</code></pre>

<h2>for-each</h2>

<p>Execute code in <strong>pointer:code</strong> once for each element in the array.</p>

<pre><code>pointer:data pointer:code -- ?
</code></pre>

<h2>array-contains</h2>

<p>[ "pv-f"   swap needs-remap? [ swap dup set-buffer array-length #0 swap [ over buffer-fetch array<remap> = or ] repeat ] preserve-buffer nip :f ] 'array-contains?' define</p>

<h2>array-filter</h2>

<p>[ "pp-p"   prepare [ &amp;source @ array-pop dup &amp;filter @ invoke [ &amp;results array-push ] [ drop ] if ] repeat &amp;results request [ copy ] sip ] 'array-filter' define</p>

<h2>array-map</h2>

<p>[ "pp-p"   prepare [ &amp;source @ array-pop &amp;filter @ invoke &amp;results array-push ] repeat &amp;results request [ copy ] sip ] 'array-map' define</p>

<h2>array-compare</h2>

<p>[ "pp-f"   dup-pair [ array-length ] bi@ = [ dup array-length true swap [ [ dup-pair [ array-pop ] bi@ = ] dip and ] repeat [ drop-pair ] dip :f ] [ drop-pair false ] if ] 'array-compare' define</p>

<h2>array-to-string</h2>

<p>[ "pointer:array number:type - string"  #100 / #1 - &amp;<em>array:conversions</em> swap fetch :p invoke ] 'array-to-string' define</p>

<h2>convert-with-base</h2>

<p>Convert string into a number using the current base.</p>

<pre><code>string number -- number
</code></pre>

<h2>convert-from-binary</h2>

<p>Convert a string containing a binary value into a number.</p>

<pre><code>string -- number
</code></pre>

<h2>convert-from-octal</h2>

<p>Convert a string containing a octal value into a number.</p>

<pre><code>string -- number
</code></pre>

<h2>convert-from-decimal</h2>

<p>Convert a string containing a decimal value into a number.</p>

<pre><code>string -- number
</code></pre>

<h2>convert-from-hexadecimal</h2>

<p>Convert a string containing a hexadecimal value into a number.</p>

<pre><code>string -- number
</code></pre>

<h2>curry</h2>

<p>Given a value and a quotation, return a new quotation that applies the original to the value.</p>

<pre><code>value pointer -- pointer
</code></pre>

<h2>to</h2>

<p>Set a flag so that the next value will update it's stored value rather than returing it.</p>

<pre><code>--
</code></pre>

<h2>value</h2>

<p>Create a new value.</p>

<pre><code>string --
</code></pre>

<h2>value!</h2>

<p>Create a new value with an initial value.</p>

<pre><code>value string --
</code></pre>

<h2>values</h2>

<p>Execute code in pointer, creating a new value for each name. The code should return a series of strings.</p>

<pre><code>pointer --
</code></pre>

<h2>array-to-quote</h2>

<p>Convert an array of values into a string. The number identifies the data type in the array.</p>

<pre><code>pointer number -- string
</code></pre>

<h2>array-index-of</h2>

<p>Return the offset of the specified value in the array.</p>

<pre><code>value pointer -- number
</code></pre>

<h2>show-tob</h2>

<p>Push the strings in the text output buffer to the stack.</p>

<pre><code>-- ...
</code></pre>

<h2>clear-tob</h2>

<p>Remove all items from the text output buffer.</p>

<pre><code>--
</code></pre>

<h2>.</h2>

<p>Append a value to the text output buffer.</p>

<pre><code>value --
</code></pre>

<h2>hash:djb2</h2>

<p>Hash a string using the DJB2 algo.</p>

<pre><code>string -- number
</code></pre>

<h2>hash:sdbm</h2>

<p>Hash a string using the SDBM algo.</p>

<pre><code>string -- number
</code></pre>

<h2>hash:lrc</h2>

<p>Hash a string using the LRC algo.</p>

<pre><code>string -- number
</code></pre>

<h2>hash:xor</h2>

<p>Hash a string using the XOR algo.</p>

<pre><code>string -- number
</code></pre>

<h2>chosen-hash</h2>

<p>This should be set to the preferred hash function. Defaults to <strong>hash:djb2</strong>.</p>

<pre><code>string -- number
</code></pre>

<h2>hash-prime</h2>

<p>Constant, prime number for hash functionality</p>

<pre><code>-- number
</code></pre>

<h2>hash</h2>

<p>Invoke <strong>chosen-hash</strong>, then modulus against the <strong>hash-prime</strong>.</p>

<pre><code>string -- number
</code></pre>

<h2>math:pi</h2>

<p>Constant, value of PI (3.14159...)</p>

<pre><code>-- number
</code></pre>

<h2>math:tau</h2>

<p>Constant, value of Tau. (6.28318...)</p>

<pre><code>-- number
</code></pre>

<h2>math:e</h2>

<p>Constant, value of E (2.71828...)</p>

<pre><code>-- number
</code></pre>

<h2>math:golden-ratio</h2>

<p>Constant, value of golden ratio (1.61803...)</p>

<pre><code>-- number
</code></pre>

<h2>math:euler-mascheroni</h2>

<p>Constant, value of Euler-Mascheroni (0.57721...)</p>

<pre><code>-- number
</code></pre>

<h2>math:pythagora</h2>

<p>Constant, value of Pythagora (1.414213...)</p>

<pre><code>-- number
</code></pre>

<h2>math:inverse-golden-ratio</h2>

<p>Constant, value of inverse golden ratio (0.61803...)</p>

<pre><code>-- number
</code></pre>

<h2>math:silver-ratio/mean</h2>

<p>Constant, value of silver ration / mean (2.41421...)</p>

<pre><code>-- number
</code></pre>

<h2>time:seconds/minute</h2>

<p>Constant, value of seconds per minute</p>

<pre><code>-- number
</code></pre>

<h2>time:minutes/hour</h2>

<p>Constant, value of minutes per hour</p>

<pre><code>-- number
</code></pre>

<h2>time:hours/day</h2>

<p>Constant, value of hours per day</p>

<pre><code>-- number
</code></pre>

<h2>time:days/week</h2>

<p>Constant, value of days per week</p>

<pre><code>-- number
</code></pre>

<h2>time:weeks/year</h2>

<p>Constant, value of weeks per year</p>

<pre><code>-- number
</code></pre>

<h2>time:months/year</h2>

<p>Constant, value of months per year</p>

<pre><code>-- number
</code></pre>

<h2>time:days/year</h2>

<p>Constant, value of days per year</p>

<pre><code>-- number
</code></pre>

<h2>time:days/julian-year</h2>

<p>Constant, value of days per julian year</p>

<pre><code>-- number
</code></pre>

<h2>time:greagorian/year</h2>

<p>Constant, value of days per greagorian year</p>

<pre><code>-- number
</code></pre>
