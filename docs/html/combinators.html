<link rel='stylesheet' href='stylesheet.css'>
<h1>Combinators</h1>

<p>A combinator is a function that consumes functions as input. These are
divided into three primary types: compositional, execution flow, and data
flow.</p>

<h2>Compositional</h2>

<p>A compositional combinator takes elements from the stack and returns a
new quote.</p>

<p><strong>cons</strong> takes two values from the stack and returns a new quote that
will push these values to the stack when executed.</p>

<pre><code>1 2 cons
</code></pre>

<p>Functionally, this is the same as:</p>

<pre><code>[ 1 2 ]
</code></pre>

<p><strong>take</strong> pulls a value and a quote from the stack and returns a new
quote executing the specified quote before pushing the value to the
stack.</p>

<pre><code>4 [ 1+ ] take
</code></pre>

<p>Functionally this is the same as:</p>

<pre><code>[ 1+ 4 ]
</code></pre>

<p><strong>curry</strong> takes a value and a quote and returns a new quote applying
the specified quote to the specified value. As an example,</p>

<pre><code>: acc ( n- )  here swap , [ dup ++ @ ] curry ;
</code></pre>

<p>This would create an accumulator function, which takes an initial value
and returns a quote that will increase the accumulator by 1 each time it
is invoked. It will also return the latest value. So:</p>

<pre><code>10 acc
dup do putn
dup do putn
dup do putn
</code></pre>

<h2>Execution Flow</h2>

<p>Combinators of this type execute other functions.</p>

<h3>Fundamental</h3>

<p><strong>invoke</strong> takes a quote and executes it immediately.</p>

<pre><code>[ #1 . ] invoke
&amp;show-tob invoke
</code></pre>

<h3>Conditionals</h3>

<p>Retro provides four combinators for use with conditional execution of
quotes. These are <strong>if</strong>, <strong>if-true</strong>, <strong>if-false</strong>.</p>

<p><strong>if</strong> takes a flag and two quotes from the stack. If the flag is
<em>true</em>, the first quote is executed. If false, the second quote is
executed.</p>

<pre><code>true  [ "true" . ] [ "false" . ] if
false [ "true" . ] [ "false" . ] if
</code></pre>

<p><strong>if-true</strong> takes a flag and one quote from the stack. If the flag is true,
the quote is executed. If false, the quote is discarded.</p>

<pre><code>true  [ "true" . ] if-true
false [ "true" . ] if-true
</code></pre>

<p><strong>if-false</strong> takes a flag and one quote from the stack. If the flag is false,
the quote is executed. If true, the quote is discarded.</p>

<pre><code>true  [ "false" . ] if-false
false [ "false" . ] if-false
</code></pre>

<h3>Looping</h3>

<p>Several combinators are available for handling various looping constructs.</p>

<p><strong>while-true</strong> takes a quote from the stack and executes it repeatedly as long
as the quote returns a <em>true</em> flag on the stack.</p>

<pre><code>#10 [ dup . #1 - dup #0 &lt;&gt; ] while-true
</code></pre>

<p><strong>repeat</strong> takes a count and quote from the stack. The quote will be executed
the number of times specified. No indexes are pushed to the stack.</p>

<pre><code>#1 #10 [ dup . #1 + ] repeat
</code></pre>

<h3>Data Flow</h3>

<p>These combinators exist to simplify stack usage in various circumstances.</p>

<h4>Preserving</h4>

<p>Preserving combinators execute code while preserving portions of the data stack.</p>

<p><strong>dip</strong> takes a value and a quote, moves the value off the main stack
temporarily, executes the quote, and then restores the value.</p>

<pre><code>#10 #20 [ #1 + ] dip
</code></pre>

<p>Would yield the following on the stack:</p>

<pre><code>#11 #20
</code></pre>

<p><strong>sip</strong> is similar to <strong>dip</strong>, but leaves a copy of the original value on
the stack during execution of the quote. So:</p>

<pre><code>#10 [ #1 + ] sip
</code></pre>

<p>Leaves us with:</p>

<pre><code>#11 #10
</code></pre>

<h4>Cleave</h4>

<p>Cleave combinators apply multiple quotations to a single value or set
of values.</p>

<p><strong>bi</strong> takes a value and two quotes, it then applies each quote to a
copy of the value.</p>

<pre><code>#100 [ #1 + ] [ #1 - ] bi
</code></pre>

<p><strong>tri</strong> takes a value and three quotes. It then applies each quote to a
copy of the value.</p>

<pre><code>#100 [ #1 + ] [ #1 - ] [ dup * ] tri
</code></pre>

<h4>Spread</h4>

<p>Spread combinators apply multiple quotations to multiple values. The asterisk
suffixed to these function names signifies that they are spread combinators.</p>

<p><strong>bi*</strong> takes two values and two quotes. It applies the first quote to the
first value and the second quote to the second value.</p>

<pre><code>#1 #2 [ #1 + ] [ #2 * ] bi*
</code></pre>

<p><strong>tri*</strong> takes three values and three quotes, applying the first quote to
the first value, the second quote to the second value, and the third quote
to the third value.</p>

<pre><code>#1 #2 #3 [ #1 + ] [ #2 * ] [ #1 - ] tri*
</code></pre>

<h4>Apply</h4>

<p>Apply combinators apply a single quotation to multiple values. The at sign
suffixed to these function names signifies that they are apply combinators.</p>

<p><strong>bi@</strong> takes two values and a quote. It then applies the quote to each value.</p>

<pre><code>#1 #2 [ #1 + ] bi@
</code></pre>

<p><strong>tri@</strong> takes three values and a quote. It then applies the quote to each
value.</p>

<pre><code>#1 #2 #3 [ #1 + ] tri@
</code></pre>

<p><strong>for-each</strong> takes a pointer to data and a pointer to code. It then applies the
code quote to each value in the pointer.</p>

<pre><code>'hello world'  [ :c . ] for-each
</code></pre>
