<link rel='stylesheet' href='stylesheet.css'>
<h1>Parable Compiler Implementation</h1>

<p>The compiler in Parable has a trivial, single-pass design. For the sake of
simplicity, the compiler only deals with a small subset of byte codes and
a very rigid syntax.</p>

<h2>Input Preparation</h2>

<ul>
<li>source string gets leading and tailing whitespace (space, tab, cr, lf)
stripped.</li>
<li>the string is broken into tokens, with each token separated by a
space.</li>
</ul>

<h2>Processing of Tokens</h2>

<p>Once prepared, each token gets examined and code is laid down. The
code generated is dependent on the first character of the token.</p>

<ul>
<li><p>if the first character is a #, then the token contains a number</p>

<p>If the token does not parse as a number, the compiler will set the value to 0
before generating code and report an error. This will lay down:</p>

<pre><code>BC_PUSH_N
value
</code></pre></li>
<li><p>if the first character is a $, then the token is a character</p>

<p>If more than one character follows the initial $, then only the first is
compiled. All others are discarded. This will lay down:</p>

<pre><code>BC_PUSH_C
character value
</code></pre></li>
<li><p>if the first character is a &amp;, then the token is a pointer</p>

<p>The compiler will first try to parse the token as a number. If this
fails, it will look up the token in the dictionary and compile the
corresponding slice. This generates the following code:</p>

<pre><code>BC_PUSH_F
pointer
</code></pre>

<p>If the token does not correspond to a slot number or named item,
the compiler will compile a pointer to slot 0, and report an error.</p></li>
<li><p>if the first character is a ', then the token is the start of a string</p>

<p>This (and the similar " prefix) are more complex. It will check to see
if the token ends in a ', and if so, extract the text between the quotes
and store that in a slice, with a zero terminator. If it does not end
in a quote, it appends the next token and rechecks. This repeats until
the string ends in a single quote or the end of the input stream is
reached.</p>

<p>Once the string is built, the internal text is extracted, and stored into
a newly allocated slice. Then the compiler generates:</p>

<pre><code>BC_PUSH_S
pointer to new slice
</code></pre></li>
<li><p>if the first character is a ", then the token is the start of a comment</p>

<p>This behaves like the ' prefix, but looks for a double quote. The generated
code will be:</p>

<pre><code>BC_PUSH_COMMENT
pointer
</code></pre></li>
<li><p>if the first character is a `, then the token is a numeric bytecode</p>

<p>This parses the token as a number, and stores the number directly into the
generated code. As an example, `300 will compile as:</p>

<pre><code>300
</code></pre></li>
<li><p>if the token is a [, compilation of a new quote begins</p>

<p>The compiler will save the current slice and offset, then allocate a new
slice and switch to compiling into it.</p></li>
<li><p>if the token is a ], compilation of the current quote ends</p>

<p>In the current slice, this compiles:</p>

<pre><code>BC_FLOW_RETURN
</code></pre>

<p>Then, it returns to the prior slice and offset and compiles:</p>

<pre><code>BC_PUSH_F
pointer to new slice
</code></pre></li>
<li><p>if none of the prefixes match, compile a call to a function.</p>

<p>If the token is not matched to a name in the dictionary, the
compiler will report an error.</p>

<p>If it is found, the following code is generated:</p>

<pre><code>BC_FLOW_CALL
pointer
</code></pre></li>
</ul>

<h2>Other Notes</h2>

<p>Byte codes get wrapped into named functions. This is less than ideal from
a performance standpoint, since there is a subroutine call for everything
that corresponds to primitives, apart from pushes.</p>

<p>A more optimal compiler would recognize function calls that correspond to
single instructions and inline the actual instructions. This would have
two immediate benefits:</p>

<ul>
<li>smaller code (save one cell per eliminated call)</li>
<li>faster code (save the call/return overhead)</li>
</ul>

<p>The disadvantages to this are:</p>

<ul>
<li>removes possibility of redefining primitives</li>
<li>makes decompilation more difficult</li>
</ul>

<p>Implementing this (or other performance improvements) to the compiler are
worth investigating, but outside the scope of this specification.</p>
