#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        r.append(parsed_item(a))
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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q5znOc3Ges0At3Pn77u5uZ6uc885zoKqph7AqqqAAAAqqqAAzdqqqbud3NAG7gAbufq91UtgAtgAkmn716lnOSznLbPPPO7u7GEoShKEoShKEoShKU2222xhKEoShKEoShKEoShNtttsZC7xfIShKEoShKEoShO7u7u7GEoShKTZNk2TZNk2TnX3JH7n79+8+X90KqqgFVVQCqqoBVVUABzN3nOc5zjO5uevWbnr0JQlCUe4fIShKEoTpHu7u7sehKEoShKEoShKEoSlNtttsYShKEoShKEoShKEpOu7u7u7jCUJQlCUJQlKlKUJQm2222MJQlCUJQlCUJQlCUJttttjCUJQlAXeAeQlCUJQlCdI93d3dj0JQlCUJQlCUJQlCUpttttjCUJQlCUJQlCUJXS+Qnd3d3djCUCUCRCtCUJttttjCUJQlCUJQlCUJQlCb7CIe4X7o93d3z896223r1VVAKqqgFVVQHdzegF0Ac3NG5vNzfm5vNzT78P0OEoSg9x5CUJQlCUJQlCd3iPd3d2PoShKEoShKEoShKEpTbbbbGEoShKEoShKW7xDyEoTu7u7uxhKEoShKEoShKEoShNtttsYShKEoShKEoShKEoTbbbbGEu8A8hKEoShKEoShKE6R2229H0JQlCUJQlCUJQlCUp2222xhKEoShKEp6fIShKEoTbbbej0JQlCUTZNk2TZNk2T9+/fv379+fk2ShKEoShKEoShKHXv19/nX1G7m7/fPO985y/gAABVVUAAABVVMPYFV83N/fvz79+/fX8mybJsmybJsmybJoT628+EdttvpG+hKEoShKEonfOJsmybJ1vfevfff3vr1Nk2TSF78Q8hKEoShKE7u7u7sYShKEoShKEoShKEoTbbbbGEoShKEoShKEoSjoPITu7u7u2RpSlSlKEoShKEpUpShNt8I7bbHyJQlCUJQlCUqUpQlKbbbbYwlCUnQvkpQlCUJSpSlCd3d3d2MJQlCUJQlCUJQlCUJttttjCUJQlCUJQlBnffvNz16zc9es3P39d77+971fwAAAAAAAACqqoDbbec5qrs9hMyEzITMhMyEzITMhMhKEoTbb7I7bY+4lCUJQlCUJQlCUJSm2222MhR7k8hKEoShKBKBO7u7u7YShKEoShKEoShKEoTbbbbGEoShKEoSg6PIShKEoTu7u7uxhKEoShK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oSlO7u7u7GEoShKEoShKEoShKE+EdttvnYwlCUJQlCUJQlCUJQHxttt87HcB5CUJQlCUJQlCUJQnd3d3djCUJQlCUJQlCUJQlCbbbfKO2PgShKEoSuk8hKEoShKU7u7u7thKEoShKEoShKEoShNtttsYShKEoShKEoShKDoPITu7u7uxhKEoSk2TZNk2TZNk/ed+S0uv3798+fr+6AAAAAAAAAAAABub3c3u5tub3vvu7u44ShKEoShKEoShPDzwShPhHbbb5+kdvBKEpb34h5CUJQlCUJSn287u7u+u9YShKEoShKEoShKEoTbbbbYShKEoShKEoS7wfIShO7u7u7YShKEoShKEoShKEoSNtttvWEoShKEoShKEoShKE+Edttvn6R28Ep6TyEoShKEoShKEpT7d3d3fPbCUJQlCUJQlCUJQlCbbbbbCUJQlCUJQ954JQlCUJ3d3d3bCUJQlCUJQlCUJQlbuf3z7ePY/c5dAAAAAAAAAAAABzc3yW+/evv3799/k2TZNk2TZNk2RQlIbbbbekd78XyEoShKEoShKEoSlO7u7u7YShKEoShKEoShKEoTbbbbYShKEoSjofIShKEoShO7u7u7YShKEoShKEoShKEoTbbbbYShKEoShKEoShKTryE7u7u7vSOhKEoShKEoShKEoSlNtttthKEoShKEoShKEoShNtttthKEoC7wDyEoShKEoShO7u7u7YShKEoShKEoShKEoT33ru9973vQAAAAAAAAAAAAFub93NqvtetwlCUJQlCUJQle5fIShO7u7u70joEoViUHbbbb0CD6AJb5zbbbbyAHfffffffeloCqqqqqv3zZCRly+W33fd3d3d3d3dAAAAAAAAAADnOc5znFVVyqqu5u85znOcvpDYGbu7u7uwLbbbVVVVVXFec5+5Zu1VV+/fv379+70AAAAAAAAAAAA3d1VVVVVVVVVVfYFtttqqqqqqqqqqqqqrYHRDohznOc/fu96AAAAAAAAAAAABub3c3u5sQ99699999VVVVVVVVVVVVVVVV2QLbbbbAttttVV47nXN9sffZXFVVXQAzdAAVVVAAAAAB+3N5m765zjz5A5nOc5z2Aqq85znOVVVVVVeQHFVbAttttVVUVVVjvO+EPK8+11VVUAqqqAVVVAAAAAB93N5znznOc/Zu8xVX2Bbbbaqqoqqqqq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vvMzcxm73z33va70AAAAAAAAAKqqgA7mbmfs/tzczve/e973u7nrc0B28svJZz1tttu9bABLB3332yZgW2220IqqukMhMttttnubDfWZg73ve27lVVW7nnzc37zn3n3znP4AAADN0AAAAAAAAB83N7m5m6D8N3IA1l5LObbbba2AC2fIHwLYALYANZeSzm2222tgAtgAtnv781lkPjro8822222AAAAAAAAAAAObm3qqq3cqqq7ub6zZzbbbbWwAWwAWwAWwAay8lnNttttbABJAC3c5nOc5znOgAAAAAAAAAAAAG5vcyydWXzz7Zd8232S+AGsvJZw92UL8kF2W22kmwMm7bbUIqqoRdoLYALYPdlB9koAtnn3uZuZ/bm5nm5ve9/d7+73+AAAALc16AAAAAAA22221l1l/WWWc88888888tgA1l5LObbbba2AC2AC2duALYALYPdlB9koAtgBbudfO/fWZuZc735372u9AAACqqoAAAAAAAO5mbmfdzQeBub6zc9ADdzmbtwB3OW8cPllD5JQBbABbABbPoBbO++x1ZT1JQKt3Pnzc2qv36ugAAAAAAD1uaAQAAA3d32QkSGSSEn2Qk4Q983fN3QntttpbOwC2ADyy8lnNttttbNLdttttbAAsvJZyAFsAWhLbbbbpDITPF535AJPs3nN47t93dAACqqoAAAAAAABzc3uZu5r2A3cqAtgAtgAtgA1l5LObbbba2ACWACWc4ALZbbbbZmZmZmZmZmZmZjfbk3nmd9Vvfc6EdEdEddvnz32R+pB+EfSMRyUcIxxUslGIxRpdEfPsu5HcjSMk0jwRiUxGkVyKXJHhGkdKl1UjkjipYRuSNKWJGkdEdSNEcKXCOEYjikmkbkpcqU9V11846++fP1AABVVUAAAAAAAAAAKqqgAAAAAAAAABVVUAAAAAAAAAAKqqgACqqoAAAAAPW5oBAAAFVVQABVVUAAAAAAAAAFVznOKoAAAAAAAAAAVVVAAAObmnsAAAAAAFVVQAAAAAAAAAA95VV+oAAAAAAAAAAVVVAAFVVQAAAAAAAAAAqqqAAABtttttttt8owCHgiEj8oDCpeQvJdS+QvJdhH2WI8l0R8I9gWCu5fRH9I37r79+ff73pVVUAqqqAAAAAAAANzf7czcz+3NzPXrdzaqqGgvfv379+/p9+/fwnEUtA0qUjSo0iFBMooUxUtBTGRmJNqNkNiY02WNNUJQUTE1IvnxVVQsnnwwUESURUURNVMRE1JFVRU0UjBI0BSQSUMxTEcnOTk5znJy8nnnnnnnnnlsAFsAFsAGsvJZzbbbbWwAWwC2hFVVCW2223SGQmfXwhu97u829KqqgFVVR83NA/AAAAAAA3Nbm93N73ve97yn19fX19fX19J7sLJ3d3d3el64We7u7u5bABrLy8svnr1eS8888888881sAFsAFsAFsAFs/ee/Pnnnnne3OgAAFVUw9gVVVAAAAVVXczcz+zNzPWZmyb95555555rLyyc22221kAFsAFsAFsAFsAGsvJZzbbbbWwASwASznektl4Du/ugAAKqqgFVVQ22AG222AdWXqy/pLJ3ZXn37822lgAtgA/WXks5ttttrYALYALYALZ+m2222tiqqu7m+s3PQA3c+/v3vnz585znOgAAFVVQCqqoBVVUAqqm5vczM3MewG7lVVVsAFsAFsAGsvJZzbbbbSQAWwAWwAWwBXm5rc33m569371fL7V3oAAAAAFVVQAAAFQaay+SSyfpLJ3Zf339+/ff379bABbABbAHdsAHll5LOAARVV2UJbbbUIqqoRVVtCfP75ubVfr9QAAAAAC3NegAAAACqqtyrL3ZfLL688+eeeeeWwAWwAWwAay8lnNttttbABbABbABbABbABLPPXrePPPXnnTvQAAAAAAAAAAAqqu5m5l0A3LyWc22221sAFsAFnJyUAWwAay8lnNttttbABbKqqt3Kqqt3PvOc+c5znQAAAAAqqqAAABtttttt1ZftlPb4FsAFsAFsA778svJZzbbbbWzvvvvvsWwAWwAWz4Aay8lnA221ufvOe+fOc5zoAAAAAAAAAAAADm5v7c3slk3vfNttJP3LtttstgA7svJZxwB5ZeSTm2222lgAtgAtgA7svJZxwBbABbPvf3nXzrv59dzp16GBJ1ISUkJMkJEhJ1IHUR2Rx86vxGI0jqqU0RkjhGlLEYJpGkaRlGEYTkRxKXCOURwgYjAGQHClxFaRgjmSJ2k2fd+6889+/vfffffffQFVVQAAAAAAAAAAqqqAAAAAAAAAAFVVQABVVUAAAAAAAAAAKqqgACqqoAAAAAAAAAAVVVAAAAAAAAAACqqoAAAAAAAAAAVVVAAAAqqqAAAAA95VV+oAAAAAAAAAAVVVAAFVVQAAAAAAAAAAqqqAAAAAAAAAAFVVQAAAAAA83N9UI+SPZfpfZfZfZfJeSPJdRH4j4RyWI4R8l9l9l0UuiOpdkeKl4R9IypYo4lLgjEjRH775988+e+++++++++++gAAAAAAAAAABuaAN3Kqqm5vrLObbbbbuy8lnHAFsAFsAFsAHzksD6Hdl5LOOALcqqq3cffe5vzc2q/X7kAAAAAAB83NA/AAAAANzW5vdzfXe973ve7uVVznN3LbbbbwhkJjiqoRVVQiq22lgAtgAtgAkgAtnfffnfX71n3e9739391VVAAAAAAAAAAAA+7L8soffotnqAdFsAHll5LObbbba2AC2AC2AC2ADWXks5ttttrYALZ8+eud99/fnfOqqoAAAAAAAAAAAH7c3zc2vl9qt2AC2AC2ADyy8lnNttttbABbABbA7777tgAu5znOc5zm7nl5z5z795zqqqAAAAAAAAAAANt3ZerK9PaBbA77778svJZwAlnfffeC2AC2AC2ACTk5aANZeSzm2222tgAtnfzr9mbme/l9vtf3aq7h7AqqqAAAAqqqAAAPm5rcu22621sAFsAFs6PQHVl5LOej2Ha2AD9ZeSzk22221sAFs6PQHVl5LOHoC2efLzyzfu5ocfrtVV0CqqoBVVUC3NeqqqgAABuazbttttbABbAB5ZeSzne3rbbbqy8lnD0BbABbABJNybYO7Juj0D7ZeSznffoC2ec3nzd+5H+EZRyWqquEmEaRiKsRiAyTCksRokknJJZOW2y9WX99/fu/2/fgG222CqgFVVQCqqoABtttvsj7BR9oIhAhAh3d3z3d2ZeSzm2222tgAtnR6A6svJZw9AWwAWwAWzo9AdWXITLerbbdIZCZzd3vd3dCeZ5NkJPZIjSNIyUtVLSl7779+e++/5/nvoAFVVQAAAFVUw9gVVVDubm5nNzfWZuYfAa2AC2AC2AC2AC2dHoDWXks5ttttrYALYALYALZ1NZZPvLJZPvPX6SyepZatIwjEapTSMkbJGVLSNKWipZI0jnvnvvf31/fwAAAAAABV33333htttgBtu7L5ZLJ9svJLJ+llk5LbLZ588887888tn0ewST6PYNZeSznW297ba2fR7BbOuj0CyX6PYLZ91lPYLY6PQLZ9+Y9fC34QyEz5yzZCTy+ffZze/nd9nffRISZIS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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        sys.exit('')
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
