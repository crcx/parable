#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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fOchahzUrzzbn5699+e+/eqLzzhHMMXOJsptU2g2TmKq90ldMlHvv3nOj3Un77yK9998+JvOJucTamybJznE5zicc4W0F+5RXUViDRWqke6qo5hCfNyVNYjbMitKNFZVZqq5oQ5FaVWFaoj33blV7pK91JPffepVXeLZNi27xucptTam1NqbFV+4ULzKR8isUXxiTzzbkp+aiq8888+IO4rULMlaKwk71NqbU2ptTam1NqbU2VK0J57qF7/JqqPWD3HuAlk87996VXalPcqq9xUe6o/sA/v7iJP7Qq90r3CvAr9wrgEeYA6xUvMknmqCOsqS81RHmSR5lR5ilebvdu++++++/CTYYUABnvo2kuctJpc5ba4DTS0ikGm0kAZ1JNl8SaVNpJl5mZmJNLMEmlopFLVLbaaaLRpFIpFLwtBeZmXVVUvl3upKrAx2gDJJVZhuA7Lv963nnnnn3zzlA/vKkr0FqmaHuqqlyKyS20NtYVq0Vkr5nLKgMlaI2YxtorRI9924ql7qq+GFbbJtampTbZSeke8qSe++9ES/ErUqeam1NqbU2ptTac3NTamyVRqbkVlVe4quRWJUWFbapTQ0Km0SJhWURaKwB77uc1C9xKe73Ur33j+95zIq2Si80qjhlaK1JaK0Jore4BzVrGZorENNSVirU9yV711zpXuSPlqK1ttpGs2StlrbMxtmzayDzRXnnnUlO9Tam1NqbU2ptTam1NlIvclVvev75StiS99296+W23vCK9997+PzLmptTam1NqbU2ptTaCnIrNFarRWBNCtNFbVTNFbIrIrRWpomUmisQaGV5pJS4K0VdapFPNQec3KKeYK80qHnnnS7FaiDvU2ptTam1NqbU2ptTaVBzKCwrNFZJLzIFwVqItorCtorSqWhpF1qOQtK2MK02rNsrIrUbDRWmNorSlpGqiaJqQ0VtFZoraoPOVHnNyknml8tBYzNmstZmNsheaop5550+xMjvU2ptTY5nNTam1NqbU2IkvMFS6FbaJqjVKWRXW5akmCjRWyK0jQrJW0SsRqE0VtqRorRVhWgPNFec5zVK8wlTzEk888/or5AtsK1CXeptTam1NqbU2ptTamyETzQidRW2NFaFXWKuRWKReebrnnvvvvvaVPNTam1NqbU2psNu8OamyCvcqTohNBWisaS2Os4xmMzase57znPfnWG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znv3B4IyC7u7wMwAOZl85znpzhozMwAPUmlmZrMAAAvvt73vzve997+9d57zve977QAALyu8b+Zkkttvf0AADZvmt4t3d33QAAPZfKW97396AABnvPe85zuyZJbb7QAALy3nOW22+0AAC8t5zm/mZJNtt7+gAAbN83ec5bu7vugAAXlvOct73v3oCUcMhJeW85y7Jkm7v4+RrSf4kJHG4NSEkqr99gCXznTvvXzv16k/c5zn78u7u933tjtnQLQBznvntexcAAzMzIAEBhmZmZDMzEml3t33veru7ABmZmZmZl3d3d3eZ9mZm92AB1y0mlV2qu1dJFWF3en5TaSKbLfPy8nUZPHAObN+bvOc/N3d33QAALy3nzzzve9776AAB3ne85zu5kktvl9oAAGXlvOcv2232gAAXlvOcve97faAABeW85zfzMkm7u739AAA2b5u85zd3d33QAALy3nzzzve9776AAVVVPOF797e/ffG9cDz3uGCQBZmZnfed6Zi77cu7uznOc5zO5mZmGru7uzMAu2ZmZgtd3eODMzMzAAF3d3d3ayZky23nOW5Mktvl9oAAGXlvP3zy22+0AAC873nOd73vfvQAALN35u85z5+5kk3d3e/oAAH2MvlvPzzy22+0AAC873nOd3Jklt8vtAAAy8t5++eW232gAAXne85zve9796AABZfLec5v7mSTd3d7+gAAXlvL55d3d3ugAAfPOc5M35bbfb3ve953333297ZrLzN3fLl3d33G6qSd73ve5dy8makqTeZme4Wm9VUk+ee6Zh5VST7hUqQ++ZmfV9O9873tSpO+9C7u7u7txppo+kqQ8zPMzxq87lZmZwTaSAN61oGmkBo7lUAADvec53ve9770bxzmGGGERrm7znN3dv2oiHQDZy3nOW2370ACE3ne85zfzMkltt7+4AAO953zzu5Mktvl7QAAHe85zve9733oAAGby3nOW29+9AAAsvlvOcttv2gAAd53vOc73ve/egAAa98/fvvny8vPEmSfNfv3d4N2B2wLvty771f3znOMveZme4zQHoAGs73vfO930xZnnGmlznJznAzNdRMzPczIAAAAZmYeFNpIA36AXdg1klt8vtAAAqct5zm/MySbu7u36AAB7vm7znN3dv2gAAbL5bznLbb9oAAGd53vOc73ve/egAAd53vOc7cmSW3y+0AADy8nlvOc35mSTd3bt+gAAbzd5vnm7u32gAAbN8t5zltt+0AADO873nOd73vfvQAA1r7Xmnoy8zA2A7YF6taF95f3me++nDgGvABngABmZl5mZmAGc5zhzvcwvLu7ySpB4ZW8zMzMy8D0H2Zbec5bkyS2+X2gAAVOW85zfmZJN3d3V+gAAbzd5zfN3d32iejhISc45iROJs3zd5zd3d/Zu5kk5xwIiInV8vznLbb+9jJXALzt5y7kyTd/d+b7QAAKnL95zm/MySbu7u36AABvN3nObu7t9sIYBs3zd5y22/tAAAnpJ3zvnOc73ve7egAAPXPZ35zv58mTv7z9/eTJfl73O8kADeiwAOhRmZne86u95zO+eZ776dzMzMzMALu7wGZmYkqS5d3l3d5mdKAAA7hmZmZmZgWAAHTjQGru5e97370AAC+5L5Pl+c5yb8zJJu7u9/QAALy3nO3czN3d90AADeXefO/Pmbbb3oAAGXne85zve9796AABZfLect+W37QAAPzvJ535zm/MySW2339AAAvO3nO7mZu7u+6AABvLvL55Ntt9oAAE+r535znO973v3oAG223nn3rn7tELz94FdfeCTb5orZHxGgV3vrfXP3PNffb+/civcCuZOT03TAEsSSGCA1gkimISrccVAJNoASt7bee73fe3L5r6CDgCUASkQJYAk+84Vkg2gEr7mb7NASzoutE7FhOeuVOZKyKVTrzFwaKqdGvVyjvujWWYlDPtCtCu/OfhX3W/zreSVXder+88u+3msG9gLs5znOc4Au526yfAkuJi7OxtPgySETjj+AQhv58878/fPP5UjvRXWqVzIWwraZaK1FlUucpOEpxhLjUTFtGxbVLaoayaxbG1ssxNrIrZGisrbvvvrvtb6VKpoAuVUqNBd32qqTclXu7v7nPucorjIrKqwqwVhiKyxVspG0K1kmLSoy1JVa18F/NvLqSqTQcPVySSmj4FtL+u78vtXWrPg99upKqo0Pfru7k+0lJpLNMK0Voqz/B333978888+qVUrNDYDpoFtVU1qSpVanlVukkEe+03d9vgSDXvvHve90EeYAA37d9r3d8a0JIYCTBAkUMI93e7t17bqSVTTjg8XKlRofB7+kqQMzMzNSolVXuqqVVVzQ8cW+qpJGl6u7u7vpoAtAAQAGxLv69Xd37YfADx8HuSSq7mZnuZmZ8Hhd39d3u7B00C77cu7uwIE9A5oA6bAcN3d3d/XZ77Ae/B94DXrku+T37BzjMuSpEkqs1mZmeXd3f13eZgC7u7u7sZGqqqrVSVV63Q2gS80klVQZsQIJPpLz775b73ve973x56ZmZ9ztb5Nan1fd7553uZmAC7u7u7vwDgLu7u7uwAO97kqVK+1VUkve9fvvvvvt3d3dXeHWnkbRGNpII4DObZc2tb83GxmszoNpuXDYIRNkg452ikwY6I0JqSRSNNrrIUxttqNtKOJsiG02SXl53d3d3d3V9qSqu7u7s8sHAUCB7VSQHwzWZl3d953XcwHMrU1KlVJMzPcoPLu7vOAHe973vegup7pqF3y7upKq5JJWpKlXre7LHwejy7u7+u7ABd3d3d2yRWqqSq1VVWs3mZmZmdau7u7uwHxj2qkmb3JUmSVJlVJOXvM8z70HwAd73ve96RqqkhVSUlTVSNOszMzMpJpZjrEk2JtNLTSbsAAAABsF1JVJUqtdAJJVJJUqaklVqtTVSVWtALu7u7u24A6B6D4ANVJKqADskqs81HgLzAAHoPgAAhd3d3dywAgPQfAgAabLu+dypJVNx6ZmYAGqqVT0Hz626qSGwAPZJV3d+3d2AAXd3d3dgAF3d3fv3b1b334PgHX27u/bu7AAAPTdVJB5pu693d3d773VEwSXhpAk0kk4EiYhmUBlYMBZn3333OfZz5K5upJsHE7UlVVXq7sHuXe5d7vJmnfvNe933b70w+F7KUkubUk0pSh70KNgd7zq71dvHNu/d79l9zMzMy7u7u7zGgGZjMAqpJ0ZmYdvV3d3hmZmZyZmZ6bHe7Lsmp1795mT9QgGJBkhhhmWNo22raZjMLZZjal777+c+pU6+o9996Sn02zFsNWbJG756AAAkqc7ec+/MySW2339AAAvO3nOSZJ3czLu7vdAAA7vmrz5u232gAAT6vnT53ve9+9BvHOYYRmzea3m7u790RENAqc7ec5+fMySW23v6AABeW853ZmW7u+6AABvK7zd3bfaAABl53vOc73ve/egADWtZ99y6X79j7mNu2yZmXvMzMx00AWhd3d81VSTjfe977EzN5qqknuZmPlSdSNSVIMO1d7qVJaVUjTM81l5mZ7KzMwdeQ8l6y06chmdzNgFtdvbc8dfO972/b9vecttv7QCGHs7yed+c5vxtJAB4mvTMLsibkkiaMwvNAALtKqSRfS7zMzMTQjMLuwAE13KzLu542kgA8TQBd2ETckkTUkl5rQACS++3ZJu7u6I+9D23MsLMbbkGF5n2cz73mqqSZmPRsB00AWhd3f3znOZ3MzMz7MPSB5hoecGdzM8u7u+97l9kqS9S7fszMzMzMBySpB4ACeAF3YADazMy73HurbSRRS0BtNbALu9kbckkTUkl5rQACTDMu7zMzMTQgC7sAxKUqpymAXv3dq6S3dtpIooPNNpKqVU1SzMy7veRNgeDYBea0AQSYZl3eZmdTQWkm4km6TTdySa/X+/fnBsH6pKmZeZrMzMFoA53ve9714sOA9/ZmZ98oBmC7u773rl3uzQOyVIbMz3MzMzmYAGfZmF3YBia73vbmtX42ksrMybTQBd2EbckkTUkl5rQACTDMu7zMzMTQgC7sABNZmZe9VqW2kgDZTaJJLu5JJImoBd3mZmYmpVUAXdgBja73kSTfL993nnme/v2X+2DwDg2djTR00DOee1777OBtgAe5gm0kABmPO95nedLwVUkzBd3d3d2B02ABmYzR6k0gDYAXdgACaALu9uS20lJblSpSakku7kkkkTUkl3YAA2vaALuwAxNZmZd2AAJoAvetE22kpJNyk1JJd2SSSTlVSpKSS7uSSQiakku7kkkE0a7zxbrW9eNtJKNJummm3KVC9xOmIfmJe6u/eVHuRLzRXuivcTtlsma0aRXuUHuXWtbWN7xIPfvJEe5VXtNJuUm21O2m2m6aTUnZJckmZnMyszMzOb99v333MzMzMmZaUqqYABOqKAHqANoAADMzM2kszMwAMzMzBJpgAeooAAPOhaSTQWmkn5TALuwABNAF71om20lJDaakkl3ZJJImgDe9gSUG97AlT9mZm97zMzMlQN71rJttJASeJqSS7skkkiauSS7sA6CaukAXdgBiaFT3Upp1KSTdt0qma2Zob7nDe/eqUfenvvvv7773SNSim20gNNtI2RpNbTSkknZJczMw6aAS9VKk7ruq737uXzJqs1zySpN5mG8WXbaS5mZmYYu9600u4nKpUUBqRW6kmv32ZUqQ7929T9d9vXWHgADRmdWUldZncvBtpBaaWUB53WrAATRmZd3k9bSRHJabU8TVuSSzWpJJE0GZd3mZmYk8zMu7zMyAmgC7sAATQBd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BXuCs9FZoV36K30KzynWdc02K+zoKzBWN3XgrvqKzFdZrKsaq81it89Fddis68FZ0K3oVrmRWu/ditxWZt20h9lqR11uK0KzBWtb1qFecFaxFrreukWkWugtY6666Stis7FdeCs319zdE33q6FbbRefab7I8dAJcsgkFdAS9inq4AKcMMOS7lW83pjWkroVvCPorCM87Fd9AJOnAEnQCVYQBKYAlOYAll528I9Fa685FfduPvNt4zMZnWCvRKsou0CV6sOgJX7jeVxdbcPUZKQJbrsVvwV52K55933tO8e/Ctiuc33lcIAlOgJXKAS7nK5nECV1zToCWGY12tzbd1T832cuNZtV6T0riBLECXGxXgrXgrvQrZTMYKz4V5sV550K172RrHgrTyr7QrBWeBW8FbwV7grvvvSes15nypnfBWvN9+itaFde9itbeNdCuiPftkd5diudivuCvfBXnWZ4Rnm4RNgLntH0rd9vS86vdrzqtEgm8AS2rRdSZ35tFevRWeCswVvoVnBWfCuxWuhWu+1eZ9vyrr7sVz2K7RW+Ctit+4laFe7edyPBXnBWeCvNiswVnorrQrNNyTOZfeSck1kq6enanO9OjbG22NjbLneu+7AQXUAS6wEndiSOyGgJXBWa8JaxnWtKM1rYrWqt9CvHQrrQrNed+Ive9Odit8kvMPfhXbemmSR8d9HOXlFDHIs7VXnZXRtxtuPO2dy3VvjnLp3y7vk4xADuWm0z0jZZY/W75Ubjxs6S7ujzLfnHlx1leyFvMIErPXjO3PONszeUW/OvRscjZrypKhjEvmDYhCEJY0N+ePX3JGHm3JVN04eqvs5zM4+/RdeVfLyo6lPG5l23jLHUmN08pCEl55znrkcp66ZG3j+ydfPbW2Alxgg56byO3wBLI3J2sbsBKr96vHz4NttsbTlX1JB3h4410BKvYTajrnq54SCts28j7DedASy28ASkb56pV0ORtuq7ZTG5kTdttum3jb185JJJJI/OVIVJUnqqrkkkkkg3slSSTuS+1WO3nZNym+dgsZxoj7VPztFovzfvX0V8KzgrzwV3grwV596JYgS7YCVdAS7GP3Ojaal+uXZzZK0uVVy3d1MOzvc017k7ye89ePsg32TsnJJxzIS5DtSpPSZ6qqQyOFNu6cVVG6o7wSC/VRZcfHvcQFMJ0naVdvH3Hdq6QJep7zJCqMGArPdOudsHfJyAJOo+PJnvQ9yL0IXXfN4326rhCoZlZjOeI876n2WmeYlmO+fZ3sVnBXZSXHxl0/n9Vt/t5G2+u9c0QK8y46vXDcbU/Hu5MptvlVX3Zt1XeK378c5bGNvOIEsrHUfaOPnZm+XunXQIJmAJZvUkfMEKMDHxtt552NbVZ9td5IRmP19KPNB0Tdu2HzN2JL3Ym3s7d7N0BLO84DnKutsmZvD116tAS5vutvfdqcK2snhc4dQW2Dp3WDu/vIEqrsZRllNuiVx21VUty8vTYsbYs9co+7dy62R0+5VcAS5O9nLngEvZk82wQZKBA+gJWgSsEHee4FY8FYK15sVvYrprQrWeCu+xW+hWYK3oVnnYrO1G/OhWvOvNuxXyLWeCtdKmvd1awV1oVpgrsV1Fb7Fb8Fb9Em33vDDsPz/Z/pf9T/Yf6f9fFz/Rdf6qJf+zF/YfHuH/y/9q//F4lxFX52PX9P/H/Cl8C3/u/zn/Li6vhefISxf108ffu8qp/fd/9f/Mf/v8uaH+Dixf/FLv+B/t/hehd87Sxk/mVF1P8b999v61/hXta/L31D99/dfnyVOld/dz7fv+h9lK57XtTPh6f2/G9PnyVW83Pl8v8f/je1+X5fj+N+b1u/3Yr5vXz+/NL9/v50soXkmyl4Sr+H5UXlAi+6z8v1NKe3evvr7e/v5zdP7Oec9pr5pyfOfLO95F9R/Pfi9Xm1vavtP+E+VVi+q8XVnfkvft59DdXevh+Kl8+fVVVP+C0vs+Pfp81r6/n39350ucClBRH6j/g1XDl3/Hr/DcIf0P3Ko4ulqjtkP3f73+JuONtQh/CfcR/Frkvn7t/mbbZ+4X7l/OvnW9b+f0z8fvS7Sf/pWJeP9Pp+FeL5Kqr1/H63+C+S7xM/U9+nerNf/Sn3+/g8UVPnxX3/gufYl+f5fTe1t/RXz53+f32r9SdnvpTr493fPk15zRlL+ujrU53XnKdqfn7tz4/T3Tr/eLf6f18fm+/5F4/I/6Vi6fu6ZwzEv8lmYQ/QxsdH4P42U8PzMN77hk7TbeDFBln8C85D+nK4MmM7StXfMcsP5/N/4v4c/f+7+SmWv8v8/Q/kOlL8s1+vyn4r35c/2Ul8mfl4++fH7Le/3K/zT+9X9Cv2X8ydRfL/J6vn+me/l78/xxd/f+K/VT66qq18bWt3e4vr+yW/sVqfu/PK/Z+R39MH/v2fn91/mw1n7eftz9o8ufzVEMK9+SUFpfl4LOER+0ZT6v4LxcX+xo/jgYfj/Gv5Vv6Yh/pfFf9tIf7eLu2l+q+3+b43+/v12F/B3f50va+KX6Kni2vp8zqrtZWq+usfF+y8+6mtVS8Xv8/7r+6ta8+a/C1EXfYMasdNJn6H5fT8c9/Rn+Tt99x8/WqtlK4ft/d9z+Hv0of8pR4n8jnYfvfd+P31+jL/XxJK/P8zo2H6DHTVffU5tfLby6+FwXn1r8e/lyL71VV+i/P1fN+fl+EquH6VVfZv4+Pw+3+cXOVS+Pr+C/D2t/T1ukq+3/DPn1+P8avbtVX4fEd6ufO8+3l+KqT+n4fN7TpXv6CpUv8f+9r9ef+3/+YoKyTKaza+TiPABFqzcAoAr7oAAVVB2+RMAaPvofewAMIApTpthkAFsAACgNFC2e+Eoo9RoAADJtQanip6owAAADGAAAAAEnqqU0ACMACBNSqgDRoAAAKSUioNGmIANDqSUh/2kBEPjoFSNt8fVzvFw24aVktpiWKxERWQoCOQVIw8U+BlOkUBGPjV8nz2/KSSh3eUm8uhmrZbYTNt8glFS8r1vn3PcIlWaR5zt53ao+DyG1KzlXJogUuYXHM4yXHFw5dDjlxMGDJtwikTEpjAQgwIhCFJkENpMtMqO3o+yh2ze2bbndZp3XM2vMbDa1pm8ylbKjtE7VC7Cd3CbFRtSrmI7RDmFF2XaJGmIpnvbPPCTtKq3rgF3cE8ykj16XKom9cFW3NVKs1IDeuVJHccE96KvWRFetenZchJtbaMCcJpSvNtdtmyHtDKPN5tyjrs7LzvtfcqhI+/JbNqlbS5J9MQKlkyU1ktJim0S2EqbJGaVKpbIK2kRmbJNrKtMQ0m2plG0WqiK1RaxjGqDFFG2xraKijaxrEbFGLURVaLaNtjG2o0RsFrFaLVtsDZGwzFG0htKbIzRpaNJpmiMJrCaZiwmVDEabDYVsVMJiTZWE2wmQ20wmqWEyJtVGZGE2yCwmiVsbUWE1CbU0TKwmWQ0VMJgmYzKhhNSMJqStEyIbW0sRoobSm2E0yLShqtNrVRqtCJsUQba0IwVYTWFWsJompom0wmQtEypMRgMNK2rG1okokiNVZVpVCxYTbZJhMJgmoWE0pVhNCYTSq2WybMy1rYCaNFVqlgqwmitRgmyLVZbRMgahbZjCYKzVRtJsVaVaa2rBsQUFGpSZjaFtUptQraRtCWzKwJhMkysJlZMJimEzZZSxIwTUyjDWwmCYTUppRhMJlYTBaalGEzYJmqarTVqxa2zbUi1aBMBmFkgrYtqti1WVWlsS2RRhMKsJphNVJgmEwmRYTKVhMJiMqRhMEwmEwmKWEyUMJrCYBtFsLMmmENgTCZVGE2I2E0FhMimE1UTCaqrZI0tURiMUjCaia1aTCYTImiYowmCYlijC2E0qYTAMYJpYEwmVNaTJomEwJhMJhNS1SrS1aTaAwVkgzNWsq2GyQrYUrYkrYLSmVgxUzCbSmsRLCYFjETCYEzRSs0KwmUYTVaWKLCaUjBNAmEyRYTAmE1ItiNhsmwmapLEYKsJikxGJRMJhTCZUqsJijKMqWE0UmEwmEwTAmCYTSqwTEYTCrCZEWEwmCYVYTWEwJhMowmNtpbRbDai2VtSrCZKMJgKYowVLCYqkwmJWE0qqYTKSMJhMJhMJgmCYJhMJhMJhNEpgmFWEwTCYJgmEwTJVhMEwTCLCahMJlCwmUNitiNqtlrbKE1SyIsJtqEmyBhMopMJoAwmSS2CjCYExGFWUYKsJhVhMIsJpJhMUhhMJhMFWEwmEyRYTCrBMEwTCYTCrCYTCaiYTCYTKMJkqytNtbGLaK1FYxao1ibNtrNIWEyhYTEqlhMkRYTECYTUgrIrCYTUIsJlUYVUtbVFbFjbYrFto0ULWzVQthUNplGIjaCosJhMJqUUwmQVbCYTIisJqKsRkRbKVhNhNKMEyTZFrUmsWJtrTVtMtmBWzNltNbQETaqqbIGxG0jYY0o1JqbbFbCbJjNjaU+lpCpHjzESqIiIIIICv2fDy8F4eI0cZQa+bFR6Qmr5S8LuSKcKEhufU2VA=="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
