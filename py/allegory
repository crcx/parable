#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "QlpoOTFBWSZTWR/6TgoG3cOfgHAf//X/796rv///+2Apvuwzg+gAAAAkCgFKKOZkofNaYAqowoE1jOu5opvRxxXONBbMqFssa0Gq2xIVqtBQIgbBgIQTMzmTNlB6Dodhg48gAAAA00I0EJpoxJkTKR5TR+qDTeqM0QPFNpNNNlBIQQoqoAEwAAAhg0ATAIxMVT01ANqPU00MTTRoaGE0GRpkZND9UDQ0EnqlRU1DCMgGmjQaAAyGmgNDJoACalVNT1CYgMjTJiBpoyAeSaGRo0DQaYKSkJT0mkoADJoAAAAAAABxQqlIdW1GybSEqay/YlCqkWucHcZYWSBwh9gaPG0I87a6YqjdIY9QdGjCBI8groyFbf3Oxfmt40Hvf4XlVZ1mrtUc5U/NUgq7Cvxkpd16Xh3FK/S4YuZ4WLAn5FzL28P9tQ6HCPA5vx/Y//S8cjWj8Tw3nTTnLziWhGwk5ZroX03XGXFuFKN88siucx269s8zle/KrAnQ+eUoHeaz5bd63FJzjb5+zzCY7gp8WQBOnqqXPwX09exS/nRM0TYL7eXl5b7NqEVKLky6+52OMq3h1z8lXri1ir8EMaQDaP52WCDY5zkvnJ+Com72xKZfdSVUcp3fpt9fNj81QIH70niyXBP0nnm92eec4e50RXsvN9y869pyUclABXYUcZt5x7ZWCAYgHLyl3Y/F3l7uVeucPVHSRzlXZ7mUNmW8KjYCECHSGSTrUPPfXXnTrnSHrvJ4gOaJK473ZnD3u079sLIIC8EupKhAePRHGb1xnb463BtFRcEBUbcKKPPuQQDbXmhB7Y17tD7YsjtiAzSmkYIDcBGZJGIDtzz4CTnbpJCSjOXM2q3z723bgdEBQgOCAYgJQBH1xzmV3ggLQKtEA0jknTogJI9rCpCTmvwgIrEA1gkzUKJAbXPe20gOiA72Tt8oQHRAa7yu54QFCAdCAl9b9vRAMQFiAfa2X4QGdSArNl6IC+y7sQFiAmZ2tK4ICuXfpMc7EJb7eWgOUxAVxblPasp69aAbbttlCArXRnZlRl6N76vWjRAVK9Ce9SR1iAsQDVtazGk2mwQXvdybvu8liAd6IBm6ZW+rOPm+qc6qmR1yPYIDe0+lbV7UWN7aQHOs4+zO3ggPe4cYgKoQHW/O6h5l+ys878V3VH5MpiAfeetICNtvOQnmWTL8zrRWbu5YgLvlivOdLHUL4mcRTBkkqVUGqluxAWQQDDz9zGLXViAv11zz7QbXLsQHhAX6kiNbO11pY7abWdqm5EgPV3znK4Zd1k7Xd7VXzleEBwfvcfXzvWICTKx8EmxL0RzaZljz3fc2ZKvfZm8w53t8EBxhke7d13Oa5YgG85t5vjZliArHOc28ePDdqjlYMEnpgMYepJJJJIMZ7mWUNzSPkvvo3zud8HAdyVLov1dczbved7Z3iuoHWFSqeSHcnbWZzdtvKdVUodRVMuPvWwA8PH7c3fPxbMuJASa+4AsppAQQDMmUcMEBE/CA2qNdugKab6xAO9nLpmiA5C7htw9sH2O9dIdofHXSHpDhDiHkXNvoybdEOeIeIdC+EPaHrr0QECOhxxFMyqfAA7hRWCAgIG6EAx5C92IEAhIEbkHlSYVXMwd3WDI7urpp0VQ7yqrJXq9eeg6htXO7nXeGN+vBAdwQEqqMfIJKDb6dBAU2PBATKJ699VrhnOCAvrWCAuGPWu16r6ICFM3O1ghKQ60hE9ggKT9FDtDxD1IedvO0O+uId8DpAUICTogHBK+7zmWJAILuiEjc7VSqsuqg4+KlKeUY6t5blMknenfdU47yynGvcZVHn0QDDRAa4dsh7SJPvPdwQDZggHBAXO3krmF4ICHhAUIDlTDRAdChAVdKDSA5vVeclGbPOm3JzXbuvNttvJOZx81uqbe5ve7y/PGZXKZ6iXnuc8IC4xI0QF6eEtQgOc9yeY+ey6eQ8qHyeBAWICaIDjHxvT2Q9IdUO0PSHtyXnwhpxCAD3ub6sOuX3xGcv1VWl2XvPbwQEwQE8IDqbzRAVXuZzvje5DeQGIDIcQ649/CHpD23wh0hx8fCBAQGCA8CXfPkDzQAlQcOkkyyquSnYyPZyp4S40CPCAsQFFP3ZvaznGVNHeh0LNEB4oQHkgNBAMS8l4V7Q9ofEvEPZc779PiKSyeoocbbvmb6t1m9ncKty/P28NEB1Cs3L3j97joPLwgJ21bSwQD5ViAsEvcQpYgON57PerHvJfbv6kgSQC37+GH53TwHVRIv48/BVT19ygkTenZ+v5mB5+wOwlOyqUsWtd4PnkOXTfmnZXKKyKilQhQdxRQETT15hFqJboiSoRTao+9n8PzyU7y51yU+Gkc2wYzbvK+3nOt+dxDzvnqKrfdvWYIeSJH6Uv9LKRggHbUYddqhBBjkkaQDbnSlG3eVQMQDMYo2xIIdKqqMdNul6fXr697OUsh6iEomd5c306887eSEY6+Oe8h5qgt9ff1eLmHUIAHutP7D2IQJRU69wMkB+JqJO/Pfr2+O59t8WPeL5K9vPmb2FPtLqdXNrWmmMZtuY+cvfXqkUjp5p03r1lFc8lzKnPkElVbCVVHXO95q165zbcx1DbpHNvCTeO4TI5yYzXOzAxndXNaIvNVtS8ITDbZFdEobJcBtMBlbKolkkUUY7g67d0uN4d4Xc6gEcrwrs5uXiDtJsjaG02skune2jTFSFkWahWlFojFGpSzQCNGotpsa5kG5CKIJEmgohJLchZKRY6Lq0WOKmNMKrKl5WKm5bbWXE7kY7joilQadMwqqkVNFSU6IUxSSSpTQx1V3dhQO7KY6jqyiIaG20222CaBjZUiNqY0THA2SSEYDbNINsZcI2wsjGxxLLKgzCnLpvKUwiG5I2XQOqjakGxDcaUuIhBiHQUOoSoFDbt26cHEDY22rInHdXY43VRlSDqQsY6mZBjbLuNhcgi03bPLW8S156eemdu7BKXLzDvPVVCgchGrtCBKi26hUltthUlGpHhpp5ZoUTNwSddd3bq6cNETjaaQRZAdbUJThRMlDbYxqkm3JmN3cbJpHdzFiCNRRi5bsihK3d1ruuZG6SXlcuXhbxKuEFektq8O1VzObmqbSLZFtRGYS2i2oXMUnTHWc11qK5xxVzQHWOuc9ZUdalUd7vbOc4gXrVONKrtlW2whyNmlJdEqqrmrKRzdtqVYqxUnNU2oBxobO9HJmXXOI2SYLag6wuYRbCDrC464lw2OYbnJmixNhaPXKCdc66hps113x0tmraF3hdC0Jslsl3o7zvOm3JnOW3OY3NcbtqvNVesdaRcwG15zW8GaOV4btatlt4WIu16ThO7pd3LVza7uuwqQ7rkwdSQxzPtltu72u8i3Zvb7eZ8O/RjGm3oxQrbbVtMwJqxarEtpKXF5my+v27du51pz65xRCH2xRc0TY2oebhD21DkfP8/SHPnvzIfbefPKr67dK4+77ddG2tj620CDzpiAbGfYRjK37uffs1/fsOv69d9jYfBANfX6nL+Qj1rz8/jEg96e75rLDWNjataugub3dpoiCqqSUQAWBAkCxpOfea3ogHhiQE+46xI+faQH6bSQfhNAavQ9abVWS1pJIxEFr5iFe8VfbEfP24l9tQp6+7lSO8AfTJPpqH07+nx9vEnmbQ+dUe8+ZEkB1pH6/5sAv72hAuNCpoQB11IlH1cQ4J9dPnCrrSNrbaIzI+7V6yU60m1Fs2X23vOrZlOZE59OU70TvFTvRkNQXV0KMQkFqRAKCAZLvPw+zYzzDqczIYsvpzzpS8666uS17xxDSvfnB5j364+LVsUbTaZsw222otjbBbbGqK1GrYrTFbC2oW1RA2krbZTY1YkxVkpNbEWZJirESagSki1kxksaE21bLGVmiaiDbZI0cZTO9nWW0r8RCTYqG0/tQG1QhpiOfO93WzWk23GO4ay325rNetfdh9attgZ2OpJBU+fIGbERpIMh2gjBJm8313xove+ENkMh5qHrHMk62yHjzl7yVzCd62OZzDdc9fTijem3CVc0R519eip0hoSppbUR160IKfcoQFIEG85QIOdgubnzyqjYNjYi2qmyjYJtJtSNojZS2SbJW0K2iWwFtSTa22pNg2rWNi2tFo1sbUaMVjai2tGqNUVY1oqsWSNsVsVoo2NqjGoqiRW1sltS2StoM0JsEy1WjWLRWxraxYtSFWxrVYisWoq2NrIWtFo2qKjWoNJto1aK2Zo1aKtGtUbWNUG2sWsaio0bViqi2LGojQbSbbKW1K2pG0G0K2jao1qRsS2jYmyrZI0Wi2K1jG1UJtorG0Wooxq2KjVsWLbRtG0GyjajZQ2hso2SNhMym1WwbSNqm0ptVEm2CtRtrRaxbaLbRG1K2lsjZtTaBtFbINFWLaDW1RqNtFjFVFajbWjbFFVRYqxtGq0VtFWLVGtaKwVYpNVtCVo2ttCVGqNTQLarYK2G0torYTaE2iNiS2raFrQqympY1lSiyaiIjVlWa2sWtZSisGo0RqNtUSjappWpNhbG1tJqmCwsqmFqhtS2kbGYTCxtVYWkGFki2bG21VYWqLC0jC0MLVarNtWlWWtjaMkmLGNFYWosLVIwspMLKJtLWm1bAmqatgbLVMDLQNqsYWYbVhYWslYWhbCNlbKWy2zRs2qbTbYTGBMLUMI1SawwtVLFjMo2NpBhaqrak2RmbDZbTMqGaAqDY1qWlVsqzBNYW02JYWoSwYW22irKstWjWxBbGxYq2WtW0SNNCYWpsqMTEZYVaS0U0mI1pKLW0qy2toNURRBkrZbDMm0kMLFYWojTCyMq0wtNSwsDVMhiWSYWRhYJhZhLa2VZrVaU2tGNAaMCWyWi0QSVRqrSrMQYWihhaKyMFhZQwsjCwsLCwsJhYVMLEYWiwtSMLRUwsVhYLZsG1W2aGEVGkiDSUWgtFbNE2VLC1IsLTGUsLCWlgWy2KtUxNqJq1VVhYRhYDQsRhYK1TRG1DZTC0lapkphaLCwiwsU2bVmkbaNkLJorGQrRjAbW21NZVmAjaqGFhTYKYWlNqUwsUW0K2lYLRTa1ksLRbBZtirNtFgsI22irC1UMLJTCxW1VMzaMxtZFaKNFVisbRqyzbRrbba2hbKKwsoMLSIYwWFqVLGSmFojC1Q2KNqLRaLRYjCzBbCyLC0pmosZlGwtEYWgGFhYLCMLStJha1JtGFhhZRVFqkphk0YZiNYsRooqIgtixqisaCKkCxmySkGjSk2jTGi2GxhY2ksLKk2lUarESwtJRhYLC0RMLKVbNqk0LBYWS2iwWRZWFhYWFhS0LC2CytCwtUYLRYLVDaqwskwWA1TUGqYLZKwtJtLTG0hkqLGqTGNYgNo20mDSVqJKoiihiGioQ2C0Y1ghpJkyY0WYyY0goksyZNJFoJqtUqzWtZSwtlEbJWRoomFqisLELZFMLSraFjCxikwsBhaKsLVRhaJGFqsLQjCwsLVLZKYWEYLBYLCwsIwsLCyRhalhYwsk2BhYhrUzLaTMNqTUQBGszWII0Wg1oitjbGZtSMlJJmxg0aybYxqCoioSrBaKiLEaNjaSLbbU2bINo0miNqLCxKMxrC1hbEK2KjC0lUwskjNVKYWgVslUYGFhZKqwtVGEmkTZtNgbStotlNkG1QLDaKqNtFrEglYo2gwVjVGNGtaNNWxtTaTapLZBNpphVbE2AbCqlqmRqmqjaVKZTQQ2hbIwsAMLSkxlSs1mWwWqFWUyrLWNWWqNRi1RtqI2zK1UaC1G1o2xlG+QjOPjPNBWTjbS1kbYvMjfyBfPmW2cedh582PYZUTbaQ22gbewQFufGTddah85R3ZZOkOEPfpzpDVTUPpuDah3qjrrjebgTZ1/GtaQlrSBHWEGIELrSQc77567wSggGCAqCAnx52IBWID5Xzvvm83pub0d6PR52vURAZQ1FGMsotBqNJSY2sWTSa2CV73ERsIbRDG2tU1MbYNjG31tm7nr+vW2r+ymg1lNeYdds6zfkF1tpHWBpIIiaX24dSA+fI9ZDucwjnnJea6zNc3b67lR3iA9uFISLEA0gLyGZBICXEIOMSDu4bYhE2I1nNmtdZTFz5tW/NYwAu+OvNfNka46fWG/IBsiEHvYUUxiAYIrIkB3vqEC2cKEB3PnuCA+d5nOUI6+HXG0hnxnx0Zu/PmfPkEBMIIDqIACiAC1bOs7GdCgADTVIZohqWtaz2CWWZpAgJHztggO/Pl5gl8s2saQHxmNAJL6MSNyfHx9ZHLi+b9pS+V8eu3x613kKYmcnXxjYgHcyoIDvICDG+xAhtCgJNRzSCAyVQgHMoBBu3uV8PbwQHJBtIDGkICTlCSVdlMj+AJtGKsVViqNtUMEghsY2km0khtCEDZHbzYd7FfZ8dt8i+OnGH1nzJO/KPVDjz3K+fJiS482y2Ald+oQHhiAtIBz0pjZjDZEqYNgcqiuZx8rMSAzny3Xe6cqykIDvz5QgeaKfSxDmKvjHzqNm2zathaCLG0W0axtqjGZWqiKKJKto22itJjM0GxEkw20YsbNS2GQmkYIaNKaMFsa2EmwbAbbYwY1KL9YW/NIupniUX2jPQxus7a60dZpu12yMQM7X05hhx7ZyhANoVV7b1vZ2SmixkYF19oQEBA7OSb8oSRXPne90v2++YJJNpL58qhAXkvZno73L48YXUJ6a8kjcvbtjtq94onmU8igJB27x3BeahmVXKuqew+D69y/Qo8aR/6Shh9k6TlcvHjaY/VIthWKC0cHj6IrTCTr7B6en+Pd7xj959v+V+B9/xuR8HSdLt+EV0WeX4Vx/H/h95+C45ZXdx6VSzcVX8or5+T1uPtdX6AqqnNoJzcnH6uEKuGrYVNqlIWxVcPf8Du8HDs/Dw+PhcnO8PF4Lu3R88fcn6JICBYrKl0b6fv+RRsLCX1eNv7UqMMbAVHmUokaSJv/F39P0+WkqgfWVSSfkyR9Y9NnqA7zhkkV0Rg7L2NOSpsRIrtKQqk2QT6syE8Z56ZY2C2mRat0ZM8HZJ5lUo9scPn9juNttdVk7Sk3WoV3bLnVh2nuUsHvFTadiIucEc3FDKwstmrv3WYXmqtyPGnaIfhEomQMgl75XxrGA51SriwfIO4WhTwviTUcxIUFaYifGKsc1bBJAjKOYJKeAYcMJ55BufTevZJzAdFCKg7A7FGmJu7oT0g3JUKOpebMJpAUQwUc9+JKlSSihRstpoOhE1dZ868iSSOaDmncLIXZ8867cgKEJ6zUCSd2WpkMQSZph1XUYikBLBOtp5vAq3uF+WGqWFQUjA8tRHADpvmwZMwsZL05KFmASAFtOdRhN1jECUNaprCC04aUyii24m6Wv0pAg8wlfmOtMHjwSgwB9SSSBpAlMSkiU8JCcwoxAmQQwvuwaQo0hWM6wCEopJMgQigiBqHlCj1SYTBCyIhg6PNzJwOlCdNp668GIdPHpAGQgMM6t3Yi5SWE2/cqYJXaaUlfvDv2C76BeFj6glhh5SGK70nq+POop15DoL8mJLDB2JLXHLvAlwCi/dvey8MAZXWQPbGQPJ8XAqRnPOWAMn5MxQEBqYBWAcYGQSYKDMEQYTVKB1T6iBvJJC/VNErjJAcVhfaRZPVIUcJ5DivafLEVq1IbcixHQFJiBwwyoDQ1LHk1Ugd4lxKBtVUTEeXVeRWS8BqwwF1UiQIcFiiEZYmBedO5peESikGfVmchkdRx1vOMFB4hoC4lZqNTSo1tgQ/OgVVbDQtNBRauMQQhAOhkwxYWU4TsJczrTaLDQEnoN+0DRJ7hNsCaX8gRm+OOunlYRBIw12G0y+c0QgHj8q5USSblSNsLorLfJacYWQTPbJHCELnYEEft/FRL9//zFBWSZTWfkhQ9kGI0nfgEAAUAd/8AABAAquZ5wgYMZ++++gVkpAUkQCoBIoKUoldmklCqFAQkgAkUqgDQNQBSSKkVQKKlc+0AAAaCgAABgAAAAAIaAAAA2zgI5KAAEgAdOgPbNjznQAAAAAPQFAA4PAqQoCCoAPgNr7h0Gh6d5eO748O9feezLrInsztin2YkwD6R9JIqTeHpgEbu76AF92d7xAAFBxNUBQAA9O++4rmp2027jL6Ge2q1ttKnD4QCh7ho+gAZ97tXoH0e9q7tdszZ2M2G7atjfPKLwAPoPX3AAAAAAB6YHoEgF7LZptmjbaz1fD2fVDDj7KHoO97vYHx2Pozsy9Gb3HO28WkbfPiAAGHooANtSL2JaPkYnbEiexn2ZY6q+++D5D6AC+95I9sBn3ucQC9ihEbfA8PoJPDQAH2jIKPkVJSREkT7MZ9QC8B6AGY8dGOsoiSO2Ws2zbF15oPBoABnt7JLZRptknzdz77znxmeHkkoIWxgABQAEOGSkzbaUqlKNMRhHplPQaQk896qqSqmmgNBkyGGUD2kpKpADAQASaSCakpUA0AAApKlA96qmpUaYAAhgpKIhJSoAAAD897+fv9f+v4VEqqX/zBIbH/1+v8H7/N/sd/7KEKFtQkVRx/tv9/27zwd13/fd71lD/Xr/Xmw1TYk++5zm9bLop7tuvPn3Vr9zq4lMU5TnOc2nfKazp7Nom11a5l49tLXvHusHNZc1nuPNr3D133evb+nNHL9nKbx0nDeHdDy87rm9d9Ns9t9eOOc7tT1zfN6VV+aqq8tS3nN13pXLUVV15uKvkqv13973t9VFVXTlzFVXGqq70u870+VVVdfKqredr9zHN8337nbvvMt+rrutqoqaTvt7tvzmct77dzWjtW57Dmrw77NnOXure3SWt6U3ns92ZO5rkZANVZ4yEDPhkA39zN7aBDKiq3vFDhHnavnbr19z227yy/VJy6R5K86R+Y1Xz9lDthtmbC5THHdlUFlGLQiaEKCCAmiMlMSoPFSRSy7MKAMgFkA7zKNQ+PlVvxeW8lx+950S2cx1ykA79CBjIBo7xM7mQYfNYY7EbswZmG6fa1myqBC0A4EDRtDUkfiPbnw8852h8od+e+l+D89+hz2hz7zxwjjjKHEl5XNNv1D6l3TVHec22ocnqRx54vW7/Wdqj57duO/O79uMeYYPVXEPENvKH3nItp7lV4/VDzvjKGvSHxDNz3+/eaofPl8EYLXih+I795OzK0h6k55b+4cr53vdHWZOOMMSbpVisghAGQBhA+TfOahpDUNt11D3lRzNbZfKpcPvzw/e/cdbsjzgcoaoZCc1qMes8Z9wZwMcl2FpYohD6QDWVLgQDCAI9lIBriF+pJTbZ33+79/Cva+s2sNaVsjMMzWbbckfl8f3JyahrMhkNqh+9UOd0jNuPhHhOTZPKI8iGBIa+m6TaCi6fPkm+anO13dMu3OKyAWKPNd3o4goBwOJEZMZsQUvd6ZaVLrDOGQ7rtCB3RB0A6pklEU4yZdmEHlnE2kOMIV2aqyQ1DHRs5uuqcy4atyTNGxVmho0YGzUy+5MSMYYwsQXePNCX6nU+r1zl1qust1rmRQ53fuc++JvNvHly5k2g12/LhYZqyufEKTerJTZuilaL153nofelZWbO36Q9ob2uUMA7IAgBuQBkjv23KcpZtttdvn7Pd5IfqHyp8IdzB58Q4h8Q+odQ9oc874zIZDXz7y+OEuJfP7kjo83HC+UO5xHvflDxdoee0Pewzwv3vz++S+nmc5Lnz+I7x/fr2ndD3nUNcQ74h5435DqHJXz4h7vSeKfENzm5Q8XUNQ4hhPvOZDIfyHivn329fkN9VlD3N6h734h5wbfElJNZdb+19yxPKNe/eofJrJALxh7XbkhzG7+O4cOmWhunM7x1lrhIyDvzz9VHTVHfJPk+VuLZLMraWwtpbyR4ocU/sHlqS3lshqGuOIY2Mkua/tw2SRmILMca0awWWIW2QYAlZTih2JkNuet8l3nchx4hqHjZDnFc1hpd8tb5M2/IYhs+XpHXfezaR52c58POGvHxlWyRmnwZK7qcbZR25w7VlqGiuUMhqcvlDEfzKhLms0SUqBKy7LjXEIGbh52llakznAbKtltNhVtD6+kfz2h5Xce5jdTzj3qr2TpBTQQMKiIW1iGIWYmZVS1bHJuEcUrlDlDIahub97Q8XSnd3xV5X7he8/vCHiq+IYhLIBaVVbIBgX6ncMJAMLJhDutniPl0jdpOROSPOPYfaHkvbYqvEMrao7fHnaH08Q1D+5kOCfFW+8f2nuqH7KBewODIBvwd06kAyHDxJNllL9SmB7Nmm3DJc1aUbQZey4S4UtmOa3e8heCtUX9frmnI2UNfYTCMMszdhMEx1fYaQN61D2iQDoM/HN80PEPBZDkG1PvVSc++9idvv9IfeOYriHw5Pn8ofyp4fJVvjfn39qzW2sm1T3y+9gOuwksISd4CQKyAXi9nJXPFjIPniXd3+l8+tUPH383hLubpiNQ1sRqHmpxQsvJU5zzzFJANHXRuECxmcmvbhOuDv1wt9Cd+kA9IB8P2gjwgB1nt67bk7OySsIOQ1D+vtD539lDd1TtDnj4/PnxaWSY7PtD9qHvjt2h150KZCIXUASe1pyZnE0maEbkUCD27b2LEcfPaHtDdQ5C5quaL3K8mh73ztypxV43aL5gj3qj477eUMJtXNznKjwTPgcdoePf2eaRvgqc9I5CfICQklALzNh8d7M6mtmhTVrJRlTczj41QxDlDPaL75XJnQlCBg/e79372oEJrUDtgQlNfeLECHvlQ+alYjLZsk20rIZ7+492fr5scSXzB5iOaPdPJ5Q8djjNY2jm5o81xQ7Q9Atnbp8faH3wj59d+UPPAmiHOXfu9997ugQgJALYQEJHUIqu12Jqx4Rw2xmNlbOZP7R3vKpahp8vxP557prbd44htnso3JGSMlD1Vm3vLh5Q3k556+NXaG5vKHsyTzHIxbHxjG3FDlUa/uVyC8qOXJZc3DbOWjNMRhHMhxiNKeyNwvNWXjGzCXZ0KO7ZrV1pRbBRAxREWZjBZVYgxhkCysmJkZJGplsRrMxlYxLJLZlosVbYgNomFwJJ2CST6gdYY7gTL2mjm8gbSFkAZYQ/IekPEObl++FHyr4S1/Zre0N5Q4RiatPnDiPzUO0khM+7ec+7773d7pIQUgFYSTeSxXaKG0ykAaAsJWBcstshVpIDcVV9/pT2h5v7zmXqhn9iHKH88UvcHil/FcqV9qHvny75+od4R4F1/Z++o4coeXGstPc2eHb21RtL5RbYlcLieayabVT5pTh5wB/f35Q2ofvXya+tH7EfB6oeeoZDlDjyHlbRHJvpx1dP3b81DKHiS97PuSfXOU2lOUOFfMhxDb+73iHnir6j66pZQ/o7lTsT52/i4fc9DIfQ2r5MhuOfZ+n9tN7kPKGeXzJ038RtAgdkAZpug9IjotMtJIgh1IQNSAMgHlVV5kgHe727kIKCJH3z/r+f79/fv9/X+fWf7BzjlwRlUfEf7ij2h1z1ybVV8kfJzMniX355R+C9XruofudVs9597ojNFwxRdm7GAD7C8YcAMkgGFCD+I555C3jk45+DUO0NQ+8Q5Q3n6xm81z5x1o9odUOyDAodzmvvue+9hQgHO4yAJAEgCQyH9xeZ3nPdkMk73iGQ9rIBkCBZA9IAySzL5wJAO7ua9z37+/efqPD8+9X8504Iy5MkZa817QxXF77uZsxGod/rvjHTwjhmvdXN3tDs+qu/xK7qifu+Pt9wa+HXykdp2ocockctAa98yPpuRL6kcP3oq+BtMqNQ+aThG7dnadxrVmJMXUOcucQ+x8rVB8auhXps0S8Q5G4qPmidoZRXl8fL1Q98/n99PuflPgXw0l8BH13nfn53vvd8kPYHyhgj53W71Dy7GaJyq3Xga5Vfv6ckOVJqG89zSNev25s3rYOeIdQ2I9XbuW3dOUNkNOIa9Q4Ryd3O5zrHEN5zKaVL5x3PjTjwTePFLvztD29Dy4doYrtDKyG+IabczzVCLNTTCBhKyBhDhC7lRhg1uFw0PNTZ0Wttsh6ZS8fD5yNZgW6bQLqEBkAbCbCgDIG6QDbWSA61DITBXLOm6Gjr8M2LwptRZHjXc01M2Gs2fb5u1tJXdDmaLq4hdFVMOXbpMjnLttOIZNWXiXYlCeu/rxOdOOIu6EJ08u9ZganeFB60M0KpSEJmEAUgCARXIGJsKP2s197nfvZhAOkA+JEEgCdEgTWFKIrXt5o2SYkl2lOajsgGsu9a1bk23USAa2QBJMIBr3x9lFKObw6hq5+Q+0N36wX3+5zG+a5mGioqmqdwgFkAckAzZAM0twNw8CkSMRjJbRKkiSK2QBmFpDUt9HvLZRxEvK5rl45Q5Y/XnenG5qGodoaWQEgFkAadkgUF9xiox7xbUVhApbFGZDLMdWqAyAJlIqSMhzIbcuX6JzhGI18vR0fcI8Oh5YbVZtm2bNVsrpPNUm0rYjx0TiGaa3vsiS8zDD6koQmEAtLw1CBhwIFgXe3JGO0eqG5Q6XP5ahrX19jZyXAozsvsXEzVq7lvd5rWt6zvMxpSusMCcyA6mtb1rW99jZs2bjTQ5uUO3lD2h48oeUOX9y5zddbnFDypPaHFD78QyHxD4ht3CNz9Yv1DahpPgbj3+d+sgGgXYQGQBkA9y957v33umvggfd8Q99S5/eF9Q8oeVdQ+EZA0QDOkA3mrx2EDNm+U1ospuhXLpDiH2H9Eao5tI1VtKzNtrbUNaQ1tmHjUNP0T9+bSPt7Xj6/VD11iOXmIbV9pP305Nc7yo2Upy+vNUti9e0PfiGz8I6ofxL80J8D+ifxe/jbYTzv34o+R5hvPjKA0Xwap6EDLIBqQDwdzvub733ggdeK1Q/B+5Q985bLmmDgj7Q+cjw13mg3w7qlfJz02b4+/nvrbZk9eOBzGRoGabX9qUvftd9zvvfa0hjCkgfBAWBA+k2MPs8NI4XaH70jr0vt2p9oepEkX3dd39z73u9fMVBkkizISMqEBSMZxhAvrv3ue95IAyAOyyTvTPhHyJ9jKhu/fF9I/Xwu/3j6+fEyXKZD6DBuu0mtGzEyxivtZNkdbnNtJp9zpO1NPvbDDM0p5NJaTSQtryaS6lU0lxP1nu616b5FUk3MN9pLcFMcfAtvX33x0fg+ByZJNTSyY73Weab7CdxgKLv6E53PQneXY9JMz3N+/fW6tAreTAHj798H7rwAFrewAAekx+439vt4n79397ne/PUvzYdAAXjYPFtc5wDcmWNbms3oHjdaB4AC1vYAANb7xZMveznLzs5z9P159fjW+ffuqu9cbIiJve/VeNg8aAKffSZzfvu3l38399+7SAAAFrewAAekzqOPgAAAF42Dx6TOe+1rWta1D9wWtyYA8AAAFrewAAekzhwO8+99OzetyZf0/WTmr599xt6140AVuTNe2cDwAAAWt7AABcutSZvc+1JvTXwU9DYAALxsHjo4BuTLk22ClyNAAAWt7AAB6TLr29/ttcfjwYm97AXjYPF5xwFrcmAPAAABa3sAAHpMNgAAAC8bB41rXe6skkmZJOPufnfg9ZmQn6TO8++HfFaAOAdFumtgOAdHpmVrbve+5+93e9+3qV+5ft92kzPe7i973udzluZDM27pJ+12797i013N8KVuTAHgAAAtb2AAD0mGwAAABeNg8Wcs3krfODxvXry6yZzWs+vP0193T7fulofwA/gLW9gAA+9kz7u4bfdeP04Yxn6cJM/ZM/fsmc8e8Tk4k857LpJ+xp8NKY9c5zIp1TXknNT777m9a1N/c3Obn6c3fe94AC1vYAAN+kw7vfB3wAAAXjYPFtc5wD05JhwPHyB+AALW9gAAtkz5zgeAAAC8bB40AVNyZ7e5qPefct++9rcuvrJnH2298fFWt7AAB6TDYAAAAvGweLmrkz7k3XOcHjfbuTNfNvwtAAAFrewAAeyZvrun5+dUAAAXjYPHrON8BXuSYcDwDGJ9N7F63sAACyZpsB42AAC8bB46OAe/N/smOa4deAAAC1vYAAFkz7bgeAAAC8bB4vOOAtbkwB4Ad7E3b9rf0s19q1z729Tcmffuffv2+R9qTOcyY5z6Pu9UAAXjYPF9vckzJmZMyb/OPjouZJkmSTkmNg8AAAFrewAAekw2AAAALxsHjcmXzbg8bkwB4AAALW9gAA9Jhm8YxEuTP0eyZzW/tcaz1573vd95Pm7+k03W9aHruYdc3ozLhn2sy7u8Qqm9G87FHlLWGypW5HK780PfXH4Y0Zb3mLr15wzMZjeGrT6bwIG7p0ZrGpqgxICwDiYIZT2HtzXDX2Y5ZS9fXQOZUdW65hTbM2ZOS73dNzLqGjJMYT776/OppXpvsOHM2Vodzlw0Q5cNHpsvdb3Oc+9mtcTGcmTXtQ+zaAYpvZzmF1N7JZzKnN8mHWUSc6TpvtMdKnb9gd08692nvuTR7l0V3lfgtNTRZsXLvHuYxc0lDMpy2Z9LgozHfKPjp3d4pxdNbaZ1OndQ6aiJecuGhLyjd6qvEd3O8zzPB9dvJDqQlSnKkXeQzae5zPM7qgPa5hrRUWJ3g5WHmFUGnTeRLmXH65sZQdaLhiWwU+s9z7L16Z76kwu8EecOpk3z1uGOHbvadQ3dYx+TNFMmrjHTQuTN3WaziAe5ZPnrEgp3G9NVOWLxw+5rABW+vc+3pDmrNprM9kzEdLPa7mbzLeW58nK3hzgpmNOFlEuS8zmXOc4bA0z4+3Odzejj9ENoPN8+0XNxFdmaupcuqwy5gm2uazLbadNGHNY5vtnI6JmqaTpvWla6O205rNb5sZhxKb480Vhw225rL2zDY5m2G/hpxc1T7Rs1dULJFbRntEk0LDVPTlzGlLvCiPx2nrrIXAuw30OIOp777LBJp30sw1ANaNGDXdKt1AuI7p4w957vXrrvc2KHzTYLvc2a7svyaTg81l4rmGjScPHJ3U4bvM44nMMnYdKfcNdLkd6w2b1KzKwu0Ns9n2y82L3Rvn3eQ7wy0wg8b3UX4OSty773gifZX7iZ7PvOtaxz52bNbrs1rW9s3Ecoprru5uaCUXjM2nW71uyVJa0WgqqY3qbc7bxprud06pitodd6soltO5WyF4pcm3m5Yq0Sg8duk7mb0KYlTnDuIJpN9DWdTfWazuZkcMRN6aqqKqrXluaKGDNHN59s9nO+ww3YLH72dzC09oN69TTqdS77OGiGmTzqGyNOl2d1vNZtlz5w3zOP3fWtyYA8AAAFrewAAekw2AAAALxsHjvNDg8bkwB4AAP4Fre38AAPSYbAAMzMySXWIioXnd6XfbO6Hrnm0lzDyT93L997X6cv3OSZr9r9Jrmr+fPW0B0cAAD0NgAA9JhsAAEADuT9qDj8HtnAUAGpMAK3AHgAN/g+PAAfpMD4AAc9JnPj4X1GMYxL7775+dADJgAAAAF/Nj8AAABeNg8d5+kwfn54AAALW9gAA1v0mGw9QAABeNg8fdHH4O8yYPh473effWd7ea/TeTN6mt6r7j73atoDW/SYbD1AAAF42DxeXvJJn7WZJka+OrXeZMHw8AAAFrewAAa36TDYeoAAAvGwePt9mSWTNamSSTMk2c9v88/Vcme+yY4+HgAAAtb3jGA1v0mGw9QAABeNg8Xum8vrr4kznsft/vW+ta3kwB6gAAC1vYAAPSYbAAAAHuHA8b56b1Z99K+/cO09yZmobDwAAAehsAc/fl7JnuTWtanebkxq6zmtzXOigA9w4HjkzJJ7hweVvJlaB4AAAPQ2AABcmd24fg8bAAB7hwPe9987LN8O81l0bU1zxS5W0cpwdua5bMJznL7Itxb69bUR7vPEy52c6k6qt5zns89QAAB6Gz+AH8HfSZw58FMAHuHA8bmZJ9mSTWQ+/qGq7Q5zZ+yW0uK2zjnNuU25LijmoZDUNQ+/Dc86xuscbNPlDir2vl/UOUPkNQ+0OUNQ92czPvDa5ju2pzc6ocoeUPrBzxQ8x7uc7u/z2h9kPaG4D7QyL54VZ80+65zUPaHtDpcf1GvO3PnX7Sa3vJGTM+zWs/XszJNzynVVuTAHgAAA9DYAALZMb2AAAAPcOB47Lr3d6mcua1YYqKu41gqJibuYbPAATZqenwlzeYndWaearrWE24SjQnslJ973Oe731bkwB4AAAPQ2AAD0mGwAA12XupM5c1j9n32/vZ3X1HHutEda06crtqblbU3x78/PWtyYA8AAAHobAAAsmabAAAAHuHA8efrzXHOHRuTAHgAAA9DYAAPSYbAAAAHuHJpzMzv737Wpn6T03nPcn0Zmanr7v35VbkwB4AAAPQ2AAD0mGwAAAB7hwPHZ9d63qZeTvPt7/R+mu/d38fU3JgDwAAAehsAAAAABeZZmObDwAGTM79Zkk5rNTm5rX6TP347qpM29r15yuqDJmwHgAAA3+D48AB+kwPgABzU9EbHgAG9AKABbuTN7b2AADYDwAG/gfngAO+7Jhz5+AAxO/kmfeyTzyE5YRsJ7IR25COQjYRsJqwmQjkI1SD8+CO3oRMCOe1iEdBHcmam5M+7z6TOb+93frSgAAakwAoANAFABv7ux868AB67+kzbXweK0AbAeAP4e8c4fwAD2XU1NSa1qT9ZM5yRrfDoAC59ZMc2Oj2jgAAAAADJnjZ387d73N81Mzee855v194eAAvN8+fg6oAOSYB0erWwAAc6OHQAHZMHAAAAD37JkncmpmZne894v3620AGpMAKAAAPeOcAADsmDgAAQAMusyRczFz3EG5zvPcneo73mcze4tbTXZOT2Zc0pgBQAfA/AAHunHwAA/SYHwLJm7mST6Zkk1mD6h/N0l0hqG/IahuUROZkzNezPe5z7fvLVaAPI2AABkwAAB42AAAAPfjh+D3rfe+1JnnffvLaAAAPpM9Wtn4A1zm+AcA6AA904+AAHbqekxx98AANgPHRwAAPVrYAALJjQAAAd3d3fT8IYjeofSGQ+0PEPqHEPyGQ+KvNvj48e7nt5tzkyTuuZmbzJJY/fe731oAAAAAAAAAAO/fffD87u7u7u7u+KHqG+ftD1D8Q+UMh9Q6h4h6hqH1D4hkOofZDz6h8IfyH2nUPiHiHvxD6h1DxD1D31D571IBogG1HWffd1xC7jRo5h9vPs1rhTNkAwIB8EA4QC3Z7wTW/XXO9++94AeNgAA9WtgAAsmVvYAANAFAByUPsT5kfKjxRpGW/O7z57vffeAD3DgeAAAAAP3JMD8eOfA/dAAXjYPHZez7Jklkz9+x37nsmffffK8AAAG/Gw8AAA/gB/HpMNgEAHc1MyTU7MZMk7kyT9s715W9AKABkwAPGwAAe6cfAAC9kzTR8CABPzJkns0c+B7RwAAGTN4H30+++HgAPdOPgABz9kzXjb86OQDovZ97J97Jkm8mSc3NamtTMkmpkk3nU8+vloAPaOAAAyYAG9gLXAOgAPfjh+AAMmSdyT9Jmhx+CzI0AbAeAA9WtgAA9LJmo3t37774eAA9w4Hjmr9JnzgLW5M/B8eAAAD942+AAHpMNgAAADcAeJya1Mkmpkk977JkmofcKrcmAPAAABvxsPAAekw2AAAAP3A+1JP0zX09M3kyTuTJO5zf3Pvxa3JgDwAAAehsAAHpMNgAAADcAeLkku5X33ANyZsBarQB0cAADYDxAA8bAAB6GwHdZMk2PwV6TLGtgA7r777g8eNgAA9DYAAAAADuTJOXJkn6ZklkmOb/HfAAeNgAAADo4AAAAAButA8bmZIyZJ9kyTQO+LJjQAAGwHgAN+Nvvvvvh4AP4Afz0mGwC37uZklyZJqZMk1kyTk/O8+dV8D8AAbQDwADJgAAAAL82HQAGrrMknPSD400utNLnm2lEnnc8ZMzNe32b4QzOk/Xx8D8AAbrQPAAAAAAd++++HjXJMz7XZlkma/fc71x55at1kxrYAAPVrYAALJjQAAAAe+ODoADs5Jn0mD8d8AB42AACxoAACyY0AABsB4AC+yJmu5Mi0hppbaaR32TAMzMzI2+ND01reltK59+5rJ+3zk5zUtv37qh2TBwAAEmZM9+maz9w+PeAAumwAAMmAAAGwHgAL+bH4AAtsyMmSffpqa1MkmpkkZMkSZ973v34oAAA9WtgAAsmNAAAAB744OhznM9rJkiZkm52TO8fHQAGwHgAAA3WgeAAAAAPWTPm+B45qa1k9JnjnDw2A8eNgAA8jYAAGTAAAAAOaA8ZzqZkhw6NyYA8fufHKvs577tObChO+NfbBCb3UJmpIGdv3t5ntKvPpeELxmWaTNA2+S1nFTOX3O81/w5d9/fvet3sXu+hMJiYESayhaE0e0HGhN6eaQmcM134vKXVCfa+6fuxCd7hmceZ3QTvIRF+hHyc0CyQlIJymPl5Q58ufYwjPVD2+8PPZyfqHLi1DEjn2ivDHnvi5y/u9Yoc3mXNUPnz6o5fNU2Uu3Uj3l6Ro7Q8X9458zy6zm0OvIvaHtDWxDycDwj3Sl75ftPD5c+37+tT9QeSezarvz+4tUqqEBKSQ1yQD1DcgHRN6wkHcoczIeeNBopsleXJhjYakIZGe7kNmpAPqQJsw093FuUJkPpANTpNfbUUUcPjZIGa719JN0PFfM1jbTfH7UDYV7Ov3LzPHykx8S4+rZetQyj6i9+vv3F+c8l9vr92wTLH7n5m/g1V5I5/ZQ8uOJHdXnlfJXyhxeNb++OczW+BAyQD4+s5zm+skBs7MjaZq7pVxtuIZlOcqH7G6465rcfn3nnlOW81xzjVDxNQ5Q9o0RoviN5NQyZZL9vlDTX9uI+UNyfCPiG3Xb6vap7ROrRL3s1DtScfz5PEZ7U9f1jZQ8a7QxvHDwI8SebsTUny9/fPf3vP6hl+/6IlKT/pHA/pH8hf2Yfv77+13n9/Z3dULv3vbOL77MPrUiC1g/H32g+3xh96kzfrLitjL93XNlE5eHkuizO5754Z5932/bde+2bninDBSos8hCQvS6y+ymDKuvvu65t3d/c396nmE3sz57u79zuz7Hmx27gKRCMVGW7ylzNqbLWv39/lCkA5/w/fp+qluBs33+73u8t39zXxPf2vSAUkCd1tDZsG1UwWqllmE1DCn7R86T3HSmrbbbW2ZJbEfYcq5VlG+KG798JFtQc98tpHyryq5s1lrdcQ5Q2XlS3GbjnNKnLX94X7+7+9I2la+kfm5j+of8/nVN2KfHuI8UfPX+A6k61D3bdb5BjijUP7z/UP0S/ej6oYh1ltmmzrKH+6rlRtNlT9hD3By1XFD7yXWZkV3VFfz2Jc/HM1DvaQ78/PlD/ff19vfOeUS9u8qn59zZJ7JPsV7nO5cTubfLfr9+vA034gX622/W38nJJPpPG1Lf1vjVxq3y3n721325y2e22361tpptJXy3763beJTDG5z09AL9cbv3n62+27X6tx/sb3fN3z7b+Mtt9t8tv63xMySSfTGpipf1tt+uK2/gA+DwL+ttv1y231LxJ5u+bmpNptJtPeb7bbfrltvttdTfoIzElizniXmZFazzJiqg9bBjGTSg23QwwFthmbDZpNqbKzWw22bjRMtZJEFBjFiCRGC0tq0uqzS2asbNm001WttYzWWLMxY/yzzFnhpzS/W23622/NIxKSSSUoAAA5JOgdt733ve2/W38/EmeOST2Yk2nsp7bbfrjTSVbaaaaVt9oHpl54rbffuW28+ttv33APfQAttB8zMzP91z/f7/fP9/f30j+VttoT9QzlDQ8bSWLM8kgW0TuZltoWTMx5JJJaAAAUTVy2222JowAD0Im0uU4egFoXltvttiMSxJ4vd8aYfg4EVy22/JO3x2228inQPgO9+oAAB0AAD/VJ9aVtttt/Adtu239bQ8OeJMAQ4jbb67u7u71DkP55EvNt/P5/FcSdtoBAD0ttvLbaAAF/W223bQttttto2gPweJMAv1ttttAAAPEAAaGJu4rf1ttpaK2222+NNKgAaeB4kwA+AAAD+W98aaXe97z/f7/f5+SZqTPbzMN8bkwH4c4bkwPL614q8rxfAHpgFDgX9aXGnbbibSkkkU2fknQA4ABL+xNJ/YlufsXiTPSE8aZ45/TlVu++Cq9qag05Q/lRGH+Fgi2Sh/WVOM/mY+GJZCERhAEfkcwTGyh3AKh/iYjvLzdbW2Zmw3sTssCmyKH1qH79d3fvn9ekpD7LsPNk13nnv3777wpUp2oiHSh3nd3d8l2SojzFt2l3fHfPypO3Y6ECTdxvmTcbSW42kiTkDz1rMWetPT3vd53zU3fsM+vqXKQsJpK+TXvffc+IJXYBalNVN3l5bb0wh31931pZOHOAFVtttoAAVp3St3baeAAtAAqAAJJJIxJNPXomtrm967rWm0m9aSm0J9yq2FOZzUrNSmucKp3JzVQ9yg8wralE7ifMQOWSTYTqYhteUxe/Pzbie+ePeOVHsnjgpLzRI8xJNttpeYl7+knJD80zF7JJ7swaY1VDvO7u7u+5dO+++IfOpSdqu1L48MONMPJOTGkklubiSbW4km0kSSnmsNgdAvskmTJZdTeTN2212QAOgAAAASSSQAABAAEkkkGmAAQAAjTbTS5ppJNTSSSd/aKfdJc2mzvfPCSnzURfvfbO9tIttttmTMygA05mZJAO1bb73vLb9XR34ABfSZMkt3q224AAEkkkEAASSSSSSSAAAJs0AASAB0AAE2krvbSTeNSc5yZJJmA28HbbbbMkyVbbbcknjRibSMZiDxtgEk1OY2ktzcSTftTMki+8vbbQAL6TJkt3q22vAAEkkkEAASSSQTYABAAAkkkEAASSSQbShtpvs2zRpJNYnNd9+779kkkmT9+/fvdtCZgH4kmYAttckkkA6JMPzWSZkfnMySO71JjeZJGpmSToO22hWgL7MyNu3bT1bbc/W2u22SOSQQCAOySSRSSSEkknve96TUkkhJJIJtpJfJ6in8yWLJAXuFe87u7u+/e736n5wdYW222S73MySXQ5Bfi22227jUzJItt/W2g3kwA9MkzJntNTYBRySSCkkkGnIAA2jQABJJIIAAkkkgmwAASYAAJtJRNZmJcxpNZjTSk/bMkhDGnJJNmBqTGgHWpMO8Hxbr3ve956luoOZpp5rOZl9mYZmZmejTZtABlNAAQAA973ukNgB3vez03JIAgAnve973e96EJl9TnutJJJTnLNS3MzVttvqNXMC21zMk43AeX3ve9bd5kkLf1vr9bmZnszM7mZ5KakkmRqSSQEwAI3JJISSSQaYAAgAAQAAIAADve973vQkn19gZlhJIEOMhBEgQJGszD43nir2222SSVbbbbdxqZkkNh39qTDkmcttvbd5Jkwtt7bazMzMzMzLxaetITaaWkB4MlWgACSSSSSSSSSSAAAAAAAAAAAAAW2y9SaSNb000ve4ve8mk22ve9Z20DcmATMyPWW2227ayTJjWSSTAfhJgP1jR8AAAMyiabaRrQAYAAAAAAAAAAAAAAAAAAAAAAEkLU20H79f8AFHHKZlGARXHYSO7n9sgG0RIBhAMIBeYQC3u/fe37++AmvSAXf9rJAPdIB/Zf7WO/v2Q2nuFhpxA2Eceas2ilTqVxi85dJNCDmGBjqAAEBqqgu2b3ZpEZMwvzOBASbRRZ1z7eHBFD5h1xEZIVk+cfzOEA2QCr957rUNtYozVK9SxC5CUzLKkxqjLa8yYGQgrFIjo83LrDZ88Hm75l+15dxDmkHDCAXJCTs/Twpw/uh+iTP6Ucy0cJWN3r45v++vb7yK9CAwgMJBCAyGBtKuTUrj3l0N2itUbVGIbn3tDqzZS1De4OSPHETj2Xx++eF6qpgzUY0jEYzZDIbYLJGsKs1KzMWNNSY+SP3XUNbUPv3zvm2zamyakaahoo1LCMoarLa21strMWtWlimVNZQ2oZJtNtiTahhZDbbNNqpeeeeeeap6JsSu84RtyquNEYquc8iWFLvCvMIxkwjMVWWqltrNbabbS0S1UttVLaaxGzSzFtrSzZmLDKMmoZCPvJXJGQyjKGbNZMhtsqwlkjQ8ylNiGWRX7ROoaGZNQ2lu8cDTlDBOFJqttbNk2qUwaodniG1WIzGqXMSe74EZS3x5KXjIAwiIoPmwkgcfZZgY+9Qjrefp+/bkzXjatKjUmbnxbz9+u7dZM/UsmNHjeTN6W9t3+9ecky79w4d/G5M5CcD3xuTBxY04bkzXHyX36evOb7dyZaGj6eda7rv25M5qfmJM+k7vf5++n77y2bSZJhdTN7xZpJ5mZhUbu9NO20SfpXOePuZMHnWuTpuTH7Y/addNyZ5sI+r9v8/SYbe64bkwPhs3JjN+++IGDAF6yqkUhBVkqBHgUFUWREMKNG1ahwKUMYWCwUEWRQUDjhaSBWBDGBUIsICxYVkBtKMs2zMojEFEW0WwWFtZVSpUhWVkkWGGWYyqxECUSpCjKkO5YCwMHUZKgqmVZKgqCVhRLZSCIirAKlYEo2/Ot0J3vve9zx71Ce9vf039rPtamub1r3tyZ5b0X4OyYZu22206bkxoK1qfrqTLd39bu/G5MHOjnGaky236W3dbkwcJPZw3vn47ufpM99uczMsOF3rM5xJzmZ7DJprNJMp3NiNJP3fPcpLxQ0g1Db33z33S97vru5PmRW0KEpLq+v2/WE9nN/fEM001fr39dyZdPy19zm/xuTDf5E2b+NyYO/G5+Dz96B6k/NDFv48nJzff4W37l8tv2gSfc3uNgpoh+yfTDsmPzT2v3Pe977ffeDXg/DhNgdaMySXMkmskk1mSTUmSe3mSTckx3j82/NOD0devX4+NgZJmR4AkmSRMkmpmSTWpkyT83y8bjnR4X7YOSYHxtqTAEaofhxo0CKr8HzZ9vWh035utyYFd20bkwEjr7RuTB3Y8O+fo+3JgnG9BuTPpMPldV4HjbUmIAorQB41sOCw6Avpnve97ygaGgfrd2yST48SYac8MCAG8aeecniXPOZ7mZvM/b+8zzpdfJ80Ket73kn2LUDiIIhIf6f5x/z6yVDX72B/ia/ynDP0U/v4kTbXjTxJJJtPzvf53vf56cA/SSSNJJuQjkkkniZiTTSMbMQeJoxNGJtIJbbbdZMkupMySAPABzJgH4oo/f6FMGkahlmqo1DSahk0TSJzSORLKaJaofv3Ch+1Kfcoffn91Dmq2bKzSVW1QjUNUh7pUnmyGVRVqGoGobMF775Koe6kLtAdgqdjtCT3FtNi2KUPpvFDEjBqwWEsoYK1DFqGOyPKGGsqls1DRLUO3fEVdqHxqH33d8qPqhmQxGyzK2qqaJqouwXlDJGoZ3eSTsJe5VXvvkU/MWxQtQ2UMkvdVV775UvcBzFV2iXbvnylOimKyW1hsWzWUVaJaQpqGRVYLVDCWUrVZqHeBCd3l2pH33gju8qUuzaps2liyh9a87zyloXd3d9dpH41SnuiPfj34PdJ7qH7987jJRqGRNQyJWwVPd4i1lbVDKWoYTMhWoYlahlSe++VXuiOl3kS7vBR7qkjUMIdoLu8lO1JHZ3d8FOoYTMRqGRDqP3VE/MlbUqtkabTmNNtJrMSSaaTt33nNSdt+73qbN3d5udaeNpJzyxySQaduK59nuL5pNO+K/lcVxXFMt8JJJyTxtJUADX60w7u+u7vjvnu75d358RT+FI/SMpmooahlTbQ21qGrUMRzOWqRMRqLZjG2oaVHvvgK9yV8mQ22Ta1Mq22A+6FPv9xIPCMKV/apJ3nnxQ1CahqqgyGEbKVg0pW1BGQ1slBqGEnbtQu1FdpHd4/NshbJVWMrUNKtQyVqG7InmrWMzUNKtNRGUZU989+Fe6Kvi1Q1mM22WtszG2bNrR7qHvviIPfrxRsiP3793y22/cKH79yh5QzUMrUMqMoaahtFmobKGUNQ1NVgNQwpgyANQ0o9xSl775Sj3KXuqk998XtDJJNpA1DNQ1CGoYQbUMhtQylGDEPdR5SwbGoabVm2VlDUbDUNMbUMkGo1VNQ2oZqG0TS998qJ7pfNpLGZs1lrMxthdnZCu7x9VYVRZDbWxKGUO3lolqKahsoaRpDEbETLJDUNtJahpRqGSnbsSu1IuwF2RLu9ofEqtshlCpqG2NQyKOyjyhlKHed3d3eqVX4BaKtQxqrY7eKgiCIsiT3va0gIwVRSCgbYdnd3w+polrCyhqpMBpVqGKahqjVYu8Dy48baAD5JtLvNq3P37L+TaaS7jTSbT7pJpe8fr+/dy5qgBG2ZldtttmdbaabUkz8/PsjUanVtttusySUDquDu+O87u7vzu+6K/aS/UNtUeanvvi91D333+fKRPdVOxdnaldpdqS7Hd5SL1QwrVXd53fXd3fKYs2A9mS5kk0ONB9Mlb1mSQd3d7E92g027zwu3Z3d3fT1psPFjSQfgABbjTzHmNsAAIY8xJ5iQAAA2JtJdxNNJJd73v3e977AkkttoYAckakB3Jhv3ve9f2TLq/km0kHoBoAABJJPPLy7vObYmp3xTDYP2TFAJkLbbbJlttttmS2222zJW8mG8ajUN41kkUAjWZbbbUnbbbbU1P15kmez2tTl8EaSabTX2NNr76Qk97DYeAAJJtk8bSWm4fjZuY1MyQASZbupkcvLrMSUxJtJeySBoAABJJPkm0k7l3d3bE10zxNmB4HiDxpf0xIaxW/rbbRNZltAbV1bbbRNAAAkzTzSSV0nbvLocyZLBwts/a1qSW222yWSW2+93ep6JP6wR9aS81J/Wqqklcaf63y7b6ch5u7u6m0mtISSRKTxJzEm0pibRjSDxmIxhJPpvnu+NJp7jSbZPpA0AAAkknyaSuXd3dsSc7vJjUaNjmZi0BMgtttky2222zJbbbbZkrcmNGw+mRaAmQCSSRJySSSR/Y3G2mriSbW4mtxsmw5oDXd/zsKi/tSUnv+5NJfpz63pepO9TflttIZ3Emm8SdwKYjEYjEbixJh+a/Y2m2jHcTtt9ByScSSSe5uJtJbiTaSJJA31pgB8Afmn+Ukk1NpNP+nfOxySWJqfzxJgwA9Mi3AEyDLbbZMtstttmTtu5bbbMlbkxbfrd5nohwDs1M1rNaki1pK222jumrbbaJoSTThtJ3SaSSXcZjbS8TWNpteP7xptptP6/vbbD+Wm0Vpe3+Lb9bb79X74PyW2+97y200PAAAkknySbfcupvd3bE1yd/JMz05ByZKbttpMhbbfZkutW222zJu7u7upvcMScGmfgD1pokAAE0QtttSdAAE1e1NJbWtajXNttNJfNPEm2mzF8c4HTISSTfZIH0kkkn5pNXWDkjUayPTM973e9LaaADRbeN3Stae000n8b+tt+qaP20nbeJW3jSQQAAaXnnkm7u7qaMzJJJJqa3ZJbbMlbkxo21Pw+n2syD4H5rWTUgAACTkkkkia5s+9n5VcXPyX7FmZjzF9+9+58k0knMaaa+++PuB0PAkk5Ek5Ivve9773lfjqyZu2/W2vwAAJJPWkkrl5znLYmp3xJgAGpokgAJkC22yZbbbbZkttttsyVuTAHpkW0CZAttsmW2222ZNXm/7L++7ncr3SO7IaZDIP+aRxqS39xJbEe85bCbEdyh57zzEeZ5vW6hiPmJPc7m0j5iTxnb+4RxDKM27/u3bQfbfJ0w3kKz4y7Rw13Xz5CcEIGvbwOOtbIB3WYQCzMaSO5rMy/Vuk8mtauxd7xY7ZdFDmUFUimJISjxY7EtpY1rzOZn3O+3vV9rf32d9oAaU1CLmbNRy5d/CP3Xqo9xHlDcEeKHnMTrxtpK63SxO1aRtnCjxEyZkmUaO0N72TrtJypLRhGJZQ15VcnKk7/fOv2jxplpqGsVso09oY5XKLk4R5xX7Sd0bSMYp5lRxS2Usq1DLjijnNY0jbGMtZRypcghTTLlZWSQGQFjLSSkoywnXlkM11zlMoaDMza4jnDT5nWMtkjV0NKTTB/d5BXSNLUMZlVYjExHHL9x3COz65KlxdI0/suWSTfdJp4TyaNNNLyzSyaYST0mjM7zMwa+6lvfv1t/fqc5zjmgNcvve+931NAPW222j2jgMttttony2/XOY/b/fvxWgBbbbb6/OB0FttocAB73v2/e57wr8HxnvZk9NSHdcz9MTmti2ayWMc0OZatt8rv4fPxb7vte95ezPqfHQYAK0A28WXttWuA7JndZOPH7uFfLb8CAW2220P2/kQ678972i4jCjUMexh5u+O73uWTPa1rJrWTWo04FttttO+N8B+9Jqe3db5bbXcs1tx8BZWgFAHwyYmYyZ+yYyYyZ99998fg+Q3JgDy222jeTD4HutyY0v2ZLbfrb2ffh+fujnRw6Ozgnw8XMkjQBoArubyZJrmTJNTBwersmh8B3IOAdiHAO5N5Mk1g4Ffu5lTTnwAA7PG+AdyTeTJB8FdD7QNDxsrUmSdHFaUAHcHAO5COAdmVpwDsHAOyQ69qTPe9J737gHZkHAfstvLba6OAdNz3Lkzn3yXqhqvaI0OZslqGVW07Q3G2TuqqcN2WK+6KaeOmWz8qr5fGkv2JJNoNMCU4B+AM6k8xvMz1AA42kjLmZMAACNPMzgAAYH93/STck1NTJJkySa1Mm7u73dSfcaaRn7EngABG0SQABtBbbcmW2223MlttttzJW5MD4fk4sYB8ADf2NLMeZmJPMYAARmK7u7u7vafHqH754Rz35+Pisoj93mm79dtIi3Pzb8zy9/d97iT76u/u98vc8xNNi3qb9X488t/cWh5+1p/fjP08SRzxGW2e8V88Ma/HoH5pNMxbl8uUDTCLzJxpn4PRASSeqpY0nmXnOctianfEmAAamiSAAJoAkmtqZJJJNTW7u7u6mtPEnJJJxNBJAATUkm7utoySSSamdkICyAbQkLbdvmfJoFhdbwAGv0/eyHfOkk/TknTltt8toBoHxoH77xpySSScgfgAhgAAfmnJJ3l5znLHEn1Y8Ri8PPEn7jMRhjZiMTWwk9kkTWK5mW2pMAAE0AAV1NZmc73aT1G2mvjkmck1rWsLfrbfta1mTSACbMSeY8xtySSSR5jzEnnlgu/v35755b/fvbv+51X2fHrmv1ttAAA973ve3QAAAJJJN0nE33l3d21xLuJPMWJA8wPMMSB536+3T19kCoye977X331TWLMzLbUmAACaAAK6mrd5pJ5nx4YHiaCaSSJoQBJIk93d3d1NatbkPJpIWpz3pJ7fvbJfv2Z7MvHbarbmZbbfr9bXXXsmXV3Jlu7bX4ALTDwJOSK8u7u6ONqTzuJMOAcbWrPgMwzMTVttASYABjqatt9bamrq5tJ5lvbpNYsy25mYmrbaAkwAATWc7uTW7LqTJOX/Or9/u0fENhTwAA973ve94DgAtty0/u973vbra3e/knMa3d6n6uLElixvMADmh+EnrSdtxZba0sm95mZmWpoAICaDOJO224lE1rmZbmZiaxW2gJOSY0wBQ7AD5kAxr+TuBfc0ZjCezx73fv7909UuYk76vxO78tzMmpP397P2NP8u+nat7fORpmAAAqpPyAA5dAD4DjTPp77bbbbu3xXn3nOctjT53xp7kkk+TWHCQATWMtoZUnALaJrjqYACX7SeLR9tJ229TeNMkA+qaqtoAk5JJATWusL6/vriod5l260a5VDF6B3fO/xJzv7m2B4AHs+n7znOGz9Dtt+u237lD8NOSSSTkxJh4AAIkkk3SdqX3331upqLI++JMADiaj3dkkj9zMSQmxAADFmJzAADU1Fu7u7I2jEnJJJxtRboW2poAkjazWJu220TQvXWt6t7bf3+fhz3O97zrxbd2208e973ve8AASSKT9uJPSXnPvryzYmvsWJPH3EmHhmZnmlvQBaCaqxp5mZbW0aAAjetONPd3d2RtCxJw8AD5NCm7pJE0KW0BJ4mwABtbst5v3O+17336e++v0NZhfTs973vKB9JnwfO7Hve973vAAAAAEkk1N3nOXdupruJOSbuzU1ZJAI3+QgAkTcxZjxZmMySSSaszMTeLHopJJqmJZjTzNU/fknJIHEtxW22AmjGnbaDamgAyia5BJpbV2hwhsh/xDjmznNQ5Q+fOfO+qLqiyHfnUOofP+e/7zIeiA3UgFCR9dGJctP1sYqpxl5fRM7s9nCAe5xmiAdMIAuvbIHDmxwD5Q96V5dQ73tPuTcXM2+eoe/bJ03yYDSAJAKkAdc7TqaCiQaNi5nN/X7Oc5tN+3JwGARSEJ9IwIVJIZCMKfaJM3S6SJPPr9oKSBr+zn9xUPh9uUOfvYjrRHfPzj2Zjt9+nd83+e59cmNdX7ttru9gJqfEHPxW3QeH077Xue97wAi2222j3Tj5fe973vKPgc/aiMma5zve/fugAPrbfrbQ4B3LbbbaACd73ve9AAZ70kiazJrWTJms1LbbfAtt5+/Od70AhuTAweAABbbbbQAIBkAAFttttBMAt9JczJNW20WRJoDYn2grwALJJbbbaADUme971t3Jnq4AF9q7tttAAPe973veBmAC223tu8mJMkAHRy2/rdyZdWgXvpDEbE87u7799/Ch6ofm89+PffQBAttttupgFayZWhb+tvMma3LaHgC23dt5afABNTLbbb6gALbbbaAAtt3MmSW208bx98DtLbbaAA5znABrJkgBbbbbaAA2AYG2nPdSaasm6ZfsuLOz3unQ+D75fgvve973lAAPxuZnve973gAAABgDADneppNZjSzG08xLMbbtk2KbFmmwybJrJismqsmqZNTJlkxTJkyZLJlLamTVWTJpNZMUyZSyYmTJMmS1NVW2aoZMpkyYaTDMxZMpkyqzNlZMVZMmVZTWTVaoyZBk1VaxsrJkWTFWGqsmImTSZMhssxVYZRk1Vk0rDI2TE0piaTaVZNUtrMsZFZMmTUGGTJkwyYajJkyMllWpkyZNJmRkxkxLJhLJibLNtKMmUNlGTVFtUZMUyYmTVWTJkyZMmTSyZGYoyYsmTJpMmqGJlW1TakZNUMyZMMmJk1Rk1IyakYYLNUMmVZNJkzJiZMUyaGZtLMSyaTJhMmTJqhkxNrZtG1NiFtIbJWyMmJsjZNYSyaTWEyYTNCsTCsmoMTVDJqLJhMmotobRDJqhk0iMmUyaVTJkWTIZNUmTJkxYTEyaqyrKsmkWTJiZViYTJkyYm0jJlWTFSyZJWTIjJlMmlRk1IYmJkxMTEyZMmTJoTEyrJiZMTEyYmqsmJiZFkwmTIsmo2S2pVk0iyZNoUyZUTJoVk0EyZJkyZMoZMqyZFk0mTIGTJkxVkyZNRZMqxMTEyZMqyZMmJkyZMmTKsmUtpZqTJkWTSKsmqpMmkRkyVLKsmTCLJhMoZVNvv379+/7++1SPyYVFkyZNUkyalVkyismKsmQMTExMR3nhd3d3fac73333gE1JJN3Unom5JJImpJJJImoeJOSSTiaESSACakkm7qT0ackkkTXy1qYp40/13ts9xXF9zxzG4eJvzDEYI8k8ib6fjqTtl7vffF2puh+ACZk8m7vtnlvlttppxph6j0PQhh8Y1eec5zlsTU74k5JJOJoRJIAJqSSbupPSSSWpqgACatziTzMeZga0klbarLd1N5jzEnmIXAAIJY1FkAA1NZu4s619780k00/sabTSf2SBsw7aAfST9KHiYX0+aSAOfNIxIPLjuLp3vh1p9873veq5cVt/Jq4lcauK4krjdviuNKq39b47jVxO4riTMTRjMMbSab+vOfW6mt3v5JyST5NSbom4AJo4ASRJzd3QE1VbbbamgziTttvk1aGNO5mYmswzMtqTtAATV4vtfsM4n7vufc99VT6gAEmSTd0m7pJIAAAAW2/rbQAkkoEkl8+vOctia3d76k5JPU1JNGnIAmtAAkSe7Ju7qaikkkkTW7p6k5JPU1JNGnIAmvgAJELEmsxySSSTFizFmGemnqaSMnU+fe/c377fvpd+OgAAB22207aAB2gSSSSQAJJJJIAT1pyS+cu85Z0aeYsxPMUk/P3EnMbkn77FmJ5JP0GmAJoz4JJNTU0ABtXWrbbbU0AACaAzqTuNPMz9Mj8ATI1b73vdmRO7/c5/TM+kPnfDtAAhgABbQACQttoBJJKAAAAAAMAI077JJJYk93d3d1Ne971yZbbMn+HPpMW1+mTs1GwLMhZbbbUmAACaAK07bU1bc6k8tp8mjQOACa9J7PzTn0nL3V7ojGn4cOHw/iC8xJ/H73C3t5fknv61N2/fXtvz+Ut+tt+oLQ7kwc7PN7btvLqTnv79r67zbdTW7u7u9mYm8xSSDTAGNgEkImpIepMA9TQjQABNTd3d3Unu7uNO21NdtttpU1bbbRNXN5DZrM7ZH9/gDxsDltt/W0VpkytZMB22220oAYBANkk3vu2SSxJ7u99Scknqa+kkGmAJqSTnJramSSScTUQAAk5JnUmZb1NWW3GnbU1QJASe7ukmpqb32rz9+LPf3e4d5PQ4B+AkkkkJOgAW2kkkkkACSSSSAEkl8+vOctiT3e/knu7p8mgAA9UaWLHiWpNakxbbQzJb+qZgJjoFky+ziTAOprMa1mczMzMTUTt2gAbXmtG/lom5IIbR77oTn7vs3Z+3N59TYdp8A+W222rbbbQeurbbaAAACSSpNp/fr99bqT3kffUnJJ6mhAQzMxNWkoDa5oDE3bRNHgAEmSrOpO23qaw1mcuZmYmpbQBJyTGmAKfv+c9/564FX9iHcou/fOv2Q9V4m9pJpI57ncwinLe9+xtJGkmks9uXWcQ8i0p9wX9iPvvnt4htENv2t5XeYezvefb17w9OEApAGQDZAHQpt9lzlPne6rIApAM+5z3t/EA6T5h3txOXmfe+7773Q195ziVgLtmO0WLHLCQhUgCQDO633YMYI/PC5y20IAPq1+53feve2B+/d1x4vz+/efPSl+1D5kjmqNqG0y1DSsoOcpOIrjCuNKsW0bFtUtpDWTWLY2tlmk2sobQ1DUHC5UOMRomkZDGUNZRtSWxDWmLBWWSW95I7rr3iBzGwiypmmoahlQ9+87qbCM9rkV/aS/YnmJP3OKmQ1Besf2kOZJ/edTtVIG7b70/e8oBH7SDvR8ABbbbbQBbbbbQB6XJlAdoB87MznZ3vPwqAB9bb9baADAD8HwBzve873oD3ve947yHd1YVFkgVoIVUlWMeNFBGImACwbKCgUsUot7hkQRwrCMttlqAlRVZRWStMxeNZjzF55+993QAAAHraS8xbu7vNPwHQQED6TAfhD73vc97vtAHRy228ttOgHve973vOBcnuHvnCc+3W0lqbSxpvc880kA+APQJLbbaAC2222gAW2220B+NyYfSZ9JnJM5JnwD4H4Afv3f0mdvP37797yhkzEyayZmaANaG+7Ovx9ZMkAK0bkxbbe207u72hxG7u7vffUPVFkNZqkmtW20ANjctvbe2gALbbdZmZMtoDWTALbbbaAAttttoAC2222gALbb66tA0QHr7V3bbQANZMkdz7n3w8PjcmDgLbbbaAHve8d3Ca+7lzkyMkCjJAGBBoMpKbSRqwypc0E+/f75/f7+/n75+9eY8SfV4/sS7dv63ve0AAkkkkJQAD+/v4ttttrzUmNQAAMfmpMP1+0j3yp8++y+B9Vmqqp2koT8WNrCd9dxp7jbp+nqTkk9TVQEgAmpsk3dSe83RpySGZiSzTQAiQkpp76k5JPU0ICSAJqTd3nE1MzN3RpyTU15Hs/X39754Ykw806er8K3y4k/rbLeVpS/Y7jTtvwzXJ38mytu75e9ve7+t9ToFtsn65f0vyufiqW8Uadvlt/EknVzqW/te+9D4SZP3EmAdTVmrbbampMABJgFTdtqavrbbamqgzqTtt6msWZmZmZiatoAJMAxp22po0inFNz7Wta7zk199/vt7zp3Vd/xzAOkIH6UeAfuAW22tM8AANAAO227bf1oSScafee3d22Nqb51TPEnMmL9J+TR7gHoAJqSbu7qT3d0Tckian0kkkQixZJ5v1Kh9aE+fn77eCw9R972ve8ejSkkkmpMkkkkTXcTSXlbSXi6sTSXvnt+bdtw73yH1p+ACSToAWq2gAASSSTSSSSAAABJJNu2TdupxL/jf6TGjbUyW20EyC222TLbbbbMlttttmS6uq3JgP0mAAmszLbbUnbbbbW1b4z9pNJe5r05O9+7fre9AACStNJAAFJNJJKFJJJtk2ZJAAAAGAaWSSTbE1JPz6eSYbxprMgATILbbcyftW2230ye96222ZLq2vpMD6ZP2tDgE7kAAAk5JJJImudzOeL8m0q2ksTSSdmlEzLZM1oxStmtrGxptJXG2mmvG3fe93ve/d6AADTDqXczH3vO973v1kkEAezt8DgH6bakgAwLaBArTdocaZxGJJPl3ecsiakk7+kwPpkFAmQW22yZbbbbZkttttsyXVtfSYH0yCgTILbb6Xvvvvvvvvqu1Nmoas0zWzaP5A/slD+ZIQUkhGyT+/sP71JP5/mZ/b734+98/Mzn5p+AT0zraS0ACikibgn3MWXLfb3q4k87y1N278Ad8pcTd4BPQAAJJk9bqay8+5y2JqSTvyTAPU06ATIttttky2222zJbbbbZktpr9JgfTI6AZItttpNazWpM1p3dzu7u4ffeF+4fzL4vrweN4hi/e+/l+vJb5TtAAAEBjTADkk/SSQMmEfB9b66ttAK/t/wf73f97vf34TWK255J5mZ1NVS222pqsAASYgABNZVbbbU1TZm0nbb1NYpbbbU1iAAEnIAAmqmkt63v77777Plr6/oOAt/oNB/L4B/f39bQX+FslAAAJJOXl3d22Jrd3vqTkk9TQuAEyLbbbZMttttsyW2222ZLbX6TA+mR0AmRbbbbJlttttazFiX7xQn5t9z977++6vs+7y+d83u0IAElaSAALEB+SAPTG2ZbQAgBbbZcAAAAkk4m7y7u7dTVknTOJMD8mr6222pqgAZUnbbbRNAAAmg95+ky2vpkdAJkW222yZbbbbYvM+f8/f0hwhisVn/ENQ745Q8Q+ft+8Uc8Q8fyHlDmQ/2gklIBqnt6wHX1N89n3Nfa4z5CBze7w0G+0P5xDQ9/Fz9swMIAhApAE+ww+GjUzvNNzfj7l0uanYEh9JIik2raaj7Q2sq1DZQ1I5MBcosimoccWLSqtJyhd4RwoZFah+zlDVWqjUOeUqcVcLgLlZUr747YllDSK0NdoL3jtDEdhj5iU7Q0o7blD/cEq80SXaH09Dp5lLzaxlsUyqtEunBViMoNmW5Q3CccE4VsHA+G7d4oY/uO1DNmaxWLIdI+dI91Dw5lyoZQwZU8OSLic5zFWKuZsTZjLmqcNP7nZZ2LalGxViquUMc1tJeNcO0Oc0s1tsmzMoZRhG7ziWQ2bKjtDKP7op2Nb7kuP3E9oar+8dSfdwWda63mST9My33Pve9+8ft8fh58Qad0BQEJMAAAttttobPjrttvf3LaABJnrzee973P3lroBr3ve97vgbATwAAAjTN3ft3zmgAAAKTUvsSbWNY0ka3qTU1JMjUmTN73mtHx4AH3ve573vAA6u7bbaABbbbbQAW222a1aBWaH3ve5mZJPe94CNmNZgASak2lMkkgEbS4sZgegvskuatttOjgPZdW221+s02fArQBWgA/W3lttFu7Qetq3cmW3jQrQAttttoAgXltt/WgXJMmNAt9mSZn6amsms1q5q360MzJIBoW2+tt5kyQDoFtv31aHf3XRwC2gOjkmSAdLbbbaAAtttvJmSWh0ayZIC311MyTmsmScyZJbbV9Y1Jj4H4+yZltv1t8byYAOTJki5c73vZnXvHQAcaky23621+gfA/F+5v3vckz3701vN5mbmTszNTjJFqHTWnKpNNE+8dbr++emnd/h4lN8X4v1u5e8AAAk60wACxo3gH97+/gFv8FaAAt/XSTl5d3eWRpySfz5JgHqaOAAAmiS222TLbbbbMlttttmS2222zIAGTLpBz6TA/fpMOAJkyTuphVfr+z9+7friTtvJ8wPDEmBoeXbfbbb9EpgIxJgFs9PF0vPUnbLeXtoAABGmYACYHqM+wV83d3l7HmLMzEnmNAPRqS220syXlr9JgfZk/RozMzMTWAADaqWru222poSulbbbU1rUxSHyTAPU0SSSSJqY/bc89nt297M797aBAJJkkk8h9vu/vN3dIdrTtTdvLfLfAAAANDwAkkzlXK093m2xNW2221J22221NW22gmrpFt/eSeZtZpNHgC2tqgGAmqrbaCTkkkia5znOTdTXvOtOdV9pt8v7QA4BJJJ45ltDw+B+/gB/HjYBbb7d397nt7iT5zt9TU6AACf2ZjQB6AemJPMWYk8wwAA0xJ5izEnmAABDEnmLMSeYwAAhiTzFmJPPfAA4EMLZtLbu7vr6Lu7vn6xbNi27zu7u7uesWZsW7u767u7vpsWZtTfzzv4eeqrHmLzHP33v3PP2e+/VXy9oCANMkkkkAkkkkhKSSSUlAAAJJN3dl55znOW9FmNrFizG1gAAQWYk8WLMbWagATWpM1NTQBcZgBZkACZLbX6TA+mQAMyBbbZkttttuZP9vXv07zn2z53y3/AFttskAkkkkhLu7u7Zf1ADgBJJu7tXxznOWxNSSSSRNTJPFJ38kwPyTPgAzMbWW222prttttqTALbamrbbbbky6yS6kustckwczMfgCZPud/prn6np960zh0r5yly/vsSf1p99JJJQUkxpySSGyydD5Jh23qb73lp+AJkAEgJ999999pUnJJJJE1JJJJE1JJJJJk/wAmS22u5MHMn01mA6H2s1NZk1rWsgBYmsgBZkttttuYt9WdR5bbtp3L9QPQgeNMPwAQ5v6fpJO6YWtO228gfgAAAttAJu7xpxcN3dtiakkkkiakkneJMD8mvcWAAmS2222yZbbbbZkttttsyW212TByZPgBMlttttzJ7f6b1yTJP6h/zi5QzKGqv9xQ5K1D31p27cuXvm4ugepgfpOh8jPGmH5lt82cknJCRN7vW0l0A7b3vQAAkk3d394uY+tpLuNpLFt5OTvYmpJJJImpJI7Jg5MnwAmS2222yZbbbbZkttttsyW212TByZAAzIC20Dys/mkA1SAe/d90hdoa3vWt739+7+777voAj4ACu22220APUmAHwAAAAAAAAASTjTmbVtkkpF142gCyTAAzLrNW2uyYOTIAGZAW2zJbbbbZMttttsyW22yRNSSQ4kwPya3Ue4mkhNvEknmZmJnfZJAr/EAYBMd20AHTd1uxoGJbUUqUtW+u3CAIYyTiSYyDlCBUSaSsBZvRAP7eg1usVUXbamc3M1kPqGhbEed8vLzYthenOa1rv17rRX6SEHCBOvwRACS81D3KrWKqPHvJKM5cKPsrzJTJ9nYEJv8Eeb3tUJM72EkMCaKO+/PPfPL1+/3IoP1i2SP9kPMZWqn5pB7Iyj3ezKXfPjaaT5pJpZlw7o2k/TOcDqzPZm0mLJnfmvu/nzT9uTHXFOPzkmD99dyjcmfDjn40bkx0aI85Jm7fWvI1JgHAvokze/smc55+Hn56/pM7yc43zvGpfTeTP3dd9v9+/c/a87+rcmG64PxuTO6Nhxp7cmVx8Nm5MW363Vs3JlDZwRp+SZvrWLPDzftW4k+fboAESfjTPAP0nJjaa/Y2k+ZiaSxpqY0+T2GnDGpMaB7veXUmbakzT9we9Qnj7g813Vttvajh8NH7kma4y369s8d+kzT4+PJ53kmafXltt9Jm+6kzV4DzUfbkz2jj9f1u5M1d20flyOSZ3jh+vL0ISGCDGfaCX77PvvfZ7YfRk9oJnvb0fTd9k7q/SZu9/X9WjcmAdT67ky2/rb5ORuTAeciXcmW2cvLbR7Rs/Bj9dgd03Jh3g+A7vmW/Sj1fg/B8D5bfrbUkkmNAH79JgfBbu0HrMySNA3b6TMkl1b20byZIeNtSY8+c3Jlts+/e8A/AXmattvJmSdtE6BBu31SZvJh46Wt7yYcB7ndyZdW3tt63uTDb8Hxu223u7QedcyZJ8foa3+7bb30oNvwj57d/W3l7abkwB7RXNzM+7J37v3eh2AABDQfjPe9z3vdvvUJ7u/dLuEC9/uftPMrkUa4Ln9zn3+KXZkq9tSd1R7K/cVJ9T3hyfhH8NHkiNpNJ902ku8ur/A/fp++xegB9I6AAW2SSSSHJJJKYULbbQAE2AABu1tNz+ABrfe+NMkkltSdttttTVttATVttuCTzNpq9tttraoBltTWZmZltTQAAJMAMsia97kA371pnD6d58gPzTDT3yOpfgALaK3Lcadtt/W7Pd3SS9t4k+pvverve9tAAAC85x85y2JqSOSSRNdAYBMlty13Jg5mQ6gEnp4Ojiaq1bbbRNAAAkwAATVttttTXJmU/frdvlvvbfrYehI+gegFvJQAAtaYAeNo0t/W2W2gBDAD6Sfr9fvu/JPne/k0INAATUhJ9JPzakkkkiakkkkiTkkkkiakkkkiakkhxJgfk0fAAAmiSSSRJ7jaaS6sbSTa8zxW+8tt9pPYpJ7J2OSSSASSSSQk3d3d62kqFtoSSSclAD99Vye7u2yZLbbbbMlttttmT/ACZLbbbbMgATJbbbbZkADIAEnd3d3d3SJdqIe6FeBpRf3z394I9ZDahsX+aT+3dRLZz9JOW7d/b2zJJJCKSUPWmFu3ngAAWSSfST9QAJJJJIEkl+vOc7xp73/cmQAMyAttmS2222yZbbbbZkttttsyW213Jg5MgAZkBbbMgASZk9byczUySak2zk1JrWe89Anx2exSSTsUkkkAkkkkhyRtySSEh1ppW38Yk0gD1NpB4W5fUkmgDmtPuqdAO9iakkkkiTkkkkiakkkkie4lPJN3dTUAAATW5u7PUnIHqTOAaAJokm7utqNZJJ9JI2tLm77+T+8s+tnzT+t76SQ9aYT9urd3SEoHjTA4guikm7tk9k7WmlcSfxbb3e9stSttjTvcxNJXPPkgD07Y0AHs4k7dzJf1tSYbJkctttsmX3vW22ZLbbbamudAATVy23MzE1JAsSdzONrw+CACa7tWmZ7759jeYkln31afwWfvP172hsoBJIAB9PZJPZIDTCSTZknU2kW2nO5iaSvidttvGmle9t+aaVtvZJ776Jq6xPe9222iaEwABNfgDvknu+Joz0bZhgBE19u6SSJOSSSSJqSSSSNrd5w+Se74YmjPgACJrZMSS9xfr7ag+6SSdAOgAAWSSSSE2SSSBLU3b+uJNID8gA8LbQ391d3fYH79W11rQcABNVWgAmpK0wyNu3bXNW8ALU1q0AEngAAmqrbbbU0aDYZxp27adttttTXNc1zLnYc77wav3PPMxY0cCTpZJFJO9QAAFkUkkkJN3d3SQVaaVtttttaaVlvl+dxJtO2375rnnPvrdTW7skkiTkkkkiaklttsyW22/70mG5MACZGgW+jVttttSdttttTVttttTX4nD7f7abpAN7/jz3X8YQDLq0GVyYyAUVIRVPvaMJNCQBN53f9r+3zpAjfsIBV5reURrvcIBrApAFrIBUTnsLnM2nbdb9o5uEht3ri3AzUNZc7l4W7oU3F9lIAg77sPbOW6dNIAl78faIA6aQDeub0fFgtb/fdzm9ftH7f3M/XbftHoa2pT43eknbFa1QybbNFrPmLik1DIaUbJ5QzJXyWPznaHSF8/OHHV71VPlxwVOwmKrZtRMn3kciMbINkjKMwTCZlW0LEahjSjEeUMJyZqGatpGxNjZJtUNVS5y5Yh4jlQ9yjuEY2JZtEtQ+5DlDEf7RzGoenA+6i7ZVhRpNqhzEnhadqHk0VMzapGQyrLUNrabW2zUNPfO3wqabWNsyqbK2tam1J405myzIr5xQ/u/BG5kdfeeale+c82YV7Jn7dvve/eABrmvHODzo5znAPetttrwAt1bbbVW/OcDx9oHQfg+d/fv378KAK1LbbbTQ+CugLQDpu8ttv6nd3d3d3dyvffXuA2ItqvjXmH15bfqoAV9bb9b6um5MaBxbb+ttBwDtoNjx88XbvFFadD4oG1tlvbaGiAnrcmS220MAX11bbaADnbd2/raADv63l+ttAAjJjJjJjJjJjMn0++3Jn33wL0AFt+tt+obNyYD8fOfS7ky3t7+vdU+A4F/W220DfjYFzJJ6TNXdtrh9MyT7JknAq2t5Mkttt7bAAFtttlpoApbfXVtocyZIB03M7bu29tPwfB03bbbaAAvva973vKrUmScyZI6OOn1lt+toAD77774AcyZIB0AAAAAAn6ebkac4ni4m/FjbSWNpLMahsiyGi2omQy2RMxY8TN+3pvPGcnUkvd8SzeG3rDa5J0AE2AAABJJJITd3d0kAAOq299zE0l3ve973varmJpLvf27u81JbmpPvi7+zJvWa1mD4DMgtttmS2222yZbbbbZkttttsyW229jUzDeTkACakkkkiTkkkkia31SxfvMSzPcVTdX7nnLz1p2rtXo8APmmAHVy23807bacoVp2228m7vNxbZAAA7b1J96m+973vbSNO7u7u2RNSSSd1JmGJoDgACaAkkkSckkkkTUkkkkTUkkhqWG5kHQJkFttuf8NZIA9MiaxJpTvyxY8X0+7z8Iz3n8BTrIbs7+JJJAD8H0k/SSRpgm5JJFJ1ppFttttAAAA+6mkujTz9JJO6mt3d3TUnMTV5bbbU1+yu221JlrttsVTVq5bbamigGCTuk1c1rPZmZmJokkkSckk5NanPy4+tZ6vsxLG3jKm5RE97ZF5J2ZA2pgAAUJKABTd3d3dFMScEAep20vyaaVx2222/tnN93dtiazYpLf1SeaTW6AAmsxatttqTlAATQbu7siankkkIkzE14SSSAmskkkkSZbbbamt6bdXhdPa1+5Pa9Jzveqy/ttMk5NT4+yy3d1bczKW225QAA+WZmZhbQAAA27u7u3U1VJJJ2JMxJySSSRtSSSaRNSSQAE0AE5MbW7u6A2gAATQAAJMAAE1eyE1zvPdO8i2z7dxJ7u7sm2gABQkkkkJJJJJJJJIAFaaVtttt9Oec5zl1Nbu6H4Sd0k7bbba1vVttsTV0ABE1JJJEnJJICaAAiakkkiaoAFra8xtJZqXkXdqPcznmaW+tPs802bGnQO/W+pPLb807bEfSQaYAfSSSSStNItttt2luNNK3ve/JPve9735NfffffGpPuk1bbLbU1baENJq2222pq2222toAAE1bbbbU1bbbbU0AACTAABNXR9ozq3v3E0lPTq+WlPs++9llu4TeyTvbbbZb4EkkkkbQB40z5ACK00pjTStoBbSSSSSdfOc5zl6mt3d0tqbW7bbbW0AACaAABJgAA1bbbbU1oAATVAAtTQABakn91ZnvKuLlM++5334u5y7DoAAUJu7u6aSSSSSptIzxpgemJNIt/NNKlvrTSttvzTSudzE0l3v2fs3fd+5zsbUkm7upoAAEmAACaAABNAAFqbV3bbbU1QABJgAAmgAATQTiGQDhp3db3+CeD8OB1nSTXf7+/r5Pt/uf3dW5CeySeyABsySTdJJJAArTSttvzTSttqbttHbbfmmkJvztADeypJK231trattAE0AACTAABNAAAmgAATVttttTQAANVW222prXD4s1D9rTaX7e20lTSaS3UfJpLhX5OfbzO3e3O61y63q5n69Oa1vns06n0RL99nfcub1s926sJGBDjCA+ShIHxAusR20MXdbEuIbaOE5iwJLCAgsoMElaRtCsVGNtQ5VsI0KZDRGwPK4rUNHD5yuCzbaq0m8NPTrXXCuM5SNVK1D3+d5rpahjCn9rvwC8Bw7qHe0PnfFDypXkjx2JcEZHzl4R0VaJpG9yf3KH96/uoPlEdI2Z8dI7Q6FbKO4jn7hQ4k/Ouo7u+0PS/se9le6gWQJYIwRRD7Xr7mhCee913veXp7weNbodfl+fAC6tstt9+gffg+W2220ffg+/P27d362/qFrex7Jn79+/fjwAP0nz9b+vf1+tH4C2222gBO973r3tgAPe9M+1Pj76SYPve8ACcnve9973vgfgP1u5MurbaADue173ve8ABbbbbQOjjfV3be20E7ofFvsxKJtJYm1mSSQCMwAN1bu7ugAAHpLq222rGgCZmWJpuTACXUNyYAyZfe973vX8Hwfg+ky2/W2/UABGfSZItv1ttAAW2220ABbZkyZbbaAA5bbf1t3MyR8bkwc8841xuTLby3lv1bkw8+ckyQAbttteNyZIA8ttttrkAvm28mSFtvbbQAFttttBqbyZI+rQ/eeurbbQAH3333xGpMA3kyQoeNTeTJAHquY0AWNb73vezep3Jm6qr23sgCEJqSEm7ZBIkgGEsgSsXohA07WQDcQge99neb+895/fdTb8azGvjnOzvPjm7u97JJJIAEkk9m74L2STgAAAVt973ve/czE0l3ve973vohE9nykn59xsxJvMeLEnPJJJImpu7oCTAABNAAAmgAC1Nq29ttqatoAJMAAE0AACa+fEaS3raF1WcN8af79sbc+Mvmnb9wArTtuZ7Mu3Mtqtdv1/S6lu6AAAP9/f3+kz8Zq3e9hP2Ym1bbbbU1bbbRtAAAkwAATQAAJoAAtTau7bbamqAAJTTZuSSNoJ79vvUu9yaTektJJpe98fnCH07u82zd4VPoAFMltoAG7Z405JJcK00pbfe5iaS73t+aaXe+dxJpd72222m3d5zl4muc5znJrXZPZJNiTxFFFPr999999z4UUU++73vedRVFGJSeSSbEsWLFifEsk/KSSKJYsWYuJK3attE0EklE2aetNa2Vp221NTe05pNpP3ejf2k3mlPr9l/evzTA/W39QA3SAAB6kwk9kkkAKnc8adt/K3y37n2etvPv2tJpL777iAkn1bQAAJPwAAmpAJE0eAC1NqbkgCa2SSg2pJCRJySe8mopJAE1Ub3uat/eV1z2vub8ljzFmZjvjS5jS/ffW97inOc7vNvZ6pJPZANAAAScngH4A9ACttp22222yVppABGnnW+k3ed2ptb5u7u6miSSRJyfAAmgAATQABam1d23dtqavgAEmAACaAACrT7pa+/c7bLT1J29508kJJIAAAAEkkm6SSSAACAAOtNK420u5iaS87iTtt+++77Xve8Z8m1bb621tW2gCaAC21NW20BJgAAmgAATQAAJq2222toAAtba4sF19WaX7uZc/Vpn2+6/QOu5MHMttrJgfP7J/H2TFafb9pWST6UAAAACQAPjO51J5niXmbuh+raoAA2gAATQAAJMAAE0AACaAALU2rb222pq2gAkw3d3dTXeb++z9mJfv3np3Fe/d7k6TQIAST+AdI5/v7+A97+t5ky23+b6B4BbiTSAAPn99998RNat3d3exNqSeyS1e1rS1Vu222j0tLQAAjTAAskknve970VAAt0jRoAvmno4J73mdzMn362311bbSAH4AX3lvLbTo20wA+DwOoAOq1ec5znOXnOc5zgt3d3dkkkkEaQAWJPVtttkkklQABJJJAtttsrT/TxmC71rvd+D6e99+1n7lt+mY/B8CAAW222TLdjgfAB4AAaAAVppW0afy3s/bu93nOLkmd0AAKSST3ve96ySSQAAskkkEAMCSAgOfd3793p717xNJd9vfeYfrz7yTS7DDG0kCaS33u7vXYXMwze55JpXy9SxLc34Tf4993n7Jnxdlvl9TSVbSX2fH7TCpeXYmZZt8+N/fJAMzuoxPt8/fe777YHoAehwDnv7OZznvOfAeAfGcv623lz/f7a6Xn6PxHhGI5SpsI0Rzk2xtkZDUNpGmZMsYioxrKgsFgyAMICyDlukaVpUyGjYbXh4q40ppAzdkcVNpK2fv94RdyV69Pv7l7Q95jYjWRDkOcWSWiNrK4W9tUc33xI/tPA+d6vS5n9uqn1qCf2fPEnCrc+byS597WSZ3h+2mmST3vfe9312bBA19bb9+tcALbbbaAAAD4H7lltv62gAszPu+17nvTymwHjJnve973vBsAeurbu0fjYJ73ve97wAD37uZGpdZzU5+5NDDSKhlpWVnDRhTGGFoKjkN61mc5NZvlv7vgANattttoAFttttAC+973veUAFtqA/ABvJi229t5R+l1G/H4hckyY0AXJJJjQH25M9733vPXb4H4PszAfg+B+C2222+NgD9yTPfSZ9JiTOXtttoADq7tttoAD5N6RDoWNaNyYB0AAAADMySAAAABprJkgDxrJkgVoqAAAAAABrJkgBQAAAAG8mSAPGx+NyYXgAAAADU3mjnPtyZkz74HiZkgAAAHjeTDbeTJC8mZ99z79PpM5kzvfZL5fWso2s1RqH9Q1DhpHFXJFcKNSe3Eq993l/R91FfbbzTuml9p5ppP7STZprnPcDnx9Le8tt/W3+ttttotttnvLbbQAAYYkwCT33092p6sbXVjSkkk5MmZiUttsaGta0mABGhrQBbR3TtttpzSaAPBuSTsm5JOyVVPttvbbzetJLuvDimfe7zvGn2edQAHWnbfwwA+aYEPvABetMD4+k9klC2220Lbf1pctty5+9tpzc/B+2AHg2AHg2AHg2AADAAJJJINOSSTxJOSXiaQHS26+6s88oc5Jk9nbaQAJKAAAgAJ9LbbS2jgHQAW9/fvzvX+nve94JJJII0v1ttoaSdt7bbbaAT3ve9sNAeD3ve8QNc0aQB26SZ+Wv33efffffZ++/rbbbattttoLbfe95zJltp0+MzttttuZbh+A8H34kkg1NSSQiejYAeTmpJJCSSWJMrtttAAKoABJJJBGyHea2ud99JJbf37MttttuW2/ABbbZJIk5PJD96AfHAPDEmEk+kVtzLZ9PfSfeqknJBI0+gB+E2W222SSSqVNhsDk1JJBAAE973vQWgD9715kzUyScmv6hPP9/ujjYD1tttkACSTd3SToW22+Wkk5JJAk3fucD9fvxbaHpJJBAAHve97wLQAHve970UG2cNAXqTpbbaQALFpJ/fqs+nPraTuJO59JP0gYkw8AD0wxJgfgD9MSck/bukk6W2222Utttt2gTp0kt/fKSQCST3oLQAHve973ve972DTAAJQAqAAJJJIe7rmt8TraS0209adBahoA/cpXlDJIa0qJqGpVZQyq7UHfffm473vekAAnW22122222mABJs3d0gcHwAttoL/Zmf6Zkk1rMkmszS0k20tNpLTTT+1mZmZ+kkkkAAMEnbbbaAAVAAEkkkEAASSSQROp3ve979f3wvcsIQ1IAhGQBBJBkf80rlDSqahh/uVc1DE7y2W970aYAABJJJJAAkrTYSSVhJQAAkkkkgAStprskknd0ACgAAgACSSQkknpqSSQAAPe973opJJAnttNKG20l+m53Xp1LG0mlQ0rEWy1DETRYWDUfuE8oYmoYNQyTIbYmoYahlKrUMjmNJ85y073tkkkkqaKAASUACSJOSSL6fNMCptJcvLbbaAAAAErba/NpLTbTSVttv6SSSgAEAACgAAAAAAAAAAAAAAAIgfv1JzCLq/fV7rZAG19SAY5/D3v55zvOkAbV1q6YbpJn1IBsdakkmf6H/I/v9SSQWEkgSEN9efgtp5Pfx/mL3vUzOuLCsizMqtkmyAbypAP84QDcg6zz5vyH3IbiG4h58Q74hvfN5+5zqH3cIbIZ22+IedoLCVqSf6rok9foTeukA1SAOdIA6IBlIBd3HRANEAu/sIBkgDm3JXOUOoZkO97Iff5DmK553nhXCueJczzzzzmodQ3qHfiG7q+ySBm7CBTYSXtKkA+SS9IB9ruO8MN3Wrmtb6QnN71c39gQKQDySekDvFc5xD9+Q4h3u4huob64gNbIBfbIBu3hAHmuyAfbEv2GIqKKQDhAL7JkgG+ylIA70vMyYrw1h7vJAPdIBeEA5ogHeeSG2d+kA4QD3s3v7xSAb+IBu4QDmbz7upANYfFIBn111e69zLmedry812znt73b6/eIeUO7IfkOfviHzqHimzIb+Q+9Q+/PEOVeoZ4rUN9oc8Q7kNziHch7kO+ff30vfPBb3+Q/b7z5Q84h7+9Q54+8fkNpIspAPaIBv4gHOEA5rgznembNdmyLsXS5w5ibkTSWZ1NpKITSWomktkO+Ib6hviHqHPEOe9vm+IfvaHah36h1DvcRxD35/fKviHz8hviHzqGyG+oecQ1PC737RrdqfCUXxzLrnNcFRVRRWPfOcRSAbSAPtgT608QDVIA96SSoyR3STmtkAe7IBukAbvnQk5M8QD0km0OfEA7rvt0rXiea7F1ZruZq91ym15yojz7DW7q3H5vNYmffZ3e2EeXQxE93MWbNj3TruYv2jh0bvWsKmPnMvXM33X3Lt58UK73rJ7V+Gopvevtbeu/qsrxOvNW5TaQACBpii48ePL25Dqteq15b876azb9yzi77zv2/urxxp2rTbes25vMq4/YEDzvnj5Pt99dpprj1+/tYfd/Y2QD4kcXrdkA+xtNN3ukA5rP3OHz0VVtrH7kkTp1OuyAc5su1v7RJfaNd32v1Nc8QDNq7IA1Xmb17KbX1rzXtG9UX2WKfPF+3nX5XT8qvWv2XyOm5bbbbbRfrcttvTunmuun3OuG3HnKby7dckA6QB8QDnqHuQ+IfP31D2h98Q79Q322j8Q+w6dOXXO/HX7d7yvRvHtrblzMsHMK62AfazDXK/J0p97JvnHuvt7DeBA7jl9zBLqPenG70C9u+4QC8a7zfvqeZ90prO/V2V7vXBN11m9/El7oDgzTo13t5wgDogGwOMOfU3p/Pc0/f7vr+u1XN/nOhJm8XWa809xfxn3Xd38q9ty+7r7MzvJxvN7NIu7/evZAPudcKU07u828Pu8mST7npAN3oad2rrjsZ7Mc7m92lTj7XTDrA6RdOkPk96yT62dV5rPrfviAZ7RtDbjxeczKZ3De+g3maz2jPb9g917PEA4e5zWbc3zXdcqTnDsDSg4rz79ZANa5Vd6ObmnVzF61rvWnVNTL+3rypVSb+7cnUz61xXPxAKcd3WfEA+33hDqHp8xDPyHOIb3qHeofHOIc3fiHvEO+IbId4hvnqHqu8Q3vvPiH4rj1DeC596r7kPfEOMh8Q9od+Id+Id1NJZm76vp/j+39F/X/jP/v9s/x/X/5/f+/9f391//zh+/Tv9F/j/sxQVkmU1mGHOM6AGMXG4BQBEAQAAqqDE8iIABUJSAA0GgKlRkaNABikIJBKuVFn1pBBIJQhARAEoOH1FODKdbhDzGTY3nY78XckU4UJALt1yh"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')
    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
