#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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7aAOmwM/fr/fvPMzMzn13+eh6cSX70ADoAB7z4tt+tltkkkkhUAZmZhF3d3d9vQB02B+zuZnmZmY+D0PO6l7u7+u71+z3MzMzjGy7u+X+bQADpVlVttvzX7P37f37397y/g7hCffoF9tRy7b5f1vifJkkn6TW1LeXbfGrjVuq3f2eWs8VwSTVWLO7Z7cvtsv5XiTb39zN39533zm2TgrRzLm2StnH8gm208XM/Xbnv1+t/JdyY3395PJJL6Y2e7wDww+9Q/F9j8xvzn3Pvt/ffkeTDwPA0DganM73ve+9utzFS8ttvtxW2+AB6DOBeW2325bbfUtbSWd7vc88/fuNNd3F740k9TTfU02kk029999tsvtq223y2utNL5ezphIj+ciDjOszwEj85kYxXds3Oc7adGbYZmw2aTam1Wa2G2zc3Gdc5qrGxrW1bfnHFmm3TnObccZWaWzVjZsMjIzMYMSIxEEZ8jiOX2/3t37bbb+ttvrYsRiUkkksskkkkj73vbJL4Fvttt9ocetpKa+973zuJNp/dJ4AHpfven5evGmkqm22+X3z46eGX9qAPPfwB+9AD339JPJJISQo/szMzb4uW36h9FcUbRtthT6o10owWSbxJNZm972ShEzMwAkO9zMVzZJJLT1AB6AWJowAAO/frViSb8xpN40rl/X63y3rabM+vD49AO/stC9+tvltsRiWNpLF73U/11u323tvVMoB6kw1gAfurtUk9klvpJJJJJUvk3mNNYc7/UbSXsf5saefJtJu89+/W28kgB8BwCPbhIDd3QEtEJMd73d3doCXAJfITTTW5/DdtquNpK073vfu97fJQD8AEkkkhwAA+CQqtttoT3DINNpPA5+NbSRbb6AABJ5JJPZKuIAA+DEmlcQcAJ2UiAC23W02SSSfTZjaS73ve+972SSSShecbTdtv1ts9799W54gS+AkJLEgMgEkBNROQkB8+fPnX3dPhuqkg5+18Hwz1oDh+8zGc1N1USAP2pNuSSRT6cbSUoAfAAAABUqAepAAfrQAABczUpqOJq+a3bty0t9SuXLly5b5xGJkk8S/SSi/JFttpctKGAAEIAfgQAASSTjQlxyECSoaGQR4iO6u929a5CE3Pd3sn7p1NJvxptftaTeZMk8n4AqSaudS1tmY/pyZtzm1aaecuZ5rzXW9tZyks0hmv666Zm6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SZnnOTJmdXffc88aMWpprMP2o6HjabJrbaaUk4qqpGqkqgT6JqNG6qSNSqgzPmawAJ+/fv378Rd0zibS3ThwxtJHiOBsN1sElx74hBRPRHz5OHu6FPgQXPMnYATc/apgHfPyN2Y1yeSRppcSbTUxfYaawdaXN6vklSPD1AAXkmb8zMzLfczMntvktLbbfaAABeS3fuZJPPN3be+gAAbvktLu7u+6AABeS0ve97+6AABneTvTve7b7QAALyWlt7390AADvJ3u/cySeeW23voAAF5O9O23d3ugAAbybpttt9oAAGXktLbbfaABGaKNor5lRznOZ85/Nftd1xzd+uv59VSSV9++8qVK5+/fvzjQBYAEJJJ+/fv379p8STk+nZlPrbbttoB0D0+MzPebkqQF3fLx4C2gB7JUg7373ve973ve9tstLbbfbgABmxib5N35PvnOTMk8TWszU3dvwAADtnN+TZv9u7u+0AAC81vzzm223vQAAMvKvFttvtAAAl5V585bbb30AADd81vPv1mSRPOa183fN3lAAAf2QImTJvmt43+3d3dv7jnMMMIk41reNttvasxtJYrraSzVuYse6k2ry5dy223ty5ix7r17raSzbi4vOLltttkkySH0H3qHj4OEAc5z3fOX7dvfa9O4rfAZgAAd73vOcLvq7u7uwADRuSpAOZmZrN6zMzMvNamq1cbSW7mrHupJq827eJrmNe40muZcvmreb5mtZL9cjOCIjN5reN+7u7vdAAA3mt437bbe/wAAGXlXi2232gAAXlXi3ve/ugAAW+VefdZkk8a1u734AABeV3jttt9oAAGTJeVeL3bb7QAAMvKvFve9/dAG22222OK97cASrDZrM97y927u383587u0AWgA4R4DnOc5x3Qu6u7uXdi7u79v27txx2SpL1e6lXe+969u+ru7u7babB0sAGZmazeswda1oAATvOu8+azJJ5bu7t9AAAnY3zW8bv7d3e6AABvNbxu223qGAGXlXi2232gAAXlXi2232gAAXlX55vMySebu/N3b8AAA3mrxbu7u90AADea3jdtt9oAAGXlXi2232gAAfffvneZ58+Zf7++29xg0D4eI2bqSqB8QBzfOc5n2u9zMz3mayZl5m8ZgAAd73L73uYd3l3d3y8AAADMzNZvWZmW+0AACuVeb8zJJ4yW2/L3iejhI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JkNC0NE1qZkszZM0bFrU2trZNtpNm0W0trWhm1mMzNYMDITCZMRmQwkCSEMgbC2LY2rarZWxrWzZNtkmzS1FsTBlUaYMYqTYUwaQGDQlmKq0NJRtRS0NDQ0qTBlLBWiWzahsTZDZU2y21NpW0mwtmbbNG0hknN3d+7t8ygAAJmSjMjK2WyU2psLaImyhNlUTKsllWkbJBo0hNqTQ0qTQwoZsyGoarUbI0m1JsKNrbZITMkMzCZvnxv37mSTm7u7vfQAALN84stu7u+6AABvNbN3bb+oAAGXlXmTJFttvtAAAvKvFttvtAAAvKu/cySc3d3d76AABZvnFlt3d33QAAN5rZu7bf1AAAy8q8kyRbbb7QAAP2dyX5y/MzMwaC7u71L71d33ss3VSQu3d+d4+xfYvRb9jmNw1ppbhiMEbFJyNNKbPzaSk+gc6gaaRJyQwCZk2fd+859obBmOuSVIex6ZPszeNhd8vN0PIZb9Xi2232gAAXlXfuZJObu7u99AAAs3ziy27u77oAARrWzd222esADLyrxbbb7QAALyrLbbf1AAAt8Lv3MknN3N3d73rnMMMMIRmtarVe23vlaaW7m5ix7raS3c3MF2+cyq3d2/pqIhwCbG+a3jd3d/dABtttuY32STiJvADmJIxoSSxi5huQX7P28xHmV+1VR5iXmoc50JzQpzKVOapV9wff33xcudXeC7jBd/fZzO6728zMfXePXhuUZ6+Takk/etKYlJpjMVluypNK7bRTJiknE1MSmNzFMSVmtm6jGkIOBrMaMTMRiSMSMacyZMUkkgEbTaaMbmVJMyVltXi973v7oAAHedd5v3Mknltt7+AAAvK7x3cmSXd3e6AABvNbfObtt9oAAGXnXeO973v7oAAFl8q8W239QAAO867zfuZJPLbb38AABeV3juyZJd3d7oAAG81vLzdtvtAAAy8rvHe97390AAC/b945+7P7Pkz4j9b33t9777edLvOXeu9vB2+Xd9799Pvr5wC71kF3eLu7wMzpsC8HgMzMwDMzMd73vvvvt73ve37bV4ttv6gAAd513jfuZJLbb3+AAAvKvHdkyS3d3ugAAdnKW297+6AABNc7ec5e97396AABZzvec53ve9/dAAAvO95zm/cySW23v8QhgO95znu5kk7235e0AADzlvOctve/uiUcMhmGY5zN8t5zltt/Hz44bgaiCIiD6jJ35QCXxvRXU3n1d1v1n071u7vvbdNX2+7u+di7u7vnOc5zJ3MzMzMALbbaDCSSSkk73ve/ffTve97JJJJJAA/JNKScne96Tvenkkm7sAPrUmlvHBxwCHFeW85zzPrMklZlt8+3k7J44AHL5bznPl3Jkm7vm90AADebvPn98+W23vQAALzvec53ve9/dAAAlL5bznLbb+oAAHed7znO973v7oAAHed7znN+5kku5Mk3d82/gAAN5u8/vPN3d3e6AABvLefPPO973vvoAAzMq73nVnnh+NaaX3vwAlJDgEn37vc++O3d9uAOc5znM7mZmYzWAZmALtmZmBa7y7+u7mGZmAF3d3d3fslSd7778vzve95znbbf1AAAzvO95zne97390AADvO95znbkyS2+X2gAAbvm7znPn3Mkm7u7t/AAAexN83effPN3dvtAAA2b5bznLbb+oAAGd53vOc73ve/ugAAd53vOc7cmSW3y+0AAC8t5zm/cySbu7u38AABvN3m+eb7u7suZmZmYsxZi/Tzl98n4AO9/b3vfvg+kySGY2tA703VSTve973LuXkzUlSbz7Mz7K+Wm9VUk+ee6Zh5VST7hUqQ++ZmfV9Lu/bvvjve96uzklSDzkN7bD0t7TU7737zvvvy/O973755522330AAHed7znO973v7a5zDDDCM45Lylu5Mk3d833YhoAHd8083d3d9oAAF5S79zJJu7t7/AAAbN83eb55u7u+6AABedO973vf3QAAM7zp3u5Mktvl9oAAHl8t5zltvt9oAAF5bznLbe/ugMzMzMzMwu8+7vbt87+/B99d73ve9n0mSSSRaAOc5znGXvMzMzO5meZmZmeLu7+u7wtpVSS2pKkCqk/ZgDX4/ZmszGAE9AD2ZOzAJCeAG7s+knxmZmZmZgB1Od7znN+Zkkttvf4AAD9fLec5dyZJu75vugAAXlvOcttt9oAAGXlvOctt7+6AABZfLec5bbf1AAA6nO95zm/MySW23v8AABeW8vnl3Jkm7vm90AADeW85y2232gAAZeW85y23v7oAAFvv9s+7Mn3555Kn72/O3+/P13bYDpoAtDg8c3znOe53O5meZmADBsDMzF3d3gxmZmDoDKzMzMzMwC7vPQ3va239QAAOpzvec35mSS22738AABd83znN3d3f0/hSQk5xzEicRzmZJN35d5zd37u77siIghLy/uc5dzM3d32TWgBvN3l883d3faAABU53vOb8zJJbbff4AADbkb835znN3d3fdAAA9mXy+c5yd73vf3QAAJ+yO+d+c5yd3My23Z3QAAI+/fZb39++d+/v3u/v3992/ve2233zN5mZmXmawBaAOc5znM7mZmZmXd3d3eXd4DMzM7eru8u8u7u8GZmZmYF3d3gZgSVUoN34zMzua1rWta1rWtAVOe3nOZvzMkltt7/AAAbN83ec5d3d33QAALy3nzy9+97330AACfXfO/Oc7uZltv6gAAXnbzvltt/UAACpz285yb8zJJbbe/wAAG9b835znLu7u+6AAB7fL5zl73vf7oAAGd573nO7My239QAAP3fk88vqfpzJMhfsFdYSdfv3rt1hXojsjgCWzc17vZhO7VfOQJeYAl1xmvpASpKmoPmKnmSvnrv1ditoK9b736mHcydPvZt13PyQGAJQAlEIErASdBbhxUHn1w20CTYCU7md16Al4WtHvRLMvsiqeMH7znWQ0DfmpatptOYEJARUAJQAlXtz4Alt1pUtAlrnuJqtVNTXNc34u14AB6fec3znOAO7fVVdk38SErTE5SQIxxnvnvnz5okhBzKPGiOshtUbLTKMU1VLnKThKcaouNRMW0bFtUtlDWTWLY2tlmJtWpUlVrVSTVSVWqqgLXKlU0AXBCOfbu7u+EggFsb3d3b3JAlw0CTBqGqNWlGahtErZUZlqahWmKNuc5znOc+qOW5xbQuqlU0AXLu/ru/LulaHwe+2pTzefeu/v379+nvRSaSzTCtJVaqSqrX8GZ9mZmfSVUrNDYDpoG80hsEJMlKEkgh9vHd29oJBz7u47u7QRzAAG+7t593ac0JIYCTQAkSMIfbm7Ht8gEte92d3T2iEc+7reXft3fL9sNSoqqlSTmh4LfVUkjQ2A6aAEu7u7uxA4PC7u7u77bYAAPg9/SSqzMzPczMz4vd3d32+7NgOml3d3fblgBABbQB02A4PAPg99iSTz33333xT3IpJ+/AHoB1tJRJNmABgAZgC7u7u7sZVSSKkqr1uo2gS1iSUzA+cAIH8c1fzTgQd87u7nLHpmZn3NfTWp2pUnve987mZeQAPbu79u7sAFAHwegHnOcysxtpP9jbbf7vfPQAkkki+/Nfe7mNbizHRzcMc2y5ta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ttvll7T8AcAMcGwHTQHfuTXOc708BhuDQZZfgPozMHR4MzMzMAF3d3d3YB03mZMzWswJUDWn7lVIgDxNRGBN0LbamrQ3dCSRJySbuySSJqSTd2QAE0Abul/NpK22+pq23TnLbbamrQ3dAAEmAbugAFzMWJeaoTjTSuc889+/Z77f1vb2SSckkk1wbCzpoDv3e55d3eYzBd5UkAZcHkgetVKkazWZsH13eBmaAAACSSSSSSSezG0lJswAN3QABNAG7tufm0lbbfU1bbpzltttTVobugACTAN3QABNAG7oAAmgDd0v5tJW231NW26c5bbbU1ZLugADamAeboAA0/cnT3jTTepJN4mWRZwVorz96dCt6FfPN49RXOxXbn6K7qHWFffQlwV5xu5kHewXldtua0pYg2IaBLN9713R6XsKGs4udsgJASYhKAEme+GsxkfIS8eKHA4ZnepxN/D5VTjhvVKaL+elNchBXhJt65z77585+6OY2tmK+AtomJaK2RWqVyaUjkRhDKOrqYq3Oeec5zn1VU4l8iq99CTpRvHOeee/HOc93FGDENUlVo8LF1JVSTslSvaqSPHnoLlSSpyq1JVVKjR348FAD6VUiSVOc555znOcke5RqSrCs4RV7F1eFGkeFWW5zzz7851zlEXtRlDjdKN1znnnvnOeOUP2IS8ahJ8ivp+6O9IufvX7v9++fvfrWMtiWiTEl9R1C0jI2tN0lbm/rz96/e/379+7R7flVxFsVwPZpUwIEmEPurpnu7DUgSY2MaYgTJqj6o2+fPP3rnOc9yPOUcFdadUVvPPvfm9+eeeIr0GVPDiBxTnOYSwTKM5mxNmMuapytNznnlznOffaa4pshNpS1VFyKxzW1I9tcOhXOaWtbbS2taUahgVrc5557uc595VNFbNkq+RWKubzr78+779+kHuMn5pAiFs9Xe7o6xJCWoEmAjo7q7Nvf600H2ZmJVSSe/bD3gVVVJ8HgHBsOmzV3d3drQO1JVGxd32VUl6u7sABAHB4B8HoPQfB4Bwbu7u75d6ALQbvfm7u7u523weraAOmwHB5sD77777712DTmgLAQqpItoAtoF/X2SVV68u7tmZur1UqVRuqnNV5qa1nfOd7nM4u7595d3gAZMqpJe4175V3d+fXi84Aa73ve95dtjYdNzoAAC5Kkd737JUqrvzt5mZ87u7u43fBbBIaGAcyGDGAjmkit73WtHp0AHve9873vQAcXu773vSAAAAEkkne9JJJCYkm/flrTqs9zM7mZdzWrvAWrQ973vlVJVd73odqXNDfd3du+ASWvd3d7u0SFgxIOZ6L7Ul1q7u7s4PAdq9Xd3d2+yqSSq1UlVqbzeZ7mZmW0AW0AH13fl3d2Lvd2Dt3a73VSS7vxoXbewHm8ne7kkkmZn32XjIB6D5d3d32qlSperAXUqVU5NTVTVa0rR6BVSVQGhweLDyqlUXd/Xd3YH3rmhz7jg88yVKrMzMzuZngHB5KlUu7v67uwAC7u7u7sHklVQHBqqlUAW1JVV5qqlV5VSqAvtxptJTySd8790SbY2kwDwD4NSaUkkg8lVKoDg8lAcAu7vy73VSS7t6D6B6Xft3d+3YAADg8ySpUzMzM+zMz0Xd3d3dgABy/vvvaqSXq75zl/B6AXd3d3c12VVSbklTclc1vdVJLfPR4oHB9EqSVJqK8Moy5KhpkG88789+eedfXtpD0Z3/wbkvuee59ns5mfnweA/Z3MzedzM8OmgO/c1znOAF3lSgGW0boPYbzWYDtXd4GZoAAfpjaSk2SSSSSBIboAA0wDd0/i/NpK22+pqhTnLbbamrJd0AASYBu6AAJoA3dAAE0AbugACattu7ttttTRjA3lXnl542krbffbjatt3f3Lbbakm39iMWKrmbeGgBJ9JySSODb4PXTTg8zLy9VUku7vv1ZjbVUkpJ9A5vweAB71LuSZkxtJSSB3yauz3jaSk+770k73oIACJNIwBAAeIwPie8yT6TVIEDcAAteYszMbSWYZby7lttoriVLdy239aJoPTd0v5tJW2+XE1+Vtu+c5bbbU1aG4AANqJYHDd0AATXUg03VoAAmutBpurS/m0lbbfU1bbuW222pqY/bc855znlp8AABwAKfAaAEn0mT6TZPt/X7fvvffg8CASTO973u9nv3n3N++++nYDTSBppGczJVSZnoC2h02ZmZmZmZnrr145+kngAec4k0uAARNAG7oAAkwDd0AATQBu6AAJMBG4X82krbxW6mqW6bbf1tqat/HnNAA6mog03AABJkDcAAE0QNwAATXf3Thw++kqTMzPQ8A1zQ2HTpoDvvOb55zgcGVmZmZm5KkzMDo9B9gPru8Om8AAAM7mZ5mZmYJuQuNpK22+pqlu7ttttqf7Mxq23d2+223242ksxZjaSzLbd85y223txtJEMySG7u85zd3d26kyREJMkRm7bu7bbaXEmlixZiTSxe7bbu7b9bS5JkiISZIG7u85zf7+zJJu7u/f5JkiISZIjd3effPN3d3dnYyYiGTG7u85zf7d3d3+hkxEJMXfN8vybGE+M59+/Pv3nPfLbaABwAJ+kmySST6TJJII778u773mZkDrV4AzMu7u7u7Xi773uX3O9JJJJJJJJJPZAPQACQDm6ABbCTEQkxu7vOc3d3duwyYiEmEtt3dttttWY08WLLbd3bbbR1u23d2220TVtt3dtttqaAN3S/m0lbbfU1bbu7bbbamrbfOc5QAiaAN3QDMyqmt6avk755r7Wcz7O3gB6D4PAODYO95znOAF3d3d3Yu7u7u7Xne85zO55l3hxd3d3d2AAGTMw3dAAE0AbugACaAN85zUF42krby42rbdnOW221NWh5znAAImvQDd0ABJySbuwABNAG7oAA0wDfGlzEuYwvG0lbeK407bdnOW221Ne59f5rf3vn2fc5ncwD0HweAcGwd6kqTve97lc5jNZ59qqkn2Y++u7u7wl3epKku7u7dvLvvlVJO9y7ypUhzGZ7gbXd3joAAN72BklZmZve8zABNAG7oAAmgDd0AATVtt3dtttqaAN3QvyTStt8a9WNgbuh+AD3HmNrMzMxK23znOW22xVYkBznOAARNUDd0AAbXikN0PjPg4AAeAD4PA/ZnczN5mY73nOc5p8HpZuSpDwFud8vy7u/3WmZUqTMzM5dSpDwAGA+DMzMx148PZKkHmQb3uSSSJqSbuySSRNAG7oX5tJW2+Jr3Fltu7ttttTQBu6AAJMA3dAAE0AbugACaAN3QvzaStt8TXttu7ttttTQBu6AANqc/PjaTPNbK0m7fr29MuJeRpN7cvGk3brSb8aad/caTdutJu35Jp3xpN/W28vzaSuW7P0jYO95rmuc3zUD2UPLv8fRrclSHlAN+7+73v4kJGml3taTfZiklC2kknegHQcHlxrmmmn6pKr9zdSVW5+/fv27tltomgDd0AATQBu6F+bSVtvia9tt3dtttqaAN3QABJgG7oAAmgDd0AATQBu6F+bSVtviatt3dttttTVtvnOctAIkrmY7mpJv3Uk3bnT5Nb7iXnvvPfPL7ff3bfJJJ5JJPZJOdNjg2DXe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YxBztpIQid97du/mdfvm/Vd3Hov27u+9Xd97Yb5z7z77t73d3d2S7vD2SpDM7nNgGXd3fe9y7u7AAkkkkkkkkkgAbuhfkmlbb4mrbd3bbbbU1bb5znLQCJoA3dAAEmAbugACaAN3QABNAG7oX5JpW2+Jq23d22221NW2+c5y0AlxK233nOW221NTEk3lnniMSTeJc2v39z3222JtfW2+pH7Q1egTfKSe/Xve/fdUkn7979+/fu+XLu7tcu7u7t+zAF3nLuVUl3d3a7Y2mwIe7iabAPEm2GkMPE2mzEwAACcknyTSlOXtt85zltoRNAG7oAAkwDd0AATQBu6AAJ9xIOG7pJJE0W23d2221NSSb5zkPG0kFt9SdtunOWW21NWhu6SSRtDWAG7p+ABNTJfN3veXz7lvjX60lgFPA7D0DDLzM5hcz7M5y5Kk+++eru3slSF+d7O971a8G5KkHIZ1LvnOZ3vve3VSqN1SS9kkPwADQB1JpTC5iSbtttt+7by/krbd3b7QBNAG7pT5tJAcTQBs5wrTttqa9tmcOAANr7AmebAAE0Ew0AATXgHTcABNdppDC22poOzIF62kr23xtXy3d7ylttTRZv2dMz339vt889xX6+O04039jTJr5KfgnnhbJ5JUhxf3egc97+835znMzx28OLu7B+zj4PV3ipUhd953Xe5JVVeBz9rUkpmpgAfm03bQ9bTYABnQ2ST4kkzJ3pImjInunA3dACJrrUyTd2SSRqgHm6HnzaSJqauX223U2lubltomu/u93d7ZJEnJJu7JJQTQBu6ASJqSTzd72+tpKZO6mjPTwMwC/qJrpN8/eczdb+5+9lTMs+pdv2fcmY96PO9y7+u75np7zk/fffZmDAwAtgC7y+3d971fcVKkPKqVQewG8zMw6ODzwVEvwG7sCUG161gBmegAJqIwMySSRNSSZgk0gvU2lbeNq23M6AW1NW327gACTCTd2SSRNCAN3QAE1JJvnObJeJNINMSYBu6AAJrzPM55Ye/b3F5793t/fr9369lVVpw6ffj8ebixN9+zMzM/APBznPvvru7u5d2/QAthAXeXfe53vcu8naqVQAVUqls09ZibaaAACdzvexzu9N7Obve9J1NSSbugACTAN3QABNAG7oAAmgDd0C9bSVt4k7bd3bbbbU1bbvnOW0DqSAN3QAC4krbd3bbbRNAG7oEkTRv37ydvLqTS1JN/vWqsUz7zxcRXXN3uP2cM7I2iuNuOBczc/knfVKUKxgJM9P1fq288gShxEAJMuamG3QCcTs0xgCTHQMBKIiMcIEpiCCekicm2eiKvqMZaBK7zrhubJadg0IdTE60Cl+Ii3sqDE3swAkwebYdeRFMYCTreI10kA2Ak4Y4AStm/OxCIb904YQhuHH186cuvqj5e5NR9b9dUAJP0QhF+KQIabEkGxX1fze+cIS4c+AOrIsJqhk22aLWd6F0gso25znOffvPrlRqiti2gCVKq5qSSo2l6qpJd3d1PJLvsHBdSVWpUlVJ456PeXd3d9vQVAOcc59nnoSca6tVKvCDVE2tgNLxuc5z5zlyX1I1bIm0RqGtFObnOc5z7zfqo9dUOWhsKtrKNUZlDSPyjQdTNFZRkGxNjYDaisABD+dfdnboxtpAMAStIRCEkXf8HO/3778+/v3RG1I02I1sSWUXyO7u2t1Al5AkxCWxW7vdXcI1g0FejkVdZI6sEwU0mxUcwDhaec89+effOvPEr7NURmbSBhWJZaK2tptbbNFaec2889+eec88ifcQ02sbZgTYNrWptA9tOZssxKec88+6aLlSVXu0lSq1rwFwkqpcaAQBfb1d3d2dKqSp74DjhrUqT16HHweg9B8HgHBsB27uxuqkg8AAu7u7uzX77MzM+zO5mwHB4B8Hovy7u7+uzwDg2u7u+XerAWgAIALaAc5znOca81088HXB5554B3uAM7mDQXer7d3drYvcqqrWqlbqpKczzz7MzuZ7oHAzOZmZ79nZvfOc57mZeAFtS7u7u7ND0LcAXYBw3fl3d3kvRNySqeZ99mZmAVKku7l6kkBtJAm0lLUMC43dre3u7u7u7t6t3dq77bhuqkjQPF3d/Xd2DwDl2C/G3T10ySVX3eeSSqcznmZd5eacD0sDa7uXfLuw0QE7d1UqXd3dhQC+3q7u7sAHnLvd39d2ySqq8zeZmZmc+u/L9u7sACJKkVUkSqkVKkVKkVU89mvd1Uk999BfAAXd+3d37YbN1UkB8e37JK9kqTXZUPCVoQRNMEGb8AS9EJAZXzrrO+d86eBwC7u7vfLvYdFSVV1Uk02Dw9kqq9qpVeBa7tuqlUA6Qu7u7u7AEDS7vKkqvtVUqVB6ZmZbQB5VSqA4PJXTY4HwB8u/LAAAC71d3d3a2pUqvKqVTgcWvJJVXd+SpUrJn33OZmYAXd3d3dgAeVUqgiOAAAF3d3d3YAAAtrt5eee57mZ7vMHC25vfugcAADg8AAAdvUlSXd3vsrUvdh0qquaqpGUbWUbK51znOdffv1UvlRgG0kkmAkxNiSSbGmjY3N3u7j2Znw9OcZ+7z+B9349STR9bDz8ySns/AHlttnB4Dwc577Xoq7sMzKlSZmZmZmZgSSTvenfvv379Pvp3veyVAXzMSTdtlttEZiSbtttA73vwNNZiUob5znvHmJtbF+/dUq/byVYbUO/3gvBWth5ibazEk0lgBu74AAmjAN3ZJQkqZmZve8zBJQb3sCVA3vYzMyNAG7oHyuNNK28TXltu7ttttTQBu6AAJMA3dAAE131Qi5uJZnmLb77+57UrmZnGra2/Pg9B8HoPBznOpNL9fl8L0eAHqTSJANX4A4k0gAn4kEmkABn7v33zTSn7uLpIB3ve97G5IVKkZmZmYtqSpDV3d3fMvDe9hgJoA3dAvW0lct1NW27u9tttqatt3dAAEmAbugACaAN3QABNAG7oF62krbxNW27u9tttqatt3dAAH/GxpW27u222ianNWpLFiTxpJvM1ybmq1ON/fZ7n8Pxn79mZh8HoAA8HJzWffvr/T9+r8zvX7xd3d2Hh9d35d33rTSkaaXe973q70bTcAkkne96AAABPu52SVJN2XEmlp8G7oEoJoA3dAvW0lbePzFbbvvOW221NWhuvQkKqZrMzN7reZmYlQN7mwJU6bb0F62krbxNCt273bQBNEJuSSSJOdk3JKAJr9xfmNZkq/Zjt79aXsbdttvzv62ngBPJiTSkk8knZ5sn5b+88GAtjGmZ3JQAwu8Ax3ve97l3kaqolBAHiYEPU2mzEmwACTvvft++P3e6dhpuAACaCGrQL1tJW3iaPbb5ltttTURkMAAEmQN3QABNEhugACaJDdAvW0lbeJry23d2222poA3dAAEmAbugACa8xppRfReT3es3z7X3PvPffc5mYA+D0HoPg8d2GZdQCDfZOPPe7tzdjXu73dvt3d3e33uc473JhnuZmZmZmAXd3q7u7F5mZm96AAJoA3dAvW0lct1tW27u2222pq23znOW0CJoA3dC221NW27u2nwHGwDznOAAUSVtvnOctttiaAN3QABJgG7oAAmt9++7++3z3zz8H33fOnbfAfB6AAcenudne8++zNVUkXd2dYAYXd3d3a7u+96u7uwJINpsAAJ3ve97nekkAhu6AAJoA3dAvW0lbtxtW27u2222pq23znOW0CJoA85zgAETQBu6AAJMA3dAAE0AbugACaAN3QABNW23d2222trzGk3kZiA/VTlkV9s87uW8zM+zMz0AAeC/v3XfpKk5m2dduJpEA30PG0lgHqTSA6p73vYk0pJJ73ve/vs+nRtNySAAQMbTYB42kgAnqhpiZkkn0kkk3dklraStvE1bbu7Zbbamrbd3aHwHE0Bbzm2221NUC85y222pqmhzdAAiaAt5zbbbamqBec5bbbU1QN3QABJgG7oAAmrmxdPFu+8STf3v6+/vL3y2dVN/AAfj4DgASSSSSTyTz38fe/Bv77v073toAF5my7u7u7uqgbkqR9JKTU1KkgnobTfcbTYAABO973ve9ne9/b3vO9lYQA3dAkluJW27u23tjaSt1NeW27u2221NAcOc0ACJoA3dAAEmAbugACaAN3QABNcAN3QAE1QDd0C21NAG7oBY2krdSefcWZ79bb97fvl2bQAP1vbby22ySSSSTyTv6fvPP3b7rl9vMAML73ve9dXd3dhklVWa3E0gPDE02BxtNkDxtNgB62mzLmJJugfW2+WflJJJN3YABU1beXnNoARNAG7oAAkwDd0AATQBu6AAJoA3dALG0lbqatt37nLbbamrQ3dAAEmAbugACaAN3QABNSd4pjSb6vPdzfPfzaSPal+/fr29VNCq23xW9tvACCTZ+aaQB4B6T2TP3m8xPr53vZ3Vr9u7v27B29Xd33q773rve5VSn02ScbTcAGmkARgB62mwTaQAdDZQQBu6AFbSVupNW27u3tttqatvLzm0AImgDd0AASYBu6AANW23d2222poA3dAAE1bbd3bbbamgDd0AATVA3dAAE1fPx+/Sb8Wnz42LWhbMIEuQJOjNASlefx/Drmdy+iey3NTE1dO6w9O77xsiQe5iL+HteLyYz56PaXE3fx8kgYaxQkknRKQLAfPvfv1+/efniqN3nBV4I6ZK6tDF1rZI4K20clOa2qjlKxtcNMubi3OHNbZrc5UXVS2pGipuc5z5znOIXKjKCbEjEnHPuvqSA7um0CTQch9tbu7u73d3d16lySQxttCE0hDkGAjESNSQIFAyEkJSQACQ+7O7tEJbu3dtAFjUJKkr7VbkrVSVWpNVKkkDi0K+SVJKnk82OBUqV3mdkzPs9+v3799/elHOlHvx5FV5gnkjq82JLqkaV76eZHiQtBv4P379znPzMqpVb5qVN6H139ftSVV37d/D5Q9DqoSQtQhC4Qk2M49Ed3vZ3TzQJNUclFtQ5lHW65znvnOdc4qqtUkns8nkqTzUB22ntSVVyU0PlouSZJJ3vVUk35mNpOSSegdPWk3jSSeuamqmprU1UDg7eru7u74PAPg9B6D4PFxockqS7AOngHBd3d3d2gAtoA600A4PAPg9B6D4PPvbu/b5y72A6aG7u77c5dgExJKrWbzMz777777W2Zjj5fr0eZmZmZmsy5d3ffpg9+D1d3d3d2MakapvdSeaqXqbZv7nvM+2bv27v68F23sZKuSpOc5zmdkmXmZmZmD6T19d/Xz6/bsfB0AXYATnOc59MtupKrM+379mZmAd72V7qenvskoe970AE8ne9773vfQfAfXe6qSXq7u7AByu673ve9AOe8vJm85nczLu7wHB43xe7u+XdgnND0u+1UlypKrUqprV3d2LpoHezve970ADsny7ve+d73sGk37uxGAfACTT6osmtpKAJeobqpIAkqS+973ve38HofB7VSS7v27u/bDpsCK9lSq+1777wbSXfvlxppvwP3P34AAAACSd73ve97YBJVSoA9B8B4BwbkSXVzSA3dnNzZ1z0JAd3dXdPdXdCQEk5ImmxJN9xpNhwD4DZJJJ9JqadAOgAeQHeXu91Uqru7s6AB6D4AA1N1UqnttL9528kqSuVqqkqrae5mZmAF3d3d3YI1VSQDdVKosOmpuqlUA7a6poF32Xq7u7ABfe973vVzKqVJPvvs5rMzPb7erz6C/bD5GqqSOgWBsQ6XPODwA8N6N37q78u+aqSq0lfSk2LTSjqdAus292Kkm+WO94eHTd32/akqtVrd3d/B7UlP777n09nc+/dPv4fu/C6W0klSadatvnjV7f37z9+/fvwAR6fe/vfduX27u8y7u7u7Ene973zv32xed++9n333073va00rbbff2Ykm7bbbbZQEAfKqlznjaWYszMWYBvHd9870dbZtNk2Dam1BtbWv3795kP2nrWzZtrRLYLalrYYxkDMIREYJJCSZLeSSeMJhMTEmDEEZGQIMhkSMhAzIZJJMMJICJEW3nzzy0AE1aG7oAAk5Ju7JJJE1JN3ZJJImgDd0AsbSVupq23d36222pq23d0AASYBu6AAJoA3dAAE0P1TEtzDgaj8B9Mndkgj4DgASSSd3bzruutBBVRokGb7dsEG70+972giXdnxe5Kku7W1y/b+l6nddd73q7uwSSSQbSQB5NNQYAE+knN3ZJLW0lbqatt3dttttTVtu7ttvQ1NAG7oAAkwDd0AATQBu6AAJoA3dALG0lbqatt37nLbbamrQ3dAOhr7jQcN0AAuNhO/b54l55fvsTeJYkml7fu8ssLp8AH5HwHAAknaaAB4H3Pv33zvO3fe8z9K/AY1eZmAd7l7kqTve96YNpv6Ae3MSTdtPW03ZtxNN20AAkkkkkk7MADdAAE0SG6AfgE0B+3dALG0lbqatt37nLbbamrQ3QDoamokBzd0AAbXyWAebuoAATXySA5u6gABNAZkkl62kg1THmNW8ufb4k0rbbamu+an3Ek018e+2teefXz69523eNmAHjRh8cDb7bbbbZJHD57zn3vuElSXdhl973ve9WAe1UkLv27u7td5Ka3JUg8htmeY+D3P2sSTdttttskA0AzAAtNTQBu6AAJMA3QABNEmYAACaCGboBY2krdTVC79y2/rbU1afLdAOhqaJDdA9AEmB9ugACaiA5ugACaqm7vcDxTPvV5me/r+S9996/MWZmP9ZZbttrYHEfAetK+22222SSSeSfv3vnmLv79+73nS/Zd3ft2OgCpV3seB7d3eUkm1JJAAkg2mwABppAT9JOVshgBugQraSt1NULv3LbbamqS7oAAkyQ3dAAHVjVtu7ttto6sSTzGrbd3bbZG0lbqatt37nLtttqat6bugACTAN3QABNAG7oAAmvd1bwAPwfdC+W2239bOSSSeySeSSKeHOdqpJz77hu7Xd3YABd3d33q773vZJJIpJJJW02Y027mJJvbjaStttt7JJJkkkknZu7JIVtJW6mrbd3b2221NW3l5zaAETQBu6Fttqatt3dtABJgG7oAAmgDd0AATQBu6AAJq227u2221NBoc3QC9SaVupr3Tbttv6/E+5lYcAKvrqtzwAzMsA9M73veJKk7m/dZMHHJKkHlXd3aSpA9ZUw9kqRbT3fdTLu7+vAAAA9aHjKqSbzWZmc/Sfv379lu/c5bQKmrQ85zgAETQB5znAAImg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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
