#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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hLkBUx19XZCQG90tsSBibeeppN4pzJJ+kCNNNtIwAAnUYhOeddc83nnnnnHvEeqlxUutrNM3TgrkVtD2UbjNy5zVUcsXec8bSU7nvMD0iab8xJp5MmSSARJtmeEknsm9Xe97393pG2l60mzzgB8He/lot+SK5d85+c985znmUeEfny8JO0kkuLGk37me7/3+362W/KettPEtbTZm5JP3e/NJvv293veyS60mxJtNfAcA6dR2itRXrLbNWz6yK+733vv57777QvbZts1DUHuBXxRodMOpR50O7WsJPXrrvzzz8888+VBEnJCERQQxiEpnu7uze1JCwYkkOebJ7JPofl60mzwD8fB2KSSSSfPr+5PJ6+AyTMrQB02B+/d/fvPAc970nkknkn6SH3oAHQAD3nx/Ft+tltgB/QAEW223t0AdNgfv3f3795+/fv358Hoed1Lu2/W3TwDlNk73vf3SbIAB0EAB81+z9+39+9/e8P0n0+9nZD0APQOJ973vfe91tdDga0Y0Gh+54DPDPwd8AD0Gkk22maHvofB+S7kxvv7yeSSHpjZ7vAPA+H4vsfMb++377ffjkwA8DQOBqczve9773G+4iHAA9MQHJJJ7JshwAPTADxLW0ln32/Z822022m39++8AD0wA8AY00vJFMx5iWLPy4gtXVVwEj8uopSq8oi7vyKnRm2GZsNmk2ptVmthtkWuJy7VVUkJFKKoRKRULl3zbjjKzS2asbNm001WttZLFjxYszFj4s3Fmz6fvoegB6AHrSmJd73ve9ISSSSSPve9skoW+W0PQOPW0lNfe9753Em0/uk8AD0xppITbbYHhJPJh+1AHnv4A/egB77+knkkkJIR/s2287uvPPPfnOfsVxRtG22FPijLWk3jbaxpN4kmsze97IBEzMwAkO9zMed73veh4pJJ7JIRNGAAB1NTJJJPJOpNv8T9PJJAkPwB4B1TEsbSWLz7WnJyT9J1GAB6kw1gAfurtknskt9JJJJJKl8m8xprDn9VtJc4m0m7f1ttvJIAfAcAmd91tJd73qSb6mm8We9kkk6km4kmzW001uZgCMbSQTve9+73p5AA/ABJJJIcAAPgkAACTrTaT73vO91tJdJD0AACTySSeyapJJJ9JiTSMQcAJ2TqkkgBrabJJJPpsxtJd73vfe97JJJJ/AXW03bb+ttnsBISTSA9A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LJMtq973vfe9V8cXJm7b73vXttoAAADve/KkqSd73M+TMMzMzPcAAAy5mb8qpJzm7u530AADLnenczMz3AAAMuZhne93PcAAArLmYZmZme4AABlzMMzMzPcAAAy5mb8qpJzm7u7udAhCtudxm7u7vdAAAzeTeNzMzPcAAArLncZmZme4AAbbdc39S/rNn7nOsSc2FaYVhT5kriG2KTe8QWyV3qHNbSraK6yK7+c7yV3ne8boVkr5lVebzd5tIfMUnjOlaKYCTBJMbj4+KVJiQm/hrpiWeJMlENcTFsclbWvngNjY0DGISrdJznGI1x0smWhqdjKASuZkBKAmXAO1URPocU1rqqmbG7ktqqIVzGRCY26GiPQpYJBK/7v2nzaejIiCE4cPp6Z+N75u6j5rdjOoAeT6t3vd2niUJkMbGkEKFWgiveniVeZK7itwR2iu+YnTsbYkJEjkEwRLju7fd7Uk0CTbNFmSJmZmayampkya888ASZmdmaPAc9vijc653znOc51xLl8JdIjK1BJghMQJNchChEJIRPpiq93e2uw48GxwedBySWayamayayTM1mpkmbQZcUaujpSul0KufnfOc5+c92YPfQc5MyXWSa1kyTUmpMyNtwDkK5CtpUwZRp8uqHXWaaRtljLWqpyUcicd651x/iHPACHy+xptvGmsx4zU3qerHrT3YuAcuamSTUaeQDkRvMmpkmZrJJGMY2oEEQDREd1Pu7uw4YMTYkJY5glllW58751znOc/VUckZMo1a0DSNFpHV03XP31znfOc4c0gS1FECSUCkQk0RHZ3dO9wtTFJmNvvQ+czMwe+g56NnwJk9u2hwdmTM7NXdttoQDgQFt6bAEA4PDYDoB4BwbAdNW223tgAIbtttvdUB02E9HTngHweg9tt9tt8A54Nj77333XvEt579bfvqeeeePNAa8ve997ztNAO2222jujwGW2220T1bffbnueueec+K0ALbbbe314HAW22h4ADve/b73zvu7t6+7uruXvJHhgEtQzUMEQ02CbGmITBhDQEMT3d33b2X3dXX3bvs8+96vJntPTgMAFaAbdLLy2rXgOTM5qZ46fcwr1bfQQC2222h9v1EOHaskiZMzUkmZmsBJoSWoGBD6e7e7tBebaG0NnPp4eW2362nOm/Afdk1O7ut+W21zLNbePQLK0AoA9EmSMm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VJtxu7u7vYjYlrAJjecbN3d3f2AAAdmcvJmZmZ7MAAAy8zzVVJL3d3dz0AAAa3JmZu7vdAAA292bu5me4AABOs5xUqTJmZmZ+wGZmZmZmZmY/y4cA/ASSZJJJJ2KSSSBAt++++c4+HnfOc55x0tu7badO973nOFvVtttEHrWZJA9ABncZkzOZmZ7MAAA+5c5zFVJOVqqknNvd3dyfQAA5d7e5MzN3N7oAACa3UlSN3czPcAAAnWc5kzMzM9wADl2GXjFVJGZmdz33AAAMvmebFVJL8vd3d39+AAAyby8mZm7u90AABNbs3dzM9wAACsvMVKkZmZme4AEITy/3e/vOc8+Z8+fPmM/e4NKBUHzpv22W2979999ec0F7OTve96oHuZJPQ9c2O973nOFtoJJJJJJJJFJOTG0lJJPQAQcABQAAZf7N+VUkvd3d3udAAA2+MmZm7u+6AAnwyby2zd3d39pUKo1CWS5d2uE29bN3d3f03Zd3dXdSpFlka1txu7u7nYbdxFLSVJdryby2/PlVJL3d3d77ERU6s29bN3fd3fdAAA29bclSN3czPcAAAnWc4yZmZmfsAADbz91xkrYVokzbP61DRXnIr585zwScEmFfP66FdCvv3z+t3wV4CvOYV/WFdItv63jrOdc47iE022zGofJkZUeAS27ZQCWEgJNzl7KBHj2DkSDyBK5ECpSAlMykcxDgUMboBKtoW6YpBwAkwEoYCToz0HmUEDEOBwm5nL9G1WVNdXbeXxTM3JrJmSTQDpJmTJ5maA6DdttvJJJLQGmTJICG8ySUDoAAybHgeg9B9uZj3Vsm97+/d7n5pNPE8/joAEMPpMkk7OzOoAkZkzNSaEAiFaBkyTAgJUAJQ+7vd0bvahCXDSSRMR17uz28lu3wetfSTIHPg+DwD15F8224V66afBCoALLbby3atABu223lpGsySIPQ9A9B8HgHDVttvl7WjgKLbbbZQCtBvYdN2g4PAe22+22vQfB4fffe+zU9IPPituA6PZzuu+d73oAi2222jvDx6ve973vVHoPPtREmSa885znv3AAHttvttoeAcy2222gAnOcve96+ABneySJrMmtZMmazUttt6C23z755znACG8ySBg6AAC2222gAQDIAALbbbaCYBb2SySTNW20WRJoDYnugroALMyS2220AGsySd73tt3mSTte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y2d73v7oAAHb67e/KqSczMzO/gAAMvHbd2pUmbu73QAANvW5y93Mz3AAAKy+u273ve/ugAAZM5jLZmZn7AAAO3129+VUk5mZmd/AAAZeO27slSZu7vdAAA29beXu5me4AABWXjtu973v7oAbbbbfxfxcOPcSKWP3x8b7fjfe6N3fe7N1+9Q7eW3vfvp99ecAt1be96ve9W2gAv4eA/fv378AFttttA/fZmMtmZmfsAAA7fXbb8qpJmZmd+gAAZeMt3ZKkzN3e6AAB2XhmZne/ugAATV9y7vO97396AABkvvbu+973v7oAAGX3t3e/KqSZmZnfpCFA727v3aqSd7meZ3AAAOXmXd5md7+6JgsqFUVS7reZl3eZmZ+mYsuKu5dxB8xk78UAl8N6K6m8+but+c+e97o3d97e93O9vd287FttvOc5znAAf379+/fvz+/fgP78Lbb3vVttAAH0mSW3y233vfffc873vbu+5mZ+3ZKku1i1gQtjmZd3yviqkmKrMznzLnZOLAC85mXd+ZtSpN3eb3QAANvdvz755mZmd6AABl97d33ve9/dAAAmGczLu8zMz9gAAHb727vve97+6AAB2+9u735VSTNqVJu7zc/AAAbe7f3nN3d3e6AABt5l+c53ve999AAA2e+89nnmfcupUnfufv379IP3n79+O8t13v623tgDnOc5zgFaAfv34Ba/fv378F7393ve9i0AC2222+yZIW+/vQ3vb9+/fu/ta0AAK7fe3d973vf3QAAO33t3fcqVJmZzPcAAA3ebt3fnyqkm7u7ufgAAPYm83b+c5u7ue4AABs3mZd3mZmfsAAArt97d33ve9/dAAA7fe3d9ypUmZnM9wAADLzLu9+VUk3d3dz8AABt7t7zm+7u73QCEJ975vznfn79+/LebtveuW6tobVA703mSTve973vZ1GpMk2+HzPlTesySfPPdP348zJJ9wyZIffP3799n0tvtvfHe971ackyQechvbYele41FfbW+/vQ+888fv379boAAO33t3fe9739uLuiiiiKtcy8MzalSbu833YhoAHd5pzd3d33AAAMvDN+VUk3d3O/QAANm83b3nN3d33QAAMvp3ve97+6AABXb6d7tSpMzOZ7gAAHM5mXd5mZ7nuAAAZeZd3mZnf3QAAM2+fvb92989+/czvf7dttrpoAqAOc5znOAHTYHltt+torTMklakyQMyT+/fgGrfxoUL6D5pWv79+Pz39+/ft73393vf2AAAdS+9u73yqkmZmZ36AAB+zmZd3m1Kk3d5vugAAZeZd3mZmZ7gAAFZeZd3mZnf3QAAMmczLu8zMz9gAAHUvvbu98qpJmZmd+gAAZeZec5m1Kk3d5vdAAA28y7vMzMz3AAAKy8y7vMzO/ugADWtfv15/Tzf7ff7nf7+v9bWwHTQBUODxzfOc57xweC2221b/Afv378ttttUA6AAAC2/vQ3vfczM/YAAB1L7273yqkmZmZvfwAAGbzeXe7u7v6fRhISXa6SJaLuqkm75m3e7vzd33ZERBCZefru82qrd3fZNaAG3u3nObu7vuAAAYl97d75VSTMzM9+gAAblRvm+Xd7u7u+6AAB7Kzmcu7ne97390AACfqjvO+Xdzu1VZmZs7oAAEfPnszO/ed8+/f2/v335vf3ve973PP2/379+/fr+/a/AKgDnOc5zgBbbbattttB26tveu973q0AC2++++++97777klVK73vb953MzP2AAAYl+5d3W+VUkzMzO/QAANm83bu83d3fdAAAy8y7zvne9/dAAAnx3nfLvu1VZmZ+wAADL7l95mZmfsAAAxL9y7ub5VSTMzM79AAA3rfN8u7zd3d90AAD3OZy7zve9+9AAArt+9u+7KrMzP2AAAfu+TnM9T9LqSpJWJCusJOv6/rzt1hXhHZHAV+686r3ezCd2q+OQJeYAl1xmvpASpJIaQB5gkjmIS9dWqASbQAlb2rmHcydPvZt13PyQGAJQAlEIErASdBbhxUHn1w20CTYCU7md16Al4WtHvRLMvsiqeMH7znWQ0DfmpatptOYEJARUAJQAlXrv1g00MevInN3d7u7u7u4en3nN85zgAvfffXPPvd5mSZPtb+44c+QlcyjvRHWQ2qNlplGKaCddEuqRdWFOrFLFtGxbVLZQ1k1i2NrY1qWzSjZVlGHOc5znznyRzAFkyZGlttvZmSbky7oKZkmOWUYGoao1aUZqG0StlRmWpqFaYo25znOc5z5kmYmhWhcyZjQBZbfrb5bjNO6+7urRISOfbO7u7oY0CQhoQmNGJJvGk3jSbefxA9AD1JtMySbJJJOmgVrMmtSZMzU8zN5mZJvSoKsmZI0ECyZGpJJJrQrQsayZmTQCTQAkSMIfbm7Ht8gEte92d3T2imRofPLfbby+0NTIzMmSTmh4K+zJJGhsB00AJbbbaIHB4W2229rYAAPg9B6D4u7bb292bAdNLbbe2UAIAK0AdNgODwD4PQevvvvvY+0g5wegAW2220AW2220AdlkySgOUeg9+5kyTznOefCoAHttvttoAMAPg9APOc55znAAE7yffObTmbVHNwxzbLm1rfNxsZrM6Dablw2HHLZzjc3PvTqxjktUpV3d1dqK/Jc4gKsVVrol5NazWpvfv3v3QAM7kmZvU73ve868A4CAge5kkB8Ie973zved0AcHltt8ttOAHe973vevAuT3T3fF593uSZnczMyazJM7re+rR8HottttoALbbbaABbbbbQHxvMkh7kz3JnmTPMmegPQfAD77n2TOXz7737vVDMkxMmskyZoAk1NDcyZm9gVo3mSQB0DnOfFHJG5znOc5zlRypLVGayTM1oC2223dNwOnQttttoBrJJmQANSZIAAALbbbaAAPQfAAAW2221WgDRFtvb3V3QAA1mTMAKAPTeZJB7JMB9bQAC2222ngHFakyQAAPR7o4Hy3y20EABbbbbQHB4btttubzUmZnZrMkzNZVbhzliG1AasMC2/e++++1ZkzGg6bXJMzMaHwe973n939P3LPfM87753162kiQP4X32K27fFbeK4qfuhh7+/efhU4BznOc5wAttttX8A/fvxbbe9fd1mSTup3q0AD6TJLfee++++973ZmyamqklTxCAUkFSNbW1ljaNtq2mYzC2WY2J9+/fvX5IXnr1Svcr79+9qL9rbNJUVSCRu8wAAB78reTzPl3fzyqkmZme/AAAM2b5u3d5m7v7QAAO33tr733376AABXt/d3d6JuSXpl3N15jzFiW5ctWnLbZ8siGABiX7l3fzyqkne9778hRCAjgbuyQLU0AboEkTXczJJ5uypsAE1H2GbzgcAPpPtkkkn0mSSSSdikkkk+xtJffb99994uRBpjaS9A6H4aXT3GYk0gPY58+91ppdibSmQOHQDxMD1ySd7z9k4HqM5BdD8upNINA5JO99735dneam1szcmeSSB+O7OAAJoxTpu3xtJAB6mr9lC7tttqanezd2SSRJySbuwbYAJoA2c4AAmoZJu7fW0kAHqaqtt3dtttqaAN3ZJJEnJJu7KmwATXcXZ3iWx57mZnfOLH6c9++9JP2w2A6aHY00VAHPua5znDzAOEIHl/M0POFft/v379kyRsIklJ9JJJKAfAcCSTzve98737uT1JpSSeUA2c4AA2gk3fKvM1tJGGLgHiavuW27u+222poA3dkkkSckm7srbABNAGznAAFcWY8xNpWhvnvmrcS83W0kYYB+8WY1dWW27u+2232tIA3dACJOUDd0ABNGJJvlSTerxYkm/N80AtvZJJskkqSaDoYAEk7FJA537vd97908Bbb/A/fp+/fgBbbbbQAAtt73vV73xbb9+fmv2/ySRNC6Bl85v5tJXLTiaoTDQttqaAN3ZJJEnJ3JskkiaoTDQAE1JJvnM5dbSQBfbjatt3dttttTW227ugHQTW4gDd0AImhZJ+6VJN9/eZ+39z33++/uf38B4BwbAdNAd5znOcALf6ZkkAflvVtv4/Lb3vf1vbqgBbbbbTVttt7+fv337zzf79+/fv0xEk3d8dNbSRXeO4uJtXU1rtt3dtttqaAN3ZJJG17kkm7skpE1JJu6AAJoA3znC+NpK23y40v2Zbbu75bbbV81bbu7bbbUmAbugACaz4zPtXOeSD+RWJV/NVU/mJ0xD5in3Hz71FfdKT7pR9yj7qXLTZM1o0iv5pB/Mus1tY385Kj7+dSpX3QPuUfchfdCPlTJ/f1/v7+3/f39/Dpo6bd5znOcAEmSJUrmY7f1tt9O972KSTxUJP0k73oJIJJgASTsG0nJJPyTSnymTwJJ9JqbaUmtJJzHAN3QABNAG7pfzaSttvqatt3dLbbamrbd3QABJgG7oAAmgDd0CSJoAN95wvjaStt8TQBu7AAE0AbuySgJMA3dAkibuTKMay1m1rK61Xnbqt50oS5qAC2Nppq4Y02kBxNpHhUk140lbbe23bJJJ9JkkkkXfdaaX2fY+fe/ffPvd+Y1zyTJNi+tfsySdA/JbcmSUncxYYBavW0ll9BppSfe/dxds7MaaT6/j0C0Gh2yNQp+mZJ+/bySfsAN3QJImpJN3ZfzaSC2+pq23TnLbbamrQ3dAAEmAbugACaAN3QABNAG7tufm0lbbfU1bbpzltttaVobugAWrMeY2ksxq23d2q222pL43MbXmJvX5qS1ZqSbxLl8t+ttkkk8fp+/fv37v79+3+A6aA77zm+c4ACDUmSA5bfLbaPGTJNEfHJmH0nZkkkkkknTJIAB7TsySSSyhu7JJImhAG7t/NpK22+poA1HOAAJqGSat2SSRJySat2SSRNUA1boACagBnu3W0lbbfU1FcA3QAE1VaGYAAk5JMwJJE0VJN+cy22+WXt9DwDg2A6aA79ya5znengLf0Gg/L0D6P378Ogfv378ABbbbbQDpv9+/T9+1r9+CZA1pfzaSAPE1EYE3QttqatDd0JJEnJJu7JJImpJN3ZAATQBu6X82krbb6mrbdOctttqatDd0AASYBu6AAXMxYl5qhONNK5zzz379nvt/W9vZJJwDXBsKdNAd+73fe96UFv7JIA/WDyQPWsmSNftfv2wfW38H79oAAAB81mSQ21+/fv37e9AAE0Abu25+bSVtt9TVtunOW221NWhu6AAJMA3dAAE0AbugACaAN3S/m0lbbfU1bbpzltttTVku6AANqYB5ugADT9ydPeNNN6kk7IsizgrRXv9eOhW8Fffd68iudiu3P6iu6h1hX7wS4K9gdTIO9gvK7bc1pSxBsQ0CWb73ruj0vYUNZxc7ZASAkxCUAJM9JJ4cDhk+ynE3ptVOOG63FqEAQhCbzd9m+3ujmNrZiv0FtFakyjaUYR0siV0pWpDKOrqYG99799999/QF7J9UHzlSXIreHrng5GSZmszM1mTMzWSZmjwouSJAeBCpIDp6a7u7tEAjEmCSEc+d+PBgA+mZIkmQegTJmcmSNSVYVnCKvYurtRpHarLc5658/edc5RF7UZQ43Sjdc56575znfBBdaiS9qP2ud16yU65+c9c5+89/matNqLRJiS+I6haRkbWm6Ubrfxuefnnvzzzz1K93kSUCBNglABgOVMCBJhD7q6Z7uw1IEmNjGmIEwTAS1Ak371bHd3ZI9ZRwV1p1KNznz1ze+c5yUflGVPTiBxTnOYSwTKM4xsENjBihpIgGJ91cd3duITOQW0qWyJgFyKxzW1I+M6ruo66yZm20trWlGoYFa3Oeue7nOfOVTVG1tIfqjUKH077Xu6CAMQNPzSBELZ6u93R1iWTMuSZmpJkbPXLd2W234EzJJPfth7wMzMk+DwDg2HTZq222qgdyTMNi29mZJdW2gAIA4PAPg9B6D4PAODdttvLdAFQbu/N222ztfB6rQB02A4PAPvvvvvvSDTmgKAhmSQAAC2222hs9OOW28+8toAGZJO3zed73vn3VrgBrve973nQbAToAACyZI73ve950ACW9k+1JmTWTUkjU3qTU1JMjWZkze95rR6dAB73vfO970AHF3bbbQALbbbaAC222zWrQKzQ973vmZJmd73oLmNZNaBb2SZmXVttFmZM5NTMkaPRe5Jc1bbacHgO5dW2219Zps9BWgCtAB9bfLbaLd2g7bVu8ySW3xoVoA82B1UA9B8ttt7mTJkuqAuTJmTk1NZNZrTNHoGZJmAaAKHmZMwtv1ttA+9c0OfccHgAeAcHkyZi23620AAttttoPJMzAODWZMwArUmZnmsyZnmZMwC9sazJI9F9vazJMD0dNyZIAPJmTMA4PJgHALbfLd5kktr0H0D0t9tt9tAAAcHgHwei2222gABy/ffe5kkurec5fg9ALbbbZrszMk3JMm5M5re8ySV89HjAcH0TJEaK9Moy5KhpkG9979+e+++WcmkPR/d/wW5L3957++/ezn79/Pg8A4NuDw6aA79zXOc4AW/2TAH6tG8D2H7z9+Be9/W2/mgACfpjaSk2SSSSSBIboAA0wDd0/k/NpK22+pqhTnLbbamrJd0AASYBu6AAJoA3dAAE0AbugACattu7ttttTRjA3lXnl542krbffbjatt3f3Lbbakm39iMWKrmbeGgBJ9JySQ4Nvg9dNODx13WZJO973v2DbWYkpJ9Jp8HgAe9S7kmZMbSUkgd8mrs+8zJIdv1/Ft/AWTJGgD2NHU95kn0mqQIG4ABa8xZmY2kswy3l3LbbRXEqW7ltv60TQem7pfzaStt8uJr8rbd85y222pq0NwAAbUSwOG7oAAmupBpurQABNdaDTdWl/NpK22+pq23cttttTUx+255zd5afgJIeA/v3f379v9+/fvx006bO75zXOe8PCkkmd73vd7PfvPub9999OyjTSBppB+BNpfv3oAHTYAHrr1484Pf379+/ec4k0uAARNAG7oAAkwDd0AATQBu6AAJMBG4X82krbxW6mqW6bbf1tqat/HnNAA6mog03AABJkDcAAE0QNwAATXf3Thw99SaQB6HgGuaGw6dNAd95zfPOcDgAbkyQB0eg+/Atv63lu/wAABweABvT9/azJJ/f39b6mqW7u2222p/szGrbd3b7bbfbjaUIVUkN3dvznN3d3fdVUkIVUkN3bu7bbaXEmlixZiTSxY7bd3bbbS4pUiISVIny93du73f27uakqREJKkDd3bu9+/aqSbu7vz6kqREJKkRu7d95y222qLGnixZjTy23d2/rbbfyzGnixZiTwvLw8VWPMXmPfOeec555bbZJJyA4NgOmgO+8nN85wQOtX8A/fv1ttttX8t73v69/W/gAAk9kk8kkkkgHN0ACizEnixZiTy27d3u7u7mwqUiElE3d27vd3d3dhUeLFltu7ttto63bbu7bbaJq227u2221NAG7pfzaSttvqatt3dttttTVtvnOcoARNAG7oAA2s3Jnfy+5zPc/c/ffu38Aeg+DwDg2Dvec5zgBbbbbRbbbbV/d7znP3f3n638cd73ve972SSSSSSSQQBu6AAJoA3dAAE0Ab5zmoLxtJW3lxtW27OctttqatDznOAARNegG7oACTkk3dgACaAN3QABpgG+NLmJcxheNpK28Vxp227Octttqa9Pe2ZvvnPT39+PggPQfB4BwbB3qTJO973v7Oc/P2v3n2sySffvz762238S26kyS2212/re+Zkk739b+yZIc/fni23dttOgAkkk3dkkkEmAbugACaAN3QABNAG7oAAmrbbu7bbbU0Abuhfkmlbb416sbA3dD8AHuPMbWZmZiVtvnOctttiqxIDnOcAAiaoG7oAA2vFIbofGfBySSTySSeySckkofAaB+d7znOc0+D0puTJDwFc75fLbf7rT9+yZJ+/fv37lyZIeAA/AD8B148PZMkHn6De9gJkG97AJoA3dC/NpK23xNe4stt3dtttqaAN3QABJgG7oAAmgDd0AATQBu6F+bSVtvia9tt3dtttqaAN3QABtTn58bSZ5rZWk3b9e3plxLyNJvbl40m7daTfjTTv7jSbt1pN2/NpO+NJv623l+bSVy3Z+kmyST779n7P37f2KST2YPLf4+jW5MkPMfv37fby28tW5Mk73+yTM/g/v37+/v4FoB0HB5Y1zTJkrSbv7Wk3qtt3dsttE0AbugACaAN3QvzaStt8TXttu7ttttTQBu6AAJMA3dAAE0AbugACaAN3QvzaStt8TVtu7ttttqatt85zloBElczHc1JN+6km7c6fJrfcS8995755ff77l/v70HoPg86bHBsGu95zn3vJIp7JJIMAAAkknjaSkknskkne973ve9kkne973ve9k+SaUyZJgAAEgBu6AAKrFmJNLFiVtu7ttttqTSxZCSpETd3bu93d3d2SpEQkqRi95t3dt++bSVtvvqTSxYsWJpYstt3dt+t3d+KqkSFSkbu8u93d3d7NVKkRCSpEe7unN3d3cmpKkRCTd03d3d3dkqREhKkgbu7d3u7u7mxUrd03d+/aH8/n8/ncHmps/f0nrPmFf0S94C62216787I2UrrfajIXe/OuuhITy4l43GDgCWREMIZBENx8xcgJcuso+6R1i3XBXX7+fO75mXM5ozD3gErugq4abbY22IxkEuG002kJGgJMBILmlSpsiERp7Kqt6PVRD1AkGVXVm+N7QEFOEgGkJIRjQJNHu3RZkyY10ArUtt9t7MmZJJrru7u7tECSKKgBIGQoASXD7rl4fevr28tBIAwuNArRzMmTB93V3e7o+EgHM/Hn8fE91+9uUIEwSCr1AgKSAaEApzKuqU/Xvnvjfju+J+H3d07tt+trwXMyZkmdmZJrJjTvpsWSSZz7vdz7uvQEm020IGkkhoBnPureguTMyRmTM1JmZrS22W93Luh1pqWTMkaDtu7bbXAyTJmT7Xn2w78rzJMxoHoPg8A4NgOmhAW2222gAN8t3beDYDguZJL888Hw9fBz0Hw3bbby1sB00eW228loAgArTg8HTYH3mZJPJ9ee+817z560+3mSRx4p4+eZkkH3t3KN5kk9HjyfGjeZJHBohvMklt7a6iazJIB4G+OSAiKBBM+6+7vdfepIC4NnonJ5742QQZ5+2Mu5t72X3QkB3RvT3dfdCQHNGw8ad3mSSvHo2bzJItvturZvMklDbiG8ySOMmprbffuzusySc+707u7UgIBB0d3Tu5rQkSwQsbEA0I1ggza3vdnPmkBz7u7vZk60gI5pEmn3g72hOnvg61zVttvKjw9GnXKQDnlu1uae25SAe93V3e464SAfds7u7vkgIxpAPZ7u7vczqhIDz7p69vdhIB7G7vd19qOlIDJ6e69nfAgESNJA0xINpICN2d3tnrDU0upICe6/T2bvcnNX3Mkm7z6/Vo3mSQDiXWZJLbbb1PI3mSQHXkS7zJJbZ5fLbR3Rs+DH12BzTeZJDng9A5vzLfZR2vg+D0DJklZMk+3kyS657Jkkyfa8fFr77MkgffAbW23nZkmZdUBZkkzGgDeZMw6bazJI69N5kkCe22lt9ttq+RsHmZMzoJz0H0Ar3Mkm5MkBwtb3mSQ8B13eZJGgLxveZJDb62+W20GwHXHmZMz0+hpzoLAHwnltv1t8A3mSQB3T1WpMkO8bHgHIAAENB8eDhzVu8ySW/W3j7Q8B8eZkzHrQd3Ojs7ceV0w6UDH0x1ZzSA7u3qqt325nK0cHmyjx1f5wD9+ABbZfnz9hLpaBe4rEPzEfN85+c98+LEmTNAFkkzJzJI2enTfe95+/T99fRYexAllQIErr3z75+fIEvliEg+PiEkmBxNJsxJNpegeNJsPwBwCSfpJvND13vOc5wnoPrc/AP379bbbbXLbe/rq/rR+/fi25MktttAHg4/Yk2GtNruNP0M/k8XLrSTtvGk0ribSVutuLEmrbd3bbbRJgG7oAAmgDd0AATQBu6F+bSVtviatt2c5bbbU1aHnOcAAiaALznLbbamqBu6AAJMA3dAAE1N/ZmHBB+AkkkngPgADYc3yyZJy9+659B5JiUn083rEuSSSARBgYk0gA4H3fPv0739b9mST9kyQ/T9+/fv34AAAEADd1gACaAN3WAAJq227uu222poA3dYX5JpW2+Nq23dnFbbbU19bebofgDxNRBw85oAETRIboAAkyQ3QABNQDm6AAJrsDd5zh4H79++B6BzQAWg/u+d3znvP3779+r0tz+Hofv3L+AP37JkgNyZy/ng6fvwK0AA6bA/fv379vf79/dbSVtviaFbebstttqaoXd0PwB4mg0OboAETttu7tttpU1bbu7bbaJoA3dAAE0Abuhfm0lbb4mrbdnOW221NWhu6AANrzE001MTba4sbaSSXcbbS1Hh6HQlAA8AJ7JJ3ve3297Xxzn33319stvtq5bbbRbbbbV799800vvvq0myQAAkkk/STkkkk/Scnkn6SdF6Bu6AAJoA3dAAE0AbugACattu7ttttTQBu6AETRbbd3bbbU1JJu7JJImgA3dAC1NAG7oARNUA3dAASbTTRjaSTfccU4o0JPfnn7uivGFbRWwVfELGIOdsSEInfe3bv4zr98b813d3V3dfbbe9W3vaG+c+8++7d7tttJbfx7Jkh+/d/c2Afrbb3vf1ttAAAkkkkkkgAbuhfkmlbb4mrbd3bbbbU1bb5znLQCJoA3dAAEmAbugACaAN3QABNAG7oX5JpW2+Jq23d22221NW2+c5y0AlxK233nOW221NTEk3lnniMSTeJcr9/e++22xNr6232T9zf79uffv35v3+/H3f6297YHOfd5zl9sttqy222i2222uWzMktttWv7MmZ+/fjwxNNgHiTbDSGHibTZiYAABOST5JpSnL22+c5y20ImgDd0AASYBu6AAJoA3dAAE+4kHDd0kkiaLbbu7bbampJN85yHjaSC2+pO23TnLLbamrQ3dJJI2hrADd0/AAmpkvm73vL59y3xr9aSwCngQ8kk72dk9nb2PjnLJkn33z1bXsmSF872d73qr+G5MkHIfupbznP3e+97cyZhvMknwfufgAaAOpNKYXMSTdtttv3beX8lbbu7faAJoA3dKfNpIDiaANnOFadttTXtszhwABtfYEzzYAAmgmGgACa8A6bgAJrtNIYW21NB2ZAvW0le2+Nq+W7veUttqaLN+zpme+55efe4r9fHacab+xpk18lPwTzwtk4k0pP0773oHPe/3m/Oc5+/eO38cW2gfX22322yNNKTvfv32ffVJt9JJP1zEk2amAB+bTdtD1tNgAGdDZJPiSTMnekiaMie6cDd0AImutTJN3ZJJGqAeboefNpImpq5fbbdTaW5uW2ia7+73d3tkkSckm7sklBNAG7oBImpJPN3vb62kpk7qaM9PAzAL+omuk3z95+Ne+/r4mj9T7Fr+/fcn7896PO9/W/W3n7095ye++i2g/gB+ttttq9tve9Xv5kyQ8zE3JJ4pJJoASfST9JOcklRL8Bu7AlBtetYAZnoACaiMDMkkkTUkmYJNIL1NpW3jattzOgFtTVt9u4AAkwk3dkkkTQgDd0ABNSSb5zmyXiTSDTEmAbugACa8zzOeWHv29zz37vb+/X7v17BBOT6X8fjzcWJz2gAWSSScHOc+++tttltf0AH62W221b3vOcn30Q2m5JJJJG03Ow09ZibaaAACdzvexzu9N7Obve9J1NSSbugACTAN3QABNAG7oAAmgDd0C9bSVt4k7bd3bbbbU1bbvnOW0DqSAN3QAC4krbd3bbbRNAG7oEkTRv37yds/MAggBLLR8jOfqokBKYdOD4ZAMojaK4244FzNz+dPf53dS8YVnp+b9W3nkCUOIgBJlzUw26ATidmmMASY6BgJRERjhAlMQQT0kTk2z0RV9RjLQJXedcNzZLTsGhDqYnWgUvxEW9lQYm9mAEmDzbDryIpjASdbxGukgGwEnDHACV1l0aQhuHHzvpy6+KPi9yaj42i0CGmxJBkX8Zvb3CEuHPAOrIsJqhk22aLWd6i6QWUbc5znPnznxyo1RWxbAEyZlmpJMjaXWZJLbbk8kt7BwXJMzUyTMk8c9HvLbbe3QZAHHOfJ66EnGurVSrtBqibWwGl3uc5z95y5L4katkTaI1DWinNznOc585kPlobCrayjVGZQ0jijQdLWUZRkGxNjYDaisBze/t3c3dGNtIBgCVpCIQki7+vfHx8b7fj46I2pGmxGtiSyjzrnOc+evmoEvIEmIS2K3d7q7hGsGgSsIQKuskdWCYKaTYqOYB1TLnXPfOfOd85I+LCla1slVao1JplGzZbNtrKMudbc58999577E/YhptY2zAmwbTTSG0AGDRDGxMYISOjuv3c+7RSZnu0mTM1rwFhJmSxoBAF7dW22nTMkye+A44a1Mk9ehx8HoPQfB4BwbAdttG8ySDwAC222016D46bAcHgHwei+W23608A4Nrbby3VAVAAQAVoBznOc5xrzXTzwdcHnnngHe22210AW6tttqrfXngdPdA4D4PfmtffffeigCtS22200PQrgC0A4bvltt+oABkyS2y6kkk1rMyTNazM81m9ST7dt9qgBXttvtva4bzJI0Dxbb9baDwDloNjp66XbniitOB6UDa2y3ltDRATtuZMlttoYAvbq220AHnLd2/W102A59b5fbbQAIkyRmSRMyRkyRkyRmTz2a93mST330F4AC2+22+0Nm8QHd3dfdW0AqBA/CDwlaEETTBBzzTr21TwDgFttu+W7DoyTMuZJNNg8PZMzPcyZngVbW8yZgDpC2222gCBpbbb20K0AeZkzAODyZ02OB8AfLfKAAAFurbbarUyZnmZMxwOKqD0ABbbbbQAPMyZgRHAAAC2222gAACtfB6Pdg4Vub37oHAAA4PAAAHbqTA3d2PCZsb3d3u5JaNIEmgSbGgSeVzrnOc6+fPipftRgtgNUaZiSSbGmjY3N3u7j2Zn0+L+IXxmz9PjPe+LAaPrYefmSU9n4A8tts/STkkk5JP37zx+DLaBkyQAC2221e95zjvV73slQF8zEk3bZbbRGYkm7bbQO978DTWYlKG+c57x5ibWY2g1JpIzxtJYbUPvnZdla2G0LapVvPPPN3fAAE0YBu7JKETQBu6BJEnJJu7JJImpJN3ZIAJoA3dA+VxppW3ia8tt3dtttqaAN3QABJgG7oAAmu+qEXNxLM8xbffL+8af4D9M7M2Weh6D4PQeDnOWTJOcnE9ZoPomlJJKvwBxJpABPxIJNIADP3fvvmml79i+O9kne973o2kpGmlAACdmJNKTO973vfx0k3dkkATQBu6BetpK5bqatt3d7bbbU1bbu6AAJMA3dAAE0AbugACaAN3QL1tJW3iatt3d7bbbU1bbu6AAP/oxpW27u222ianNWpLFiTxpJvDPy1Y8X6b76eH8WQt/fv34+D0AAeDk5r99739P37P1d7f3i220PD62+W23JkhkyS222W/2ZMx+/fgW2/gAduqP6SZn8/tSZJp8G7oEoJoA3dAvW0lbePzFbbvvOW221NWhuvQkkbRgBuvQAiakk3Vskkia+k2bkhetpK28TQrdu920ATRCbkkkiTnZNySgCa/cX5jWZKv2Y7e/Wl7G3bbb87+tp4ATyYk0pJPBXuzk3z30Tdq6p39MAH4t/CSE++++++O9FMbSUEAeJgQ9TabMSbAAJO+9+374/d7p2Gm4AAJoIatAvW0lbeJo9tvmW221NRGQwAASZA3dAAE0SG6AAJokN0C9bSVt4mvLbd3bbbamgDd0AASYBu6AAJrzGmlF9F5Pdw397nv73nnnh+Akkknsh6D0HweDk5z73cmSXvPOa53peW7uraL2221e95zjvf0/H79+/fv34AL3vc73veyToAbugACaAN3QL1tJXLdbVtu7ttttqatt85zltAiaAN3QtttTVtu7tp8BxsA85zgAFElbb5znLbbYmgDd0AASYBu6AAJrfe9vO79+995+/d7fb+tfAfB6AAcenvJzn3prMkl73vbe/vwB+LbbbVtve9W20AfsyZn79+/fv378ttt1b+H4IbugACaAN3QL1tJW7cbVtu7ttttqatt85zltAiaAPOc4ABE0AbugACTAN3QABNAG7oAAmgDd0AATVtt3dtttra8xpN5GYgP1U5ZFfbPO7lvAPQDySSSSSSScknff3f3iTS9m9n3fupNKSS+h42ksA9SaQHVPe97EmlJJPe97399n06NpuSQACBjabAPG0kAE9UNMTMkk+kkkm7sktbSVt4mrbd3bLbbU1bbu7Q+A4mgLec2222pqgXnOW221NU0OboAETQFvObbbbU1QLznLbbamqBu6AAJMA3dAAE1c2Lp4t33iSb+9/X395e+Wzqpv4AD8fAcACSSSSSeSee/j734N/fd+ne9tAA6Gyd73ve971tSSak0p6knFixNJSReQbTfcbTYAABO973ve9ne9/b3vO9lYQA3dAkluJW27u23tjaSt1NeW27u2221NAcOc0ACJoA3dAAEmAbugACaAN3QABNcAN3QAE1QDd0C21NAG7oBY2krdSefcWZ79bb97fvl2bQAP1vbby22ySSA9Lxz33lvdcvb+/AH4ve973rq23vZJBJtmak0gPDE02BxtNkDxtNgB62mzLmJJugfW2+WflJJJN3YABU1beXnNoARNAG7oAAkwDd0AATQBu6AAJoA3dALG0lbqatt37nLbbamrQ3dAAEmAbugACaAN3QABNSd4pjSb6vM93z382kj2pfv369vVTQqtt8VvbbwAgk2fmmkAeH799+fGue781H153vZ3VX22320Hbq23vZ3v330+++G030knrabgA00gCMAPW02CbSADobKCAN3QAraSt1Jq23d29tttTVt5ec2gBE0AbugACTAN3QABq227u2221NAG7oAAmrbbu7bbbU0AbugACaoG7oAAmr5+P36To+oMxPuNPvNaTcaTeeL91AlK8/h/B1zO5fRPZbmpiaundYend942rdqUxm7HuLibvvRJCQJgAZ6rvu3jhVG7zgq9EdMldWhi61skcFbaOSnNbVRylY2uGmXNxbnDmts1ucqHBNiVlAT7u73d3ISRwCTQITYkYk45919WZJB59kmZrJGTS+2220B9cxmZkzbaS1JujCfJ0104i4zlUzPJuSSZk0cFmTMtttaAKNRwIFbUAmgSYNCAO7uzt47lfAgmTyebHAyZM9kB8K+yTMbyTM557UHaqXdK47aknCVkfOXZpviabaxNt5/IBJCA2m9/YmtySe977fckzLfbfh8weg99mZky5MmTEyZjYzj0R3e9ndPNAk0CXCBIbBJc0CUOO7s7ujuQAAwAKJJEEs7u7va09yTMsmND5UWRoLbPMyTLbb87t60CTQAoQxoY2NHd3Z3d7Xu7u7eDwD4PQeg+DxY0OSZJaAdPAOC2222oAK0AdNgODwD4PQeg+Dz722+3nLdgOmhu23tnLQCAffffffa3Q4+X16ALq2y23v0D34PVttttHvwe/Pt27vtt+oWt7HZMk+++++OgA+k9fW/Xn19tHwFttttACc5znHe7AAd72Z7qenvskwe970AE8ne9773vfQfAfW7zJJdW20AHM7rve970AC2222gcHjfF3beW0E5oelvcySzJMzUzJrVttFxoHezve970ADsn0u7fbbVjQBJkyxNN5kkAJdQ3mSQBJkl73ve97fg9D4PcySW32232gAIz2ZMz7XvvvB5aAAC2222gEmZMgD0HwHgHBuTMx61mSS2+cvL5deN5kkD08PTeZJB4TJmAcGwHTcyZgDoAHkB3l3d5kzLbadAA9B8AAam8yZj2tL7zt7dWgAFttttBGsySAbzJmFDpqbzJmAO1cxoFvZdW20AF73ve96s999faD29uq+gvtD5GsySOgUDYh0s84PADw3o3fdW+W81kmZqZFfCk2LTSjqdAus292FW+Ud7w8Om7e33JMzWa3bb8HuSZne959PZ3Pv3f38e/fovoAST+EmnWrb541e23lv9/fwAR6fe+eX7vO970ttttBbbfO/fbF53772ffffTve9Gmlbbb7+zEk3bbbbbJIpJKqqXOeNpZizMxZgG8b883zGrvbWy2ltVbFsVWzZnnnnqQ80/NbNm2tEtgtqWs2ZkCqIREUJJCSVMy5JOKJRKSklCkEVFQIKhUSKhAqoVJJKKJICJEZmX5zmZmZmSpaG7oAAk5Ju7JJJE1JN3ZJJImgDd0AsbSVupq23d36222pq23d0AASYBu6AAJoA3dAAE0P1TEtzDgaj8B9Mndkgj4DgASSSSTszyddaCCqjRIM327YIN3p973tBBu73Xy7kyS2q1y+36XU7rrve9W2gAfm0kATDUGBJJ9JObuySWtpK3U1bbu7bbbamrbd3bbehqaAN3QABJgG7oAAmgDd0AATQBu6AWNpK3U1bbv3OW221NWhu6AdDX3Gg4boABcbCd+3zxLzy/fYm8SxJNL2/d5ZYXT4APyPgOABJJJJJPJPf3p77Pv33e/ffip2SSQmdAJJJPvjupNLve96YNpv6Ae3MSTdtPW03ZtxNN20AAkkkkkk7MADdAAE0SG6AfgE0B+3dALG0lbqatt37nLbbamrQ3QDoamokBzd0AAbXyWAebuoAATXySA5u6gABNAZkkl62kg1THmNW8ufb4k0rbbamu+an3Ek01955Rq+fXz69523eNmAHjRh8cDb7bbbbZJJ+k9nn79755bJkne9ttXve973qgHuZJC32222d6JzNSaUk4pNgcJ7JJ4XMSTdttttskA0AzAAtNTQBu6AAJMA3QABNEmYAACaCGboBY2krdTVC79y2/rbU1afLdAOhqaJDdA9AEmB9ugACaiA5ugACaqm7vcDxTPue57+v5L333r8xZmY/1llu22tgcR8B60r7bbbbZJJJ5J+/e+eYu/v377799J3xd73vnaOgDJlux4Httv7JJmQH79+/EkG02AANNICfpJytkMAN0CFbSVupqhd+5bbbU1SXdAAEmSG7oAA6satt3dtttHViSeY1bbu7bbI2krdTVtu/c5dtttTVvTd0AASYBu6AAJoA3dAAE17ureAB+D7oXy222/rZySST2STySRTyT9++bSX7339G7VttAALbbe9W22gIJJK2mzGm3cxJN7cbSVtttvZJJMkkkk7N3ZJCtpK3U1bbu7e222pq28vObQAiaAN3QtttTVtu7toAJMA3dAAE0AbugACaAN3QABNW23d2222poNDm6AXqTSt1Ne7lttv6/E+5lYcAKvrqtzwAA7JJJJ5J+5zn1kyTjfukDjkmSDzLbakyQPX7J+PZMkVp7vup+tt+v4AABJPJkk5BtJaYAfqlbaW79zltAqatDznOAARNAHnOcAAiaAN3QABJgG7oAAmgDd0AATQBu6AWNpK3U1bbu79bbRL8rbbu7bbak5JN3ZJJE0b93z9nMxLnN8Lf3tvb2XZIIA+/fv3m/34HQD05zXOffufvyhbfwDhHn9+/Ad7+t8kyS2383wDoP37UyZn78At/AEDeb2D9Mgbm9kksbSRiahgZn4ABNRGB5uySS9TQBmAACTAMwAATUMDMAAE0AZgAAmordtzLbbamgDzmLmcwAvraSuXE1zZ7D7WvPL7zy2/d7Mkkkk+NgAA+c5znPi3t1bbSAHwAverfLbTg3JkgPjZ/T9+SVAd3tknf3bAA3dAAqaAN3QABJgG7oAAmgDd0AATQBvi5i4AW/NpK4muW27u2221NAG7oAAkwDd0AATWgG7oACakk85fPAC/RtJXE1mZ9+6Hy88a88339ffffb9b2ZJJJJ02AAD5znuuc8+GTJHweggAFtttyZbseB6DYDskne1tNySRSa2kgJJPp+Uk5t5wACtK0N3RAAXE/stt3dttsTQgDd0ABNSSbuySgJoA3dAgCatpl222GJr6SZzZJOzE0IJhowIYmpJN3QQEMTXurnvP3h5332ecSTfnu75w+73h6ISrPd7hCUe8AlyFl3kdDy97e73RGWIS2ygYefr4EE9VeyXrvb743r+IygEvhAlEfGVOfEFIhkeixkzCt/D+CztYCUzyd9zWal+4rrtAD4PfOb5z3nPgD7fNeDktxmSS3luzq5JZkzEyZmpK4UTYlaSucm2NsJhWis1KxmTbNZtmtzXMbTaDKNbForb975zvnOc+c2IxLFNQ1FYVpsbNo6Nz330UAHZMmJrMkk1MySSNgEEAaPkhKBJDaSEhuIjm+7t2N3d3eBJJgAZmTMs1kmTPfY9DvVk02AbuauSZiebDpWa1MmZrNTMmF7KJzixSaStlGVwtzf2AAMfWm2G7JJ93793e873skjbTf7GuqSfeePXp0ZJEmd1O6PfQqTJJ5NTMkzPteBxSeJJJNzJMm9bB03sBagC1MncRsOnrMzI1ofB26tttvB4B8HoPQfBz0evttjUmYKFD03mSQeRbbbbUAFabttt727AcHgHweg9B8GvLbb9e3YDpoW29stoBALznOcnINe22+/WvAC2222gAAA9B95Zbb9bQAXJknO673vZ1TYDpJkne973vehsAdurbu0fGwTve973vR3d3d3d3rxI5mtSyblUNFMbYTEENQ1hRJBLRJEA2xyiG0pkaid2893d3ANattttoAFttttAC973ve9UAFtqIHwAbkyRbbeW+UfS6jfT4hcyZMjQBcmSTI0B7vMkne997127eg+D3JkgPg9B8HttvttvTYA+8yZzv2TPsmMmee8tttAAcXdtttAAepvTbc81rbeZJHA4AAttttoDMkzAFttttABprMmYA6azJmBWioAttttoAAANZkzACgLbbbaAAbzJmW228t2PjeZJC+AAAAAZrNW2221uZmTIA6SZmBbbbbQA6bkyQ23mTMAqjw3mSQPYatttvbFaPTRt8HO5kkurbbaAjWZJAHr6jnwCNZkkAdtt7lms1IbNZDKPijKOqxHVUukhCRACSaAC04ne7vd2iQIjozu6e8bobu7u93WgxpBGQljWNB8tc0C5yZndZPPL5bVv7QB0+8D4AD5znOc+4e+W2/W1bbbbRbbbO9W22gABprMki0OjoAXTc73vRJIWNr+FjStMu229uJq5czErbd3bbe3E2NZmJgG7oB0xNjWAG7oB0xNXFcdtu7ttvbiTUkm1c4caaQHATQBv7nAAE0Em7skq6nMTVuW27u222prOGNLAA9Pr2fbkmyST6TZAAB85znOWTJON/oB+kyT9+/eMB9Jkgr7YT2TJB8+t9tv4/fv378BIAcCGEkne970gaHjaSAAh3nOEnfk13ve+c5zo00pDhE0Aec/eeATqak73znOd73vyaikk95zkkDrVWAHnOcADrTUkm7srTSA4CTQBu6fABczGmsxq23fOcvAJ42kjEncSy23d36221Oe9991vzf79++f3f1rQB02A4PBWnznNc5z7+/flBb+AEAv1tttd722+W0cALbbbaAIG97Xve1JySbuwaaQHATQBu6fAA2gDzmK+eUD77G0kYmqrbd3frbbU0Aec5ySSdTUkm5K00gOAnuNTA4bh+ABNekDcDwATUm/pznM5ikk8uNpIxNZ3xboaFtnZkkkkn0mwACHdDkkknznOc58W2221bbbbQW2973ryTJO96v1vtD4AAAAgf3nnn4bSQajCpqgec0+AOpqNBpu6SSRNGdT3Q8N3QAia+Tk2buySSJqSTfNkkv5tJGJq0t3XttttTQBu6VtK3bDE0Bw3mnQCJqBpuEkkbRk9nW/dzz3999993939f2gDpsBweAfOc5znxbbbbVtv4H79+/frbbky3dpPvh4+G2sySAcID2SYD5oSSTq8ADcACKrEQN1aaARtSa/pzj5zZUkg0v5tJXEnLdu5ZQBNWlu5Q7MTVU7PJzjTS2bJPk153u93d70kimBve36ST9oTIG9KcJMPY3p9f0viTSMTV4km+fliapbe/W9mSSSSfSbAcHhbfb8nOc+4PGwHbbbbaC23ve9d/rfwN/vwOgAQSSSSLySKbkoBU0Q4c5pJJ1NSSZt4am0gOQxNE0Rz9oARNEJuSSSNrpmaHhuABE1OybkkkiTnZN1Npb5MGmkBy+tpK4mrbdzb2221NWlOc5bbDE1Oo42kjgd+DkPtyTZJJ9Jskn9+/cHh3v72/fuc5eazJI19bfLTWZJDYPWmsySDwPLrMklt873rvf6/gfv36QAAAJJIpJJJJIpIHMJJ9Opo5gcNw/AHianZNySSRtdWScm5BppAcBMIftAC1pS05hbaDaSuNq/UuW221NWBt5yh2Ymqd505sknyaFO9kR3d3JF9UW5oXygSYI+GgSj4+JQIDMf1kUff5w91fpRpBorBVXmlDz70VL1UalR3ij7qD7pR9yj8isIPuIpdKNR/MAuIrAfzP5qT+e/z+dyK20Pe9nO9++PO+zP3797KTskknamkk6Afv379+aBb2973qh4PQfAAOc5c5znOc5zwfZRsoxr70lVdKbxtNKrLbd3aBImpJN3ZWmlJsiakk3znJ9Jfm0kYmgDd0LbbU1bbu7QOzE1UB4c5oAdTUkm7skkiTkk3dgk0gOAmtAN3T0AGm0Ab4ucJJTqav73iw2eXjaafWk3jXt/Xxv1pN4lijmUfPvqq81596Kde1HUovv373NtmNps/NJvUkHQ/NJJ/kwtt9kOd73t/vnPec58JMkAC2222gt/ZkmFtv7C38AAAAgB+bbYarf1tu7ttoVNAG7oB2YmpJN3ZQIYmgOHOaABE16AbunoEMTXoBu6e/gDxNehwObp+AIkvQ4HN0/AEuJ/rbd3b7baJr3EAbun4AE17i1oXmkJb0AJS1mwRlvMtfKBJpJCPnVSvnzl3RYI2Wit80g+e8hfcKvwLQtVai+887Q9KMTRWDRWAwrbE0VlZRqqd+ed0HmIVzK9qNJSnT1ttAWh734PJO9/ed9n79+9k73ve970TUJJJOyQAA73rT73ver3vqTSkgmk3+PwABJO973ve97JJkkkg00lWk3iSTadusAN3Qk7RNegG7p6W21Nfrbd3bQtqaqt23m7bbDE0STd2CDUkzIYmtbQBu6AQxNSSbuySdmJqSTd2AEMTQBu6AANrADd0ABJgTPVQsh+pEO42ofqsBJxD6pASp18Nv3r+IjbwBJuXjpyei2fLXpBBzQJZDjAEuaQKb+8R/S1/kaGx/l+p+xH6QTMRTioX9D/mr9f4R/lg/jvv+dwSf683L+XXv5/jD/stz9O9p8e+2vf5fdv0uo/oP7v7v/j/6/3/Vv/Q//X/dH97/3/4fLP76Wb8z/w933xn2f8O+v/H/8/xj+9//cfZX9f9X7v3fZ7x/b9F9Z/GI/5e7/lH7r/L8/tSSR9rECEISTYJIBI/s/qn+qPSf1T/X/Yf1/2Ordf2QhEkqOgIiDzK/t8pbfn6MpfN1bIJpuqZrCZxyk2XMra665nFe/BXzvmFdfBXkV00uvnXor7hW+itwV8+iuuxWxIp1sKQEvOgBJsBJklOHgCVyhW0utzKzivnNLr36K78Fbv4K3YrrgrnznBW8+9CuordebdIfM4R05FdithW665CvfRXMi531ztFxFzsLmd99980V0K3grr6K3XfPeqJ15ylceIufeOuqHGwEtm5QgrwCW5c3DkkuKqJqrwAWXdRN7IhKAEuYIOQJMED3QEroCt1uCt0K6+uCueCue+CvO/HXdD4K5159iv3jOfenWbZslfBXOlSgSnygwBJzTeTKlt4VJ3sQJdHgEpwBLLAS9nXAime0BKQEu6bveIASvQEriQEsm531IEqk0gBKdivL1dkxM87byMr0LOvcyY6OsBKkCUtgK/CueCvOCuimzCt6K+dCvnzsVzuRt4K48V7wVhW8CpYCUsBLGAlVWI9sTboSQ75Alm5Fd8FeffBXO33jsV+xG1wV72AlegJZgCWV5+SAd0ghNpI9fiaKvI9hTzxve9NvkIIrAEukgFSEO9kivr6K3wVsK67FbwVvorwCUUAlF2hY/TglXWAl3kCViBKeCuhXXWSuCvn19+SPgr56K3wV86FbCt9Fd8Fbj1t5572785zNGQN8ZMVmVg2xttjY2yY9zrOhID71wVzCt14qfuceiu+Ct9+kuYd3CEEzEgJRAlPsASdAJVACTj14IF62VwCU8hCxh7QEtrazpG5fnTeRlXJ1EOYWbM1Hq9BbdtjHfSeunMvnGVLJ3Z9dtAA8ihpjOiGyih5TrJlvaxs0i6mSGS+czHnM36tyLeaQEO7qV1Rrhtl3W1b872G1DxnnlREwWxL4YNpCBCStobp+fn6NiQ1tw/NuHkRzvxU29yFjv2e3N88iXB6G4LceatzczDcvZASS+Hecazb505cOXj98VJ73xLgBKtBB6eyHL8Al0OIJcZcAJbU+zCHg223sQ09nBIMs8ea8AlN0RY3Bnx7EIK7Lu9h9BWaAldN2AlEN5N10wW227naJY3vQm9eN7c+etusjYiIiIhjiI2CJiDpqaiIiIiIiBvYiYiIjx6nlW6d+cFNu7ipinXIEvAJPgEssBK2AlgCWb4BK0CXqASnwCT8rY96L86mq7LNd73R2cbtd3dW37ZOirzx59ceyH7IfogbqI9ETBDtwMfojYhj2IzZmYg9MkqHUuFMwOZVWJBlzJWQ62D1oCGESb0r149rbtXKBL0uY7JGVBbOaEWbprjaBv0ZCBLMcO5v2wbkLYIKn2w7h+upwguB3NF6CD2UhtN20CqIK96MwBJ0AlYkhY0gFjKl/Dyafvu9DptxWusECm/moc1zg628J3XcXrbfpmX8enYj2LHF3dMY389GIEqtwQQS/Xs4/G7qlCDc5AlfkkfDEFNIRbbb9bdDXxMufTdxBDMfxXiTzQeE3TphzPjoSWxC828qdjdAS627Bxc5PUT17I/Vs8Alh2ZU25sn03DFdmIKbBy686Kr41AlM+ht9WWqc0TRTj0EqY+Mr4G2Q2xXvok+Fsua6Icv1zN4AlHn7LnQEtu4nYBB0UkA9ASpFfaHu9wVnwVhXPnQrroV65wVzdfRXnBXXYrYV1wVvvgreSOnQreecfBX1Fx4K3apz70rmFd8FcYV4K7iuvBXX0CU+ASb8ewsyO+n9n/e/6H/5n3H/h/V5e/zUp/pkiv9Vr+w+TcP+T/2L/+Cw8fDi9+VP9f+3/o19Pgr/X/R8f+3tPoX9fgOP7WuW/fbfz/qqv9v/kf9Pvvg/2OFa//ZXv9h/t/OuCqz0q2R+CkqVH8Xv4Qvxf/R45/TMPhZn7Rf1GmRH3+/d+H3fH2sj5x4/nvopX7vpUr31HC6vn6/X/r/NVH6fp+f5xdTdz+3Eeec/5v+qcX9D9/NxTBe2+GL0ub/D9yr3ARveT/s/nHF85ET+D/dv8nvU19vr9jD7BfPz9nz9e3ffJ+PwvsqzC6KojWv5fn6t8fiWadv1M/d93xDlzHfRWM+z34jbX8pJ9v0z7vsJ/H9d/b9WZgSoFCP2H+bU4ZVfr5/LcEH8HuTJi8UpPUQfj+n7m4cNtQQfnHxiP1ayKz8e/Bttn4i/FfvXwnU19n3d+f4BrF/U+C1+/7vydn1G3i+n8I/I+pvhfH8PjPurx0//R8/h9PyXwcM99H+H5HmfaH6/p90kr7iPfZH6/hBGA2BHZnNP6ZUe+qL9PxzP7H8aj59s35qD5/Uyg+fp+/fHn+Qu/mP236V7+VafQf8ytePw8Xhdpb/LZmEH1MbHJ8/rRLs2LO9uFx6W27GKBlH5lXkH81zgyLZ6VSqstxQfv1v9355+X4/ZLKX8/7/B9h4k/Tp/h9fn8zPr7/0YfVfH6Wtv6fxKr9iP1F+BH3fD/ifzCfyfX/Jh9n7+z9M+z8+N/k/M/gfP4y25PpFNk/J+P8Qv7SF8/t+vz8R9v0HfzFj/jR9fxr60HM+7Puv6Duo/CYQwnfoRIUl9HYsGj7hnn5fmtKhf6mH62rPn+Rfeu+tof1jxH+5nwv42bSD+B+75n9vfhXdHz21+jxr5Z+o1xR9v1+NHr5y/wnl4/kL/c0S2WZ+9/uf8839h+MHyfEKPQMZQ5aTPqfR+PnN/ff8fV7cefwmaZKqD7vx+M/PV9ZH95JpH2OPQfk/d8H5T9WV/DSIifp+DnX0n1GJg/wd+o+tLof0PfBf4j/Pf098n4DbP1P1/bx9qz9fz+je/P87b+6vr9fz+/+f4Pef3wfX8vzPz86/diTB/f/0+Pt1Wv0cUoG/0+nyomPn7Y77/RY2L936fYqSZFfd8DZ/R/xg/b393/+YoKyTKazPQFhBAJKvzcAoA7/4AAVBEUwZMAzuQCvrQB0ADlbGQJKSuC+5tz1xyNQymtZtGMQVVNtTRkqNtUVKkQqJWstWmqkooCRAJUkYRhDQSp4ipp6QAABRoaAAAAQpE0gUmmINMgmpRKKbKZMJkGApKQSalAAyBgKgICJ9YARQQ/Ovv8+n0+Xz6W56AW+sctwC3LHkGvth1CLazNX21rrxmc+22dqKZYhKYce2K7o9MzDrLBBF5fahBUkVVVF1rq4YQCSe3IRsIQ9iKfs3I53soRC9nhHnk1feq/PJcRJsSJCnpJGteVb3JomwEmAk5l3K7Ifiqusy5rHGnphyg+H1Qd8dEjZtVdu7bsBJgJAS0CV+mbkmJASymIsBLcBCqHWY4vT2w564KIASq0IMQgkBLh8yag1mc4Z1a5ihtEwuASmG3B8UUtYCV0+JRfEbNVUeda72NJTjT1qN8ASgBLECVlNI6hCKqIhgJbXpHggucdcKNvPzm/Nw+CvwV2K4KwJSJA30RG16qfuASwQInQEmC8YAuZl5LWKBmau+qdgLJ2jwBetIJcAldOq9ICXV6cAS9ICUVzfRtCA2AEmAlBU1WIEotzYCWTNAJSkJEGX6cVaAlMly4yEgVe9ONCCIAS9plmRKx4mgRLbJASkg85yGVFw99PqSsBKYn0G+71JEMBLAEugtrmYxDYhK671vM97IoBJ1gCTzC5z07m69PV1qIuHOw7gBKY7jqmsmFbeUgS3nvRfRYCXvYISaBLoiA9tVrnSdtQyGAk2AlbfjOiY9t4azWXs7l0AlVdRLVXpkq00XBCNFlhSBFN05GLDk0UASqpASai37cYtc0AlXqnvPvBs9WAJWAlTIBttxCuNrXYvO2DZnTLcQgS9OecbOl1U3HT2TMxmT4BLB92vnvcwEoi5t6hA8gEHpROSy6Hfu9uRcTWeu82ze6tAS1hcYRlVt9na4ywEo6Jyr7xfZYCU5HXVOn0ZlUbNjECnDMgZfoEgZAAkCQHpOi5ZHPe26MrYu6PWjvL1xlk+9kRWMveqvTAPHtDmw5OoImIpv1JU0TcRmSqnIt1rmYIiE49zYkLw+fsvN3zgpl1CBKIx+QpQjvaJI3GgSgBJlxsniwEoT4BLJnHTkCWm/MBJ1kbUswBLYKqDKg9kJ9W1DVAJeCvvXQr4K4K4K8qnIrfjibdCueCvBXSp9FfRXvXornAEmm5HDhEsi5jRIXWSTYCXgEpObsVm948vcEqEf+xIpDuktoiCYiKRLCRI25rItIy5TNWVl5oBLZASi5kt9AIUDb44BKcSAiDAEnkkfFR6Y0zAEp1qKASqTXjXT6StASiWYqL6sEgUQc0AEesBKU/QiuxXgr2FedvOxXfXBXfHQroVxRzYV9FbhHf333vp80JQkoCH0w2TqhEuZlwPuN9qi3V0S4ajKgqlgCT1qgEmbRB6yEnL973YAk2WAk4ASqOq4muZVgJQSheASoBKNqZwBKgkBJpC5AlscouCKcMbqnJDkhvX7V6K7M8AlUMEjAEsSAoASp5HXc8zontsyjFtEIlDLJ1C8AV4K69Ffmb5Lr78CvgrzrkjEcFdiuC+CvtDhdeuCt8UOyLmtlt0MnfU0CXgEuAS7lLvAEpnPb3i96DdidhSAkwEqASqDvAJaFeyepr71+CvBXH3wVwK8EsEC33uhCCFzmSJiRw/IQZcJJKOASZLcvdjIrNrZLrB5ZuqUw4MuwEm5+CufaGngryK+CusK+dEfJfEXl9FfRXFeiuCvrrJ316WkAm5axzeAJchSXVXw97XlHNeUBXHXXgrz509FeCu08Rdr7leQ2oBe66857BEUEPgc986febkM04mWDKanJ7gwOAZIr6+/NCLVIbgzNaFE6JRcqVgitZgIeMzSC3vAF5vEF4CdZUglozFPmfNmJXuetY+LHQCYRZmZArZkWt5veZUnBWjmXNslbOPlJFDT8ePJz3779S85r08VOSPWVEJMjdy8LWIBCQkmFeihgJWwSWtc4zFiVoWiQYGOntIQQEbdpZQCWJAvV93h5wN/gz5V+nu3RSSHOdKW64q1jabYVrbe0qISdXd7zDpVFBWJENYZVKh6NoFJA2w3JRVTGqjNWMRmGW+WbdEFiSW0x3ilYy1Zdu3iIQ5EnB4EMtcRDKLCKsMxiTMcinqCg2taZusStpRzROZBc1RznKjZKNqlcZI5kLjBFzLmkRpipM82zroVc0g2VJbzgV3KUrnnk7FFbIjWpQ1qQN5xJSucrgTzVK80kl3knfMuURNrbrcjKo6qNErrXNs2g8Q0jputuSNxzrk50e/n6P1kUEKQaKVVwN3noxofnRo0OoMYBJtSvMcxtFYVsFfWFcQ/GALv6bAF+bBDCkqa+ZQKB1agFomSrkYvLnMoNgLByQxQPWIAZvB7zNIpzMJFeyY2YAugFvlinMRUEDIVXx5wfWvehEPOjuip67vOIfC5UcQ77cXvpUvMRs1lVXyx6ZQ7itlK2UnrxmkSkaqqiJEyVVzvFNwPMKrzSp5ad1Idc4KuVGLNSrvPTslfx3vXExqjRT4mSmslpMU2iWxCm0laxIibCJtBVrWykppUJoqSIUJgpSkAKp66hsTu5jYyWZLU05wvW60q5+fep3qD9Z5qJ6K2FYV1qV3nMB1thX3XzVRzQNQZGQFPXnAVu6wRBb1gC9QpNUYkdyeZUXPPh2R5qvfUgoRppAqigpoFpBKWgpBoGihoKaQKKBQpEpFoKRCkopapBpQpBqqrZGwzJG1BsU2htGlo0mmaoao1hNMxao1IYjTYbSW1KYTCW0YVthWlWWFaJhWVLYK1pWFbagsKwo2raUwrQVtLKWjCtWQylNUYJmNqQ1RkjVGkVhMqDa2lqGRDCak21RjSxQwmUDaE22zLY2bbSTEZJWqNE0lawmEyYTasKyGUtRLFWBhWVFtSbZjbM2bVUwmKSxYVttJapYVgrAtUZBWEwTVGKrabVa01rZCMmVVYVqKYVgsjVRtLVZbRMAyFtmNUaqWaUbIphNSKqGiqCqaAghmWkUpEJsoraFYVhspLZkwRhMJpao0smqMkwrW0yTImhWLJWqzYVgmqNFMRhNUZWqNVNNFGEzZUZlNUZQNAKwoRQglVExUzUMTbZLYiraQaqMVFskNUaCYTVJhNINUYTVGqNUaFqjFGqNUsVZSVhWCsKwrCspMK0SrCswrAbVNi2TMmmUG0qNUZBahhNUaVNUZUmEwqWFag2CamEmKtUhqjQmtWk1RqjBMJirCsFYppK1TaKxFhWA1oVkyFapZFmS0sKwrIVhWFYVoECVCEEiUqqKoGIqmYbQ2q2lCbAjYSNimosmqtItYVtRZhC1RqqYyEwmKjYSWwTCslYVoyapTCtBGVGSo1RqhYTSo1RhFtQ2GybKMxJahklaoxRJiNJWqNSWFaURhWJWStJMDQk1RhNUZUYqMqWFYhgrFWFZIwrUVMKwrQrJGFZqlkRqjKNUY2VsbE2G0G0bKGFYSsKyoliTSCtUaITVGhWqNQUwmiI1RqjVGqNVWhWhWhWqWFYVhWFaVFoVkjVLQrCsFaFYVoVlDCsFaFagtUYE1RqCwmIbUbRWw2mbYKWE1RTCbZSJsqrCZIk1RlRWqMCW0SNUaVGJZIyVpIwrRGFalTVGomqMCGqMJqjIjCsKwrKUwrJGhWhWhWFYVkjCsKwrSlhWFYVkrCtJbQNUaKtpNiNpbIbS2Nm21mQWE0C1RoqpaK0iFhWFCsKwoTBWqNUYIWqMlGhBCiBSjQ0q0hQVSCUlGy1swhbVSGxlGVQ2pCphWFYVqBLVLBI2qWFagTCtCNSaIWxKwm1RpRlRhFBQinJe4XJMEoSVoBd615d9aK/jiruy8wrMR2KxDIL5sSkF8wq61hdWAIVRSbkp5iqtaCrrFGDWUZIhALeo1rERDnWtNBQ+YaIUSQUmFmqgpmkoYoFRGWwC2lVbEbSNqxqh3HIz1gmMnmTnmNwC6DJEXOYpvXWbLu0q5hXn44Q6FaK7z3eAAGdYgo9QhqTv1ii752aNWWArJOsK9+cpTYV75Q5+cFc85wvm5t8zlMZbKjzpwV1FaC+51KKh75gCpQoPUNBHjPW0TKPWYAt1mIneAC9xuvWCrSOCWnNztwVzCtz3ole4V1zhU6lAXM5oRHXMD2KEpVChlCh1uE8bMlQhJVdd4gvdygFvEZB1PMxDUtC5hnN4gt1re1F53nfeMOe+OlSdaVHdiB+ZJssRQA91TEU6slQj3689t65zYaO9Igeus6q76zUOyMlMgFqQWw5m4RdazUcgF5rxoARyO6jLF/GIiKCHwBH3CooCH6/P7/rv87/Wf9+/3+f/F3JFOFCQSgdUow=="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
