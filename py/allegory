#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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Z2j7dRW6pOVVyld8eqjf0V3UerZUOhWq2VbvHW4r06FZFc1grUi8oskZnunMneUV9hVr2PGRXfD11loEqRw0QIwihPQhQbWFuSilKuQg5AanVKFKISKnVuqiSAsECaCT7fLmnI2RWv6oaWrrl165LoZTubRbAy7RtiBLoNdNHaBKAJaVMFclZkeYRx73uqtie8hXumsRaFeCannEVxU6ngLe2+P75qzW2sm1T13f3UH9vUrgqe+GUayK15me3jebzXGrIrzoLeb5Lz1lFdPfmdUjeM2YlZFa2StFd7jJqqGXdVHOd95uVJVezuvZ9VSq3Wql779fbsAC/rrx74cB3R4AAHKqSDwDXNzX3d+T0++dLABfrYcAE5UVkVxnXdDPErzCXdDp1131zn3OAHTYC2gC2gC2gBABsB0AD22h8HvPK+PdR8q61SOVGiv67ivajr7pUlVrzVSqnlSVWt+dfd7YAAAADg8AAAAAAACgA6lalVqSSTU+1Pam6kq+yK7UXTduK262abqMvc32jBey3SqustlWMcpNgkGISpPEkhiVp73FdqM2K0iawNZV3lXUyo7263alNEumbSPMRLvaq9ulPVUbXcVlVtXNznJV3M0VjyGm4rp3zHWUrPAhrtK1KrykwUtQ15vs499t+467dMx1zmrjXM3M49tRWCuRWeoj+9qt1NTySqqbqqknld88ta1xoAADs17774cAeg+DwDg2A6aALQAL9qpUqe+1J3dVKlT709c+uVGJXruiveqLJWmzYDBMypMFZd/adsx9eZhopPeh3krmj1p3O4rt1HGaxtGs1kdZaRW4rshMxu2ePYl20kkc6VxAlZYkCaSS4cmb3u+32vdA6bAcHgHweg9B8HgHBsB00AWgAd9k1JWCtaisRZ8+5rN5o8FeiuhWhWCtUNqNZ5rWud866znwrwj58222cqnrgrF957qrVj7FcMzDGGYrMaxPcje9INZCtBKDYIItWIRwzGJptOoQBJtmIKtyKZSsqi9ImbeuXDO4rncTnfp7auorc3cV6mSneORhZh4wyxmZpFaAy91WqE6lXLkvfK63RtmcuRmiZKxK1rQrJGCsxiDyRmi7ykMVjBsYAhUik2PjV3KtsbiGxh1szNrrrTa5trGtOk5c1dZ1ZJJxlSDHGVTUaaZElIqkG023IsGa0y21uB7MJfaHuTed1TVR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V4t73v3oAAGd513ju5Mktt9oAAF5V75y22+0AAC867zfzMknltt79AAA2b5q8W7u77oAAF5V4t73v3oAAGd513juyZJbb7QAAPYy+X5bb3ve97zvvt77+9u8AsA5rfJznPfuDwRkF3d3gZmZmZ033ve8zvc8wMzMzklSDwzMtttvvt73vzve997+9d57zve977QAALyu8b+Zkkttvf0AADZvmt4t3d33QAAPZfKW97396AABnvPe85zuyZJbb7QAALy3nOW22+0AAC8t5zm/mZJNtt7+gAAbN83ec5bu7vugAAXlvOct73v3oCUcMhJeW85y7I0pJBrKbqXau6uqtU7tXd61vx8kmyr7O3fvO/XqT9znOfvy7u73fe2O2dAtAHOc+5rn6dzMzMB+zMzP2ZWYB+wJKku7vve9Xd2ADMzMzMzLu7u7u8z4Au7AA85aTSq7VXaukirC7vT+ptKVmW3z8vJ1GTxwDmzfm7znPzd3d90AAC8t588873ve++gAAd53vOc7uZJLb5faAABl5bznL9tt9oAAF5bznL3ve32gAAXlvOc38zJJu7u9/QAANm+bvOc3d3d90AAC8t588873ve++gFVVVVVVT7pe+evfOfN66H3PYYJAFmZme527wXfbl3d2c5znOZ3MzMw1d3d2ZgF2zMzMFru7xwZmZmYAAu7v33333tkzJltvOctyZJbfL7QAAMvLefvnltt9oAAF53vOc73ve/egAAWbvzd5znz9zJJu7u9/QAAPsZfLefnnltt9oAAF53vOc7uTJLb5faAABl5bz988ttvtAAAvO95zne97370AACy+W85zf3Mkm7u739AAAvLeXzy7u7vdAAA+ec5yZvy22+3ve97zt3d47ZrLzN3fLl3d33G6qSd73ve5dy8makqTeZme4Wm9VUk+ee6Zh5VST7hUqQ++ZmfV9O9873tSpO+9C7u7u7txppo+kqQ+Pj6ptbQdyVUkzMz3zzzMqVJmZ5fegAAO95zne973vvRvHOYYYYRGubvOc3d2/aiIdANnLec5bbfvQAITed7znN/MySW23v7gAA73nfPO7kyS2+XtAAAd7znO973vfegAAZvLec5bb370AACy+W85y22/aAAB3ne85zve9796AABr3z9+++fLy88SZJ8/a539+4N2B2wLvty771f3znOMveZhswoDgAGs973vve34xZn3Wml3vZ3vQzNeRMzOZmQAAAAzMw+KbSQBvgBfOW5Mktvl9oAAFTlvOc35mSTd3d2/QAAPd83ec5u7t+0AADZfLec5bbftAAAzvO95zne97370AADvO95znbkyS2+X2gAAeXk8t5zm/MySbu7dv0AADebvN883d2+0AADZvlvOcttv2gAAZ3ne85zve9796AGta1rWtfa809GXmYGwHbAvVrRnu8999nOcOnQNfADPgADMzLzMzMAM73vc73uYXl3d5JUg8MreZmZmZeB6d738ttvOctyZJbfL7QAAKnLec5vzMkm7u7q/QAAN5u85vm7u77RPRwkJOccxInE2b5u85u7u/s3cySc44ERETq+X5zltt/exkrgF5285dyZJu/u/N9oAAFTl+85zfmZJN3d3b9AAA3m7znN3d2+2EMA2b5u85bbf2gAAT0k752pJu7u/j7W2222222235zxtzcsRvJzlpo3e9z3ZAA3osADwUZmZ73fL3u9z33znOZ3MzMzMwAu7vAZmZiSpLl3Z73vGZ4oAAD2GZmZmZmBYAAeOtFvnOcl73vfvQAAL7kvk+X5znJvzMkm7u739AAAvLec7dzM3d33QAAN5d5878+ZttvegAAZed7znO973v3oAAFl8t5y35bftAAA/O8nnfnOb8zJJbbff0AAC87ec7uZm7u77oAAG8u8vnk2232gAAT6vnfnOc73ve/egNttttt/fZU62gQC+7ABKsgCEN3kVsj4jQK731vrn7nmvvt/fuRXuBXO9ea+1zjsV3VMIcwqbxK3uOKgEm0AJW9tvPd7vvbl819BBwBKAJSIEsASfecKyQbQCV9zN9mgJZ0XWidiwnPXKnMlZFKp15i4NFVOjXq5R3sCNNiEgH6AJQBLPu/QBL11k981UlV3Xq/vPLvt5rBvYC7Oc5znOG7u7707dZPgSXExdnY2nwZJCJxx/Ak277/ff39+/fFSPuiutUrmQthW0y0VqLKpc5ScJTjCXGomLaNi2qW1Q1k1i2NrZZibWRWyNFZW0PBb6VKpoAuVUqNBd32qqTcX2vvvvuc+5yiuMisqrCrBWGIrWKtlI2hWskxaVGpWqqSq1r4L+beXUlUmg4erkklNHwLaX9d35fautWfB77dSVVRoe/X998d4lJkljJgrIrIqx/Fzj5mZn1SqlZobAdNAtqqmtSVKp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pkwl8kjYGkdA+aU+kkkkmZmZmbzM59vec9z3e9t3ve971Yu7u771e71VSTver+u7ypJVRgAAdzBtNgAAGZmZGwFJJLuSACaxAauwABNGYXYBMbSUlpqBL7qSSSJqGS7AAEmZhd2AAOKmpJLu5ckkHFSSdU1Jku7kkzG0lJaakkvutSSSRNSBd2AANr283td+18c3mdzvcZ+9/fv379+/c/fngABw+eu9598SVJferu1953Xe96sA9qpIKqHxghe96ve95+aQHme9Pe9X4SEtaEl+GwGzskm5JMzO5l5mZmQAu7AAE0AXdgACaALuwCY2kpLTUkl3c9JJImpJqa1cADE0AXdhJJImpJLu5AASYBd2AAJoAu7AAE0AXdgACag+US7knJ2TuqGGgCLstSbADMAHpmXfeZJUndzcyO9y+8kqS279V+9733Eml72ZvuDQG0mkYUbvtLPe7vp67u7u7u7uwHrRUqR31lVJN5e/sz3n5KEqEl3ckzMiaCw1dgE8k0pLTUkl91qSSSJqQN61oADE0Ab1rQAGJoAu7AAEmAXdgACaALuwABNAF3YBMbSUlpqSS7vskkka7yynv7999+/fu/v1v2xkzMzuZnmYDg8CPR3usVUkvve4tl3d2D4dfPP2YB3uX7dyVJd+4BADM1KlVuSpMzMzMPGZl5lZmZncz2Xd5mZmSNqSVUkkkE10CnWgABNAUqACY2kpLTRKkquySSRNClTVQADyaAQAAJMAqgABNYUFUAAJoAqgABNYprms73fv7797+/cu7aAOmtgLAHx3ve95x7d3ft3dpd3d3d2Lu7u+9Xd3dgAB+mZmZn6fv34C7v8DWgP0pAG9UtVqgCfNpKVKTWlJJd3JJJE0AXdgACTALuwABNAF3YAAmgC9rVLQATraSlJq5JLu5JJImrALuwAEnmZl3eZmAJrK1ns9zcW9LSvf3PJP3Oeffu/rv9oA6b2A6APjve97x3V3d3d3YABd3d33q78kqTve5773vZAAADMzBtNgAAGZmZnFmZq7vMzMwTQBvU3uSSdxtJSk1JJfNakkkiakC7sQBilJclySXdySeTQszG97BKmBvex+zJUDe9iyVP2ZmXdgGNr3veu7973vSk0LM5nFuves18ZlpCVYe77srawBKe9zav0m37oCTBA+e4MBLyFZmv2+57e+k5ghLeWrys5z13Xq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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
