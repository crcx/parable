#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
# BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack
    if type:
        return stack.pop()
    else:
        return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "QlpoOTFBWSZTWTlnUKwG3cZfgGAAUAd/8AABAAquZ5w4YXTffeA+QAOo4vk6AKK6YBtoc2Edq53dXEaxA6DocoougrIItckkRuWAAducDZmzABIA6cLm1LsbajIXMdAyOzNl2O6soAFAAAAApQAAAAAAFAAAAAAAAAACAAJQIgKAJqFhAAAAAAEKAAG0YANG6FO5EoKTWUAoBTZUGA2WYZlrCqUWWFJA2wAsYNCgAC1gAAwAbs52s3QMscAQ063fce8O0lUIORfQsPQLsejT63nnqhhLahkA2xoLYtgwjQoApQYmgtmgZjqxWuR1OtFSs95QAGwPAIZ7uOd6cMDeU3DjiJIoVEBVEkMCwJJAhEqEVAFCz04AABD2AdB455r3gAHV3p2gNA4zuxBIK447gpQO51cFHx956veBfPqAj6qm7FfeAAHYKHXoB7bU9dHfAHfebx8+0N5xuAcdwOOEAQg07owB7juB63GAQgOfF9i99VoAAPdnY0EKAJ8DGMA83Te9iDx7AMzDo93lwDMYBhAI2A9uTgPvqpe2fOyX3t3QABsd49zseVDobu4vgGZb5AzrAO7pzoOOwD548e8A45xwCyYOm4wCGwDx8Psb7GuhrT7wAAp60Uti2Duzr4B9jnALJgMbALLcQ4QDsmDpzmA5uq4DuHYDvfR032vrdulKADm1ma0OjpSrc93l8AxrAIdgO4sB31568ODHM4G5MAsmDtrlgFkwD3r4Nq32D73uat4AAemQFGh53c9vmhulgGywCysdGOsBGwHbkw4ZywDGwCxYDvPmWl9mVuh9ADtg1TWjQ60XwDGwCasB3cuATLAMbALGBmQIg9jAw198tc5degABWSimlDyDHrICEEIJUNhgkD3huPYO24g94e8eB70gFClFKCiAehoAAEEGSU2021KqUo0wAEaYEITHvVSlVBoZAaBoBIgmKUqn6KBoAMm0hT/VST2h6VVU0aBkAGgEKUpsNqqVU9QAaMgAFKRA1JSkaAIaBg/1+5+/v8/0/2f7e+++++/9fU/2Cgik/3ZAE0KoqEQf/Qf9b//f+Tu/74y6g6wAHev+P+H5iAWMrIIf7+hIBTVR+1TdxEfv747JtAC2tuK4FLF99VeefT99ZL9uAkFio1wXMPctgkDHM187J9eurIYQIBMb25IYBVej3b0ZNy5kQixQ3tYCOvoz3u9Htn1OYpdEiSRsEDXP3m1biPX67I2zAATABVknohZ7JZpdep1nvXduNO+kEVuxJ9uPbtIx21h9XstW7AD7PdJLjLsKqvftgd1oDetP2tfN6ffH7WgFa6x8Hmmu/vc199VDANa0eaA+10w28zIjNp83Td1vQxjbb3m4iG3Mua7u95vu9j6O85j1+hueq/N3cxEyzLud9URHu9Vv3si+edOxtbM1k9GZHnFTkxrIG3UZl1lwOnVMAFIACDW+8PzHFAAtqIQIUoSRrI8AC0EBXiszJ3sh11wUYCQSACvxAALTLU6yLIgeszzjcuogohjYzQAUQ24hnUSbeyAChtc1RzXSOE+cKW2FNVFNuoI8LPKuhJ3AVRBYZJevrr2xc+PMOwZ4TqtrvW1IPchsdu9bmRg1svlGXMzKUGurq7jjrsg1u984uCIcW/elkzWlxV9L3uLzOpmUvK66CeKcEu9iqPbOTalobVJtG8b89BbBewXnrvEudonfWteb0ACeXnXBohIjBICW7kAFXrG7CIjUR1vMs43SNfMiPPPnuRHXnmqB1vGZmM71RGkjrdS93bdvcd2ZuautLlItzpI7oOtpHpB2qmAjKpIoRXsIIdPVjllEUVmHV1fscoKcJrAY/iDHLAgIgz+Hpeg6IyC7olawM/HT1EbqtxG4jrMKMpHjyRWP4V9n02PeAAA4NAbD4HwNhoDgyA6ABg5znOc+50ke59koZEZkRrIjVIzXNSm8e487wR47pHnUFqCCx5loaOcNEuxjiyRqallQO6N9W+2a1hR9jcFuq9SO7zDqUeJHdrw66hWtxHkRvzvtT6q+d+1Wu0jXusdPNJGzbCI1KlndZkzPojsreTEDbWmMSNG1TO1I230u7N8sbKLpiI80i2ab83n2aYdZWVXZDQjoRmdRHutVVjJ3lIdPiR1vplEZdojyIxmu+fSR55dkjCqy8ojz4o61qbmKyEdpNdT6AhL0zlGNTDPOGiWK4IbTbSJQIaCNRGUjyZ5rIjERiRmZrro0IyUZYszyhWj3zo+79w2zdI60K0kZUjcLzroyz3FxNmrwS5CLUQQmxiEtQIKmGRKSFsRjPbSR53StfY73vnv0pbrsimAmRaEIgIiYqjFEPF25qaJZEYixkRkRmSRzskaKN4xmavKR0ppZlOgQn5NEpIArQQrgVsGxunz5iv1L2EW62FPnWNtICE2PK26PMGwDyPMTGlLVjBsjbpqIIZFSSeJFlZAIMoQ6AdQSlAxs8/NKp8SIdQvMtpHmkiHZUNoFSJHRZ6yHUFzElREpT48NtqhwOBoLKUx3lLAaYS0QmDdy/FDI2DGbDxz6KqHUxFV6U2HsL73tWiubfn6JiSVbBw7ekEkohpuNEQKqhcPx+woywryzrPyr50IsCxEdCLddRGVXiIxVdRHyI6hA5SQpvrcwXBCtxEQ7fPWRcUIAWkjyVdojfWmmsJYF4I0I8EeiNiO4jXW+mMEYIxLz3V41EtAec0UbHWaaLxI3jRO9+RHS76RHekjvaMfVd0usazub7AAAA+jA32vvvvjiVd1LZyAAAAM6A9nd3d3d3d3opskJZmykKatAg8xJQc7zuLeVXWtiMaEa3yI11ngjYjVB2I6zpK2qXjXm4js310I3EdRGFGsZ7veCMiORHRX3V1bF3RfI2SMx7CC4tAgqBxHJAnCEqiCqPG3uQmc2RBbmECDz0OYd5t5NTOU9jGXhEzKmC4MdZDuYhyCTEIJ9WoSQSNttCQdfyp2na2DQoxCtKDSNADOqR0SNKcyjpFhVM6ZkISCE4mZP1gVCz1BT1dWWFksy1Ya1pMhjWC0iNxMEYxnFXdd5r7fOAAPgbDg0AAGQHTsYyAACVd0x3d3d3d3d3d3dlGAIGIQQAgcjYCHWC5MBI+v83gVF2ghiCFdvaRtvvczKR1ua14dQrRl0eQMFCjQCDEnYEovUphUCm0WtG5LFkRkg1EYIxVXm+VdXVYuquq0xnjvERgAADuDQAAAAAC7utdMjgAOVznOc4TMqrq85xV3d5xeeWLW81jeJG+65neNUGUmNagzKrMWZMxVWZDj5I4+8SOzrDzGGbTvU82Q7W0jMdJGbZEQZmTB1Bj1HXWVOZWJiWKq5VBpI1EYIyIx53EbWtVdVdYxr6quqr67k3nO+zvYyA6ABnICQAHc1d0aBAAABnQHOgAZuqq6rVXVVWLqYIzkRoDURrTWYZmaiNmu9Pdt0Rtqt1N46Jy2kZuk1VGqR1p3Us9iOoXdmFVbiMVZkpu8dbiPToRiRzWCNSU8oMhZnuu85jzKI+wo11OSWHrEjzZ66zqI3PHEkKyFBGwQSHTZTiJJUTUQQOIBhGLW1rbTWreb6ze9VJ0QZFLl9ayaTMRGXtSYrK3q3neS2xvOtc26wdpHXU50SPTL1xnURqI0qsiOSsyPMRce97WxXvER7prEGojyi1POIjip15hkohdl6eeyxNTCUqfv586UDy/AmrLEoe+GQayI15me3jebzXGrIjzoDeb4XnrKI6e/M6Et5ZsxIyIyzEjIjrOttFjcLAU0twlrXXWNUR09zp3SNXWLrdXdTXeScgAAAYjAEAAAAAAAAc5znOc5znOFHSR0zz1TPkj7CGdXljOvt8HIw0AAEq7pgHaxO41jsmvndfH2986AJxk+AAG6u66ZfAAD7mrlcq6q5VVWsVYWqliR7dJHilvmIjN4pVVq6q6rFZ11vvYjABGACMAHBoD4GwADGAAAAAOqvF1d4uqq6xvFfXWbqrqpiI7hXTduI262abhZe5vsGC26cqZxlMmhjiU0wQBYhSnaSSdI097SO6qzAGYF3hW5lS7273alWiHTG6U8ygO9qjxujuVMy6SMVGYNZrWkjTLqYyIx5VadJHTvmOspGeBJrtI0qjyKyVVqq15vs499pxle8Wmy4hpQNQxwyCRoQgYAg1EY7invUamNlVoK37vf3PufcACMAAAAAAAAZoB0xQBFd73ve97U+u6RrIjpzuPtlS3t5rhpFiiO+iR5iqySxIykZMxmBMRZhKwRjv7V2zH15mGpUvLIdYkayneTqbajpjqw1lMyNZaRHdRLrG7Z49iPeqqvPW/Lqrqvq+q7q7xd3dVy+Z271AASmAAANh8D4Gw0BwZAdMAEUAHfqrFVd1WKqrqs6SMQZ9czNZp2C+EeguwFLABQJFJJBD9Bcy73pofHAAsMBc5mZmY3UniX2/SDKxeJGBUkQULRkJ5IddYCoQiGIplHz+FOz9+hmm6wwBCo/ICWpKxSMqqrtUsZnerRjOojOiWuu3jK2kbqmt51EdzKi/SYJA0HZBMVYIIYAJPmLigj/CoY4L3i9XQVEY4pQI0iMEYzCRrBGqLEjKJ5IzRd4pYumGZYUG5uzMwu5/v7Ov6isSiTqaiIp66kpypgmToHHJeo6ZVu+sP7MIsj+6nJmMVzHrMKaMxgLMJ6M6FE8SEMHuTWdVVpU6iOuvdOnXe47wtJGaJHojsI6EazV74lHlXkBlzGWdxGdRGkjJkmj0BAhLUxAgkAROmR72529vPu7g6ZAcGgNh8D4Gw0BwZAdMAEUAHar7FXYJ3AAFyQMdw2i2XACCiXUAiWje9K1maoLNQjMqD3iJ3EdZzrWLtSMcyQ1EfOhU76VTiDZUPaI768S318kb0kdFVu5j72jRqI6tMsWTtmZmOqLd2lkoxkvAzMUVotDrLJYZlPlT3FTVE2d6Uc6+RGZEfdvJl6xPspHg7RHYjuI0kavojupVd1mVI3M+NNrZ1u+YkZRHdHeSphUs3PcSetalmUDURpB5kRqIzObwR1shnsHrVJYSORvJJuJ7u4po9x2GCPcyvJkRmnsl9OZkzrBHcRjo8xNmcSO8kj1Iy61VNZ0crGfxmHWYKwSeQgv8ghCIfVVV3KBBmXbLQCGxMaQIMKq+zd7t7/DuA/ez+973ve9waDXax998fcDYaA4MgOmACKADV1dXisU9escyq1pq1JGRUbJzRR3Eba7amYg8pHlaxgXQHvnUnxVdrtvEj5rZWZ3jXusFGMszbeZmO3erKhnNteZPNkjbRI4ka66imdNTTX1VkR7gjoRmdfeSWOojZplvvW963mWR3ELQIKECCig0kNK9d77t7efd3d3dnMgODQGw+B8DYaA4MgOmACKADVZq6q6rndYEYIyIyIyI5pdZvNZ3jBGQm96iMEd2ojakaJxAgaShTHDUgIQYXE13u3t593d3d2GQHBoDYfA+BsNAcGQHTABFc5znOcn0q6q6v68XjCpT57pctbNCRldyW5oUYsu8NojCtV33msZjKIxI3y30w2dUjRjKLvFFvURuekN8UVvKqj7fT26kvdVXhq6dVI1LZI0kagNWEll31lHtFmipe1I0fdhDyqzJlKMiPMU1KM3bm6bwyysZBMpbiMFrEWRHseVkVXjKluqLq1jWMlTMKlkLoRiZqqPMpNxGUEdXjw63wlzyeZ9U8UnhhU2kjtzX3vvPojAB0yA4NAbD4HwNhoDgyA6YAIoAc9OdhGpQ6EYkbqspSxl1011sR1tSebkOm+6rVqocmQjhEzMEZdd4yRl28d63mM0zKrXQjYjMSO1m5vDMmRGYIyaiMu4jVI1N41vGtsNRGOtZWVFXmm8eMmnVUZ06pLfm4ju7qurRtIyVuIxWCM8iMmZrHWHSXWUjS13Fak7C8TXlrGTbNZptaMh3lMx0Ks1UAh2koj/HYd42T0Gf3VZoa6pGRGdtyw0K7VNGRGBqI7zbKkZ10bhbZmb1eu9FGPUwsb8QW2NpPzh2qamxTNmxfriHEChzAemiKiWEUQ2yT0W6YyVFV6ZcQealVCj1wTAyAXRex5nsPOWN3AABhzd1EtUIFniAQnjgJobbIlAg3VNIhrQjMEZIszNpvHas1iV9r6OdiMAHTIDg0BsPgfA2GgODIDpgB28d3d3d3dl+Nv2MBB5AgoEKIUCRWdUWCu4WkWqR3010dtu2+uxjdQnlQ0gVU7p2AgsmX51UeqGeiJN7eZ0U3EeCPEW3Qjznr7emYUazozZGq15EepGb9YVXvRDB+r0yUQxtsqDJAQQgQOUCCc/AIf2WdB+T4KSoZiCXIwyBspYzMaiNTFVkRmCMQZ6nerMUaSl0ay1ZdMiNWT663s0zWKqyI3EZLBGRHQClAgiZTwSQSDECfU02y4UZLcRFNhZQdJ1gf39inWDjgrRXo2CjEjLy7Gx7ikdGw6sGYBFRUUytC9An9IgtUqr/GxNCMYutWu92WLWeb02+0tbiMEsEa0146pG3hI1WMpTe7VIw2TskZqI2prihkIKrY6XCPKJCBrFHS3LJqIbtQRlzVVdS89EuCCHUkgvSgdKquqq7wHCssZ3a06ZvURtF0kdpHbqI6iNIuaRa1m22a0SOqRdxG0RskdxHsR4I6SMySN6vrC+SMxIykvAzTvkjfuSBBQN2kIGgQMQg49Ge7N3t593cHTIDg0D7tb3vb5wbDQHBkB0wARQAc3Kuru8yiOt9egdc2l6I6SOtwXsRgjoRvwR3vq15naRmN9u8t701rWnWrWZuU8iMiPYrikYUGUiEq0ixFUINSCEgFCMozLGV0yIyfL76zCR7dx09fEjttq6xJZlewn3pqSy1vVmUjSL11iqZhdu4jv2IzH1I3EZEYkcUT5iJ5Vcqjhd/GZmKjrfvhR4nWDOvGIjprh1pwo3qI6iOT1v3nN96RgA6ZAcGgNh8D4Gw0BwZAdMAEUDnOc4ke3Uskj4PtRHfWrMWsmCtEj2I81HRlvWVDPJLeFQ8rXZmM8e/PPPGZmMTx21RqJNIAYkmxAxjXNCggvazvZ3bz7u4OmQHBoDYfA+BsNAcGQHTABFOc5znNMfYqtYutFHEjMUjldsns6MkaltVX3ZRt4IxmGSI8L26qGxCC2xjSBNtIFxlZe+3u3n3d3d3ZzIDg0BsPgfA2GgODIDpgAigA7uvu1jGauro2LdaOGIQVQ9MbVgAmhAqABcC9gA/f3U0QSIsT/KAQZUM4vmKqqqqzXc9jgjAB0yA4NAbD4HwNhoDgyA6YAIoAMVVXVYuquqxiqq733tZ5Vo8qj2MiRm/epF7EfXinkg66so9MQSpmCUaJocTWSFsLLIZLVrRrM5b3mGFTuhplDOt+YVFt0IEHVnnCAV+QAVW+92d28+7u7u7pkBwaA32t73vh02GgODIDpgAigAxXN1VXVYuqujEAop2AgsANAQSlB6pb3LCfXE1ypdXdXxXc/TvJEYAOmfAe972gNh8D4Gw0BwZAdMAEUAHa4pp8CMAHTIDg0BsPgfA2GgODIDpgAijnOc5thyVr744IwAdMgODQGw+B8DYaA4MgOmACKADah8CMAHTIDg0BsPgfA2GgODIDpgAigA1dVdViku7rebaE6RgA6ZAcGgNu1zdOVqTl1X2L+1z7XeunBkB0wARQAatWKqpWKxWEMhDIIiBigQQAoGxkHT3d7u7efAOmQHBoAANh8AAAAxOVGsvhAATFXdMgGgODpkAAGIwBAAS7umAAAMAEDnOcxvW8c1oOwAGau6wAhNRrIdIwARgA0BwABng0OgAa7XMVVVV8qqqrxdXd1JMZ59n6qqqvP13dPta73vQAAA5GGgAAlXdMAAARgAADABGau66ZDp340OAABrWtAAA0BwZAdMAEUAFb1xRrZ0jAB0yA4NAbD4HwNhoDgyA6YAIoAFACMAHTIDg14Hve974HwNhoDgyB2d73vekUAEis5ARgA6ZAcGgNh8D4Gw0BwZAdMAEUACgBGADpkBwaA2HwPgbDQHBkB0wARQAdq7rXKnNZ3jWqzn6la4+c6RgFfV9998ODQGw+B8DYaA4MgOmACKACWrABGADpkBwaA2HwPgbDQHBkB0wARQAKAEYAOmQHBoDYfA+BsZ5znPucZAdMAEUAE0rIOkYAOmQHBoDYfA+BsNAcGQHTABFABOdrd1VVfpABRWN7GFAgMgAFIAKTbri59sCMAHTIDg0BsPgfA2GgODIDpgAigO7mJGFwQG8ZhNlYXBXmTBHE8uIOFKV2UrNKUvf11X2MffBuD4HwNhoDgyA6YAIoAMxWAdIwAdMgODQGw+B8DYaA4MgOmACKABQAjAB0yA4NAbD4HwNhoDjve973vTABFABIrOQEYAOmQHBoDYfeD3ve97YaA4MgOmACKABQAjAB0yA4NAbD4HwNhoDgyA6YAIoAMZ5pKu6nOVrU1vXcfc5it9z2c+crHTVa1rnYdMgODQGw+B8DYaA4MgOmACKACZxpWQdiMAHTIDg0BsPgfA2GgODIDpgAigAUAIwAdMgODQGw+cxznOc2GgODIDpgAigAmlZB0jAB0yA4NAbD4HwNhoDgyA6YoAiwA5MV2qqqvO6xqVVVV4XrWtnSUwAAB2jIAAAAAAAA39998EZq7rDmOa5vmdg5IjAB0yA4NAbD4HwNhoDgyA6YAIoAJtWRsIwAdMgODQGw+B8DYaA4MgOmACKABQAjAB0yc5rnOa4DYfA+BsNAcGQHTABFABIrOQEYAOmQHBoDYfA+BsNAcGQHTABFAAoARgA6ZAcGgNh8D4G/D3ve5vH333venTABFAB2ruuWpp8CMAHTIDg0BsPgfA2GgODIDpgAigAUAIwAdMgODQGw+B8DYaA4MgOmACKABQ5zm+Y5wDpkBwaA2HwPgbDQHBkB0wARQATSsg6RgA6ZAcGgNh8D4Gw0BwZAdMAEUAHJj6qoFmaCAdsAFZ6um5Eh47MABWa3jGMYu6uqx2t9+3CIwAdMgODQGzm993sm4NAcGQHTABFABmrulAdIwAdMgODQGw+B8DYaA4MgOmACKABQAjAB0yA4NAbD4HwNhoDgyA6YHOb5XOcAKAEYAOmQHBoDYfA+BsNAcGQHTABFABIrOQEYAOmQHBoDYfA+BsNAcGQHTABFABFYAIwAdc3vc27pA2HwPgbDQHBkB0wARQAdq7rSmg6RgA6ZAcGgNh8D4Gw0Bzx73ve973TABFAAoARgA6ZAcGgNh8D4Gw0c1znM84DpgAigAUAIwAdMgODQGw+B8DYaA4MgOmACKACVpWQdIwAdMgODQGw+B8DYABoDgAAAN3OZq6u6k5M/Zn0Z5998m4Q12vsGR3oAGru6z3Cmh1AARgAjABGACMAGau6x3OT4IABNsjYAAAAAABkB0wARQAKAEYAOmQHBoDbHOc5z7gbDQHBkB0wARQAKAEYAOmQHBoDYfA+BsNAcGQHTABFABIrOQEYAOmQHBoDYfA+BsNAcGQHVb++++UIAoARgA6ZAcGgNh8D4Gw0BwZAdMAEUAEmMVd1is/ZrGKrOFY+CEYAOmQHBoDYfA+BsNAcGQHTABFAB2lMgIwAd73ve97waA2HwPgbDQHBkB3z3ve973vRQAKAEYAOmQHBoDYfA+BsNAcGQHTABFABNKyDpGADpkBwaA2HwPgbMb++18ZIHTABFABvvaq7qs1VVV7la+4r7X3CRGADpkBwaA2HwPgbDQHBkB0wARQAb1V3UutKycIRgA6ZAcGgNh8D4Gw0BwZAdMAEUAO1fZiSSQYAOmQHBoDYfA+BsNAcGQHTABFAAoARgA6ZAcGgNh8D4Gw0BwZAdMAEUAEis5ARgA6ZAcGhvX2Pvh8g2GgODIDpgAigAUAIwAdMgODQGw+B8DYaA4MgOmACKADHau6mO5zvqvvnNuxGADpkBwaA2HwPgbDQHBkB05GGgAAlaVnAOiuXiqqrpKzVdqqqrzrTW6pSrus57ojAAAFTkay+BsPgdq7oyAACfMh7uO0no7u7s7sr0ZrnNyYpKwAUwTsKK59SQhawAVgAqgtrGeYuahnr3puMfsOywAU1DuyZoEgvq9mPC6rzMcz6HOIAUPYABTGYbU+i1bfqzXmxexYALu8IBNAC2IgOyqxzhOWoZDABQwAVt8e2Jcd6/GM8y8nPXQAKq2iWqszis9Es9Ixy6HxCtgy4iomYGpIx0ACqpABNRb68bFjmgAVdU73R0Bk7XgAVgAqZANtuIVxlY7SwAF0eaG8qSW4gAFb6p5wcCQONrfXU3Ec+9MS496dABeHu49ebLABRtzTwwQgyWwvInOZtDjey+yBznZfssyN2MABZUKrr0REXE5G57MZGV4AFOxUVl+nvb6wAVe9Oey3Q9jfVRs3rgQkVBD9hfe9tXDHniBCCGnc3kvrK9m329vcWJHTX2h05NMvgidZaIwSsTT7QIldZaA7VVeTQInWWgMB0y3tnOnp7uzuzKBKJhxreXfdXVle2M6OKeO1d1nms8Vd1zH2N7x9p2dk4NBIzkAAHau6MgAA2HwJpkHSTH2azVdmK1rHGtb2SM471j6runcbvndTm+Y3iczE7IHg972/e9xsJGcgNh8D7t3dffZ2aJyRijGA0QcATTIOnPu5jGtHBPpWaxuqc+JiuqC3YkW1EtRLgmCJkgmLkIDg4n0iRDEiu2mJG1VETCSIJ2GJE5IYYYQWaUHixGnC4fqPd0ema8y82qaq7ruZ9qrus6+xWob6arVXhQOdAAmmQdJOy9xzm+bI7equ6NB0rW+mXzgjABIzkAAEqVK1VUq8fZzrOa+z9mruua1rY6ABGACaZB053FVRrQFZq7ruc1ij4IAAAEjOQAOc+q7pn6fd7iqzvN3dN5+7X30472ATTIO93s0IiJhJFzAz3ums7s3eitgSHXh9PN9SPgbAAJGcgAA7VVeeKfPhAAABNMg6dmZeeTT7mvnB3VXdGg6AAAEjOQAAJV3WGQHSqzVK1WAGpkHSTE3jWts6+Eju2d3d01jRx0AAAJGcgAASruvstB0AAAJpkHSb7U1mqZ1psM1d0A6AAAEjOQAAdq7oyAB3d7z6fZdvrLHT3bqtM3BIfpvxHJJIwev177c5waz1QgBR4nHyEqEIfGeFJ175kFsFjevduOwWr4FrzevOnKCWm+YAJ16MqWvAAsiqheqDvRZ91661l0C7Bc3sF6C0C0C7qTUFmJ9m4LsF2C0pOAuAu9+AsBaMzbNZqbzWd736qn33nV4C4C01mwWPM117sAUspZ0368qo1oSIrJ8RNe7t3u7u7u7iRnIAAO1d0ZAAAAE0yDpKk3V3Wc6zWWtaHTNXdAOgAABIzkAAHau6MgAAACaZB0Zri+uTkvO/XVU41ypNc3UOYiSZ5zMXEW2ENl0XOJsfoIhoshkOJTmHfOA7DZpyMb9JKmMyW66M8RLlqXEvCoBBUY6JqXDKgGmIGxB5kjCYOk61XitmXMBBGTHTIOZhjqIr0kFtTZK8ou4pxMxSKJSloW7sa6KY23heI8emyHAZPokoR6JKOVkZV2Hvb01XmS15Sq6kbJbAJYy7PekildihemGevyykQMXsFheVVBDMiD0u9oyclnbio70UQ7mHwRBSohWNzBcvJlpuaZAQz0zKrZZMNjUuvQPjDLjzZ5uohjIiCcZ7ChYUmxsi3EjioHHqht+ZMXNZ6ea4Ni35IxiFDIPQxN3KOo8yPenmsqAHkOZKohjaZnk5ho5ohsHjkjH6kyKmJexJ4agHVESSyIQ2ehd7XORhPbApIuRj94xkq/dESS5Mgu2YwuKlp6yaIJVRLTpwESpuKmp8xB3oS140xDZkuMKhnoTfk5N9UiBx0ZO3TD1QFsqepyEyx02urJm5mI9ETrXocePeGyZcHoG4GolR6fTE+94sCmGm2vZN0eeq4BsH6/bRE2mDbsmopRMUQwmIlp24HNTMREQRhRR65c3kLydClkswq6bcOjIiD1TV+sak8yC/P1ENHi3ETUxkKS25m2i9HBbc1Um2SVFQEJJtxA11CSobRUEnL01LggipIGnpkHRUoiQixsi8DzB2HbswDFV6SpKQFUUSOHcENxSCJY7g4k7oyb5xmT4bFrgsG7tWUZZGspnkYOM5GMy61t+2i2SWzDxg1l2vHomfOWeklYjCDfFYRKyZ9dni6UNTDRFsLa6csj1jeUX7c8jPExBIh+cZSY9DyhxMXmeGMjXD3yZJ07zqqlzrssq4dlVV21aZLTZWRFzNqgUDa81NsxxdXCUMUQ4GOAbbYyXGMtzkR5wVjmcmCW2RCMd1CgZEQsmHCRHmyJVv1hCbbgfpCIdumZM3Q2SyGe8ZLBlMvAqcZeNVOTMpySxsczcOW22xtttuH6Im5chDVHrnbOn2dMlwk2nvTkyRB1Kyugp0sZF4vFCKaXOkWk4MIsyomKaidZJ70z1+zd6BI7u7uDgwODjhpKp9W7u6mNMYxo3xAA7V3RkAAAATTIOlcvlY7i9xj77Z0zV3QDoAAeBIzl4AAdq7oyAAAAJpkd2d22gQehh6M6Om/e7uxEuu9NCQ7fLWcY3rJ2dAA4NAc5ycm86qd1NfTFb3vtZW1V3XNY5vO9bu7pPnXQAoAOcxVTPdTH1Vdcxd3V0x99zhHcmgQAGKu6AIzWw+OgAZ2Hx0ADdXdB8AAN97zGau6l3WcVVXfWfvuO9AAzgBAALu6AAAAAm2VUqlVuqVjAACV9Jzjm9kkc1uruhtt0AAAJGcgAAxntXdGQ7AAABNMg6d3vuuVj7u95wc19znTmru6Hw6AAAEjOQAAYz2rujIdgAAc5vvdW7u8TOL+q7p36zkl573W/tY3U39d3Rz510ABQAkZyAADGe1d0ZDsAAAE0yDp9mqqqvdbnaqqq/tZ1WL3nt1Tc2wo8BZ81q8BZ1t911zeu33gAU41QAL1yY8YbPSq4AFEs8qDGu+eKUzbmRLnYLVnObgvAXgL2Bbd+dAuutAt6bBbBaqjQLwFnX2skPQWXXT3xd9xuuZu+T776ckjmru6Hw6AAAEjOQAAYz2rujIdgAAAmmQdOVO4ZvXZj4q7rWu2znfZOyMZu7pVKpQdgAJGcgAA7V3RkAAAAd0aDpnXaziYrExjO91pvejkO6qqv7NGRzoAAAdoyAACu1jDFSZq7rONM6+B2MZAAB3RoOmququq5XcN4ffHUZq7qMA6BXe6zKu62+uuZ+3wADfbu6yabB0yAADujQdJf1S98rvPpii2yvcQRMOIHMHhw3Poi+96XM7fWR6s/XjNc+x3P2t94j7mvqu6lSsta267AAAB2jJ4AeDPbu6Mh0AAAO6NB0zdVdVKu7rFXS7iMSPtxGKtpGtZj7FLMRYBxRiyjHDCIlGEHEEPPDNdbYZthpmMniRoh3XlRciNRHlSxIyI9iO8y1e6My1hvMyms1skdNxH0RqI+ZVb7RHeHmNZrea4yS7RH0RKv9KviCEghnaqrH6HycyQTuI7SNlp9FYi63a82+zxEZm5DQjNCMZmqb63vpg4QpNiBSkhe2DEhJSb3X3u3t7pEh93cdAAADtGRWKkne1d1M5nYAAAB3RoOnKmK7zOL1zVTEMptjbGWnDAbYymXEyWHJIEK+BJFiBNICrIWjKu5lmVCp5UOqkVuUoTMkSO5AgtIFKQFbszue3ugu6AdAAADtGQAAdq7oyAAAAO6NB3unK2By8qhOqp05iotyyVDiNgdufZ11vbsjNXdAOgAAB2jIAAfcq7rWta+7Wau63n67utbmGd/OA7o0HTvI7p9W73nOvnBmrugHQAAA7RkAAHau6MgAAADujQdJ1dXV/MtsVh4hTU87IQhOBw89c12d3QJHdwdAAADtGQAAdq7oyAAApe85DhO1v77V1zr9c1TJfiVsQHigbUAAmewQCg12NLIofG74AF6IVgAnAAKY11N1Gs30C02q4C6Ba9zrfe3oLsdABMSFqAFdOmL0np25nj1buL3dXqjPud4jNXdQDoAAAdoyAAAAAAmrlVVtZDvd3d3d3d2jEAZcoEEtjkfOH4SNKbzvWvk6dwaAABd3WQHQAAAzsPjoAG6u6D4ANPu4St8xX2dyqq5re9akRnACAAT7NXdby+HOAAMgOgAZ+Bt0ADc52sazNVd03r7ewADpkBwaAADMYB0ACVd0wACgHTICdrHWM71WW9iAFUrbd3da8kjaSRcpIcJIuSXGZnuYkb3d3d29wAwAQAGfuZHzjoAHZX1XdYpjQdIwAZAdAPDvTWjwADtzFYrFVjGKr6Vd1rVUxnQ6AByXuVd1rbf3x1HcGgAAAAAF3ddMgOdMaq7re+bmfvs833qOgATWe1G86EAAnzIcAAaq7oDgzOMnx0ADXwN8AAfUkd3d193dSQgtDSQGNIA9GZ6vZ3bu3UAB1TIAAF3dAAAAA7s0bAAK+q7r3pTv7oWdxHPGuddVN67FmxZoK5lgJyC2KBM3PCRCRJQJxoNIiQTgEyATishIop1Ee72ZvUJGd0d193Ob1rmufeAua91JOwXanqR4AmACYALzyO9c6zIncteo8sogUiHrsz1VwC7Bb8BfYz1VvOPQL0F1tooxI7BbBaC9BcSNJb8aBZ7rryI0SOojSRlU7EfRHGu4DsIxIxFyIxIzzcRkl06SNVdVdVi6u77XNT7ck5AAdUyAABd3QAoAAAbwGwAD6rugbDfezX3e7xV3WHO6670ADqmQAALu6AAAdMgAAADuzRsOTGmnw453O8Vq7vF4zGau61vmMmwADpkBoDgADvDT7u7u7u7u7u68EJCYCDQEEAIIHDwR3EZEeRGoj0RqI+EYI8IdZnjx07zXbEWcKd73EDIASbyAQqGAJwIEHqEibuqv3QAMgOnBoAAOxjIAAJV3TAAAABznfUR8I1EfCNxHojwRsR1EexGJHojwRgjcR7COvRHgRyI0I9iwR4I6Ed+CO/RHQjsQeAQV7wCCMvyBBaBB5sdzu760ZPiRwMdTVzs1XiCwEEACDQBB4Kuq7ndSvvtud6gAAAAAAAFUrHN/Vd1nFVV47VVe9VVXjNAoAU742rn02hX6oiumMwm4SBBoc1I+pH0o0UZSMrFPO1fZ7JNe5BCFc0ITmecJIubre3N7s3nHd3AAJV3UZyAADABAAcr7s7XLurqtVd1zla05n52IADujQdAAAAAMZq7oB57HwNvQAE0yDpyr7HNIQSaKUhBiQgmO9N97u6BI7u7udAAADPTIdAADu7uuvYRgkZQkUrczzq/Xu555nJCCjeW/tiM4AQAC7ugA4NAAB3hp8AAJyruttOvvd3e7unu7u7fDMROmpCCUhBkDY8VdVdViqq6rNub13jp3BoAAHcVd1qz4OnwNgAHeGnwAATtXdc582470nzIcF3V1Wvte7mgBRQAKfAApUubABTN57OL7e33n33Xzq2CwFvoFmnoLPQXaTupiz1v0F4C0+8BaBdgAmAC8ISO3mtaKbnZq83e7u7u7udwaAAqlcqruvvpz7Wfs846mgOAAO7NGwADlfZmt1d1yrunzbc6ABkB0ADsYyAADtSrusYwzkAAAO7u7J7p7u7O4kbAQMBBmOkhBB3VoiM1d1sPjoAAAb6ZfAADtXdGQAAABB3d6YyYv2cB3DFEEihIQckIMEL2V7nIkZXp7du62su7vJzDbmBItVMbPhXX28xAAAAN6DZ0l3dXiutNAZq7oB0AAAO0ZAAB2rujIAAAAzQDp2TV3V1TX3wGau6yAkRgA4NAABkB0oAOmQAAdoyA5d1dVyvn1I8lHynDZo8PHXtTpTu86AqilmEYTxNkqOIwnNM7QUMRm7uZGgAB2jIAAAAADNVd1S7q6r67q6qVd1lkc6dMgOmQAAABwaAAAA8APMxgHTmfrq7quXdXVYq7q6rF3V1WqGvnEAAAEq7pgA6pkB8DYABnYfHQc5zkq7rvevgdzMXVXVSqlXV5u6uq1VXdVrdTF3V1T7u+8AAIrAAAC7ugBjOeZTP3cfN8cQ+BsAAz8DboAGOQk4mBISgIABMbHHRvR6Lz1YSXXvEjM7vfbay3wd6dgsNfAtOJGgWk7BdwXoLbwF6wrxKepHS4CxV2C2zWhddfF1VcYu8XVVf3O6+47IAAAAA+q7rXNajDbaHTIAAO7NGwAD6rugbDlaq7rA0OgAdUyANa1d3WgAANAcAAfUDYABy6nOFOJCBkpCCEhAxImuvr93d3d3d3GQHQAPowNgAEq7pgAADIDoAHyru7q+9z2r1fdH3O96ABmrugHQAMgOgAfcGmwADlWju6fe973vd3d3bgjkhBNDGwEDARUu6uq59x3Z2AA+wDgABd3QAAAAHdmjYAB9V3QNhfMXdXVSqu6rNMtAAB1TIAAF3dAAAMgOgAABn4G3TWKxM3Uq7qPtaOgAAA7uruvj76t5++ycQyA6dMgAA7w0+AAF6nV3V1Uq7rGn3zgAAANxg+AAEq7pgAADIDoAHfjQ4OUNAAAAGZVfVd1loO9AAADOw+OgASq5V3TJ9z3Oc5z3vPStXdXVMg6dwaAABvFXdBsAAABnYfHQAAAACb1iVWLq6qt1vAAsBKDLq/D72t+o0a4UAAoUydgu/dmAugWxdJTouY8xFgJMpgApI9PFRkXPT0md18+7u7u7OZAcGgAA3Kuvpf0b+1whm94r4OOdJVT6Vqs0z98OmbzjACRmpnOGgQlzGW6u6+lZ/lvP3OVjPu+93wAOuTOsM6bAO1r7H3xwRgAjABGACMAEYAODQAASuVd0yfAzKtgHQAO9NaAACXUlXdNa0AAGQHTtGMZAZyAkABuXzH1XdMnOEABkB0ADvDT4AHPtVd1zmufcCZZAiMAEYAKAAAOKNAABr7mt57ml3dNfOzplQHSgA1gDoADmR8EAB281d1GNAgAOmQHTIDABAASVd19jXG/jaAATmnbu6x8c2QDtY+++0cKADpkAAHKGgABzzcR6ayUt1UaLDy6iNctfJhIx2iO73R13NTkRq1WRGmlAz1Srow676WtXN7ZURrKzKI8vPSjR3lTMo3NqjvV2kZG4jqudNeY6tsazIbdVV2kdxGWYiOq10SO8BXfV7k6PKLXqL7lkvgHmKl2p5MyRdOuaaotZjTMzEjGiTrxI5o7iPWO+tojeEjWMiOumCMhJ1amG80vql2EzOrLn2546iOalWsAzO3ap7lnTzPvWmQ4mAUo5AgpeFXrbGxscmlgkE1nl8qP5BD+F7qgoJqRCOz2VB21oq1NvtTrHTxE3VYkYaPANvVmV0yIxSPRTv1ined6m50UAOmQFAAAHIw0AAGpV3TAcAAHd3d3d3ZJxqYkJMTDI4Y8EDQgOqRr7KI6tEtVI3kddDEQhAg8kAeEIKFJ3vbde3d7u7u7u7vQPggAK7mrujQIAAAO7NGwAYq7r6uczzm+DExV1a1EY6avdOd69xUZq8t2a03g3lAcKsAQiBXMBEPoLow6Mmw9e666pqzrDTWmEjpMSNRHcmVUsqrxKzoyIymLEvs8iMmXM1R4kakvHmYIyIzBGCMzpu9odyTutrvaxI1SLTjydUY7lXblhmtUR0y1EYZ1aOkkdBOs3RMKjy863yd7IjAB8DYUAHTIDpkB8DYcGgAA4o1znOc5vIjF9/pCKzEqEmZVBCgRpFCkUpFaFSlUUKBVpQSkBUaVUClFSkEWkRGgREpFUKVChQRDaSEgS/cF3fWjgyD6j0wgVOPx+VRRcEEMy5vHNjgX5+d3jfGN7FJ2xQDghOidnz168h0zWhtEMGMpjTY8ehNdSLv0ebqIhxAyMtdlVcHvSTG02xlT7aqjevrL682o5zuX2T42C0yUkhEhEjZBJ5QVpFTkSerKKrrgYk1JRnddet3cW+7tFvjpj0ZQ6uie2DqRnUg2aCnQpCkoIYIgOZGRTG2P0UyWxsYkREMhMjej7mIBd/KC2IBMYUwIcTCIv7rvf4QH9FKkzQ71h0mn7+2z7fHxIr6BQ/XRJHVlSxNNLF/dU+kZTWYqD/fYAD+kAeV94gh0Ii9TSBRQBS0EghSCE853+8/uf3wQ4szILFRkRhKOpQT+6FPIOlQCAqqmoJFRpQQ+ELMvoU++89+97kRhEKbdVdXVYzIa4zV3RLq7qrujO8g95nFqgfczOc5znOfPcoh/KD8qjlEw1m3kRsRtIzKTkpZpjNWtYIEKExRG96PZ3cIQfNIA+fo+0SPpi+yS2m0pfKlQADkK+JJMsxtJ/NJo+zhznOec5517sSAlaYI+kfyqQJmIiBp1u/t73d+5CIcBQ/enAUDoATokFf1fs/4/bu+7vb7+VAhw+svd+7+JdVdUmWQfsXVXVLq7ur4NCelVX1EZQOMWZjKzHrVU0iM91znfXnOc5VJwzGWMyicyCPEWI1YGiR+1DbMZUS661v9+fu/3799UlbcKlro1jEje+c5znn3PqCtUk20l2d/SXPTx1fJttwAs8GfzVq39+/fv379+7ZczWa0BKurquzEAdMiSG7m7v7d3dnZJPpJJ9JPvve99+970kvQ4AWHE2vB+PgMN3v27u+Z44HE2gsDnwAjAB0yB+933va973vNh8Gu7+fDnzru/zn3ve77nvMgnJ+ZCAYaqxJJPVu/t3d3ROOLMzMzDJQAe86ZA97vve173vebD4Mvgb6b+nZJc9ck5JJJPQOAABm3QwOgBJQBlGA6OmQP3u+97Xve95sPgfA2GgODIDr3s+973ve9PzFfv1a/fv379+/figBGADpkD3u+97Xve9797njQT6eGw0BwZCSem7v7d3d3dwkkmlFFGn4AADCpmZmZeZySSQPAfgJn2ZmfZhBtHQA6BP0zMzuZnMkkk9A4AEnq2KSSaQ1oEAAAnkqSSSHpOSSSB4CFATuZk+kkwL/AHTKOIqJJNbVVW/t3m7u/bRuog9V1k397n9/QZEH0HQAMvQ1k5mFiAOGZi6Z11t+juN3N5mwfT7e5mZ3KTN/e+N39vd1b2UU2V+/ca/JV7kqk2v1D+/KSfpUmfpQdf4OFBYdDhT4m1fJU3jZS6H4hu92t3d3u7upfAz8B+AN7tu7u/t3d38nnXvvQicMj9/IKYKpk2fv33ve77dzGru7/Xd3e7mIZwGWHGsMDU8l6qoL2xJmX+aLMz+JOiiKgIigKJEpSkCJoCqLLCOrKVYKamaWtMMGJK6MzJsMIWJGicgwKIikkhZplnDAYYMMM/sNMuTfJNye9Lq7u73bVvHu6fJlST82mnJJobujaSQABuh+AOgG90A6AHWUlJP0kk7NS+w6vlxNpLj4t/b3u7s3u12+IEp++7JJfdDd29zd0EVme97N8/VVVXJ8v03fbu7ibaGkzMKzMYwg5EZA1EYKqaTSqq5ISSYnKqpISSSVVLa4ATUB1AB3dDYmigABGa89zVSSSf1JpJ00q3m3vt37dxJtIr27+3Nvd3ZvqA3u7u6bu6UHE2gN2bszM73PUqqbodSYcYAB6TQ4BCtAJJJJqTVF/3ptZiVpxNulu/u+vd3f0kklyT9BZmdzMEk0j8I1SM0i1jWtc5nOaU5znwjgIcxRRy/2Zvu796H9eK3iD1+7lTd93JAAD8SSS5Fc4s/ZmZniHNW7u7u7uaL1bvK7W7e7u7oBwOJtWAFgEkmr8h+Tav9d0k09pXu7NDDQ3d3d3d42mkVSveHRJ4GA+q7oPj37V3V1X79rd3d2bJmaikq6kknzefu9W7u7JJJJJoBQcTaAJLkkkmgAAHEm0pJJJ6TQAAAAsOJtBwJJqQAdSDm7u7u7u7unVgfGZW7/Zmbv4Tdwd5m7gbu79tbW1tbWh+RSYB80Bu7vkt3d3d8ePwfAAEgABYdADofmk0ookmm0UNoBMGQRhEd1b2wkjetchAOxA0uSTsuSEbTafWm37jSaVUd4HTwYao/RR9f6oOrkpy5f4Cf9lmHeB5HWVWb6lIM++2JL7JQ+/z/P853KOc0VLmSXMJTmKI5znOZ12krQY4O3d0ZQHJMySSboPgfA2JJJJIykk73Dn3OZOqqruqkkk3t3dkQklr1hu91d3d3du60CDWgQSXdyRTpYqgADAG6pi6ug7Y3d3d3jzN2Td3Lqq2+9V6I51x1+26++d47jn1XTFfGxznOc5xUq6YoMpve/m1SrpiooTf33zapV0xUA5ve97SrqUzTQOb3ve1SrpioBze972lXTEA5y6q+c5ziXdMAOb5znOJV3dVVVvFF11oo+NzSqpzEVN4BfZzCj3FOe6VS+xQLmVR5kIHMqGsIjmIK5hCLeKqo5kiDmUTmVI5inMKKozV3V4Gw+wARyTMkkm6D4HwNjMkkn3JGWwk5dVfOc4Tl3bgSPtfZ9999zyp9PvtQ3kRL7KWtI3Y595JEbs7t60hAjHzQkktYF1V1UkkOmaurMqojGwBgDaSSEc+YhIRvHMlAofPu7uzPZmRmdqrpgBzvOc5xO1dYZaBze972lVbEA5ve97SqqUy0Dm973tLqmKqrmAO9vmOc5xurpiAc7znOccq6YgHN73vaVVsQDnOc5ziVdMAOc5znOJV2RvIEushFbxUr5rfS47So7wo5zQpTnvu0JznNpRzmqrpirqqumLYqrqrsG8AAAckzJJIAPmw5sSSAbyBuRJJNpF3V3YDkmZNXdVdVJIckkk7zrM73r6ZkmyqJGABgDdXdVVUQxuqq8gc5znOcSrpgBznO973rdXTFAOc5znOJV0wwB3nOc5xKumAHOc5znEu6YAc5znOcSqtgBznOc5xKumAHOc5znEq6YqqsBznPe97tEc+7u7u9mZmZnYCtiEGMQIIZRmTrEPuuuOqJOutVRzCTvjV1GWKqruzN2xTFXV1V2xQN4AAA5JmSSSgEmpJJuEkkkkZAlVO973vRLuqupJJIl1Jm6mLurS1rWbsIQu6O7oEju7wuaBBr8wQVUxV1V1U73qcnUqSSQAwBurqquiGN1kDnOc5ziVdMMAd5znOcSrpgBznOc5xKq2AHOc5zlVxKumAHOc5zlcSrrVMg65znObSr7iqmMM6DrnOc5tKumLqrkkhzve97xyrpiSSHPezM91Ac9e7u92e9719ogD2TKQB5iF7jzHrHuJHrM1757x5US8872oVbx01dGau6uqM1Rli6q6oDmtaAgAcyPknZJJCTUkk3Cakkm5GQJU6u7qST6YJV1dyTkmZhJJqoL7737nPOc5znHlIucFpI53U1zECDmIEHVu7spI9udWZkJIx4znr3mgDd1VVVVQMbyaDve85y7uuJV0wNJOc5tziVdfMgb3vc5xKq2AlTe97bSrpiSSHOc5zaVdSmbqrDk3ve20q6YkkTfOc445V0ZBxznOc2lVbEkkOc5zm0q6lMg65znObSru7qrzirQ0+0ZjpjM3rVI+a3LaicZSo6yRXOc29ypfZQo5lCTmSKDmFUuYhHMiuZKi5iVDmIOYJOc1zmlSznOcznOc58wgOKNJJJJISakkm4Ndq7oyODIHec53vevkuSSSJVTFXVXVTEk1Uh9JJJqVUhmmKuquq5V2DXEn3e5mdu93cc+7u7rQHMELmAhAtZvQFXkDnOc5ziVdMUA5znOc4lXTADnOc5ziVVsAOc5znOJV0wA5znOc4lXTADnOc5ziXdMAOc5znOJV0wA5znOc71mrpigHOc5znEq6YA73ve973akd0JCCejdqUCD3vUBJVV2ZuzLjV1V3WcGjd3V1QN4AAA4o0lSSSSA+BsAAyB3dVV7c5zUcYq7qYmJJOu5xV3UmZJBICSTve9SJmd73u+pAYGA5d1VUifVWcVkDnOc5ziVVsMAd5znOcSrpgBznOc5xKumKqrAc5znOcS7umAHO973veu1VMAOc5znOJVWwA5znOc4lXTADnOc5ziVdMUxd3QHec5znEqqtigHOc5znEq6+1rUxXM63vcpDabXECSAV926+8u6BCDmd3TrRdWxVXV1QN4AOmQHFGkqSAbD4GwADIG+45znOI1G7u7u9mvdkQAazd3uvd3d3MwaBB3nOTvHXe9+73r6AwATpkDnOc5ziXdMAOd73ve9dq6YoBznOc5xKumAHOc5znEu6YoBznOc5xKumAHOc5znEu6YAc5znOcSqtgBznOc5xKumAHOc5znEq6YAc5znOd6zdXN5JO2tbmZMhOZIkcw5zUlR7z7dCnMnOaCR5iJjIjnObEHWJVOZFJznOc7hnOc5zgAHFGmZJJOSA+BsNh9YMgdrlc5x3uYLqqpm7ugHToOYIQd0d3dXkkbsbu5mNISFnve3PdLiSckzJAbzgPqbq7q6ujEjdZCOc5znOJV0wA5znOc4l3TADnOc5ziVdMCSb3tznEupi65hjQN73Oc4lXTFCSb3tznEq6YsBznOc5xKumLEk3vbnOJV0xYkm97c5xLqmLAc5z3ve7RFvdhIEE7HNIQXdeKG2N3AhRO++9yjznOdLmXMITmc5oOZzLsI5jIAAOZUfJOySSA+BsAAyB3lc5znESru6k7Mbu73B0dPMQIOYCELu7tvd3d3QFhMbu7oakkkkKqrBq7ugOGA6cu6q7q9Yu7qqtI+vIHOc5znEq6YAc5znOcSqtgBznOc5xKumKAc5znOcSrpigHOc5znEq6YoBznOc5xKumKAc5znOcSrpigHOc5znEq6Yokk3tznOJV1xmgN7nOc4l3VXdV7lZq/zbRX9EazGM6QZmpDYjbWmmoR/CN67/mojv9v795z9yquJCvVVAIGXzQIIcIPSQUwcwgbCWQ2ympZTb64FQ024IDzltjPoWMLYUNLZISltvohrzVxHPxESyWlo/OSKFqHJHP4BDoBDCu9P48/gpC2B5lOXEQNodQKE9iENX6SWWCRU9FFH+OsQ/j7HPzhmYWYf66RIurCFlphmO63mhpFvCI0/mxGtiGZTP1y1a/zrdPtajnu23WL/PtG+s/z9v3n3Me/eMAjMoX7K1lC/Oj7tUeh4eZXWZl1dXWAIkQiEohCTKSZEYVmUlnXfnPP37nES4VC41kVHVC7s7rSQu5AhJoSBtCQyQxmuc5vnOc+iOKVjMQMSqscoKEq7q2MYCgVdXVSlVVVdZrdVeM6Doq7rNbyN7kfJd3dXVsHDnOcquMQylhRlIxZmZgjBGZhVZnOc5znOcSRwwpWMoWMZLDJlQYcpGta5znOc5xyBCRQ5gAD6Z33333VFKSqQNUjCWRGJSyCsJGIglYRZoaYlZkgZUZQGQGEEKQQgBKSrnPec++++D6BAmCAYNiASqqqqju3b3dEgwSQUgi+2SCFYCgYQohACtY+5znOc5wqWIKz7mc5znPSiPsUITCSIhECIEMiC1MTUlUjIqMoqQJSqoUkwIUSMSNSSMURAwECrCyIxVEzz77X3333OHKDEjIghEIEQqKEgEKmBAhFWVQyHMArMqhkiwqGvd85vnOc5UHIjLGTEjMVmMpZPkEIUXEFWQamihKVJWBikZ5vn2/vvvRH2ZKMyZJASMAEQ63e7r3tOEhAwSQxz3d3d7AAS0YhA0JjG0MATfd3d3dmjSaY02klygAAvH+5yKfopJkiaTzDNAO0NYByTupmSQcGg7V3SnNM973d3Vd7vXRvAaCOP8fe96ve97xsaSTptto4AAEWSpJJJJFJJJIjAHCPsgODQcq7o4+PgfA2GgODIDv3vex73ue97y5XLqpMySCgBGANmTIDg0G7u60cOPuh8DYaA4MgO+qqqr972a973ve91QAKAEYA+OmdgcGg+q7o4OfA+BsNAcGQHfXV1VKu69jHvA7Kk8AUAIwBo6ZcByTMkmqu6kyHwPg+kk1JIcGQHfO8972vvZ973IaAFJJJJ2YAydMnZJuSakOaq7o42fdOKb1JPpJNAcGQ7Mcz4wHp70UAe971e973veIwBg6CDkjQYq7rlO91d1cb3bs7sCRu7Px8xoBDew4hAk1SpJJOqdJVykC+r78HE2q/AApco5OJtSSeILn75emelXR3ibX6rtGaZMucz75CXWr1flVd+Ta33t8HsnfvvkdfE2gCEw4FNtC5JL8m1S5J99mT78m1VAelyv1ycTaneJYKfouwDibR7gAHQ4m0B714cq/uVXySSdOu+r4M4m13IEpWfjgcFOc5z4Q+JAvcDIoaVCmqXIBvHKCqKWIOjCwsysg8DDA6kxKGgiloKE8ujMFDIOoUKEyBoBKaTIEswwgx/T11hmGFQURWYUYmGYlQYRkZCZOSrSdHWPUGRTEA4RmYJE5Ce9YFJSHVE/zLkFUdZEuSVJGSYRmOCREVSBkZIOFmfX3eJte9IB4QcTaAJjtcrP1Kc/VX6k2qTa97xhJJ8AHk2gPwAlJJJcnE2pQDALDibQc7YqKUr76TibUk/YvomknxJJOjgfg4m14D5RZWZxNrMz9mOL6OV19ET8fXBQkXU/fV9fTlM2XswJHp3fZttGtJtHs9WxxjEj3n19wkklAhBzIjQqMSMKl9+1Uumda/a7/YKc5z9z1VX6j2WrMDBTFAz+z7Pf33G2pOyJqZXCu/jmWcTa71NoPHen9Nvvee3eJtG87ui/BzocTaAV/V4SX80ru3z99u78m1Xt3e5LPwAfufZmZ9eez0k/VJJ9PTo7Vu5mZuvuO60ULu8JHXz7Hc5k5l+y+7u9x1dXd1870iAXgXgXgWGe93fMETvWsBfoj1IyoZEYVX7VVXVZq7u/pqb95z2jYZ7tg7xuqvr6t9d+ec70I4iMEYsYoua5zXOc5zgI4IxEZlSM95zmd993TO+29ySHybWAT7hYAAeA78m1SzM/ZmVmAIsOnxQfi+IAQWHQk+nJPuVUkuWH34qHE2gD9G05cST+973ve99FKTaknQAgWHenybXUvybXsV/svv33Pl9mfk2s8+T506GgN8H1A5vHpdVV+9n72Oe+97x3jMkkkAAAA2H1AGKu6CyjMA6NAcBsPgnuY+xq6q/Yx73s8z32ffe0wznUaDoOGnz9j3venvY97pkRkBXcYZULu64J8wC6Vi7q7q6x8Q2KHBW+ducqfVVkCcCYyVGZrr3nXOvvvtVftxOS/4gHYyf7zDkPP7ABT9FmH+Yf9mdSPI/tiaKcEBDFVDvKirKmKjrCimv7QR/ZQB55y6RQ/1/pQeuCuCn0KoHJBDnMRRDkqIjyAUXkqonOfdLGACwFDijQGw+D3t+8B0CSSSSSckkkQk22s97vku/e4/vvELTTaIk0mzAABtpIEjp98mUkk20U2Uj3E0UU0spNtIAAzGmml6kmk0veaT96/Av2dbaJJ9JGkk5IAH785znOc52qUc5qRHP0Kv8qspGJGQmMKUxEf2pVqIxMSMyoykp1lIzRUtRJgVGEQ2QQ3nOc/vyohsqq994IId970IhyEuYJZilKUpSlKUJSlCoAckBFNgVE/oakmRGVVU6xQzEomsyIylSqyIxRWMSHWIv79+/fuuwkf2RVLzCieZIS8yj3uCKifSpyFswTIGgLMAoUzMaEzMEyBoShAVX2oQAbJH9ooNVWVkqYgsojCKyIwsiMOsk1EZUtacRESQQ3d3d7/eCK8kEOpBDzzz33exQ8QQiAQhEKKFOQlmKZCUpSlA0JQmQpkJZghTFSZH9kqjeKVmJJtIQohIIR3vOc5+/diibCKnkqh5CiB55vSgJyEpSgaEoShOZgmSpkpZgGWQIKEghuYoIQCp1AiFCobu7u7334gvkIF7kkPcpS99/tiT9SLEGAApgOSlKUDQlKZCmQlmk1hZiZkqi/slDZUsKQsiMUsZAqwqsCsKDFQZUsYiN6KqZlKRf2Io7pu7vnfj5KiHnmAiHnm9Koo8hTkJmYJQNCUJQmZglmCWYJQonsghs/39mIAQpkohu9m7u/vO+++/7vcAQ+hOWSlCZCmSpYYuQNCUJmYgGK5gnvP6elAE2VEPxCIPW9m7u8889D2BAPfcQQ993n8pQNCUDQlKUDQlCZ+1Kr9lzTUIbiMKTIjAoOyIi5IKA/rBVZgRqISMpLIjKoxlUayEmkglQWQQgEU/rezd3fDvwAPJUQ88xRR883oURPuYJSlCUJmYJmYJhmA0DSlmKKHsihwIRUP7IF1EYAdsUXX94/v7+/vHnsp6ZSoe4999/ukT9EZQIhEJBCQQeQlA0JmYpSlKUpSlKUL7AghiiJ9P0MXeOv2kQaO+9HRgk6UV/YijeSi7ype4Cef2qpL+yqR/Yq/siPwF7qJJ+xUTWUofsKl+xShbxVQ/ZKJ+ybTbRSbbRTTbTRUqKSSSDSSYAABIvSckkklyT9JIJtBYB8BJJJJJJ+kkg2m1lpJ2l+d07s9geSST9yNtU00mcPgkiaSYLG2vxXqKX1LrTbTOI/K6RSKXTiDgARNpqek40mlMWYZbzMMzMzMz9lSSCaZaD8BaDjTar9n79MCh/JJgsZD9gIMQQhQCpAqZBCWQQhFf6MSBUFJRCQUoggqQQkBU/t03d3s78UBfAgRPQgEIhKZSUVKpUH33AFR993pUQDsRCUFDkpSlKUpSlKUpSlKUiKeyAqGKXSCEKx/YCaiMFVVkRkSsqsJKzEgrIjFFVkRkFTd7N3d87kQeyFBe7uQQ7juPdxVFyRShV8hRiDJVADkqJaMVkRlIZEZCsiM/sgmsrLDGMpGEmTFKmEhKbKIb2bu776qeeii9MoITVEiMxQiFIVMlRRRTIeSCHkgh55vQqhyUpSlKUpSlKUpSlKEUA5KIUUIC718dAoUKAG72bu733561FHnmAIh55vP5SlKUpSlKUoUoHzK/ZERqIxkRlWJGEUxEZMiMyqsYkZlEYSMiMplSwKYkZVKyqxX9lCQ1EZFHWJKtRWICJsCJvZu7vnfgoCdwncKKPfe9D8ghEAhUKKBwgApSlKUpSlKUpRAHJREZBCIkYqg/sqKtRGUAzEjIjMSMpUMqsRW8VGoBCjEEghJSxUrAiEoUMiMmGZEZKGSWSlWQWVFYRCIRChUTmIDzTd/bvfiip6yABBE0TLMRJUqL5KonkqIvfe9HaowhyUpSlKUpSlKUpSlKUAEDZII2qrMwliLEgYSN5qylLAFkRmURkjIRiRmIqYoZKqyIzMpTIQgVCQQlQTkghzNN3d88hBJ3iVDvEqXff9yI6RVmZEEKChyUpSlKEpyTJSlKUpSlBUHYAUHpBCoIRCQRDqBQxBCVFAN5pu7vvf79+/b8Ci8lKUpSlKUpSlKUpSlBOXLIFRdkFHVQRhVAkEIYVAoP0YQRBEUsH9G9m7u99+5ARJVFCUBUB3HfffR+SNgUDBBkEIQQjkpSlKUpSlKUpSlKUZCAJtioZKsiMEMiM/YqNEsEQmCpBCQFD+xVx3fxu7v7wB/fsVT9+3oBU5KUpSlKUpSlKUpSlA379iI/vxiUH77eed+++G+hnvwKiHW4ghyd+3pVAObg/QIq6xUnMnMBOYuYSpzKR5jkD5JlNppUAASAAAAvSckkgHgPwAJppBYB8BJJJJJJ+kkg2hG6ZgQJFLGsz7vrMSXd3d3d9pu8IEk5Tack/NQbST4imAAR40mlKTTSxZ70wknZCSRptpySSAAkkmcKOc65cuxVDmcnihyFFNQQu5KU3dN3d/eKofv2Ij+/b9/KUpSlKUpSlKUpSlKCewiFbCgHUIANACnJ2ETezd3ezuUFf0io/pBQ/SA/rZVeSlKUpSlP0GSlKUpSlKqDgghAobIBiIHRvNN3d7988+99993nalKUpSlKUpSlKUpSO4cN/t03d3zvvvvvvefKUpSlKUpSlKUpSlPIZBC3o3dN3d+88zy888837tSlKUpSlKUpSlKUpTmG7/YghvOc55+3vvvvecUpSlKUpSlKUpSlKU5AISoE+mZv8b/fvwpu7u+99x55555vPFKUpSlKDjLkrkGSlKUpSCO4bvOc5++73zzzzftUpSlKUpShL7BMhMgyUoT0Tejd3d39+977773n24gGZgmSlA0JQlmIBmYJkpTkBvRu85zn79vfffe8+hKEtwEMzBMlKUpSgaEoSEAA2V99wAUP7+/v7o6/t3fPN3ec5ykUk2kUHE2kkgJ9FJJJJJJJJBJJMFgcAASSTDwH4Ak7JJ9JBJtoAAAgfABMak9n3FmYB6SSSSRpJMkgkU0B+DhXm2gPwGZ6kk00vc5z3eOu973vUgMbD4T3vV7wb37nOd893QAzMEyBoShLMADMwTJSzBMlNw3f34U3d3fffPPPPN52DQlCXuPG6hLMEyUpSlKB5G9H7nOc9/fb555z3edKUpSlKUpSlKUpSlKeb0c++++397333358pSlKUpSlKUpS7ZKUDtvRz7777f299999nnylKUpSlKUpSlKUpSke+nvvvvvffffffnqlKUpSlKUpSlKNpDaR0G/lCRu7v159CxmPHjA/D6EikK5AZKUpSlKUpSlI33vvvvPO/ee++++/fKUpSlKUpSlKUpSlKWlz777777vvvvvvvz5SlKUpSlKErkBkpQpRe+++++/d9999978KfSlKUpSlKUpSlKffb/df2edv2fnWdtee9+e+eQR3lSqHmSl5iLzBSHuJH7AH2fsv2SS5hVFzmoBzKkcySnMSocy6qrqmKurozdVdVVsVV1dYAAAwrplsaODQeqqqr97nve9973gJJJP0kkwSTTky/n7ngmNpt4kcaTSzMzO4SfJykm25JIJNJHj8AHk0CS+BfuvP2KaRH7CI/dU31znOBJyZDmZmZnzbVkgWAAB1NNJoptIPmkJIPvoW7O7u9me9mZ3UkNpDaQ2pSlKUpSlKUJzPvt/CnOZzmbe++efx5e+4bcn+ZHJBoBrIDJSlP+rMUpSlKU6SP91/j/f7/f7/f7vnnnnnnn++1SlKUpSlKUpSlKUpTcPvvvvvt77777757xSlKUpSlKUoDcxSlKR3DnOc5ze+++++994pSlKUpSlKUpSlKUpzDnOc5znff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ArpkBwaA2NSST6SAakkk3U9WbqrZrPe6q7rvzHvtMxnKQBxHwCcDb++7qz4++knkkfeq2Uw+aTSaKRnAzPuo5PzQdDq8k205TTTS7UqvpWZL+h+KUffNtH4F9JjSTn3JJJckikkknm23BH5AAF3d96YUtqq5VVBTmYNHE3o3d3vd5wU9999999336eZmGYKZllVRF2G9G7u97vffPPPPPN+fLagBesXd3d3VVW932GAADBicUkgF2ld2k7qwUVOqqqqqqjiAIHKrGKqqnYAABNY973pJcxnOO9xjve97c8AABesSSSSqxir5znL9YAAGL1i77c1JVYqt7nYAABjmE+ibk3JVYqt7nYAAAAQaQQswQXO8ye4sMb77HoOo6rX3Mvcq6qqquZ1Prq6quz3vTjABAAKA971eex73veHTIDhmSSZ3Mk+kkn0kmZWK02ru5hlaABwAk0r2B+PAZ9D820FBme9XrsXvT2SKSTkkkk9JJ+bakkksBAAF973vTCqqqqqqqq+I0qJ3+N/bu7vxz3MUfLyE5zlzYAAHfYv9i7u7v97f79fbAAMB3E+tdypPdqt7nuAAAZmup70k5vf79OwAACa6nvSTnuYxjPOVU9wAADkv9H6S7vk8xnOGO666/c1y9QAABvGTBhf0SS7vm5VVV9uCa0BgAvXz9cknN73vc7AAAPMJ9H0kk5VVVVOwAADfv2M/sP2PuTf0m+yT3vPe9728eK0o0BwoApGADpkBwzJA4cfA+Dc+k+1znveHhJJPakkm5Ikk7367uuYY52ruupE5KkkkkkkkkkklSCAoCB7ve96YVVVVVVVVVUhzM+znOc75HJfYNhX2YU9z3+wPc96fY2Tn7IzAoKCiTHc23d3d877+8888340pUjzBSwyiNtt23d3zv7vvvvft8VMyyicxxzAHeuW7u7vn79+/ft342ibIUzLCOYIlIm9bf27u75+/fv37fd0UzLCcqIs3OW7u7vn3JU8vLzzPLnX4AAMZxd/W1d3d83Kqqv14AAAvUXcknN73vc7AAAPYYn0fpJJze973OzBgABh7e++7yqq6rldprf3JO330kmx4YAIoAFAMKRgIOzEkkk4Zkkk3IfA+CdmJ27uu96CpyTMkkTMkknJ27umJJLupOvqq+97rvUhXT7WAb973ve973ve96YkiST1b3vcqdgAAH5Pokkld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01JLuvTGc45zlX6gAAOYZv65qSXc5VVu+2AAB6/rmpJyd73nOVPQAADPte9r3vSVve97nIAABJ8mpJJW973ucgAAE1JqSSVcxnOOc5zl+4AABMev99eru7v3KrFVV9sAAD7V5++v5JPV7npMyeHvT3se973vOypJIM3d0KAEYAOmQHBoDcnfTkrytYu2uZ+wOknkk/uZUqBvN3fybXsEkwO9knz+W5mZiTzOVmTQCSKvm2s9333r+owk7mZnyWeysOqSak0kdD78GhmXd3ZkqqAAE1JqSSc5VVVTsAMGGGMTUmpJJzlVVVJ4AAE1JqSSc5VVVTsAAAmpNSSTnLmM5x3ve9ucAAAvV3qSSX3vOc5y/WAABepNe971VKqqnYAABjifSakkqvVVVOxemNaxgxgxgxgwza71JJVXVVV9thhgsAvV3q7u75yqqqvsAAAtr73PafpjP29Zusa/fUznOL/fv0391IDpgB2VJJJAoARgA6ZAcGgNyd55p89NfTqN88D5J76TUkk2i7usXd0PwdZzV3TDT34CSePe8J3qSSbgye97vaqqqdgAA9rSMa+mpJJzl+xnOO973tzgAAHb+u9Xd3fOVVVV9sAACak1JJOcqqqp2AAAZmpNSSTnKqqqdgAAE1Hve96pVVVTsAAA7NY+iSSV6/YznHe9725wAAC9W973vTl85znL9YAAF6k1JJOcqqqp2AAAZmpNSSTnKqqqdgAAHda07J++lYEk5JJJyTEngRQAKAEYAOmQHBoDcnfVJ9uezrwM14Dpn2gOJ6ST0kng9J3ve96MkLKTaA/EzMz3vGEnJAPeu7uzCqoAARjUmpJJzl+xnOO973t/pwAAC9XepUk5fec5zl+sAAC9XNSSTnKqqnYAABjyfSakk9zlVVTsAAAmve173vTnKqq54AAwSax972ve96c5fsZzjve97vwAAHva73ve857nOc53wAAE1Jr3ve9zlVVVfYAMWNGZPpJJzlVVVJwOQZljBGRGYKZllURzM/u/vxz6977933t73u930wUnwcACSs98ZmfGRSSQCgBGADpkBwaA3Ikkl3db72MKPJJJyT2vAHpUk9mZhth+DbAAkmySSSQAC22iT9JmSQD3ru7swVKqpU1tc2kfgA3xE2s73vbnAAAJf1pJJ3lXznOX6wAAL1E973u33nOc5PeAAAzNSakknOVV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P1gHgPxJOJtSZmZeSR+97wEk8AAH73vez73ve73m97nYAABia97XpJOevPmsZzjrjP3OXNgAAbv6TUu7vnPc5jGM85y/WAABervUkk+5yqqp2AAAZmve16STnK3vc7AAAPYn0mpuSc5W97nYAABiMa97XpJO37WNM+aYznHXHOXPwAAGeYv6TUu7vnPc5nOcc5y/WAABervUkk5+5VVU7AAAMzU9r0knOVve52AFVVV97zoBDUEI+gEN/v1511vvm7smoPwSebac1AVJJnj2LMvZP0kkU5AOxjYDhmSBwaA2JJOcuZmZkAALAAAJJJJJmZmZmZMz3ve94JAACSSSSQ6AcOge9fe9MKqqoABNe9r0kl97qYznHXOcubAAAvUmvXJOcvnM5zjnOX6wGO6xrTQW27m7u75533333vpuimZYRllERubuXd3fOVve77m1gATF/Xer3d3zlb3u+wAACa97XpJ3jl6xnOOVV/rmgAwYPl/Sa9clVdVnOcVUv1gAAVf13qbkqt/v0nYAABma97XpJOb/fv05AAAO+1+rfvevOMZxhrH79nnP29uenfwGgBmd73rkmIAgAFBJJ0yNh0yA4T8J3viRV3VU8AklABJPu97r0kyZmLMzMySSW21JP0AAKACwDh0K/ffScgAAE12a9JK7m61jOcbZ27ermgAAL1K165Jzl85nOcc5y/WAABervUkk5yqqqnYAABjmE+k1JJX3303XgAAO5x7730+qSc5ze9zsAAA90zifp9PtyT3e47f7Gc45zn1zQAAHc4v6fT65JzmL7VVfrAAAu/ruffpJyv379OQAADM12e+kk5zPN73OwAAzMzjf7m3M5vrvs15En8kZIT7JKP7CbZJPe9EPNaKsU5zaLZQQNkENkEO5Q+IaEiZCEFTYEU2HqCaYLcQEDf2CCLsACbCIbIK77gCqSo7s/fv2f3vSTkmJ+AihJJJKkJJOzEkB0yA4STclVVyRx+97NV+xjF/v379+/fv0r9+9727D6g8JJJ9VV4PCSTMiTSQAFooAAMDjSaYcbbbKZJJ9JJznN73OwAACa9730knu8v7Gc45z3e3OAAAbv6/r+kk5fKqqvtgAAXqXPpJOVve9zkAAAzNek+kk5zHKqqnYAvTGtYYx69X9f13d85yqxiqvtjDC8MaaD1/X9f13d+7yfYznHOY5y/UAABvF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e+81dVVW57mvd9ienlckmpJIAIx3ve97jqYBCrqqqphlJJJckA4NGKkkknYHwNk9d1VXsPh7wAfSSfSSABp2Xd1i7uu4q7r7skhOAyA6ABgAncJ66qquZzV1dU+r3d/c973gAJJJJIHd3dyBB2xHTz1CQakIISRPVUd0pF1XTJKfdDYd+73uu96AA9dVVX3F3VVdV73gd714GrurqgODVX2t53vZ0A2Hwdrve973oCTEkzMyZKTTS/NppSSSK5k773hNNpL4RfPue97wAAAAGrurqgOAABJJJJAAAAB2e9nXve97ffey+kkkkgBGLu6BNyTUkgdM3d0Mgqckkz2rxUzBz3nIfMJGJGYyIzCTmuuc0pznN/UV6IyqsyJWCMrMpJA2MGjY3d3d7szMz7730z/dNbtJAt387d3z3d3ds9u7v27u79JJOySfpJJLki5IOk0wARQAKAEknJM9VUng8APe973gJO973jtV1JPx9zm/1AIboDu7u7vDlAIbvFTbd3d2dnm2pOfTQAO973vQxynVVVVVVVJiSSblVVVuTsAAAyziJJJKqqqqk7AAAJqSSTe973uTsBa5gUQbbu7v7YB7u7u77++FPd3z9+FxrTWGGGNMMNYvV3d3u6qqr1XfvywAAvV3q7u+85VVV37wAAE1JqSSq3ve5OwAADM1JJJ+23ve5O4gAAE1JJJve973ORABVVVVVVf7vDb3d+Sd7mnioVwk7JJ9JJPgbDQHCNZA6YAIoEnJOJtSKTSwAkzCLkmfNtdSvMP04rkBL820AEssDjbX6QA9O5hI/yTieqqub73vfRV3XXva973veAB1loPe931b3vd3jOccu5+AAAvV3d3N7uqqrv1gAAMXrV3JJve973J3wAAE1JJJve973J2AAAZmpJJN73ve5OwAACakkk3ve97k7AAAJqSSblVVV3Fs4xnl3PwAAG7+u7u93VVVbu+2AABNSSTcqqqtydgf160ABm9Xd3e973vd3fYAAB+5+5r9nGcZxjf328Ls+v+Z7Zu/AEnZJPpJJ9JALAPwEjgyA6YGw+igAUAJ+MNjXqdkkzPKoOgkkkmYne76NppePGZmGYKQAAAJUkkmttJbV3Lu7u73ve97973bAAAmpJJve973fcZzi13PgAAL1d3d7lVfOcq79YAAF6u5JuVVVW5OwAADM1JJNyqqq3JPMAAE1JJNyqqq3J2AAATUkk3Kqqq/YznHLufgAAL1d3d7lVfOcq79YAAF6u5JuVVVW5OwAADM1JJNyqqq3J2AxY1kxgwrdYxrV/qxVU93dgbkaS3d3d89vd0+AJ9JJPuyT0+4+HBkB0wARQAKAEnrBJO9lXJCq973vA8Aenve9ZYjMz5PCQ6m00ik0wAACSSGw+A25znObJ+/YzjGcZzms5zeM4zn9n9+u73dVVV32M5xy7n5saaaaaGr1d3d7vvOc5yrv1iNDTQ01eru7vd1VVW7vtraaGmmmmtYv67u73dVVVu77F61ljWmtY0zJUzNzd3d/b33333+3d+ImjbKrc3d3d3VVVe9jOccu5+AAAvV3d3uXznOcq79YAAF6kkm5VVVbk7AAAMzUkk3KqqrcnYAABeLq6vOuT093OJN75J+5znP3Oe/NAbD4AAaA4RrIHTABFAAoASSSTve973vZKoAJJmZmKUm1nve95JO9RFD4CwD4JJJJAAAG3Oc5zZPYxjGMYxjGMYxjGMe1JJNyqqqv2M5xy7n4AADd/Xd3e7qqqt3fbAAAmpJJuVVVW5OwAADM1JJNyqqq3J2AAATUkk3KqqrcnYAABNSSTcqqqr9jOccu5+AAA3f13d3u6qqrd32wADBNSSTcqqqtyTzIAGZqSSblVVVuTsAAA17mcam/ve573gDYa+BwEkD3ve773s+94OmACKABQAk8AJAK973vAkkkkTve97zqATINppAAAESTkkn6SSS5JJOy1d3W/e7AAAJqSSblVVVfsZzji7nwAAGL1d3d7lVVVdXfrAAAvV3+u7qc5VVuTvgAAJqSSblVVXyrv1gAAXq7u5uVVVXak9+AAAmpP0kqc5VVuTvgAAJqT9JKnOVVbk74AACakkm5Vb3+k5AAAMeT6Tcm5Vb3+5zzlVVVVVWvZh7AIeftjn7e/VB6Bv7N9ylu/tDoB9JJJJJ9MzJ2SRS4ZH73venvY97wJpQOAp0zd3QJMSVMSSbu7rs8ZrZT2ru6CpvcnsttfszMy8me973BtNLx4y8wyKU2mkHg6m0fABaKKKTkkkkkkknZd3d9kwCgoKCioNxU9Tf7d/t/ufv379v3wp5ubc/WUTmKmZYR3ubu7/b+/f3n37d9/qNyaaaaaaadznP7d/c6O+8VP2/t334KB3MUgyyq3N3+3d73zz9+/t8336qqgAmpuJNyq3v9JyAAAZmvekm5Vb3+k5AAAPYn0n6Tcqt7/ScgAAE170k3Krf0lQAAC/X+ku63dVWc5xX675YAAGC58dm8/L9998kmkLMvnbze/XM3SwALPAfgAkkkzMySAFhCvwTkkuSc9OyR90wAQAd793vdd7xJPw+enm5JPADQk3PXdXVTF3V1U76STySSZmZhJJJJNZG2igADstK7u0umptXc+AAAxeru8Xe71WMVdbu+2AAGHr1JcrcrFb7+k+xwAAcx7E/fXNy6vf7V3uwAAJi/tdu5dXX79n67qwAAL1q/SSpv9++krwAAG59Ll3yr3+1d7sAAD9i/r7dy63+/Xe7AAA9Ptd7311ve94xjO5OQAADbE+kk5K1WKqqk7AAANY89nE3qSTqe9ckklXfbu9fv379+AB8DYaA4MgOmDplOypJJDve973vU730knp4kk8ABJJ3vqq7qpjN3dT31XdNsVdXVHtNppHij5tNIAOtppFbVJJpbu7u7u373u+e973ve9W973v3uWAAB7E+59JP0re9/pKgAAF39cku6qqqqu+2AABNVJJ+lVVVu/YznF374AADN6kku61VVfOXfrAAAvU+k9c5yqqqk74AACaqST9KqqrcnIAABma973pKqqrcnIAAB7E+kkqVVVW5OQGbaAvUkl3VVVb97Gc4u/fAAAY3jX73d49TSaXC+9+97bEve9sk0DVu7vy3c3d/AD1XV+973ve97z4Gw0BwZAdMATsqSSQ73vZJIrdJJJO9SSSAAZu7oBVVfXrurqjI1d1dUSGAuEZQB82mkAUABNIAAFnuc5UnbAAAvXve9cqqqtycgAAGZr3vekrFVVVUnYAABNSSSVVVVVJ2AAATUkklVVVVX7Gc4u58AABjGb1d3d3VVV85y79YAGDF6v67knOVVVUnfZAAJqSSSqqqqpOwAADM1JJJVVVVUnYAABNSSSVVVVVJ2KqqqqqOckUboBDLz8f3yCH51k++s57WnrgwdQ173j2fHuLRsTVa5667DvfNCQfdnX8eqoufQVuv0vjsaO+xDxrTNZOlK707oMCe86/d85+/X3KVNd40KN1JthRuyGFvLMSTAEKkMAXJoVHFEIKcCSHLBswMmoksxQAxUaBEKkm8pGuffd/fffQPhGSJmBHknG9193dtoEDQch8d19Qkdu7W7v33OfVyqsZmZIZS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aUSQS0SRANscihtKZGokmr3czO7u7u7glzve971IACSSSSAAx3va73vOs7973vb96e99SlVJ9JJIHwccSbu0eayM7r7u7RAg6o7u293AEIWvd0AEk1JJNh9dXVg2PXdVV/Pe973Pe9PuDTYdfVd1mSTckAH2ztd73eyAAckzJJIDRmrug+nUkaAu4BNJFv33MPGN59AkX30799KjNXdAOySSRd3dGQCqurqgSqq5VVeqz9n59sAG9XdXVBsW00ve973vZkkkkkUnwkkny/vyaTTEB73Xe968AATN3V1U653G+/d6gAAVWlVVypJuTN3V1UgOgbST6Sck4m1Lkn7o0mkAAASKTibUBis3h0EjNXd3V5ASKq7qgAOGau6YAAMXdXVAEAAAHqqqq+er3vfe973tRjmx91wAHve973ve94FGau6cGjoHM5z777776+ZYUZljKkZEfJGRGjAGlS1VFaFGFR3eKzqDpLu6qryyBCqAFd7330mmK+57N/T6Se92mJO973fe57JJAAbD4HwNhoDgyA6YATveycky2kkkkgAACSSd673vepAAAAUAc1ze+ce9TbCeUAu+/fEKTWIkDoXffr6QpNEnoBaV9++IUmoiT8FBavvUk+9ATWKm/4qa38bu7vfsS++2/tpNRVtVSW/jdzd7911v2wnhBqVDu83fN39/ddb9sLqW79vN3e9799s2kntPdDdrd73vUk+92bSa5ddr9rWqr3ve57vp7jAG5M973vUkgGw+B8DYaA4MgOmAE3dte9wWZmAW21JzMzMxdbaJJO1JJ821JJOyTMwkzAkmZLk/AAAEklSAH5NoCfJqFAAd7374sE0AHg73v3wCaiiOAdDve/fGoa2m1ugbu3d33u7up80Db3m773rtJO73YmuoA6WHvevvTxE0AfHg97196ETUQB0sPe9fehE0ST6AeMz130iaJIdOB73rtJO7CJrvwuz29yqrn3ud76TwByTM73vfu4u7rvcySRsPgfA2Gmw+4Mv3ve97097HgJ3vZJI2B8HXGnwNuDQbkmp3vesSdSSSQAACv3ve97wXd33p4E0AHgu7vvQE1EAHQvPe9+uzfk2tppLQDd27s9d7uprQNKC7u7baurASYAQLu7708CaADwXd33oCcpKlQAWePcW5me77eepNraTWgG7t3Z673dTWgTuh73vd6ETUx/V+D8Hgk9gA6ZeCST0nJPc+HwPgbdM6A4Mve973vT3seAnfu97rfenwEYSSSSQAJJJ3vWbu6kmr6mpJ4973ve9XjVXdKBwAc5zm9nqTJJALu7tp3VgJoAIF/ru7sBNBySAe96vUvXZ9tJtbSaFu7u93T3veu93U1skndD3ve70ImiSQC7u7ad1YCTACBf67u7ATQSQC7u+9AT2hbu7vd27z3rvS02tpuUlOZJz8vr79ve/fb7dyVJAdMgSSSSRs0bDvwNhoDgyA6YATve673vaOSSSSegB8m0YHDsmZmZmJJ/m2sySdzMzM9MkjLFXdHwdAwBRAc5zm9v3tTWgG7t3d207q9hSaAPiB79713YRNBP0gHvXfehE1EAHQu7vvQEmSSAXd33oCaJJALu7tJ3VgNoOMCB795+9xe943qbW0k90Dd27u+93d1NC3d3f273333+/b9yE61BDmLyyqy3N3f2+b7sAdMhgcGkDYfA+BsNAcGQHTACdx3ve96SSSVJJ8NGQNSSTfe/vCruh71eBgAgAAHve973e85vfvKuvABd3dpO6sBJgBAv9d3dgJoJIBd3fegJqKkAFhd3eXZvzbW0mtAN3bu7Lvd1NaH4ND3ru0ndWETQAQ7zve9CFJr8H6SBfe9+wImogA6d73vwA2vv22lVJ/v29TaA9ubJvuVJySSekrkUj973nve970YbD4HwNhoDgADACb7iruu473vRxd3WKu6P2vdAC7pNoJ+kkn0pNqZn77Mk+7n2EkgSeJJJJAJJJJJJJIAABd3fegJokkDve960+0AJMAId53vrpWG/JtbSa3QN3bu773d3Wxbu7vd27u+92G8aWh+Dd33rvvd2JokkAu7u0nec8HyaACBf67u7ASYSQC7u+9ATUQAdC7u7v774R037fVfUPEkg/ECBgg/GgQRPW6Sf2HMoF7+0f2V9KmKJkRkST9klH7+0VXURipVvJI/sUV/ZRH9ih2iyRU/sVSWkjCf2SQaJGBP6ltJpvZu/NtJ/q/Ukmt3dAwJJJJ2SPgfUDYabD7gYAJh+973veane5793vvD9dVdVYHfMySSeAE5yTWu96kkgAAAHrqq/XdUhSCEIJG4ICOCISim7u7u7t3d97u6m1tNrQDd27u7ad1e7upru7u73dv9d3d7Ck0E/SAe9d96ETUQAdC7u+9ASZJIBd3fegJqAB0Lu770BNEkgF5d96babW0moVu/t3u7fe/fbu6mtmhu7fe97d7Ck19979SpT799xnUm29aRk86/veq7iMMiP7Ej+50j+x+3FAM7QQxQF3d6BHZFDZRDfNJpcTW7N20kklaabS+3d3d3dkkkk2k1JJPqgbDQHAAGCSTvOO96mCgBJPpJPXVXVbe89y7qqr3ve95yMzve+mru6kkbYM4AQaCSxJJoOLd3d7u7u+9dq7vSJq0AfAXd2ruwEmAAF9+++ATWKNBw+Au773oCa8mTkALxe9d2b5NraTWJ6cN3du773u7uprQN3dvv332gk8IHwF2773oCeUkckALu+96A3ouJtbu7Xd3bxe73u/fmAvogSXzBIMffQAg/IgK9Jnsry1CMol9gUe+6uqDEUzFkRnuCT3+0IcwU7qrFVlVlK/v79/dSjtIyTIjAyIwJgjMyTEjBiRhVb/v7YSGygbCqpsh4ghKG7v2/lV3r9+/d/e9rwA2zJ9JJ36oGw0BwZkkk5Jgkk7zjve9E9V0A9AD3gPhd3TdVVuPXdVdV7YyPu+lV7O5mEkkikkknwm01qaTSpttNpbN/PTc5u6S+973ubuprTd3d2+973uwpNEAAu1d3+uyFJoPfgA967u7CJrA4AF973vSFJogAF973LsPk0TgAHrSTu+XdhE1YfvwAeu7u7CJoAALu7u7AbVUABO/ffHT0TX1JppFJ+SGqpVB9u2IQU4YCCHulH03QCCPGzczlfdaf2ue9fsZwlzIjkof8z/q/0/spZgkAAIKjP1vxPz9br6FJKUfqDGV+sJbeN/omR1WslIWxHkCCZhoEDAQdwEdpHXv2/OtKvGvuCOYIzyIzQjzgjfURma2I8zUIx5md75zr2I99SMyLvWrMK+088pazPqWO/hGuojN/CM6Eb0I13rQjO/NiNxGbazEXcLWkjcRmRGt531COfRGsQa73rtBpBroDWOutxGhGeRG3ojX3XeuboretWxG3iDr3TtF7Ee9CQLYqwEEWAgqJivbNgAer3vRQ29b1pnrrWa0kdCNYS7SMJZ52I76CM3mojNxGtd6+3voR34I172I73vRTeM6VO869Eddd8iPu2Ne7bxmYzKR4I1zW8xlI2oLAQTMt3MqW3ZUnb5Ag7AEEeAjzoR75z7UWY+1EdiOc5nnm+NCOtiOtbEd673vt54kb088Edc1mw4jvP1RVxVM33qoY5x7W7sFyAgaCPcyI7Ea7iO9CNlWYyIzwR5uI886Ea6Rdaa7iNNldaSO+xXIjwR534iNZEdYgQeaBBVWAtm+rvMSSbvyBBvu4SO+oj12Iz53vexGkX2NEu8udRHvsRvoR719C0jSxZRLzcrIMjHvpsqmVuutyWkCmDuECbxEZvQu0YuaJHr0RnYjMEb6EZ8Iz2I7Ea6Ea77Ve693ryq5rroRz2I8ojfIjcRvvKRoRrz7vsl5EZyIzwR5mxGsEZ6I68IZhsRrb3vUZd0VEQ+wgkbou46/Pw2xttjY2y459nXeQswR7gjM+7VXmtORHehGPCGYzrKLvW832I1orzXkRrexGaEZrO+0HuvevuCNxHWaAg1vDb7ph1ka/N1Xem48Q/FZs29hRcx0VLvxN5RdZMxJDhxD2qNyyMubrJgyIqndOLt5l+xvIlv2wpVxEFjl+h1shkkeJelU7i6Mq1TLfOW59sUVpCINIlq/RTbbI8Op8/XDYTMWzXlRExLE22sbdu4mJMbeTI5c+luW3E3NZ0rJjLczMSbnqr0vzhxtS/OJZ6fE+bl71U7L8+roHHmQ7f0QedoEHnTbwQJ03D1y4doEP7KxBDvP3O/jy8KqvcybPbygRjSp0mfeqrZaBBc3H2TXrmtiPMp0CR53N5noguwEEuYPQX0HUgQWSxsjZnI24K6Yl9PUdcKHjPPMhu3HcTz5t49mTJrbjnGxddEnugWOsgWRTx0piApZ6Ljrrr6I4IzgjzwR3gjwR59gCC0CDKAQTgCDIbqp6IizqsutPF7u9tRt25n27ZJR23Fce3e6qr3ee315LrL69iK6M9Y6iOiJiXMREx6Lm4hw4iIIiBu4iYiIjDqyrcNvPaTbr2xMsOsSFczJe+9B4qITeu3MGOSLuwKYiZN9KqC3UHOX0ZWVdYV67VSgQTE+uRlQWwpiC42yXHqB36IgBBuMc7E3FTEe2/ehvchZBBU5s3rJe7M6QbA7mpeYCFtUANkxACtmxF+3azQEDoQgvHd+yfPMfz2Xv+Pdey39OusEAfelueqPnBnm/E9viVTbiZur9c21MxEXd/lxNRJENt5nU6pJIxwesiGomtkfnnoZDyVjhAgf1RdN1SpkuSaahCFl+AQVnOt8yLmdl0NemW8d1EEM88rxJjQYJunTDWd0JLWGN9FZd9HcAg227Bxc+nqO72YdFdPgEHjvPIjdyY9E+rIYqsxBFYwmW6+1AgqnUP6vWXczO7du4bUZJLjKqu84LlwjfbMMwc+iHI2/kCCouL9RoCDa9CU+alM8EbiPEXuIjHcRgjXe4jexHjWojM1ngjvsRvoRmRG9CM87EZ3Rc110Izx4836I4g1z0RrxVa+3KzIjvYjTBHgjpI33Eb9CCTQBA67LPd/B/T9H/v/L/7/oP+P5f2/nH9f6/zJP6r+H7+34OaTPp/R+5B+3/H/5igrJMprPABcZ4BOQuvwDAAOA//+v/371Xf///9sEigPfBQAAAAAACgAAANcAAAAAAAAAAAAAAAAAAIAAAAAAAO5gcAEHXO+AAAHyA8pQJRzikl2NJKKSe70PoHwALQyNJLtly1XWKSVzcZ75vZazIop4yADcHABKD7wAByAD7e4AzYAtZ9yVrSinfTgAl9u+GSomFlDVQgU1lJoa2NaGjNqVmYU2sDMCwGCCbEs+fWtJKVsyklbw4AELPXnNspUlKUqeAGABbUpVSqV9spxgAQWUqkpKVKjD6OACT57KVKlJUpODAAl9nh70pSlSkpI4YAEWUUkpJTvuc9sb7uMPbR4B0BWg4AAAACU0QE0mhMTCCmCNJ6IyZkZDU9I2p4ibJBpU08T96qUqVIYIwmmEBo0wAJk0YAmIDKZtSNSVVTTEYmAAjATACaYAAAEKRpSon6pAAAAAAAAAAAAmpVNG1VQAAGgAADR6mmgAAAAKSkEJUqaExGh6E00ZDTTRoyeppiYgZDJm7fq02bBjUwzMwMMzAxwEHt+1o6fivS/uP9/H5Uanr/p/1t/quXt/e1vge0vn9Py1VmiRVHhdo39e6zayfwzc8atgns1Ozrx5+61Ws/w15fR5fX6EXfz+n1fn38t2/38dng+XD+ZnvVv/ONM6gXj6vZ2fXfw92X3Y7s9u+5OzpUcFLvgvSZHiW+thT08lFnz8UsbI9VFidDJc4fWVTUQU1v5e2tF5ptVDbJ22Vd+dNmkqRLUp6X4fUM4gYA+9MDMkzA3n+oR/dL5+0pvH6KnsqedU1T81TVT85ToXcX/GoYX+YXlTuL2LCwtRcXBd9i6ULsWFPRbyoaQwtK8FwXZLC9F2S8/zC4L4JYXBdl717U7FgWqHouVDFehdFVwr8eqdVO6noF2FguQvQuCfAuguqp8qYL0XQXQsLwXlU1TguheiPotFqmC5F2LwWUMLVOxdQv8xX2pqLSHiphe1NF9C9K9+u+ivou/Qs8F7VOxdReFHlTwXfxU12LC+C4L0XwXQvKnQuCxXyLVTgvgvAuqnwv772XO91395U7dC4L9U+CwuhdC6FyI7F9FyphYWqfqnX6L0Xap9qd1P6Ldvj0XOvanihlhdqnCvVToXKS/uy3YuqnYvBe1PRdhdhPtLpKsVyqcC7Fhd1OheF896F4LlLC+i9qaqfhfwsF0C6qcFhYX8LguhfxfvKp0LCwu6mFwXBfVU+i/hfBci+jupkuhe1P4WKOxalhH0XlU9RdC+BYR8C+C7F4qfRfKnYtU+/Be1T0XdT6V9C7S8+gvIv4XovoXUXBeCwsLoXFU9UOqpwXZf3KnVT+Lwq67+FnpXhRhap4L0XAvoXBc4LsL4E0LrGK6FqnVTqS6F/C4qmFhfwrypguhd91PBdguCwXUWCcyp4F2LwXAtF3UP6ofSuwXtQ7FqmqYWVGFnKqYL2UO6nQXQuxcqnBap2Lwugu6neVOVOUsLgsi4Fgj6i6F0Vhei4UdhYWEdVOFGFgthaLCyWK5QtJcFiuC5U6qn0XYXQu1TuqdC4LC0R1FyFnwWqHSqeC6FxQ1Q+i+i5QvQuyvKnQvAvlT6V9K8BfRXyL4I6qeBfBfKnKnguxJ6qeVPap/BO6h0S9F8qmqfhYXvcXip+F9L4L2p2V+FwXyodheVOhaphdCPP70X79VMSvBdC/C3QvgWqc6qn4XVU4F9Fyp50FwXguC4LC4FlTguC1TRYXdTwF1Uwugu6moVdguhfAsF4F2qaicF4L8Be4Lyqap4heFeVD7VPAXeqmFlDf1TEuVPSLVC4LsWFwhfhcqnFU+BYLgtU+5Q7FhYXfBH5U0XQvAsFqntTSldRfhe6pgvKnCXgukjsXgucFm0LVC+i8FxVMFyL9zguqnIjyLgu4uC5U50yXwXPBd1Ohdi67F4Lqp3U6EfheC6F78+BcCwuCPwvoWqdC6F9otwWUl6LRYXovAsLxU7qcL47F0Lor9U/VOhdVPSskdKHYugulT5U/VPRdiPypyS/YL2p0LVO/7fdC6F4LwWqd1T+FhdC8S48Fku6mqfov1UxLgtgtRfAvah7Rei8K9F2Lyp8FwWFqn4L7/C+i6F+C+VPRdC9F3UPkXgX4L2qrhL0XlQ6CwuqlYWqfotF/dRfRYL6LkLsXwlapcFwvoTNUOBYX8L35uhf1TkXovv8Lp+hYvJfH3qnec1ks4LL8NKtQZ7AysDKAZQDKgNV4Bq3uknpWsT588LYt+fS5nRcxdui6+uy4/nhnm5M+dm5M8+T7JnnZ9kz581z33296AO973ve973oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8YA6AAG5rWtBQAAAAAAAAAAAAAAAAAAAAAAAAAAAHkmAPQAAAAAAAHOc5znAAAAAB+73ve973vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbmta0FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2TDwAAAAAc5znOcAAAAAAAAA73ve973vegAAAAAAAAAAAAAAAAAAAAAAAAAAG5rWtBQAAAAAAAAAAAAAAAAABZJJkzJJn6AHegAAAAAAAAAAAAABZJJJ9kx4D0BznOc5wAAAAAAAAAAAAfu973ve970AAAAAAAAAAAAAAAAAAAAAAAG5rWtBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5zmpM5zzgAAAAAAAAAAAAAAAHe973ve970AAAAAAAAAAAAAAAAAAAA3Na1oKAAAAAAAAAAAAAAAAAAAAAAAAAPJMAegAAAAAAAAAA5znOc4AADyTAHofgGpMOmw/d73ve973oAAAAAAAAAHe973ve970AAAAAAAAAAAAAAAAG5rWtBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5znOc4AAAAAAeyYeAAAAAAAAAAAAAAAAO973ve973oAAAAAAAAAAAABua1rQUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAd73ve973vQAABznOc5wAAAAAAAAAHkmAPQAAAAAAAAAAAAAADve973ve96AB/kttt6edAAAAABua1rQUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOc5znOAAAAAAAAAAAAAHsmHgAAAAAAAAAAAAAAAD93ve973vegAAAAAG5rWtBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5znOc4AAAAAAAAAAAAAAAADyTAHoAAAAAAAAAAAAAAB3ve973ve9ADkmD6Nzu9733veSZ136B3ve973ve9AAAAAADUmA2He973ve970AA/gAdAAAAAAAFkx8AP3e973ve96AAAAAADJgA73ve973vOc5znO9AAAPsmAcHe973ve970AAAAAAAAAAAAA9kw8AAAAAAAAAAAAAAAAd73ve93Na1rve9oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAc5znOcAAAAAAAAAAAAAAAAAAAAAAAB5JgD0AAAAAAAAAAAAG53zUmeWTPnkmckzyeSZ9i5ws4W4W4W4W4W4W/i3dBSpHZc4qJC4XOy3BbhZwt6W/i3Zbstwt6LoudFsW/i30t0XwuPS3Rb0twt2W6LdFvsRUui50W4LcLOFuFvoXRc9Ldlui3C3BeFYrsWqcF30L9y6Yrgu6nQuyX8LwXwWqYXovqp6L+F5F2IwXos+iwvCLsXVTqp4LhXKp2LsXBfRdlci/iXC/ui32UOCv4rS/hcpc8LzhZwtwW9LOi3Rb0XYuy67LcLcLei/VOy4XXhZ6W6LfS3pbwt+LfxbhbhbFvpbot+L6XOiz+Lfi2Efxc4XwucLPRdlzotwtwtwtYsOFv4vovVT4LlTC+i/qndU7C1TFfKmqcF4LguBYXog+l99LeF0XLot5UPgvRciwvamqfKnKnouVPosL0Xr0X0XQugvQuF98Lei4Lqp4LoXgv4XQu6n6pqn8L0WF1U+BfBehfqnBe4XguxeC9FwXQuxdi6qfKnQuBcC+C6L9i3C3C3C3Cz6F/C+i/hcFiO7+Lfxb0twt2L+L4XT0X4XwXZd/xb0t4L0udlv4X8LBfBeF34W4LfwquC47Lwudln4Xgv4Xpd/xb8L+F0V2Xf0t0W4LoudFvgui56LwX0Xpel5wvhcdlum+C7F2Lsu+C/hYLC+F1wt+FwrC6F9F8Lz0XwXioq/i7xb8Xpcei7FhYueFuxHhc/i3Qvovwv4XC7+luC+i9Lr+LyXHQvS54W/i3Rb+F9LnC752W/i38W6LfS37sufxdFz7sLqL9VOCPoX8L6LgjsJ1KHyqYWF6L2p0LKntK5qVyl/FcQuSXgvRYX9U4LtVPlT6LwVfIuwvAvovguhdxYXeC+8F9FwL4L6X78W+C4LC/qp+Fqp0FhfBfKnC94W4L8Le1TBaqeKHAX4XyLC7F1UxXBdBYXfYuVO1DsWqmF8VToXQsF6L/JCpIeYgNa21lpZbNpNptKlMW493PuOkeRUVO+vOjwjsVJUt4J9nmVvo8J5ZyKJFU2MNnqiqtpe1URtZgDy6ePUMh5up8PCDHnZmaOwF3UOERojdcKOCwtVKxaLC6VP9cuJB0L/Wi4i7FhdC7iylf5S6Jdyh1U5U7qmEdCwv8ou6h1VOiXBYLSjVK4kYkf62ojqqmqq6C4LssXXTr/X779/2Pn37+/fgALbbbaAAAAAAAAAAAAAAAAJJJkzJJgATJmZ35M73ve973oAAAAAAAAAAAAAAAAAAttttoAAAAABbbbbQAC2222gD+mFtvbbegALbbbaAAW2220AAttttoAB7L8tttoG5MDQAAAAttttoAAAAH79+/fv3790X0CpSn+GVtH4rRaL8LC4LEsLVPxf7RdCDoWFqnYuy4LoWJPS4KrhfxfRfiMLtUVfC6I/heyqd+C7Lguwu4jCwfBpdUrBvXlbzU5CWqdp0sxrM1rbWZm2d4605wAvxSlnWd6Wyve96sAMMAM5CBKQqMWm7MMM0OzDOJDJIEkmBgQhnh7StStbXve973AAAAWTMmSZJJJNfMyTIKKRKoIgNkHn2YWQcYocqKyXkVzMKomssiczCCsyzKZqKabHHJEo+xVFAbk1E01VDih2w50wKZKZOV9uc4Z0zMcciMzLDMMxsIyjCOXORmWBXMypuZyyGjIMojLAXVQDoKUoUoUlEIpQgHDtJSVUFLFQxQyFQJBQlFUtKSQyVVRVI0Ay0mRgRZjjiGYhRBE3CMzO2RdMyA6R3OJwowOTlzczveTlHOUdnvcyu5kZw3jzuEXbKzMwDIyww7AYWRc5yTMDDDvOdDgZnenYuXec7w5mVhiVzDIKaqgZCKMzH3MDZM2Mp9mZmGQFR5yqq7mFFUz0osQ3XM064FXXx0zmnD3HPGFMbznCo3mEbzvcpzChKyHK5iYYQlwOFc4YVzMDhV27XMwsQoqnpjWYd53pZXOZHDMLmY9Juby3CKnvTKHu8OG5YVXiDGI8XiClOYZkDuFh3jNyiyaojnuJuE4G9y3Hl0joVcww8RjuiIvDa5nbvOcio7jl3dAfCaXfWGUmoFhSaxZmTMpNAWFJoCwpNAWFJoCwpNAWFJoCw4k6TVu73u4JgJ9t2+yanAQTvASkKqaYKJne1kTHHIIzHE5xOHMMDDFwLIYJTAlwkwOv28Tv25jmWGGdzhFRE8iIcpmkywgqqpaqzMgoaKooSzBwgoyTGKSqppckyHJxhFoMIzDDs5GRyXhOQVRTSIbIA8jJVNuaS3OSocwrbapbQLNInWqWy5nWgc1IOaqQ0KHCTk0ZHKlURmaAFXmHTN111wxuckpzRS2oI665Ii5ubZ0zmiRc0JPMp3k7drDB5IKnIVAiFWhRpSV1rTnONmlIuWhLaAuapm2zc1wTSlsFXXXJLZCR0wbXWpyZlutco2iyliYU3nKqO9UusJXNCHNCJ3x10Ti2uZNxw4666lZLahNHfIqTvnXVWmx0d9OdJxmGIiHYUeqjCKhEUdijuGJl24WOFGY1YRBZGN6o2F9Dcw2l1jmkNkcyRparmbHQ5ZOYLyZgqjkPQHEUXFewnYKWiuJtlRRFWZlRVCUOTncUzmGMUBNNmcCJ5hFBmTckz7v759ySZmSZOfTXOegA+yYBwAAAAFkyyZ5mSTMsj42kkmgrcyk1YVYUkgLCk0BYUkr4guwpNWkwqwpNWFWFJoCwpNAWFJoCwpNXV5c42k20kL3vXDvvboAAAAAABkySKqrd2k1YVYUmgLCk0BYUmgLCk0BYUmgLCk0BYUmrSYVYUmrCvu9+TJ9kmSST3333W/fQAAAAAAAZMyRJnyZkmT798N5k2ACaAATQFhSaAsKTQFhTYFhSatJhVhSasKsKTQFhTatpNtL3333W/fQAAakwGwAB+/fv379+/foRwtU8LCPC8LgjUK3d6k7TXMzJmUmgLCk0BYUmvLMyZlJq0mFWFJqwqwpNAWFJoCwpNAWFJr3u+rqTbTbfUnQeO57d3d3dAAAAAC22STMyeeeX3qTVhVhSaAsKTQFhSaAsKTQFhSaAsKTQFhSaAsKTQFhSSr0zMj5mSZPlt177aAALJj4AAABbb7JnsmeSTNa8u9+TJve/u9+JoCwpNWkwqwppXzgVYUmgLCk0BYUmgLCk1aTCrCk1YVYUmuVd8zMmZnsW3fPaAAAAAN3d3d3fe95pNKqr3vUmgLCk0FSUmgLCk1JUlJqQsKTQFhSaAsKTQFhSaAsKTVppptpb3vYd7u7u7u7u7ugAAABbankmeTMyckz5iTTUut3aTQFhSaAsKTQFhTYFhSaAsKTWLMyZlJoCwpNAWFJoD7vfkya5uZmSTIpzfoAAAABbbbbS22ZmZk8kzUkzUmfczMzFcr3vUmgLCk0BYUmgLCk0BYUmgLCk0BYUmgLCk0BYUmgLCkytFWjMzFkzMxlcGLXvk6SoUlWorTdQzCVTgsLgtVOxapwWqcweKnTpxAEQR+6xRTUyDSItobCHguovvVQOzZs2bbGZrbaiOlKwtVMaLCwsUYWkXcXFDgWFgmqmFhYWCxaiMwYWC1TVTBHip4F4KmKwsUYowWKMVosVhGhYWiOEriqclDUhlStJLKGC1CspLCwtUwsqmEZLQLlS0ocVNwXBcCxaKWFhahaqaqGiP2K6I8M9yZqTPkmbkzsmdkxmZ+bAAAAAAAAAAAAAADJgAAAAAAAAAAAAAAAAMmAAABbbbbQAALbbbaAFttttAALbfZMvy2gAFttttAALbbbaAP5AW29tt6AAtttt9kyvAAPZfltttAAAAAALbbbaAAAAOSYPoAAAAAAAADUmakzkl4XheF+L8X4vS/C/Fi+F8LlOU5TlO6cp5qPIWJWFoL8XkV2W/F+L4X4vxfS+lhfKmFhaiwtFhZUwtRH4Wqp9L6XZdFfS/F2XxXpei/F+L6C6FqqfhH/mxkzM8kz5JMyTJPb77vfve3oAAW2220ttttpbbJMmSbkxJnkzMySfyMI/z8LVNVDBaLBaUNUNItUMF7z3v/H+P8efJFMzM22thdphJzJUWFqFWFiqK1TUHOc9c53FE62bYtsYrmKE+KmUMZaqZQwjRVhfPnz358+BfAsR3sam2wLwFagYWqmFznPXOclDo1Ntag4KtEc5z1z57VQ+CMLC7nC2xiocqGArC0VGCwtQsqrKVoSrnOeuc7CLrZWhcoYEPnz5vz54B4wNEEDVAKvve7776I6Gij4LIsLClaqMpqmCrC1SsLSTnOeuc7EnUsJVcqYFznPXOd0k4LCMLBdplU/fP30o+6KmZJNyZ973m771+AAL775JnvvvvrhbbbbQFkyyZ5MyTJ2SZMn6TMk+SSTCxLVTUA1TCwtA778+/5zuijlTKp5llQ9dVOKphaVEwsI2SVNUwlWqYRznrnPUUulstBV6LBYWFhaqYWqhhSp73zfkD88go4pAAp73u+94FTiYC+VDCrSJgtCwMLCrZKiwsBapkQ535779UJ2FkpevUvAVecC5lD1CxFWFgLQtVK2KMLaSsFhZSMLVFkGU533znqBXanmXhVS60FLoLUajAtEaoYRoqzBYWFhZU1TSr33z33yEHotUNU1BdzaYl1qiLoLVVWqYFXfOd852Kupap41CcRVipqlc5zvnORfCsVgu066qp1UMFhaplNU1TAtznO+c4qnUvHneevOpkmZMhbrnt/fgAAttttoAfJMALMmZM7kkz9mZNa1+/fvZJM+yYXMFHvvvnvvsFdTaZI5qD8AGQYB+fPnvnzBLd3u7gngHPe9vtwS8A+97fewT4A/AHmA/Pnz3z2J6+YDFgQqHPnz5vzcEkd3e7vgeXyxIM+fPme++/fffJyTPnz5maySTMhbrdv78AAFtqA2AAA9kzyTMyak8r3yBoSBAySBA1KUlSjthBWtayrVxgCwpNAWG2mrzMkyk11J5mTMLWcSXKzJmUmocLCk0BYUmtiTTaaS+33py2/gttttpbbbbQAAGSjheFwI7L9ySXfnOv37ifxe++zMrOcT5xP9xp03zne9vvaTQFhSaAsKTQFhSaxJ5mTMrq40u972d7SaAsKTeeedeecT7++eiDvJJfCyCH+PP3u98LbS2222lttttAAB+/VVHpelyLvvn79+5H82L333v33iZmZMyk0BYUmgLCk0BYU1i4+JMLCk0ZmTMpNSVJSaAsKTXT2JJppd+STMmSZ3u/vpVpbbbb2THe973ve9WTHwAABZMsmeZJMkk5JnzJMxpBW5lNfLjXEnmZMyk1mZkzKTQFhSaAsKvjSC7Cni43xJ5mTMpNZmZMyk0BYUmgLCk1lXc7xNJttLnu3DPvve6AAAAAABJMk8qt3a+XHxJ85xriTzMmZSazMyZlJoCwpNAWFNLFzMy8yk1iTzMmZSazMyZlJoCwpNAWFJYuONNppLd30Pat+3dAAAAAAAOSZ8kiSV3W7tJr5J5mTMpNZmZMyk0BYUmgLOJYuJ5mZM4msSYEONL9jSrjazMmWiUJQlCUJQlCUJQlCfD3vb68JQlCUJQlCUJQlCUJu73bRKAvmAZCUJQlCVMnz5Mnz5Ml3JJmTO9v3l77+t/AAAAAAAeSZ8ySTPnnh87Mnz4JQlCUJQlCUJQlCbA7vduiUJQlCUJS/WYJQlCUp73u+tEoShKEoShKEoShKE3d7tolCUJQlCUJQlCUJS7u9295DIShKEoShKEoShKE973fWiUJQlCUJQlCUJQlCbA7vduiUJQlD6yEoShKEoSlPe931olCUJQlCUJQlCUJQm7vdtEoShKEoShKEofZglCe97vrRKEoShKEoShKEoShN7so5yvv2Zv0/VN7m+Xa9vubunlnZz3c5XNWZeedc5797+efnm+0tVMi0WEm1UMLKJtUwtU9FkuMV379F1hYXaf6f+X50FqhhdqnJDmqcUMLVVcFwLgWCMSwqypqlaoaqffpf4TNTvnm+b539+AAAAAAAAAAAAAAAAAAAAAAAAAAW2220AAAAAAttttoABbbbbQAC2222gAFttttAALbbbaAAW2220AW28nvz31baAAAAAAW2220AAAAABkw+SYAUAAAAAAAAAAAAAP379++fRYFhYX0vpfC+l2F6L4LCPC9LsL4I8F9LhfZJkn3n37vnttoAAALbbbb+/fv379+/fv0Louv8n+TE1JtSbKmwjLFWxI2BbSVW1DZIbCM2xGzYTbYJtKbKmzaKmwWyFspGxLaFspbKg2gohmhSttoS2rYTW1lrEasCYCZVaaUlkgmgFoogkCSIhiCIpBYqYjd+vruksERLRMCi8hKEoShKEoShKEoShMSmmQYCCmJSIKCiohVoIgo97Afb64JSejIShKEoShKEoSlPe931olCUJQlCUJQlCUJQm7vd+4D4TkCUJQlJ8shKEoShOfPnzfl4ShKEoShKEoShKEoTd3u2iUJQlCUJQlCUJQlB8n3sB9vrglCUJQlCUJQlCUJSm7vdtEoShKEoShKEoShKE3d7tolCUJQejIShKEoShKE973fWiUJQlCUJQlCUJQlCfZu5JkmR991rnv7v4AAABbUmAcAHZMSYkz7kkzJ7JnySTOc876+CUJQlCUJQlCU/UGQlCe97gPfWCUJSpQlCUJQlCUJSm7vdtEoShKEoShKEoShKE3d7v2Z4Sn5OQlCUJQlCUJQlCfPnzvz5nhKE7mCUJQlCUJQlCUJ9z583fl4ShKEoShKPskyEoShKE973Ae+sEoShKEoShKEoShKU3d7tolCUJQlCUJQlCUJR6D3vb60ShKEoShKEoShKEoTd3u2iUJQlCUJQlCJDCQwkzFnvKYzMzQMJgBoytaU6Vxi9wAAAW2220yYAeyZ9l119/fybJsm3+MuZNk2TZNiUJ73uA+3BKEoShKEoShKEoSlITd3dVA9IO7u+0ShKEoShKEoShKEoTd3d0ShKEoShKEoShKEoTd3Ud0S9i5CUJQlCUJQlCUJz3vdB2EoShKEoShKEoEpTd3eiaQrQFHochKEoShN3e9EoShKEoShKEoShKE73vjdEoShKEoShKEoT58yT5zySe695+ne67vvtv4AAABbbbbQA3JnJM1rSdmT58mT58mT58TZNk2TZNk2Tvvvvsv4ucShKEoShKEoShKEpTN3d7aJQlCl9YuSpQlCUJQlCe97vrVShKEoShKEoShKEpU3d7tolCUJQlCUqUBexDIShPe931qpQlCUJQlCUJQlCUJu73dByEoShKEoShKEoShKU3d7toF7AMhKEoShKEoShKE973fWiUJQlCUJQlCUJQlCbu921Nk2TZNq95xNk2TZNk+/eZJne97q9/UAAAAttttr9L9+/fv379+9LqXXX79v5Nk2TZNk0JQlCUJQm7vd0HIShKEoShKEoShKWt3e7H17APe9z0KklziaklziaklwSdJrgEOJqSXOJzWtfdfJk1791kmG/de8/X8AAAAttttoAJM+/fv18mTWtfddkzySfNhDiaklziaklziaklziaklwSdNcafGuAQ4mpJc4mpJc42qabfe5kM+++3QAAAW222pMAF7JhJ6k+pPqT73v3eJqSXPJOk1wCHE1JOdhO97zsGQ97znbEaYDvec7oOCWhDiakkjakkiaPd9MzjTVcaTdz3oZ73oAAAC2222222232TLad37U1JLU+SdJrgAJqSSJqSXOJKSXONKSXBJ0muAQ4mpJc4mpJc4nPOb8kzcmW6+65773oAAAC2+973ve973ve95p1VbvE1Tkq58k6TXAIcTUkucTUkucTUkucTVJOSrgk6TXLCocTUkucTUkucTV97l4Z999u7u7u7u7ugAttttttqA8882+TJrWvuuyZ4muWkwqHE1UlXOJqSXOJqSXOJqSXBJ0muAQ4mpJc40pJc4mNPjvi2bdfb737UwtUyleb6LC6qGkWFhYXdTwC6C1Tu0p0TsXYv774F/C8FwXAvRdVToXz4qThYJ1U1JNUO5Ms43vXvLQAAAAAAAAAAAAAAAAAC2222gAAAAAFttttAALbbbaAAW2220AAttttoABbbbbQAC2222gAHsvy222gAAAAD/pC23ttvQAAAAAAAAAAAAAAAW2220AAAAAAAAAAAAPdRfSXhYXRahwWC+l0VOBcLwvxfAuFisL0sXRfpM5mZk3rX333gAAABbbbba97MNa1rWta1AagM4NKT3vnmzMzAkAJDYi2qmyjYFslsStlRtsS2kbCtqS2oWxKaABaKpUaQCh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kkkkkzmTOc5zm8mb3ve/2pMPfvvvvv78AAAAttttpbbbeyTNa1o3ve973ve972AGNPMzMwAAAAAAADGnmZmZfnb77v3nvvegAAALbbbaW+973ok9SfySbeZmffAAAAAAY08zMzAAAAAAAAMaeZmZnffkk9STM5lZm/ffL93tG8kJLPd33KNq84r5yvqOr6v77/fd/dd/N9854lrJbCzCzKGsLTCMyWZLe/OIuuC9F06izVM1T4LRaFqh9KxWIsL+3KmpHVU6LguALVTQMFgWqYWFgsLoWqcFitVTEsqfSuVU4FhGqmqYWC0lNFoosLVTC0XQspLgmeSSZ5MkzfkffNa5VAALbbbaAAW2220AAttttoABbbbbQAD2X5bbbQAAAAAC2222gAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+AB0AAAAAAFttttAAAAAALbbbaAAW2220AAttttoABbbbbQP379+/fv37ovgXpei4LwXguiwuC/CwXhel+qn6pgvS0Z5JM+SSTPkkz5mZk/jJM++/W/V70AAABbbbbQA7JM3JnySZuR0HFT7sPOYe99fXzWkWlRaVR6QmU1RVUTTBStKpQIJXe9O9AAAAAGmGJp3mZeYAEkkmta1ub3ve/urqTPnn3et8/fvwAAAC21AbACTEmJMsmdky227aYAeAAAAAAAAAAxp5mZmG973ve973ue/bd++SSYfXvF70ABbbbbS2222gB2SZ+kmb3vf79ve973608zMzAAAAAAAAMaeZmZgABve97+3nPvOc/fvy2222lttttLbbbabu7u7vyTaUkn3wAGNPMzMwAAADGnmZmYABjTzMzMAAAAxJPPvV73vX3vVttttLbbbaAAAHJH1JgG6AB808zMzAAAAAAAA3zJnOc5vm973v5Na1917XvvvttvVttttAAAAADskzWTNa12d3ve9caYASSYAAAAAAAAAAAAb5JM/STNyZdW6t/fvy21AbAAAAACTEmJM/SZme+++++/vcmd73ve4k+8Tfe973oAHkn1t873ve9AAAAAAAAAAxp852Skk9972Z7379vvetttAAAAADskmfZMnJPvsaeZmZgAAAAAAAAAABvd5znOc5kznOc5zVnPOc5zvS2222gAAAAB2SZyTOSZ5JJM/STO9739+AAAAAA608zMzAAAAADe973ve973rXMmcr7Jkz9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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
