#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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t+ttoBoDf0kjUaySSTJdSt7c3va28mS6yZJbd73UmSDyzJpuDe9vwsyNDe9rbzMjWmxve1v6ZF3bd73bf0yc1znN73xbzMl1bd73bGO8Iro7uiI7C/egRPoPe9ER7D3tESxAss1bb++y6v18mZMm9W+W/ZkzAfaAOGwPrec5zj9kyT2855znDWZJGTJNAVzesySNW222tW+W3nPlttF3bbb+oBoaD9mSYq692b3sgsye6yNQb3t+gsye6jTV22/QWZPePDXu36CzJ63kyRdNv0FmT3WZGjG/PPH6DkyetrpsOTImtaaeXbYWZGrbve6huSY1Zk1JjcakyQ83sOZMl93Os9lZ0GCQkGzeZa30IEvM970+aFJdSZMwH2gDhsD63nOc5+cZkkArIAK0eZJkah9mSQfn1tt5+5reSZi28frbbT4PQNAF4TZve1t5JLq273u23mZLq27888ocmRqDe9gsyNDe9guZGoN72CzI0N72C5kaG97BZMaG97Lu+iXLu6qru7vqriIAYlRACyCio3Au6EFW75gUEOxu6AAXcEAhEFu7wAo5gqLcAUC7u70EmgDhsD63nObznHOHAJJJbbbbWpdTJMy3dtvv6TJK3bbznN5kyZFt4/W22gANfNDyPfsyZmYX19s3vY/G5kag3vYLMjQ3vYLmRob3sFmRob3sFzI0N72CzI1BrUgLMlbzZrUgLMjWDWoPizJyN5893sFmSzVu8kmZ5r7UyY5zm8igq5znCK3d9ylxuKABcu6MxprMB9oA4bA+tZbbfucSZIATMyXl1bbabazJkyNZMkmQHwyZIC57Jkltvt4tttoADRWj7MkyZGszJMi17mzewWZGrW9gsmNWtAsyWRubrewXJOY3N1ubBcktkeTb3c2CzJzIeTx5ubBZkalrQLMnI3D3cmSbBRLh3t1VXd3fQEOxRbIoj4rpihCEhIQT8ZLyrkBcSSSaEGSryAucSiFAC8AXFcgC7ut91rYqe2gtVsgJStwBL6TElMTyiZaHMJQgAY+cuts413rrO9tu+TpjOunU4klLdbZts7x13w7ZdbprlK5ZtmqbCjh1ttrY9fzne8a2rzcbaGotDUBxMGQFyAtEr33M3sqEidIhI8mJMUUz1URuioZEDGKQVKAmmzW21Lrpm1c3LOc433oJ1dSZmZM83TTZvK73U710R3oKrxgBawKD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2ysitRsNFaY2itKWkaqJompDRW0Vmitqg95Ue+9c6pJ1pd2gsZmzWWszG2Be57qinvvvT5EyP7U2ptTam1NqbU2ptTYiS9yKl0K20TVGqUsiuty1JMFGitkVpGhWStolYjUJorbUjRWirCtAe6K996660VdYiXuUpe4knvvv2K7gW2FahL+1NqbU2ptTbmrmptTamxET3QidRW2NFairrFXIrFIvffed9de++++/Uqf2ptTamymymsKV7lSfxCaCtFY0lsdZxjMZm1Zf39711131hmm2zZNhth7nvvvTyZ7pVcqMqsis/tTam1NqbU2ptTam1c3NV/apV7uylpVorUGisqsJkra20VqlO+Q5e+/OdVOvffffflIf2ptTam1NqbU2ptTamxecfmxXtAa+2Aov31IL2P1/YFAfvUNwEVMxFAuJcBAOxBF7FF1HvfX4k5xNN8gAEmhgAAfQkknqbagKeJAGh8uxtwMbSQASfLcbSbS3iR73uE75RaLjfru7u3qC3LiC2e94kmySSANpJoAAAEk2HQA/NNKe93wh6KgHwCzcRWRT3vqwOIivfffffvym1NqbU2ptTam1NqbKq9wlzSkbFD+veRXvvfTrAdYqvcqT3KV77z3VT+1Nk2P7TmptTam1NqbU2ikKEFgK/RQpEcHvfZxjX33333tqSM2ptTam1NqbU2ptL3j+df399VfffffetSRSRSRSRSRCT0QqKSKSA0gs+wfffaxisT777769qSKSKTU2ptTam1NqbU/uPfe+RXvvfOe++++/39Tam1NqbU2ptTam1EiegCyRUYkn2D7OVA++zjEMfffffe/KbU2ptTam1NqbU2ptIP1Hver7GPvvvvr+UkUkUkUkUkEl0ms4ms4lnG1ziauK25mW20lxptc5mYnNTc5HMmybnFTnOJzU2V7x777znPfffff77k2Te8hc5xOamxbJsm5yU5ziclC+7zRVc55D3v++/v7+/gaakzMtZ5JkyYHqOAK0B2SZne3vskzAfSF8AHQPIL73roLgXd33WwQ76u973nICC3znOccoAADf4eDne9ne93vfe972/xbJsmybJveJzVzc1NqbUfUffa0oH2c4x999997ikikikikikikikikikgv1Hver7GPvu/ffeypIpIpIpIpIpIpIpIpIJ9R971VXve97vg+iVFJFJFJFJFJF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V99kTMTcETMcz7NB9X2H6fRM+KkI1QIVUqQlFDXp72KrXve96zfmmqUCUVIQ+Z9LfN37bbe/1c5mZutxzd5zMzdbjGIk83ZJJ7BjGEARJ5uyST3oGGOOXYk8+1zmZnx8VbbPoAAF2pPN2223tAAAu1b5uyST2AAAcmxJ5uyST2AADWtamr99X6SZneTvnt/frbl9tt+6dGgCVAAQAX2233l1UmSAEOXVttteW236pMkMmSbW85znOLQB40D4LWVq23vDR5vfe972wAADOcybEnn2uczM+fLbbPQAAM7i+VdX+ttvaAAB7fKuvkkk9gAAHJsTUkknsAAAmxNSSSewAAD9yeRPvl3nMzPP635bZ8AAAu1NS223tAAAu1dWSSewAADk2JqSST2AAAfObN55J399973t70aB8PEbN5JmA+IAL7bb70Vr5ocN973oBbbbavbec+52+dt6AAA+tvnOXnvskiansknsAAAjYm35zmZnl3mW2/LNAAAu1NS223tAAAu1dWSSewAADJsTUkkntFMw5ubvMbubm7zmZm7dq6ttt9oBjmW7V3595zMzy222egAAXampbbb2gAAXaurJJPYAABybE1JJO+sMZJJJPUqO4IvI+rOjOErOPHs6ee97ve910B7UHz9buTJLZbaC2W9ndHadyoaQFUT3d3dpzb7kgKmvksELrPAPgz9qTSnN3d3dROE8RJ+ibS5P0+kAh8HyTSPA89IeB+/JNICE/HkgDve97773XuuySfugAAdb13zPLuZzM8SSTv8AABNjuu9kk9gAAF5fKurZJ+gAAHO713Xe97390AADu9d13ve9nsA3dACNibfnOZmeW23+zLk0AADb5U1JbbM7QAANvlXVsk7nsAAAzU8iakkkz2AAAbvOuc8c9ZGa5znzdw/vNxSRBmK1hKWtZoiVjPs+9PX67uXfbu7uoC22y20Ftttt1beXVs5SDw/u9723x4W/r223+lt62HTgHe97JJJJJJO973v7vdd12SSZ7AAANm+RJ5fvOZmfPlttyegAAbfKmpLbZn92gAAeXyrr+sk7nsAAAzU8kJJJM9gAAG7EhJJO57AXWbuYZhjnl237v9vOZmeW2+25vWMdxmtAzy+WlvttmdoAAG7zKt3dtknc9gAAGankhJJJnsAAA37/b5M74fe+n78AAcAAJsUkk3d3Vu7skLbbexsHCjpbbbe2222r23fOc7b0jve973ve9bAcDxrMkgPuojM5mTUkkmewAADdyeZsTfOVzmZnl2225P4AAPN3y+WEltszuUAMMcbfLS2SdyZ0AAbuk2Qkkkz2AAeboeTyQkknc9gAAGzyOZzMm/bjnMzPFtt7/AAAXl8ryeJLbe0AAC7LdW/JJ7kAAA+nM5ieSEkn96AAAm79+f3syT+8/tZz99zn7J9vX33kmSfc7zr8aAKgLWCBwLbbeyAAO9zve9d73vfej2gyZJ3ve9ttttvQAAHe99673vezsSEkn96AAB7vvq/eczM873vff4AADu9czmZ7r33ve3l7QAAHKtLZO/s6AABzu96d73vf2dAAA7vesx3veyewAABkSMy/eczM8tttmdHTmHOGsM0zc2+Wsxb+tt79XHN3N3d5u8zmY1drM5mMtttvtMGF3cYJ49X2c5r3ve9q/QEKqVIQhAv6b9ehGyVhWFe6JO+uCttnWI0VhX597Cv7CuxJhWFaF5dQBcAAtfdAFwIMhgqFcqjNUmDG0REcmReZdSAk7tqAEqJASbzK9rM3LIVAExXK4VkUOALQg4aQWqU5BJQ1CTAC6wO96lUYDIC0AtRBbPMO0itb0YTOtd3yZ9jgIG8a0pIyOancd3jnL9721oIqgSXd3d320mZMnmZolt/W20AkkkA8waZMkh+Cu9973ve9/d7bbbd2sm9Bw7d3d573vc68oJkW901d7x73Oe9NqIwdf4B3ve9d13hoKrVQBIzJmakEBY1orQJJkyTcnmbkmZvQ49x5a+yZMxNZmZk83s/DyuQ2+B99kmQP3wffQPPQanON6tt5bw0BCoACA4bVoS239bu0DhvYPMfmh+9B8AFttt3aG3DQ4XltttBABWg+2F/NqD8APra9B6D7+STM79m+9973vO9/DYDhrQ3vz305JMy739+t3u/QaTYGgB6Ld7u7u6NJsABARfXdYuXd3fjYCtyZpzABKiAGIFQrjRgAbDd3d3d0ZoYdOnEAL8l+9999L13ve96H3Ob5zfOcNnHDfCS2222gA12TMzXutbzJJJnOc95+53vQASSeTWZNayZM1mgOHZ3vQE/agJJq3dPQQY2kj0ADUgCSSSSQQe971973ve976/e8gvOUAtwUGALASZnd9++73vbktttt6AHOc5znOJgAsjJJM1bbbeSdxJvv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OoRgAAApJJJJt6Gw2v60487qYO97+mZO973n2Sd1J4ZOOcVD7TkoYmhcnMnFPpfE0cS84359iOJImNmYjjS+DoYzjRxM4jiSOJH5JpYmjjOHDi9AACJJJtHGmziabRxgcEAB8LnFxq400szmc5cvLi99bSXbbbfhzG0lmcznFxZxcQr3OVW362+58UAAu1cttt/QAADk2JuZzMSSSewAADs81Mkkk/QAACbEv3nMzNtttk6AABd8TJJbb7QAAJl81ctsk/QAADk2Jkkkn6AAGHz3m8fJ987OSdnZJ7Nkkk78/d6734FAC+WX9bv6+33Lbf2vuwW227ugEn7dzfvjdN3ekkkAJJJAAADps3JkgPhpvJkmgOs1mta1rWtaE2Jq/eczMtttn4AAC7VySW2+0AACTF+atsk/oAABzu9mpJJP0AAAmybuZzM2SST2AAATZN3b95zMy222fgAALtupJbb7QAAJl826tsk/QAADk2TUkkn6AAAZ82ez7mZzkXPv99+/37Offvz5f79/f1psBw0AVFttt4tt/oJJJJJS223y12h7+CebpJGmlJ7Ju7u7u7JJJJIHQAD4kmzkkkADMwCSewAADORsmvOVzmZlVnLb5/Xc6AAA8t+Lr5bbb7n4U5hzhzjd3N1fLd+7bbb7Xcc3c3d3m7mczN2ZfNurbbf1FaBjjLtu7tttvuVQAC7bu7bbb7AAAJsm7t+85mZbbbPwAAF23d22229oAAF23fnnkkknegHOc5znOc59++PM8zO+c9n732SRKQMAAn0nIAqLbbbz1bfejve7zJJ3vejh3ve973ve9dA6Wrb2/Ud73vegA73v3ve9+d73vZznMzkkm7skknsAAA5Nk3dkkk9gAAE2Td2SST2AAAW+W7u/PvOZmW22z8BhjjnuOXyPl8ttt7QAAO3yPNkkk9gAAHJvU2SST2AAATZybuySSewAACb1Nv3nMzLbbZ+AAAuxL5bltvaAAB4/bfkn2Sezve93ve972T2RO973pUcur+t3Jkl4tt6Sp3UmSb73vfCTY00snO8gEnjaS/fQaaQe+gHq8bkmvot9t3+/OctofpMkHjkNwX22+/OZ777ne972czMzJJPnnnkkknvQAAJsm7skknsAAA5Nk3dkkk9gAAE2Td2SST2AAATZN3b95zMy222fgAALtu3zy223vazdzDMMwzDGZVu7tttt7jGFADl23d22232AAATZN3ZJJPYAABNk3dkkk9gAAFee/Pb54+eeW/f62973vd73ve9ecND8FRawF/W28768Hj8H50O9D49tt9vMmSc5z+uTJLbxrMkjR4FA/AAAASSbu5v6QPA/aBmYASewAACM2Td2/OczMtttn4AAD2+W7u222+0AACbJu7JJJ7AAAOTZN3ZJJPYAABNk3dkkk9gAAEZsm7t+c5mZbmW2z8AABdt2+eW5bbYxxwA/svkm7skk/QAADJieSbuyST90AAD8O+d9eyZJ3Xe98tu7bb1w0AVHLq228m7ukn7PpO+SSezSAHjaSAMD8Ekm7223tt7aOgDud73v7usySG1tt673skk3dne97+6AAB1m97u7fnOZmSSSz8AABdt3b5bbfYAABNnd3e3mczJJPYAABybJvfPJJJ7AAAJve7u973vf3QAAJk3PJN3b85zMy229/gZ+GmYZm62eSbu/ZJJM/sxnWM3eczM3WhjGIk3dlzOZltvsMcytDl23dnltttgAADH39k7+n799+/36/fv37+vP4HvjYd7e910VoqLbbbxbb1sXl1+nOc7egN+d73vfmuF5cmSatokkggAAACSSbu6TJNnmcbSQB4SSbuzve9/dAAAmTc8k3dvznMzLbb3+AAAmybu9kknsAAAmyb888lzOZkknegAAcmybuySSewAACbJu7O97390AACZNzyTd2/OczMttvf4AACbJu72SSewAACbJu7LmczJJPYAABz+nkm7skk/QBJJJJJNe3MT2ZBEB9ABaiCJeKQSkEGAggBCOYCXVc3nz2evLyvZ75xBbgAubJXKvt6AXKqREDPNYBU3BF6c1K45AWYpBEzAF1K1O1JfLa3fXXd0eBBoCUAJdEsBLQEn7S554xAlF9XdeaAl6Eh7sy7lxm5Tu05you/MNGlXskzYXmDZDIiBCQEMBJgJdWRvwBLbr5t00CXnV1fzvVfXd98+IAA/fv379+1+Ae/a+++r9PvPB58eBWmATvA4ScMVWCoCicmsZz31+u1SPmiutSVzIWwraZaK1FlUucpOEpxhLjUTFtGxbVLaI1k1i2NrYwgJIwQWQQiCwWS7u7vt9EVpbbbyZkyXVAXMyTcmNgUzIr60VqqxVhWMitYq2UjaFayTFqqMtRW3379+hckzE0CG8ySLkkmW2/rbWgC4zQ+D325JmZGh78CT9qZMyYREYRIAsQWIKz8e97XvXeUUblt3b0OGgVrMmtSZMzU8zN5mZJtUFJMyRoIFkyNSSSTWhWhS4ipAFgIKYIFS7vl3Xb6gLcuT9JJqaanJJ7u7PKk0gA8ADu9TUamZJOa8PHFfZkkjQ2A4atttvLAAQW23l1aAAAAA7JMzve970W23y9D8NgOGgCoAWy22W0rQBwAfrXgHwe+wHvwfB4B+Nak/T9Pu5J9+Pg9khqTSiSbOAAbu7u7t70AW22212NZmZmskzLreTWskzLxtt97i4pjSaWfjPPfwGiW7u7u7skAPu97325rX5Jkmuc5zt53oA9W3222gAkttttoAW9mTJn2szMzLb73vrv13d3d3d9LjOVIlQkVCpQQKki5ta37uNjNZnQbTcuGw45aFUSpV4MMCEwVEY1VU1UZG4UYhJJGpItSmQpJGQzqtXd3d3d3d3fUHDd/fQevvFU/ACIHuZJAfSQ4ABk+/fc+9++NJ+HxcTTaSA8ADNttv63oAc5zm+c5y5PdPNuX9by5JmWSSZqTJl1ugfWnoBbbbbQALbeyXNZkmZrMzNNjve96Bu23d/bsnshPG0kZgATdaaWtNLWmlrav333331vQAF5zk5rMknOZkmcmTWSIy+3d3cBC7u7u75gBigbAXwoksmZk+n033u8ySc1zvedHDbWZJAHEFsRbu7u7voC2AiQBYwiCzQABbdy221rgCgH4eGskmZACrJMzvuu+d731zZuTJLbegAFttttAAHuA+AAAAArQD9e5JMzvNednz4fW3zoNZkzAC22220AeG8ySB7PYD4AAFttttAHDcmSd+/O6eehb08A/B5nuvfbP1l3znOUAAN22W39aA+/f25Yq+tRWqrcOcsQ2oJNZmpJqSSZrQFWZMxofh4uSZmY0A7zm5zm+aiHvvuvbb7l5X+BPu6ne933xAdRxU/c0OHvoE8mxSSSSTc3d3UT53oW23od7rve970UW2/uc4t6XupJJJD08AA/Hm7u+SVFSvFeN+cS5znOZjbJtbNrLW20bZpsZpmBmNqnvvvvPEqddeB7/f3Qp8jjM4c45mMYcSedABhjiuLueW7u+/OczMttv3OgACbJu73sknsAAAmybuy85mZZPJ7AAAOTZN3Z+kk9gAAE2Td2d73s9gAAEZsm7t+c5mZbbe/wAAFy+W7uyS2+0AACbJu7JO9/dABNZu5hmGZNk3d98iH332Pup9JCEJrralRoi+1WPd9jnv6H9need73va4aAKgA1dZkk89t9+t/c+lm+75rMkj4HzJL2SZAHcN5MkdmZJ3Rtw3dTLbec/PLq9fRrv7qDf3G0kYdCHJN3d3f2v7erJinskA36eeSST2AAAJud783b85zMySSd/gAAL6tv9u2239QAAO7zvd3e973v7oAAHO9783ezmczJJ5PYAABJPn955JJPYAAAjvd3b95zMySSd/gAALl8t3dttt9oAAE2Td3ve97+6AABzu97u9vM5mSTyfoAADfdBE3PbCoxtuIGHszPmb68+T73veuPe969cNAFQA5vnOc539ej0fj86gCAcA7+CfpJ2fffffv37fvjdoAABu+++++++973ve973tkk3Z3vZP0AAAyb2bvy5jnMzKrPL+s7/AAAf1y/L7u79ttvtAAAmybu973vf3QAAOd3vd3t5nMySeT9DDjjM7zDp3MwAATX3ONGIPM7fMWcS8WY2kry8tOpP9ec1q29zMXttts4ucbMDMkkkSc3ZmY5WmkB0E0cSTeVJN9PFvEk333l9tm27u7m7u7Wk0VWW8ttpJsUnAP1tttpznOc5x3ofB3vS23nOc/fv15ztoAdBA6AO973u976dktw4c5mYW2798feczMq/1s+/nC/y2+Zn6221NEhmSSSJObszMUrTSA6Caz4DuZgBoJr4Dued5eNpK23w4mrzlC5ltttTRIZmJNKSSRtfuSTzMyVppAdBNec5A/QVSTfe+/v3fvX7779+9v1sg8A/DYDhoBec5zn9b0C7E2koAABJpJJJINom74mn999376bskkkkm7u+pNLVu90AhwAAAzMJIAmgDOZ47cbSV47y8OJqq0uZltttTQAsySSRte8m7MzK00gOkTUkmZgAAmgDPOl62krb04mpectvmYW22pokMySSRJzdmZJJImqpxfsxnjcHsVpKvcoXuJ0xD5iXur8/eVHuRL3RXuivcT6y2TNaNIr3KD3LrWtrG94kHvnJEe5VXuivcqnv7xUrQ1btty22SfSckkkm/ffffffSSKbOT3lDErznHbbafIJKfkAeIAkkkjTSkniSAAAJJJBJpyDD1Tkk9+kyeb+SaQdSSaDE0k/ePQMwkkiam7M872XxtJVt22+tL9zittw732221fkrQzMACDSvFy23My22iakkzMkkkTUkmed7L42kq27bfU1bbk70tttTVoZmSSSJq8XADMwABNC4rxp8aTcxvFxPjWzMTW6106/uu7JR708969xHz32xtNNXn7jbaQHW2keFaTXiaQB8Bvv8eDhr8Bl1kyTmuaznPudv7s1ndfvJGlgAeeiMxtJad9kkn5bo00oJ3nFy8tq7asbSXLfw00pPvPJs4pL+CfpJ2T5JpSZJzd3fuffvpre797INtIMTS94AZmEkkTUkmZkv5tJVt22+pq23A88tttTVsmZkkkiaOLgBmYAAmpJMzJJJE1u7mZZz1tJVNgHqattwPPLbbU0buZm7u7ranOVgZmAAJreNP9xp473xefca5xernqSb4l9+WHoe2bbJJOwUkfht0HDQC85znOcHtv63s/emTEiSSQA6Aft3N+X33wT8lJDwAkkkg7/d73of13f6ZkNjn8N72ttsyW3e82+tpITYB6mrbcDzy221NWyZmSSd7lYcOczMMrFtu7tttlcySTd2SBE1JJmedh1tJVN22+pq23A88tttTVsmZkkkiaOLgBmYAAmqkm+9Vfnbbb9boAB0km+7u5pJJPpOSSSTe/LnOe84Ae5kk73u53s+Dge973vfoFv63vlt6DoW22222222g73ve7zCSSJqSTMyX82kq27bfU1bbgeeW22pq2TMySSRNHFwAzMAATUkmZkkkiakkzMl/NpKpu231NW24g88tttTQryTFmSSSJo4uAGLMAAbXefcSyQu/O6effv3nNe+9+vOd6Dxaw/DbgOGn4eFt6B13oHcknegWDyTve997qZkjQ8tt97behXe970Lbbbbbbeh3ve93N76CZA1r+7r9mSStu9tv5NCvLdO9tttTVsnOSSSJo4kkhJJJnKYySQkkkzJmSVaX9+40lbb4mqBMwABNS85cDnAAEnJLqqv3ve95HU3aIvgF7AFoQYIMucAWZgC4IAuMgLjuu7QXQC3kBcK9iAsyAjQCzEkqFQxWJytmLZOxCc7IhK/j2u9GT5R70XdTtRLXePXs51jZnDsBYouAFl+172DGN4Wvb9rjy516wfbnDJ4wTjVVjOKzRnbHaIBhEZNd5et+97K3FkJEgJwAGRUICOitkVqlcmlI4kaSrQLRQyXebu7vqAA2qcRQN0qI0gsxeO673ujqCxViisQWd7ebu7vqCgbBG6u83d3fRATawVRLl36BgA+zMkZmSD1WhMmZ+mSVqqGqNfSofKnHUVkrpBEl3m93d2qCts4gsq7w5vd3eNgr6IqiYiKInEF6HsBmKqFezr2ve77eowIMgKQURiiJYrQqQRYKyEGUgsqfj3te367wCaLShBkRaQNBMAJihBYFTvc9xv13stQWEhCBBBgMAW0Fk5ebq7u9qqZiC2AlQaEFneY7Nd73ogukCKn05QOVOc5hLQmqM5mgJIQINRUoIMu82Xd33aMLQZKqW1E0iXIrHNbFHxrh0K5zS1rbZNmZFYq0EhLvN7Lu7AGwFkJFFeILAVqXeb7cu7BANoRnYCJTeLzfLu9KoutJvjSamSeT9uztguAHoBEk0l33PGHy8JJMnweAfjVtv63fK0AVB+yTMt3bbLVzMkaAAAACtB9bfLbb6D4PA8w/Df4DhoByy222hABQBytgPw82B84eg9B8a0fvQu37wt4AJ+5rnOc5wAHIC9ne973vr9T2Ii3dCbjgjJPTWve933ZbbbbQAk7nqbmpMktr8OvwAE1mSS239bvlaDhtUB6D4AHk+12ZMy32/W3vQAksn7QKRIAZhUSEAS4qNVTd5u+Xd3YAq2228oH4eLbeg73ve9nQAN+++++++CE4km/fljTbPA9Pg3Vzm7bbe1mgBMkzLbbbWY1k1oAskzMatttvMzJn6azMkuj0FyRmlttoeAXGgD7uYkmZrJMzU32b733ve97WgtvLq20AD3nOec/fgD4D6TJOc3Oc5+XewAC5MkvZ+/bySSTyTJN5Mk+nf3s73q9ADwLmTJkfgCZkzJ+mprJrNaZo9AzJMwFt+tvloeZkzAPwAAA2e9zJmd73vff3Tz223v4eTJmAfhbbbbQAADyTMwD8NZkzAC5MzN6zJmbzJmW223lAFnBJt/kmnjaSAADd3dkk/SeJtN9bkjQfj3HswPz8AAC27tTzMkgffB8HottttoAHZMmS3rvm++973vtD08Q/Dllvu48DjgAD5prMkl1bbbQOG01ySCUglKy7zeG7u8W3u7vd3ei1AQiC2EVCDSKgRIIBLvN3y76bJZ0LihmAXC/UpuK/qj2IJvOO57rvvfWHi23627oHDQC85znOcAD+yZ3pIFaN53ve+zumhbb2yW3tayZIOhbbbbf0mSW7tttB3ve93vYAA0wDMw/ifm0lbbfU1bbh3ttttTVoZmAACTAMzAABNAGZgAAmgDMwAATVttzMtttqaOMDO1eeXvjaStt89uNq23M/dtttrbb5xpN/cS1v+/v73vvfd5kk73r1+PFtv1t3QOGhIBObxtJbm7v35d4acxJpTf2/EzPpPASAP0anA5w42kgJPtmLWnPetpKZ5IC84mkvQ805JBABqTSnBgIPwEPy/cDZ5mTskkhNDMwAASYBmYAAJoAzMAAE0AZmF/NpK23y8TX5W2553ttttTVoZmAACSvFbbmZbbaOsDnMzDLbd3bbbbc5bbu7f7+5zMy22+pq23Myq222pr5XHf2d7b+8NIdPwB53ve9fhsB+4a8Av7nd7tv363vfen5d23qQ8fD59sXl11cmSW3ovRJs5JPt5ukkkACn5AHgBQDzveySTU0IAzMAASckmZkkmpqSSZmSSRJ7u7mZfW0lJOqcTUkmTvZJBiatoe970A+TWySZmSSRJzd3Mzd3SJoQHd733ve97Mm/pr8PO/u960DwD8NixqHDQC/c5vnnOceYEj7uA7uTJOyd70cHAOlr629B70At3dkkgAB8k0gOgBmYe3jaSttvqattzMttttTVtuZl9AD1NAGed6ABqaA5wAAG19wDnPAABNeAc4B+JE0ADzML82krbfE/ecXEwOeAAC+igSEigS/eqe9v3veyeigSEigT54bf1nlXvuPi+7++/Lv3PPPvb+oAAdACfpdW223hoHZ3qy23nO9i2S23o72d73vQFtvbbe23ttlttttt6AQAD8AeAYHeAH6arxtJc4+cSaXA9m7skk7MMzmYxhmczDJJN3ZJLbcMzmYxhmczFturbbllwzOZgYZnMx5My3bu7bb7llwzOZjGPO65bt3c222ytPi4ucafFxVx25296sv3zaSvtt/bRhCQGEPvc9U9v3wffUKfa+BhCQHxcXXS33vUml22hrT4uLnEnxcVAMzAAGnxcXEueeKfdWSeT38WySSeSST2bu7bbfw2BbznOc4LZbbbVttttAO2285zvbbd222/reg5JkhsbkkknwgDMwDdTW7u5mbujATQCM8ziC9bSVMRxteEDPMA/AJoPZ53JJQ1NT9wMM4AAk5smcgACaIGcAAGmQM8aecYXraStvbxN0tyd7bbbU1796vyztp4e/vgkkk8kkD8SZJJu/iSO3uju9fpBBs7u/FlfO+OKaQHX713u/Pnvbu83d4k0pJJsmtOQ6B09bSQHoJtTvegB0AAB3ve93vfehmI4AZmABE1JJmZJJImpJMzJBgCattuZloAmpJMzJD5JpAdbQBmYBbbU1bb53vbQCJoA873oAETVSbttzM8VuK29tTXivnLbbdtoAHgA+W7YBzhsC/Xm+c+5w9vOfua5zhbfrb5R3vUW285O29ILWHe973v170AAkkkkkADzvegARNAGZgABmckk3dkkknMuM5bbu7bbbK4c5gc4lbbmZb982krbfH7xLnFy23My222poAzMAAEmAZmAACaAMzAABNAGZgX5tJW2+JrmF1d8z1tJ+e43Y0m7frfry8SsaTeXl60m7caTfjTTv7rSbtxpN2/JNO+NJv6hgBN/WTJJJN/XWua5zfNTg9yLfLf4+jW5Mk68wXl/dkgSa00t3a0m9nFFQttpu7u7u7FJJJJJJJHOLa0m7060m+8AMzDS21NAGZgAAkwDMwAATQBmYAAJoAzMC/NpK23xNe225mW221NAGZgAAkwDMwAATQBmYAAJoAzMC/JNK23xNd56km/r1JNl8/ed88Xnvnl+/vv7n9/eg9B8t3bbb+GwPrd85z3nCPl5zuW29vS23oWznFts9tA3d3d3dkkkkkgSSbv27vLegW2prbTncAAEmE4YAANzjMGZmAACaCc6dC+tpK23xN+2nLltttTQBmYAAJMAzMAAFXxvltuZltttV4k0szYjM99995znvv5+Ee++++eEZmxGZ7/d+x/NzRXRLKps2t1192394C6z+0j8FYV+aR3vfnO1LduGeIwcASyyIaY5JghzsQAkwQNvWVHNLdcFffnHedcX7nWTY8C4peTLJJCEUqipJEhOUCp0BYISCr74sHt9z9vyPVMR17HCEt6iSXzmiyHryJbhRVFFFNXLgBJiEWISD5jPc+7u/esBDUpQIiqJyILuXeb5bXGpkyY1JkgeKH4HhZmZkkjVlzd97nPeAipZugAYU0ArelArbx+4EH79g99YALjQA/ZkwSXd5u+XdeUUmMe5Pe9n3t97e8iDBUM6tBAyoERAcb3nWcuPz71+77vqud73t96HweCyZmTJnMzJNZMac9NizAG5d8u5d3roCyMVCCAwQhcu+oOTMzJLmTM1JmZrVoQu42Dhtak2lOSSTZM3379Um2j09PvvwEbTTafb2Hw8kmZvTQPVHxd222/qbAcNCAqAAC222tm8aS7s5PJMnRJNgAegfNpLzc3dPZJk9B7wPg8A/DYH63VtbHqor0HxABWn4eDhvskzHmsySb0DvXeZkk5Pj30+G3prRPfXvEXPpSAnPT72+nvAJZ1JAT3XXucw9hISz777v3V79OQOtpI+A4fhbxtJbu/bu/C33wNypLhSkk9tQK1vfve7rvN6nVAxWJATOev2/N6u2kgK309F1O+5z4PfBNhPyyAQV2/Kn5cPPB23j+dt58hIDvke6e7vjeZJP2m3ltNNZkkD0bN5kkD23V68zJIHd9/dnW8ySHDzepDf5953IgawUAukFiC+2oGN3u7v131QKBC6u7u75YRFMQEdyCBFTsUC8mSbenH5q6zJI0B8bzJJz0znx5+LbOHvg4b5pbb9bL5Xo0feZkk0SeT2KB+8bSXPZJ5D4Q20zj5+62kuAGfe8F8UCaigTuO973vLheaUDku8Xe7zvZKQEP3q971+8jpSAyenuvurvIQCMEASMVC8qBXa73vMd0HGL3KgYu/vRtcn7T3MkmzPnxo3mSQD8hvGkpJFJPovRNL1HjaSA+PjqFuNpKQnrzzMkgH7mjZ8HvGxJ+3mST73Jm8me5MZMv2v28yScv3lt9AfIR9837WPT8+K9ACHPncmZMkszJJmc9zMk1zn7vm9373Mknbe/fAAFmSZjYDiZJMxoA3mTMA9xwffh5Jklo3mSQVr4PQfDzMmYLimT9JF5okmkg6AB1tJburdP0n0mKZIA5xrMkm9Xdtt/VvMklbBfm95kkHnwe7AcN5kzPAP3H63ct1baFgHZJM7767rsP35vMknQ9OABo4bkyR+NjwD9ANc5znOfuQ0Hx4PwhvMkloOfaeZkzJPJJPvZDeNpsP35gH378cbSXf27+574dznubmpp5t7+C0ifW3y3Vv6nmyjbiTyBofgAkkkmptprGuJttr820uJquooty71e77fSwRzV5woF3d5vfQBTYhdXebu70BuCbgbjuD6WQv812GICw0guvsYEFrWruz77qC9igj72NtMDqaTZxpNpeh040mw/AHQJJ+G4Bf11znOcBec7bb29LbegLbbZ1o6ELb0AONZkkaFvddigeUROxFKIB3vrrJ+c5wAPvexEe5Q9959xG22xGZtmR77bu7bbbbnMxjDnOMZltu7tttsyuZZraRme+++85z33333330jNbEZrbczLfvm0lbb57xc4k0uLj5bbmZbbbazmZgY45y23d2222ZmZys5y23d22221u23My220TQBmYF+bSVtviavJre95P7+/tf33zuu99Ueg+DwD8NgW7kyTi2399B5Jki75zsnlt7e8C7OScSaQAZJ8093N/b3VAPfG0lJIoHa1JkhAALby3d1nTvd/3nn9/f0tqatDMwAASYBmYAAJoAzMAAE0AZmBfm0lbb4mrbcne2221NWh53vQAImgC972222pqgZmAACTAMzAABNHr1cxh4H4CgAeAE+Dw4Pw+/ennpbrnOc95w9ECf3e96tvOW3rve97O2+22zvx0Ftva0Ekkkkm7u+ffG+EzMkgAmgDMwAATVttzMtttqaAMzAvyTStt8bVtuZO2221NW0zMD8AeJoMDuYABE0AZmAACTAMzAABNAGZgAAk0lvEkmzjbaST55jSTXV0wAIUADzve9fB4F+tu7bT23nnOc4C2222rbbbaBbbbLf7JMx3h3PO9704Ekkkkkm7vu/YbpMzJL82ki2+Jq23MnbbbalqVtuZlv1tviaDA7mAARNAGZgAAkwDMwAATQBmYAAJoAzMC/NpK23xNW25O9tttqatDMz3ve97wPoICJ9EFA7EET0BV5BXajQk985RXfbgVs2Vf2KgCia3upysfZ59sEL++xd3d5u7u5q7u/Bb9bd22ntvPOc5wF5znOdt9kyTvX4/eB3vTnOc5ydtW2220GgCk3d3d0UgZmAACaAMzAABNAGZgAAmrbbmZbbbU0AZmAACattuZltttTRIZgAAmpbb5mW221NEhmAACatrtzMtttqaF3Ek3ia9xecSTfmJZX7e22libX1tvqVv3bcX622+/393vgX5g2HFvOc5zhA4bAJQAACbv33Eml9z775TdkG02SbPc4mm5IeJNsMAPE2mziYAABJJKFoXMStnzaSvLb1NULmJW222pq23zvepWgETQBmYkAAJ7xMOmZiAAE18gO5gAAmogO5gW6k0rb1L3joXMt+ttqaoXzvbQDU0SF72222trl8F9931v30L1rd0kIcKHoEPQA8A6+DwdW3yTJOc5z34PfZMkB8QkkkgBiTSA/IAxtJa0w4B7+3e/ak0t/aNpuGNpLwAPwADOICQvOJJu2itt20u23vne20DU0SGYAAJqc5wDzMAAE0SGZgAAmgDMwAATVttzMtttqa8AM970L62krb1JgGb3oW21NWhmYAAJMAzMAAE0L3eTs5Vz398n2/e+/uKy+Oh1Nv7jTA6/Lb9bdvtoHgaT2STsmyfbzm/ffefffpPZ5JCAX+AO9DVtt5+47JmYDvef3OJJu4nbbb+bTdtD1tNgAAIkkkADMwAATQBmYBdbSVt6mrbc3vbbbamrQzMAAEmAZmAACaAMzAABNAGZgAAmrbbmZbbbU0AZmAXW0lbetq23M3ttttTUni5x3Er5epo04TJ+ckoe/kAegB5JJPZJOyC2fy22973ot6A7e9873ve97xq3fOffefKbsgB04mmwDxAAAE8STkknsiySSrUmkGWW3My2gCaAMzAAB3idtuZlttomgDL3tt91tJW3ra8tt5y222pqHA5wAASYBzgB+ATR4GZgAAmgDzMAv5tJW5eNo941eW5mW221NXnnD9pZ7ia/bnv70Sb53uc3X+89v375n22qry2+S3fr+t97xcTv622+W62kta/tPg8Bbec5zgBh/Tve973s87e9A+QBN377n333Q3T2fm03JAAAbTYAes4m2mgCJNI4gBfSZB6GRo4GZgEkEmAc4AAJoAxNpZzOAACaNDM86BfU2lbetq23MzbbbamrbczAABJgHOAAaJowOcAD4E0dDPO9wC+JNK3LxJ2285bbbami3ifeP83OEYV74ePeuOorrn3nDWdEc5SC0SUUINSSpD1CSFTEAWPcb1i/TfEF5KqgFhvBUmAGFb73OowAVlhACUOHFOECV1MkFwXPvpRjq/VDwcjt3ACTG2W3tVfve8Y07xQhDiYltAoiKfqhnmQWEMBJg7ug9bH6oGAsz3pXO1oEJAFm8UTAC4hn3pub19m8z7Wfa973Ca9faAWXWA3lqSX904IkZFUN1ru989z1iLRMWAAYYIMQSVDJts0Ws7wXFVNFbffv2772+tgLAFCQGS8N3d3exF6QAyNgGTyQAcyTM1MkzJPL5ba4A+8D7Jf1tttsz3eSZkxmpuakkyBgECCKMhIqrBMS7u+XbYnURYEiKMgCsBWEFBuXd3d9ueBXnCr6yraobNFYVrRVkr+isquTNFaJkGxNAkAAkUFgAFT3vb97nrshJAQgAugUpFTWvz73vd771KLICLBkUWEiiJEFuu973vtXaC9QWCLdZu7u83YnYEQXQUCriIC4YIJBBSIkgqhUAAKBiXtxfLu94v6lfs1RGZtIGFYlloLIyJIySEQWJdSXe7u6u0EtEb7iGm1jbMCbBta1NoAcIlQkGEBFMVd8u5feCC5roJma15aLDJmSxoAAK14B+cMyTJzXh6H4yZHgHwelvltt+o8A/DbWPAcc0AUFttstr98PXz+73ve9fjdtt6/DwD4PQeg+DwH1t3bbThoAvmID8CACtbttt/DYD8PDWg3v94l8tttrzzzzQBegDsB4F+tttrq7mZma1kzeZJm+/teXvw8+7w++++++++CH7AD0BIQ2kvvvvvvp8YQAc5znvFvvjwD8W2+2y30ADs91++m5Jmffufb/fvud70AMjUkkmtZJkzWszPNZvWSe7tt+5bQAJznOc3y27zJI0cAW26ttrwo/DfOftc3z7nPQ7JMz7n7ySZj93953ndXtks+tt9tvQAoA1a0K1TJMl0AXKAfhvMkgH60B6HttvcyZne9733ve96C20D4ACa9kyT3nOe+8/cNgOAttt1bQUA9Ek35mJNL3V96+tNL5Yg/H037SSRSSQFttttyTMXe3gHkmZnmZMz9mSQeHObPMyZnDZXAAP1u7bbQA7kmZzWZMmTve+9C229DzMmYB+Hkz3AffgAD4PQAABZznOc5xWpkzPMyZgH5X3Oc7MkmT3s7+/fu97220AAAA8zJmAfgOc5znOcAAFttttAA5e9353ve953uwHgH4iee6yZLbfvra+aHgBL5bbfrQDdmQuru7vhdoHSKCxBZCILIhdXd3d3YgnQFiqSKqwBYMgqsY00dHd3d3ZmZnzs6fAV9avpQI97Pnd9K1gW38fW2+W23ySSeySd3d375fT7776eSST2AAAAAegB6Td+++++n303d3ZJUBfOcSTdrTStttojnEk3bbbcqtkl875E+g/Yx99qqxhkUJFPvqBA++pXWlXvvCuqajBsqbJDe+++7W221JyTnJJJImgDnAABNSTMySX5tJAdSddtzMttttSQGd70CSEaQGZgAESdAzMAAE0AZmAACcvvf7+9/vMmd7zvfzVa3/Hweg9B8Pz2+W3y/W/pMkf33HzXe979JknXTc+DyTJHS/BuTJHe98P2TLfrZH7uHhGsySHQdzJI73ve973oCB+Hg3vJJa2krb1NW25mbbbbU1eW3MwACJoAzMAAEmAZmAACaAMzAABNAGZgHyvGmlbepry23My222poAzMAAH/G40rbczLbbRNb+xppuedh77+8P4fW20Ak9kk8kknkkA/AHZN37z7Od9/r9bzvfu+953Vt3bbTj3MkgPi3XOfffL6fbBtNgAgAkikAAACSKTJK207y22y5mW2SVNAGZgF1tJXluJq23MzbbbamrbczAABJgGZhJJE0AGZgACakkzMkvzaSLb4mrbczJZbbU1bbmYSSRtHOJAGZh6ACa3EFXvOP22/W2wSS/W23539bTwAngPfg8OYW37nO5b3ve9721MAd72SSAABJu/fffG7uiAPEwA9TabONNgAAEkikkkniUkmZk9kkGrxW25mT9+bSUk6mqAZO9rTttqa9CTPO9oAJP1oJMzPAAE0AZmSSSJqSbO9wSaRdbSVt6mqW3s70C2pqk9ne5QASZJMzNkkiaONNLk7975J9+Xc+zz1fc53nOc7ei22g9AAHltq2+c5zgAHoPgAC3V1mSS85zj92He6973ve973vQAED8P3o3vdtvZk7A3vb+5mSTve+TJ6G97BMl3dzM3d3U0cUkmZlAImpJMzIAAmgDMwC62krb1NeW25mW221NAGZgAAkwDMwAATW5M+SO9D0/BO7u7oPPQfgB5b0tvO6tt73ve97073ve96Lbbegtt5znFtoA7mTM70AAJJIpJJJJJmZJJIJoAzMAutpK8txtW25mW222pq23zvUu20CJoAzEsC221pW25iy0+A67xqK3L53LbbdTUQYedwADU0QM4AEbRwgZwAImt4mmyHF4H6q227fs4YSUA9AD0HnwS/zvX6TJB5P2u9H6TJE6b9IPZMk6S+22+SZJ0En7I5JPvdzd8G03JIABA42mwNPW0kdAAaaXyOHG4pPJJqTSnPZJnJJIJrZMmckl1tJBir4mqW5iy220TQB53AJPk1qkyedySSXU0QMzAABJgGZgAAmgDMwAATQBmYAAJq225mW221te7O+XN871JN+79ff3tvn6bafpBgfj0DoB8TJJJJJ5IB+k5O7s93Tz0Lf4ejr63oegl3bec+47mTMabTckAAJu7u7u7JJIpJKyHAOcAIVtJW4mttvOdu222pq285aHwHU0Ba+9y222pqhcy2221NUwzgABE0Bb3uW221NdoF73tttqaJJmZJKAkwDMwAAaWkWZxLhnQAJZJJ7/d/v7+/vP7+/v7+AB6FtLbfgEmSHe9+73vfS223oc95znOcF7JmY1uTJIcPDiabA62myE8bTYAetps5ecSTdtttyq2ST6STMySSQqSttzMttkbSVuJrttuZltttTQHTvcAJqaADMwABJySZmSSSJqSTMySQYJoAzMAJE1QDMwABNSSZmSSEbSVuJPz4P3c9QuNJvnyn3vn5bt/CX331kgSoA8QW29AINNgGAB8T3fJN3d++++yBAtttW222g5zm5Mk5+/fj9b3MTcMA62mwAAIwA9bTYACAJQAMzD4AKmrb297lACJoAzMAAEmAZmAACaAMzAABNAGZgF1tJBiavLbc3vbbaJoJMzJJJEnJJmZJKwE0AZmASRNfcibR5jSb8wQJT6dzOASwuyCvm+3dHrH8u+Kq42wnbupnb2duxIPdrr4YerLh5HyPfPGbwCJs8QmAALMqDAAO+5eudv1wugATnmcFXQjpkrq0MXWtkjgrbRxU5rYJylY2uGmXNxbnDmts03OUjkTYlaUOoItXd3u7uwEsBYIjIqbWVd3qxfskzNZIyaHwBDeZJLbzMuZmM22ktSbhon2dNdOIuM5WTM8m8kkzJpyHBMmYfD18H4Vq7uxQdRoWILAiIBd3e7u27dWCAmDFX3Xe96iO9+4F3r29e97vtILdIV867qDuql3SuO2pJwlajdORFwIqQVZ+fe9d+7dqLWoJU73v16/PskzD0+HzB6D19MzJjJkyZQiyELJLve7u8XEFiC2grICtxBalXeu97XeggBAAMmDChiHe9tytPckzLJjQ+VFkaAJ7/ZJmaxB973va973faQWCA0kIkCQgQQzNW362kbAfh4W32232h6D4PFjQ/DYDgbW239bQBoANAHDYD9bu2234PQeh7bb5Q8fhtAOGgCoACdSTM1oB3ugDhs1omhL77bfb9a873ve97zsZkk8stt++lvXvwei2222utZGsb3knmpLqd8nv3f3e/eRb7b+t6c1qGwJ2ZrMkn79+/fvu8kne973ve979IffW333lG3wcNlttttABNZkksmSfTvn28kzOe89+5296AEiZ+1P37977mZLfP379bQA+fbuuecttPgH43mSQAUAEjzMkltt+to/e/r2d33993ney22229/Dw/IeW2221P2h6C5kiZJmamZNatttvMugBC2222gLJ+jYDuSZn292NHed73smTLE03mSQtts5qW7zJJQOAsmSWTJN7t5dW8SnweyZIHxvnOc4t2A9mTMB8zzsmZk+++nmTJmane9972jve9ABbbbbZMyZAAAHgH4bkzMAcNy2lA73vc933N5vVKBd3y9S8CL4BexDM7373u8ySd5Xu7bb1w3MmYA4AB5APw3mTMC/ry+W2gAC2222tTeZMwByuzMkzmazJmd593v7md/d7fuGwAAABvMmYVqTJBw1N5kzB+kmc19+5+zOa4AsaAtttttttttO5MySd73ve97291NIPnCbfA9Ylt+1JklttAB4I+OQ5+J4BwmTM3MmSMmTJmtZGDBBaGlVKjJogCG8XdauAhd8OQfj8fZJmazT09aHPckzOc3znX7n7zz+Hnu79oUklSadatvnjV229tts9SaQeg9C23+t3q3vne973v4Atttu7JJPvvvvmml999JJJOSSVppW20P33OJJu9ttttlDogDVVbO+JJ85znOW254vO+d6dM2W0bBtTYTZVsZ7772Qd6zW1tmqTai2JmtrWm20bMzW2q2of39yrrTZbLTVbNZtmmm2zbTaxpmGc4ZzMzOHDnAGMxjJJN3Z/SW2pq29ve5QAiaAMzAABJgGZgAAneW25mW22iaAMzAABNW23My0ATVAMzAAE1QDMwABNcuuZ074B1fHxN7yfZJBHwHQAnsknkkk8gtt9kyTnOebSA+kyQeW232TJFt9tt8kyQVr7Jlu79Lqec3x7baAFONpKSSSDaSINNI8BC4AaGfps7mZJHLUk1bjattz7vbQBNBJmZJJIk5JMzJKAJoAzMAAE0AZmAFjaStxNW25mfW221NW25mAACTAMzAAB7xsOmZgAAmp+8nWs7+L9xN8S40ml++t2wtAAPyPpOZJJNN2mAAeBJtmSbvm6Hkknu7U55J7ITzdgAeAH32fffv3hBtNySeXnEk3bb62m7cvE03bQACSSSKTJJJJ9MzJJLW0lbiattzMttttTVtuZltuhiaAMzAABJgGZgAAmgDMwAATQThgBY2krcTUtvPvO2221NWzhgBoYpx840YMzMAAHeNTj7x+cSTd4kk33PWr+t8tvaHWzgB40cPsky+AGhe2SSa16F9tvnO29712770C1bbbaOG0mlu7v33303ROcxJpQAA0kkkLziSbtoAI3dlh3EmlbTly22gmgnDAABNAGZgBY2krcTVtufd7bbbU1aGZgBoYmgDMwAASYBmYAAJoAzMAAE0AZmAFjaStxNW259jH333333wneVV+z32tFxzjc1s+2Gta65hJI/12W221sDqPpPGlfAALbJJJPJJLefv3OceWgAW2220HOc3zWZJP379J7u6NJNoAAAkg2mwAkk1bu7W7DgBmYBKGJoAzMAAEmAZmAACaAMzAABNAGZgBY2krcTVtufd7bbbU1aGZhgGhiaDTMwAASYBmYAAJoAzMAAE1nfOonx++976H03Qttttv42vskkn0kkkk8kk3u/fvP35bRbbbattttBznOcyZJznAkkkkkrabONNu84km7bbbbu7zeat3ds+kkzMkkK2krcTVtufd7bbbU1aGZgAAkwDMwAATQBmYABXU1x8STttzMttkbSVvepK23Pe9tttqatDMwAASYBmYAAJoAzMAAE159sWdO+eB7+A+95WHQCr7iDuSSSX81knDwfj573vS89kyTmtd3qOc7b+kyRc3m7u7+SaUiUnkGgD1JpEOHjTzebzb9z3nfbbQAeAfvpax3Mkn0aHtS0CW5mW2FbSVuJq23My7bbamrb297QAiagHcwLbbU1QuZaH4BJgfszAABNAGZgAAmgDMAAE1Lx23uZltttTXyQdPO5iALqTStxNfuRXFnO9/X239bqtySCAPpMk3d305JPAehZddLfud74tvbbbfrXEnzz+70AA+++79+/dJu7skkkkDiabAACbu/fffG7+SW7O5e9QAFTVoed6ABqaJDzvepNIACJoAzMAAEmAZmAACaAFmAACaJDMwAsbSVuJq0vMz6222pqhcwD0ASqXFbdWZbbaJzWfp57q+53bvO9LGgDhsD4PQPhZec/fLxdWrbbbSAAJMk1bbzn7i23cmSAOHZ3s73vf6f39bu/fb97bJPpmST2SVNAfZgBaNpK8TQqZc+tttqalL550ADU0aGAACTI4ZgAAmjQzAABNEhmAACavbbczLbbU1JJ53i7zvJJC/kmleJrOfKVF601+Qs53PPy8a/e+++39bqvJJJJPpMkgAB8eLLb9z9zybA59bfPbbfW7u7v282SffffdaaX79+k93dlAAA4k0iTRtNyTYm0pJN3d3fysl8xLMAAqaAMWYAANqLhgc4AAJqI4HOAACaAPFnFgAX5tJXiay23nLbbamgDnAABJw4HOAACaAOcAAE1EcDy97bbftbSV4mvFPbnPbvJ3zy+X6dSSVZk1l373XOOwEu92QAlsAgqct1ugJeQsmsyNjo727nojKvWgS3I56aQU7NjYudunTvPm/M2NA9ojAErQJX6fny68K2JuYKDqggiI6drGexxx7YjzYCUG/Y13WZkn7f3nNyZnnlu197zro0AU/ZmZmd3d3TTqve2Lc+rdPi8eNIbiIfB8+T73u+vqHRFsRYItCALICLESucm2NsJhWis1KxmTbNZmzW5rmNpsqtFZtTVCSru7u77YiyEUGApAQigsAzNZNamamsk8k1sCgge5kkOSZGyKAQUALrV3fe9FAOE6otCprUkzMmtb3u20PQfBJJnmAfoMzJmWakzJjYC5NRsttu47JMzZloL4xXt+9z3u2yCLGAKDYqCVQwFEiIskgISEVoGVPx73vevzcmZne72Crxt4AzJkzP2slySfeePXpwTJEmc1OebPvgqTJJ5NTMkzPteD68tnlzNzJMm9btpw3sBb5iA/B/TM8mS52d33ve871mZka1bbbRsB+HhbfbbfaHoPg8A/DWTM2A5PK8zJIP1v6232h8APMGq0/BXDYD9bu2234PQeh7bb7v221z8rYDhoAqAAltttsNAHDZ5m9kEfUe/B98HwW2220Afmrq2239e3Wtbu/NTPda1N6nb377937ve/agfAbDvQ09USaX78v378fJ/YAAGyTd3d3d2TkgFcurbbaAF3qdkmZ9qayTM1f21Gb898987u7u7u3yRTOalk5KoaKY2wmIIahrSiSCWiSIBtjlENpTIw7p/cOUARN3LznPucWgAttttoAGW22W2m+973ve9vfJZbb9begage23y7tt+l1G1fBcyZMj3aW363mTJJkuqAA/Dz0Hwe4mlJJJJBNNgAegHn6Sdnv33v32fffSTu7u7u5xOIQYhBiEEoQbVVV5vd3dwAfuXW7bfLd5kkD16eG8ySPzxnftSxJknn6b7zf073eZJOdvRwAABmSZgAAAAN5kzAHHreZMxb9beWgD3skzN/vfJMmZ2d739VW229AAazJmAFAAC2222g3mTMAcLbbbuyTsmNpKSTwTaQAABJJJJJxY+ALdTMyZLbbbypMzAADnOc5znANZkzA/G8ySNXQBQ2bbSUkk9Qkm/wcDwAO7F9Jk7+kkn6Se+2fffsySWe985znL2uitSZIAAu7u7u7u762RgKyMIisQW0FiK4YFxE5SU4KtA8Nzr6freZmSZN3dtpSQAc5zvtvjU9n5k79rMkj0c6RoA4bFttttD4WXnJP36744b/ORo3JkgDlttttPXOec5kyTnOAAALbbbbu7u7v7dkz+HegAVJK0MzAABJgGZgAA1eK23My220TQBmYAW2pq23My20tqattzMttsOJoAzMACHE0AZmABDiaAMzAAhxNeffp53w8PD793vfzRsHDYttttqtPhz9+nkmSffb7O3rve/pMkN222/SZJ26t91bb7JknJJ5u4093e7pD0A8AkPwdACSTd3dkk62kpJFIGZgSSDSVXGrbczLfyVt8rnMozLbd3bbb2s5y8wZy23d222y8Tda5bbmZbbZeJO8dtuZlttl4k0AZmAACaAMzAABNAGZgAVDV42rbczLbbbU1+8q3Fzudtv79bpJIDhsW36TJLq3dofDl/jnvkmSfuvfbrnb0cNv2zy23lt/C2339+3xbaAAtYBpwCh/eeed73vepkAPO96ABE0Aed70ACJoA873oAETQB53vQAImgDzvegARtAGZgAA7+4sTVtuZl+ttE2wDPO9DwC+NpK8TazjTdtuZntttv6t+eecl4r574/3PPbbdNOSSSSfSZAJBgBJ9JPZJ98b+++53zpe223l1attttoSZJbbznOLbdyZIPI0PB3vQFvY9B9A3vckkgkwDMwAATQBmYAANoA87xXzy227vG0leJq23Mz9bbbU1bb53vQAImgDMwAASYBmYAAJqSZmSSSRNBgd73neIAPbxtJXjahFaefc/e/p+z3333+5/f1aAOGxbbbbX4fvT9zn33Na/KsOW2+y23v3Rw2t6LbfJMk5znH1tAAW225Mkto2HPuXve7u7pU1WB53vQAImpJmZJJJEnJMzJJJImgDMwAATQBmedAC/NpK8TVtuZlVtttTXyttzMtthxNCAPe96AGpqSdne5JJNTVSTf7piXuNAf37+/rWgDhsW2220Ph+5z76fJOOWrZLbbatttto5znOZMk5/W973ve96BTWZJAHA2A4G97ttok5JMzJJJE0AGZgADqXEGMO9fe4AT1tJHE1VxW25mW22iaAMzLbbDiaA6d7gAETQBmYAAJMAzMAAE0AZwAATU93PPyzO+Cf5tJH70OfufQ8Ps5JmySfSZJJQAACSeyT79nnEgKc8E529naCDfBHve97180gPej3ve3zeNpKSbu7v331AAEBIBJJJN0kkkkk5BSSZyT9sl8SaV4mqW5y3bframrfe3vctAImgDMwAIcTQYHeAARNRoMMzAABJ6mGGZgAAmtTDDMwAASYBnPDiAL62krxNUtzHn3333333wm8+qsDpBYifRBa1t+ygge49yKPv33o91f1UaQaKyKHeJV7/coTsViFdaivcVXuRXuSvKjUIe6lE5Faj3QFxFYD3PcU9+++9oms7iTVtoECSSSeyT7fr+9Et/fGhqX9kySYAvdW2229Oc5z1znni20AttttoBWnckn9MkzNayTM1man9uNpJLGk3xtNIAzMACXiaA6Z3ASAImoGGcBHwHU16iBnAAG0LhAzFhgBE0BpmYAA0vpMmckksbSRx5xMgZwAgJogZjTSwwDZxNX8GeHe4AGpr3PM7zkzmT33zxJtOtJvjXob3XkVjRXuivfvaPc/veUXPkVxFPffenuKvdSvfyK4PffvvvxC/Jpt+eW22376ySRSezd+jaS+9998WNpL8XVfrJbbbV9tt9ttdzJM33smSBec5223vkmSA+atYA4PQfdzMxhioBkXenWmkB21JgGfsAPgTQeKZySSRNCIIz3AC/m0leJogZmAACaAOZhWmlbZ4YmiC6d/YAGpodb0BmS91rfe+93rve96mRTegJMsR3mhFmDeOdoBcwc4MZ3NPyCwAZ/aqV8+cu6LBGy0VvNUHz3lU/dUPKplTQ0p7/f3vcq8itJorBorAYVtpNFYaK0F1770FXuR7kke6L5pN8TStsvrbavbbQCTd3d33d3fd+/fv3P3OW+87MlnWgdd70C3ttt8yZJznOzJMzr8N973o5bbbbRo3mSQOogfILABR++p7mlA973qrJEQx7zTSA7dTQBnMPgLamrS5mUDZxNVAGcAP0OJrJM7O8kk/JqTZM5BppAdG1qkyZyfv0k6mhk6HeEk+TQpvZO87u7RHt96H73veQfK94oQlAxaZvBlQVs831OxCXZ8kBKLdzBA/MpybRI2SAsmdzNYvfMP3sYbBDUQXFRRH9gH+KL/E0Nj/D9D9wyP3/nJVRFuKimf0R+c/yyf0j/HB87f/24JP9uey/q63+f5h/ktz9e3x839Vb/j3vfW6j+g/u/u/4f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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
