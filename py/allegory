#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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vak50IxpAVSQgK3pqQH3Oriy5aQF/c2qfkZ3IB6B9iO5zuXE7m3y1fX79eBpvxAv1tt+tv5OSSfSeNqW/rfGrjVvlvP3trvtzls9ttv1rSSbaSy39fr9bvzXJ43N++9klv1xu/efrb7btfq3H+xvd83fPtv4y2323y2/rfEzJJJ9MamKl/W2364rb+AD4PAv622/XLbfUvEnm75ua00002095vttt+uW2+211N+gjMSWLOeJeZjzMjDzSpttg+OIaaaVtg5JY0UDG2A2NgNjQhtIbSTGmwG2xxwZTgAMGwaabG2DSY0NwkjcI0aybWNW1tbLLDNs1azWWZix/lnmLPDTml+ttv1tt+aRiUkkkpQAABySdA7b3vve9t+tv5+JM8cknsxJtPZT222/XGmkqkk2m0rb7QPTLzxW2+/ctt59bbfvuAe+gBbaD5mZmX9c/Pz8+/zvflK7G22VLwq1yUymbSWLM8kgW0TuZltoWTMx5JJJaAAAUTVy2222JowAD0Im0uU4egFoXltvttiMSxJ4vcTYAcCK5bbfknb47bbZodtu23t+oAAB2gAB/VJjS7bbbb+A7bdtv62h4c8SYAmkhJpZmZ8AARNJCaSvjSafmZltVxJ22gEAPS228ttoAAX9bbbdtC22222jaA/B4kwl9AALQAADxEkk5JibuIv6220tFbQA8aaRJKGngeJMAPvJJJOSH8t7400u973ne96fJM1JndzMN8bkwHo5w3Jgdnr9J+xe+e57bbeUv60uNO22+JtIkkU5PyTkAOAABfcTSfMSmfsXiTS400016smdufycqt152KrypqHe64f3bMaP4RDG4lA/kUZrX8ap+GmRIQmNCAY+sdUMpxQOUBGH5lCCordDa2zM2G8E6lqqTaFDzULvwHfP5E2200lxJmJLzMTWM88nJINpJC7lJKuhV3ne9736p3FJNpeYk8wxph+PfWmkzDEiECTd3xvckxtJTG0kBwDz1rMWetPQDeaZ5i+87RXYxyCIhUyPrL73nt6IDs5znO9DWzMfX1X27e37p37pTvfb77boxVUtttpkw5A8AVqqqgAMAALbbbnwS3nqcdcc75tRWxNqU+aqtlFzXNQ1gWc4BetLmCPMoO8K2KidYnuIHLJJsJ0mIbXdNLz194nnfbzjgr2l9XBRPrEk2kBXNX1y2/WuZManltvnbpkxkkkyRsB9kY0cPzSXuNptNGNsxtfHhhxph5JyYpjbbcyYkm1MSTaSAANMYeAB9FVuSTJk2HJ5kzwANtoAfAAAAAW220AACAAFtttMmAAFA+fPnz2pQ81R3kJ7qpT9tNnO/fW2mm1zG0mk599FzkgIkkkkTTbgAGnMzJIBXe973ttDw+H3jd3V3d3dJMmSU84AGgABbbbSAAFttttttoAAEzDgABaAHwHe972Zkku95JMxkk5zmZJJmA26H1kkkTSahJJJGpPGjE2kYzEHjbAW3sy3eZJLq6kmZdTMkgDoBaqtkyZNPOABoAAW220gABbbbSZgABQAAtttIAAW220zJN5EJXsXGgR4Q8283EIQIzMzu9773vTMA9MkzAFtrkkkgHwzIPskzIfczJI+3qTG8ySNTMknr0Om7u7rFVbmZMzNPMmcADQDAC25baQCAH1tttlttpbbb3ve9t5bbaX333334qD8tFP2pYtVAX3EzKgH1L7PXB8wtttsl3uZkkuhyC+Ftty23camZJAPgBvJm7u7u3MkzJieSXwASW22ktttMmWgAZkOAAFttpAAC222kzAAAkwAAJmSTck5kvMkyc5kyRfR4tVrJltt7dGpMaAfNSYfcHhbrd3dWmwAMQeGNMzySeyTYAH3Gm98gAanAAKAAd73vehwADve96U8AAIAAW223ve96UJvwnfPskkkl99ftfWjVttvt7koFtrmZJxuA6vQqHmZJNVbuu7u7r1Xft3eyW226SW22hkAAsy220tttpkwAoQACy222y22gQALZMzHzzNnPffMkkmRr7E03ixNJpJTG3J7Dx6EJySSRJKVbbbbdxqZkkNh97qTDkmctvfe93kmTNVd01VVXdXY5zkMzJknIB03pOW2oW2222222220AAAAAAAAAAAAADp9JkkvPOL5Jkgdm78mk22vvvuc5IAB4kwAE20bFJJLbtrJMmNZJJMB6MyB52XVvltrd1d3d3d01S5JmZJect0NAAAAAAAAAAAAAAAAAAAAAOc5zd3nBJAfvp/ABsdOoVUGAJt07BJ/pX7BAYxjEBQgKEBNoQEnM932e90BeSAd5EgO6IDbuvZTvnaRjO6RFumBgJ09uLGNkZxkdNN7stitjddOjrdypG0VJbm22NvNeZFbGNKqJ1rUIGLGNja467lGjGw60cdMYwFGB2oGCAsQEb7+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+7ZJLEnu7u7uprd3Y05JE10D96kySHya4sR4AGsybNVVZMAACZAByYqzIrv0TJIfJo0DgAmvflpn0/NP36Tl7q0RjT8PgPhfEF5iT+P3uFvbfUnzbU3b99e/v3uezved73vnQAfZMHPob23beW7i9l5ntnJLqa3d3d3szE3mKSQaYAxsLasyW15JgeTIjoCZL3ve972TADcmKsyfKqozIqqkyO+bTw0eX75+/gDpsDltt9torTJlY0wDtttttuABkmySPYBO+ySSWSYB++kxV+mTqruTN3dmRVAWTFVUmRiqqyYBv0mKv0yNV3Jm7upokm7siTkkkmpqd/eVfv0t873J3s9DhDgttttW/wH79+/LbbbaAAkkk3SXz685y2JPd7+Se7unyaADjTj9GScnJyTmc5Jmqmu7uZFqoTGKu7rJgb7Jhb7MjkAAJkN5kXw1XMnzWbv7Y05IIbR77oeznvfpJP25vPqbDtAW222rbbbQdurbbaAAkkk3SVJtP79fvrdSe8i76k5JPU0INd3d2ZFKgZk94BuTFSZDoAEmFd+kxV+mTTm767u7syVUAky27kwD4n3+/evf764FXeIdZRddcfch2l0SgCA5WVfvc02u9u/vCA18YID2znm/dIdxZD5qV+xHzed+XSG0EBj7eVHlUernN7l+8+GiAggGkBiQDsbMfqlbDrzI20gGxAV3d97OiA4LrRznkFWyc7QZ3XVsjQN8ap4xtNp1EJCIxAMQFdvOYDTQx9ekrbbQgA8rXvPt/fO92B779rjpfHx153KXzUPNFOao2obLLUNKyg5yk4iuMK40q1No2LYVsoayaxbG1ssymxlDaGoag4XKhxiNE0jIYyhrKNqS2IaxiwVlqh7qHPeSO9dPeIHMbCLVVmmoahlQ9951i2EZ5XIr7pL9id4k+84qZDUF4x+0hzJP3fSnJJJkDdt72e96oBHukH3w8AAttttoAttttoA7LkygPqAePpmc+++56KgAeW2+W2gAwA9DwBv332+ffL973ve973veOajmRtEY2kgjgMI2xRtNPXBsGNMZQA2hxQGwIRNkG5yik0MdEaE1JIpGAyMbbag20o4NkQ2mySrvnPe973ve973lxICM5zve/dcA+BAQPJMB6Ied73ne/d0AfDltt5bafAHe973veuAEa9w984Tn262ktTaWNN7nnmkgHwDwW2220AFttttAAttttoD03JhzMm8ybzJzMlttvlvtPnoB93Xe973oMmYmTWTMzQA03oeh4kyQArRuTC23620O+FXaVu973veeeSryKaVZrFTWrb9aANjcW/W/W0ABbbdZmZMttA1kwAAAAAAAAAAAAAVoA0QCq0AADWTJBzzzzwHhuTBwAAAHe973vfL7TvnPnxxhXLCrKW5WchbJKxqtCcyqXnnnzv53t59/PPtfYsSfV4+Yl3m39b3vaAASSSSEoAH79+Lbbba61JjUALQXy6kz6/1/aR85U7/v2XUeDMUKM1NN76zGnzG2T9PUnJJ6mhASACamyTd1J7zdEnJIZmJLNNACJCSmnvqTiv0ybN3Vd3ZkUC2ZHnOAbJipMi9l/efvPDEmHgdPV+Fb5cSf1tlvK0pUrjTtoM1yd/Jsrbu+Xve3nbfU6BbbJ+uX9L8rn4qlvFGmYB+m7Z6v3qXlz6/c3+JML+9kwA+mRvFVWZLdACTABky22ZL7bbbZks715JltvkyIAJkVACTADcmKsyeHgnsnk+5znO++zn39z3efH2q+/jmAfEIHL+Zoc+H622tM8AANAAO227TwJI5Ka0+77u7tsbU3zqmeJOZMX6T8mj3APQATUUAJMANkxVmR6qqzec5nOZmbzx8m9SXe5Murq33k1rI3NDwPGSW223sT3d0ackia7iaS8raS8XViaS989782+97h3vkPrRc9A9JJOgBaraAABJJbbQAAFttnf3ff1tv6zJf63fiTmSeTE0IAABNSTd3dSZJJJImu973ve9mSy7uq3JgeSZbbQTILbJEnJJJJG1J9p3E0l599z9z32+363vQAAyStNJABCkmkklCkkkkoQySSSSAEknLy7u7bE1JPz6eJMPGYY8gATILbbcye6tttvZk73tttsyXVteSYHkye60OAT7IAJMskkkia3e575v5e/JtKtpLE0km8WNNpMy2TNaMUrZraxtKH8xNpNrxt/ve93ve/d6AADTDqXczH3vO973v1kkEAe9tDgH6SWpK21ABJJStN2hxpnEYkk+Xd5yyJqSTvyTAPVkFAmQW22yZbbbbZkttttsyXVteSYHkyCgTILbbZMttt73ol5pDY0gKiUGhjTY2I/MD9SgfsiSERiSE6SX79R+2CX5/mq/Z+/Z7LlMzn5p+AT0zraS0ACikibgn3MWXLfb3q4k87y1N278AjtLibv0k/SSQAkmT1uprLz7nLYmpJO/JMA9TRwAA2ZNVVWTFVVZkVVVmRXd52TA8mR8AZItttpNamtSZrWQI973vAb6AvzEorgEHBAMKqH329++nz+/ABBrJgPrby22hkwjwA+CGEgAAbC+Wu23s3d5zvdTQpJvZM3d36ZGVVVmRwAAkwgABMmsVVZkTw3yTFX6ZNlVVZk2ABupPnN3d3U1E0l5nnlttKss7wD8AElQGAF0zQAC2yQAAttJJJJIASSTbtkklia3d76k5JPU0LgAALJqqqyYqqrMiqqsyKu9kzd15Mj4AmRbbbbJltttta1qak5uQn5t9z977++6vs+7y+d83u0IAElaSAALEB+SAPTG2ZbQAgBbbYpJJJKBJJNTd2ySSxNSTpnyTAPU0cAN3dmTVVVkxVVWZFVVZkVd7JgeTI+AJkW222yZbbbbZM813fP7+kMQxWKz+oah5746Q8Q6+772o52h/PH8Q8ocyHXYkokAz11QPOwzfV3b77ONeYIMM5wsKztW1+dsOeJn2FBQgGCCCAZ6lR0cByQ9fea5W51vZmEd4uIEjqSTG1sNpqPaG1lWobKGKOTAXKLIpqHHJi0qrKcoXXCOFDIrUPucoaGCsVc+qKchynKqcMqV87dWJZQ1RWhrqgvHHVDEdQx7iU6oaUdW5Q/nBKu9El1Q+HkHR3lLvaxlsUyqtEujiVYjKDZluUNyTjgnCtg4HpunXFDH7jqoZszWKxZDoj3ojzUOzmXKhlDBlTucJXE5zmKsVczYmzGXNU4Zd56TXpTahW1DIHCrVzW0l21w6oc5pZrbZNmZQyjCN1ziWQ2bKjqhlH7oU6jW+ZLj7xPKGq/duknzbkmZ8183mST3Jlveed733p7vj0deEGn2gKAJMAAAttttoNnh97be++20HoeEmdvN53ve896tfAHe973veg2AnQAAAI0zd3d3mgAAAKTUvsSbWNY0o1vUmpqSZGpMmb3vNaPDoAPO97zve9AB8u7bbaADve973vQALbbbNatAYHne95mZJO970CNmNZgASak2lMkkgESa4sZgegvckuatttPhwHcurbba9saPAVoArQAd73ve96Ld2g773q3cmW3l0K0AMW2220AgOW2322guSZMaAvcyTM9mprJrNauat8tozMkgGg3be2/avMmSUH1Atvh9of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Peu1DupXcjt1EuCMj3l2R1UGiaRvMn7lD94/dIPaI6I2Z66I6odBWyjrEc+8KHEn106R1uvKHhfsedRLGkBEgUQxoY2MK9722MF585fOc+32AdNbofPV8eAC6tstt77A89DxbbbbR56Hnr3du75bfaFrezbuTOe+e89OgA9k8e2+372+Wj0C2222gB9999873YADvezPNTw88kmDzvegA5O973zve+A9A9t3Jl1bbQAfZ3Xe973oB6ALbQPhxv5d2362gn2h4EmtpRNpLE2sySSARmABurd3d0AB2S6tttqz1sehMzLE03JgBLqG5MAZMve973vaAPQ8yYt8tt8tAAjyTJL7mS2++W0AAAAAAEyZMAAAcW2+23czJL4bkwc6641xuTFvLeW+W7kw68ckyQD60A6bkyQB03bbb9byAXrbeTJBbfrbaAAttttoam8mSPK0Pe1WgAAB9k++++++jUmAbyZIUOmpvJklttv3bcxoAp5+7fe972M6hZG22+ScSAYIVpISycpllDquUXNbfGkd7zah5ZMkdfS9d4X8/pmZ5k5zJ00P2/jv9QD9qySSABJJPZu+HsknAACSVt9ttv3MxNJXvbbeiET2fKSfn3GzG0sxLMeLJMfFVWZEAAkwAAJkAACZAABZmRX5VZkVACTAAAmQAN3U1X+W4l5ni1eqc/b5+afe+a2+XSfNOS873vbky2npd5Mtvbr3q+y6+1bvgAAAAE6HUneTOzzzzd50E2pJJJImlVUzIAAEmAABMgAATIAALMyPiqrMiAASXmYeW23MgXv59++f5Z98bjbxLEk0ve+PzaX6d3ebZu8Kn0ACmS20AAbUlPGmfIARWmlLb73MTSVtvzTS73zuJNLve20CcOXnOXiyW22pMgegH5mZHxVVhOTnFALDk5yc5OcZFVR5OcnOTnIycX1VWc5OTmclki+KrGck5OYoAGTOHPJzzzJzzY05JImueeJ8xNpP733W7ibMXLKTv0rT3d7JOzd3d3SAAB6kwk9kkkklTM8aYH5B5bf1PgP17mJpK2/ernf3Oc7HkAACTOgAEyWgATJ0ABZmQ8AFZk8QAMyW20CTAAtmQgAHBHTkk197Zxy3ebgNNjba9EGtBWYHe4pznO7zb2eqST2QDQAA3ZJJJJJK22mAW22gVppW20aedbpN3ndszIeAATIW22yZb/ABMgAWzIAALMyHgHgEyH1tQkwALZktttsa898WeXvtCynqTt70khJJAAAAAkkk3SSSSQAEBoHWmlcbaXcxNJedxJ973ve9779n3330vWmpJPpJ+UTkkkmzIACrMiqgSYAAEyAABMgAATIqqrmQAAXMyezSfZ9N5P77dh2NPb57nUAcONMD85JINMA9K1Q9aZDD3zcVkk+kkkkkoAAAHpnc6pnOeSecAD85kQADMgAATIAAEmAABMgAATIAALMyK/KrMioASYAAEyfjz7hzknvv2/3J/fj9+4/tTQgBJLJJIAj920ADdsn5pySTPpJJNoBbiTStttt+f33331E1q3d3d7E8ivyqzIzigFyS222x5zk5OQAC4Tk5xVVHgADEABeQ4cAHuTNd53M3s8H39/W29urbaAHoAu6SfpJA4B40wA+DwOq223q71ec5znL+tttv9AAC2220hyAA2TOKqttttYAAW220FVWuTP69N0n32T77fve/vvff39p/ctv6Zj0PAAAW223MluxwPAbAdAfsmSfv35kzsPz6B+LbLbv3AACW22973vettttAAG222kAALaAB7939++e9372ZJLyS65z92vsBBe89zyQHOCAcu52PN533jTzznyTSny9SxLc34Tf4993n7JnxdlvlXogPkgOV3l89y0RkdjJ2LHr6Z3rEBznMl89/dp72ngPD4fec19r77z770bHxnL+tt5Z5bmP1J/DSEml6k0sSaXjaqbCNEc5NsbZGQ1DaRpmTbNtZrW5rmNptNQ0jam65zSNKym1QyGjYbXZ2q40plAzdSOKmylbPnRFzJXbs9+cvKHnMbEa0IchziyS0RtZXC3lqjm/dpH7HYe9dLwuZ+3Sp8agI8zbEIiElC/RB1XxoFte9k8PyA73vne/duzYIGvLbfPbXAC2222gAAA8B7yy2322hwD6zM+7rve9nVNgOmTO973ve9DYA7dW3do9Ngne973vegAe5mpHmdaplZSsaHcGFSEajDSyiTmsnJvcmtamuZN61mc5NZvlvv3QANW223tAAttttoAXve973qgAttQHoAbyYttv1vKPZdRvp6QuSZMaALkkkxoDzcmd73zvXbt4D0PMzAeh4D0Lbbbb02APeZk75mTzMjMjx0AAA+77mT7fO8873oADxvREfBY83s3Jg6fAAAAAZmSQAAAAG8mSAOmsmSBRUCgALbbbaABrJki223toADdttv1oG8mSAAPTcmF4AC2222gBqbzQffSZkz3330dJmSAAtttto6byYbbyZIF9mZ77378dl1L778l7fGso2s1RqH2hqHDSOKuSK4Uak8uVD37306r5ivPfDueZX5ncp+aj5snvvfQ9/j+q/eqvVf5VVXd1VWBq22gABpqTAHvvvvvvf0yT+mskVVR5zkiqqSOTnOTFVUkcnFVUjzFVxTJAAgeW222W22rMWSSTNxpYcUzfd53jT7POoADrTtv4QAfNMCH3gAvWmB8fSeyShbbbaFtv60uW22l7zxp75u87znOcm7u7u7u+bu7vQ8ADoeAB0PAA6Hltv1vlAO/A+pP3E5J9OSeed5meeUN5Jk9nbaQAJKACAX2222ltHAPgAbulttu+foAAZbbaS8n4AGByTPMyK9VQLb37573wOAdDve96UOe8OQA9mJPerO339bbTtskkkkJJJJIAEkm7un5pySBwPQA+AAAAN7u7u7e7bbTJbbaEzgABMttt6W21smDFVQABlAAtttpDwp595Pfu/1tqvehJJJJCSSgBbbZJI2pPJD96AfHAPDEmABwEAAG3ec5y/TnOfuc1Lcz4APxMwVVbbbWVmYHgHt5bbSAAF73ve0nADoPuTOTJJ7Ofzu7sN/frofgAAJJJJIAEkm7uknQttt8tN3dN3d3d3dWgH5/vwqh2220gAB3ve96E4AB3ve97ZTMw9OAP0mIqqXd3dnFiTvYi8/W2k7iTufST9IGJMPAAPjEmB+AP0xJyT9u6STpbbbbQtttttoE6dJJO1c5zm7vOc599zVm7u7v33e973ve97pkwAAqADAAC222nfue7nS+0MobVBahoA/uqHCrEKsyFLFWoGilibbMbSSOG4He970gAE6222u2239+/fmgW9ve96ocHgPQADz8H6irYqxrIVirJPzd73u7+ttttAANJMVVUAAYAAW220gABbbbSTDkAAfP5nOHvkmTJ9QxahjKGR/dK5Q0qmNpLElfG35jaSxO8tlve9GmAAAS2220Fv7JmFtv4t/AAAbu7r/SZk/Kq/gAAQAAgABbbbQAOh4AAAABbbbSAABe+ZMPfnKH99573vPez9QyqGlYi2WoaRNFhYNR/cJyhqNQwahkmQ2xNQwxtJYm023jaSxNLmNJ85y073tkkkkraKAASUACSNqTySfp80wKm0ly8tttoAEkkk2ttrraSxtppKSSP9bbagAFAABAAAAAAAAAAAAAAAAkyT9+8mX7fsnvvnPN3zjeCAfqlTkEBTrw+96+ve7wQDZO3VuecV184h426qrf7f939/zKmyilEYZ8EkOs9+P5Tf7nGVXHTaI0m1VRtxX+vUPe+ZD/XxD2h0zr5z8h8yA+CAcEBXBAVYgHlu/SUIDrgIbIZ1beod9UNpfdzK954rPku98Q67Q3fxDdodcQ55zrdodoc896Q6obrzdXHOUOkMyCqpCA50QEYJS6lglASliFGXd3zUOkN4h16huu+fuqjrzkjjwJTkIxAdYlOCA7bnMsoyXcq7zghbmXKztAgggPMS8kBUEpIIDvRA4h11uIbpDfHEO/EOfvEPOc0QD2+JAdwZO0UxtjY2IDRAT1KkgLa4aICbjeVSpt6XR7mpAe4ICaIDbEBzfciDjU6kBogPZWZzpBAZ4QGShAbWV3lpAXR0ggK7L519z3KlVjxvZt8i32Zknp3wgLSApsAT6hvvqHvSHamzIb8h86Q+e9ocLvPEM8VziHPlDniHWQ3OIdZD3Idd+/flPvvnBb38h+3zntDviHm7Q5dN8Q/ZW1xD9sySdZkktmSS/WcyhPez4vhZ95dd8O+dfqvEP37pQ9fEN9Q2Q67Q3xDeoeIc7Q551e/PiH32h5UOvqHSHXWI4h78/e1eoe/kNogNoQDYgHwQFwQDh4bzPWXkjOjIN+NqXu3o2xttjY2zkfnWsbIeZDfvBfecfkO+Ib58VczVbziu+8hvnaHfENz578K9uvyH6pYw3ogOXztw89fGY49G7ivaq5y9hje7GMe9ovJclPrm3TK72uZjQnssaYz3KptYYPlu+VTfbNODmXdEZT86qcdVnL7sx70gR5l0vXOjjGzMvt4+POxtR6zj25KhjASAQW02N09evZyUjjbj4249k684XWPuxa3nN53O8b104cjcMc41jrKqN0+0hB55vjrO5z0xluOnx9/XR3n1OJAdEnTfHMEB2nIW5mQQG3X26U9G22+yNPtpLDhxkeCA3MJjc+sSnnd8zkfYXzwgKxt4IBxt7WX6oY36R7frMuDfqibOvW+5XH1t2+ttvjj7U8xt3tXJJJJJBvslSSRnKeXx2/b2o8ce8cqS3ziQGiAfhAbggMYgNEBveCAxIDliArggHwMvM32e570zx5lzOe8dfsnNj852Tj7I5KlVUQ6ojvQD11Rex+Zwh71LN18vuYGUkBx1KntoatVzhrmWDfJnKEBNceVnuwbXNIVW8jwj3L0Zkd1mcEpywNGvOy+97zogHYgNA40a+vLfz5Vv39ez6Y23WfOuAlWU3K84exv4rvXkx9jb5JU9y+1Vc1a5uYWxvJ+9OJAd3johC3mTHp3nFSS7vkgMmcDHsjeW8GvVTo5WZIRmv18KONBwTdu2HWe9El2Rcbe3XZO9EB6tZrWO3beOM2r5ZnAd7V16yvZ6h8v1eEBp7dusdZRysjFmGoLbB02/uJAVU9ttuUbit3Kpvzj69y3cLVT7L+bZG2LPclLjK9I6bdeEBDXkuuiA7nNEBSHh7iGfUOcQ3nSHXSHrnEObr1DziHXaGyHXEN74h4rriG8856h9K589Q54LnXSvch52hxkPUPKHXqHXxDr4hZm76vp/j+L/r/3/H+3/398/t9++/uv8f/mKCskymsjuCkXoAykE3AKAIgCAAFVQYnkRAAKhKQAGg0BSqjBMCGjzFQkWLpg0ftFKEiwqUCCAlBw+opwZTrcIeYybG87Hfi7kinChISAinyA="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
