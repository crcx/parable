#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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oH4QU3yiXjrzz157888/eaK/qV6+v6kugGCILqTVf21858+X8+cL0qMGlF9Kl3e7LkmYu2wP7eSZnZMyZOGxx2SezAWAi2QZIRZDhBBa5V3rO7u7BL9bNtmI1B+wK91GhywChBfUgYIQgiCZzWPezd3xRVMHVESshUIIuMd73177fQF2RVR1PNyez6fQ9XjSbOAenwd/Cqq2222/PqXIm48BZkzDQBw2B3+/r/f395/f39/fz4PR7fbb9frTwD9/d7vve/G8ySeybnJIW2230AAAkUkkkk7NSSST9bu223+7zve+d73vXweh5xt4Ph/d96AATO973vZ9KYAAHSrVQAARqVAAAENBrzDgg9Fe6t+l79b7fLTW7u3l9tt9801qSckxtSTdwvGrpO3Lc81u3Zqpa9STVWlq73bst3fru1Jt5zNLXO5zmObDgrVw25rZuRXOc4d654TSaSfNJpPeauldL7VtOVaS1pAHAA8NJmtAcAOGjqzun55vaXhjRxJpZNTvd913rA82YBsAPGpqSblxs0gN223y6ttvlocBmbA2Htt95q22+W4wxGvud7hE9UNZQGlRqPlUREFxrWve+X813Te7u+d3d351lMJEfzYg1lZngY33cmtau7Zuc5206M2wzNhs0m1Nqs1sNtm5uM65zVWNjWtq28ccWabdOc5rccZWaRGYkIQyMjMxgxIgiIRNPi1mn6k0r2/S3z6wt9ttvl1VcdMTNSScTaT72yUAEkkgAEqAcAPAtvlAPADic1JJySQ8Lzp4+a0q2k28e75u2y+LnmKSTnnskvvgAeHwGd73vfPvu0z+BvfJ53d/d3d9zMkuSZhmYCSZM9wFhSCxVIgsQSS7v3ve90bknveJJJNa0rrAoAHiAL4AWJo0BJJ9frlWkk3zSSb00tXL7freW9bTZr67vL2/UJ5qSQ++C3y22mgxtJFn2JLmknJj5rkkniTtxgAAFDCySSTtskkD3ve973fIhPIhv/cUDvQ0Now+Ios02lpCkzl96T2ybkgB8BEk2JJvSaWST13LulAu76AtgL6lESp9VXzvz+/v7+/grUmSW3+A73vnQfgW229kyotsty2nuroqbaT1b72+O3lp6GBjaSAJ5JJJJVtAAHwaSaV0gAA6ULbQDG03OqSSnQJJJJNTTaS73ve9973RcbTdtttslne1GktcSTeVJsAM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u757wAAHbOt3d/bbftAAAz9vktu7ttv9QAhGPdnvvu7vv77775PoAA92e++9+5kk+fPnSZJ353dfgAAHbLbu953d3e8AAB2zuu7vvvvv96AJw3YzXMd5O7t3e7us5PSbuZkm60AEmZkzWTMiPIKC4N4rCieioIHoe1SC/PncFJ5ooeaoj9kKv2iv2KrGsmSSNTMjUyTMag8QAVoEk+n3dd6TTaToKAHoG5ZJJ2e5ILkgtvbbbbaAAAAd73ve937Q+gq+govvewe76qq7u76nyVJJJJ7Zbf39zJJ8fPm1bffgAAHt8lt3fzy237QAALst93d6237QAAMu23d222/aAAAq27u2237QAAJW235yTJPj583nd3mSddAAAztktu73nd3d7wAAHb3Xd222/aAABl227u2237QAAEkzPE2Zkm3Coo+gnvUoj72vd0CAnroEFNW8jRuTGpBB+gPq0B2SZne3oEaUDlb6AO975kmTus73vkndRrI5JkjVtvOOc5zi0AB7mNQk1yZJk1PU2mmptTTDxAZmAB01rWtaAAl2W3v3Mknz5875J3d5ygAAMztl8t83vO7u60AAPnzzztndd3bffb9oAAGXZbd3bbb9oAAEuy27u2237QAAMuy29+5kk+Pnzefju7yfO2gAAO2d3bv953d3e8AABO2d13dttv2kIxgZdlt/PPPLbb71TdkIhUIQ+e+XWM3z5gWgUzXNms85WwUXe6VF3EEX5zmD58pBbiiiXdIF3d3f7CAKrQBxbb2NYUBMmYSTO223nO3qAfhkyTwLbbbaAAAG1aP2ZMkhe9+ne93vfbbfvOAACds7u/f3Mknz587u7r6AAB2y27ved3d3vAAATtndd3bbb9oAAEl2W3d222/aAABdlt3ZNttv2gAAXZbe/cySfPknzu7uvoAAE7Zbd2TvO7u73gAAJ2zuu7Jv5bbff0AACS7Lbuzbbb9oAAH2ez7Pnu2ZnxCPu5MmTSSZmmFaq/tUriGzUk3rlUutROZRsbFWyV1kr9krrIuI82axkBYIvIqruGIKBXqUXeRXpnqrRWFYqzbv777u/mcCTcNOIgZ4k6UQ1DsevYkujozdtC534gQlGRzltps9YCXSTICUKZcA6IZUyRlNynERWxHUKZIUPWQ225GiGVAUKf97+f1jVLq2UAh3PtfXumt1rG9fVnO1vNWfUFA9FEDnrq4khgyVCgD3c8z6+8v3ThhGNQkICU056CLeDQiusldxW5EdorvmJ07bZSnSYBiJmZxd33t96ARBZIdFQsVXWTU1MmTXngFkzMTNHgH7LkmZpu8XZd3dWqWdUSlRWIQEWAjBBY2iNJSomKmMXd8u9l3eLLLu733td73ve7A6RIMAggyCrEtBYFLSCFJSoFS8Xd3d7Fu7x3ve9znQpyISIhAgKdrtYve7u9qoWKhIIWqtFZfXCrnNY0jbLGWYADQqFIJRmNYK/H2M+971+4ciKsRJGPqFoaI0jVWYu7u731ggQuXgu7u72WXQMEFiAQhCRoQqgiVd4l3d3s6QIMgosW4IKRIgVV9zdXd3fAQWxFiMQWBCCqwRYKQRaKZV8zd4u7suKC9TJQq0OBFiVV7zd3nt7HrARbq9Zu7u9AJSTnO972e9rTbMMAAPYt6aXdLfe97936ZMzku3gAQD8HugDhsW362+Wh8HugCgD8bzJI1qbeA5eW3VtD3jSHwW2W22itAHDYPda0eDwD4Ae22vg8A/duskzO9833ve973hoAqRSLW5J8LJzns7J70PPsXvvvog6Ek2Ckk9knYAB6BvIpJJPoDbbSmtabTetWaA/wavmirrIzbJG1ft+3UmtaaetK+Zb99feXeqk0iLNSSSTsOEknkkJmtfffffeM+fQAASXwGz2SbikkgAD9AOAgBHBAB6A+69DgeGd6mq83QOYqvIKAZitQu853u7933jPve972/e9alkANRqGUiJUZAZCMEekLSxLemks01oA6dBL4DYAGSTuNpLzvfu8iYdOAAGAAJT6SdmpIABPd96veN3Ovdd73HfX73gEeEHsFFKF90mKHvPOAReSSckkBQ0AIAHttI73vcd13u6zr09L3fOXV9QLEWIqMQWIr6wISgMSru7u+CckiEiSW1eDYAAwO973p3vdkkk96lpdzszfOd73viG119xJNLEk3vS5M85ACdNemAeEne973vSQ88AEe+ndd73verv2NpIBAB0AMA+Jk+kkkAAUkkki4mhr56SSS05Mzc1rmv36b/d7772W+dfh+g8AsyZjRAAA7zPMyZmvcyZmpl73fne/uPou97vvSSHySA2AAfImSSSetY2m9PpNySLsF9PttJJd4s00Lw356ADAAAPTQGwAPWljab73fe9790AAANST4K1MmZ8Oe14oHDZ+weAOYS7xd3d36wFhmt4aER7UZD2PY1fLvQ4b973ve9/SQeA+ktvlu7d5kkrcyDwD9g89wH34eAfh4B+g8BWgB3IkmZrMkz93w9C3vJs8K0oWWW220AAPL9bfPre3d3dy72j0QWK2iIxQqEgjEFgAEibQWUSQTEUAaCVV4u99v2TMtvlofpkzIPAOzl1N5Ld5dTpPRKoQ5yuQETnPe9exES7u8gXd3f2IAK0QDj22323nYB+mZDM7bbec7e+ZJmW2363vQ+yZbeg6SSSQQHiTSADwF6AcAAaBAVe202bLZtFsNkbKti2jZWwraihMwbbVbMZtVmWtRs2jWzWwbbMxbZkRMyE+fJvzu7+/JhDMmZk7tqEAAD5DEzGRJCIkyEk7yd3fn6zJI+ed3d32gAALE7yX5d7e7u7qAAAztl66ttt9AAASXZ7bq2230AABLs9t1bbb6AAAuz23v3Mknz5kyT53zu7vkoAAD73kvl3e87u7uoAADtnddW23+voABONneTvztd3d19BIZ27MM1m7uzdzJJtepBewBZPHtmMHyNQiCSUCG61Dfz58yovztKohd3gAS4gt3d3qyFyQ3mSRqZkD2tAHHttvv0vWvJmJZiNhvjaSPEbDIZiSSQs+jTSza0j776tPffQp4EFz8yWCEuZ2R3dtWeqeivRMe9v3qUROiw5FBbnsel3d8uHXm5MkeHp8ffH5xzhAtvMzMl7e+zvndW237QIyc3tl7v39zJJ887u7r9AAIds967smSd53d3dcYAB2zuu7ttt+0AADLstrdttv2gAAXZ7bq22/aAAB7L5L5e/cySfPO7u6/QAAO2e9dd3d3e8AAB3eTt7Vtt+0AADLs9t1bbftAAA9mzIoVAECdqqr0Lz8m575TsaKzvuO7BAz9++8yZM/c/v7+fmgBbbbaIB3vezySTner77776d1ZC23LbQDefdmT6Tu+wC23ugCgNgOLbec5zvUPdW237QAAM6MTvJe78n783ZmSfE+OZnJ3dfgAAHtnfJ3H53d3feAAAu87vz555bbffQAAMu1b5u2237QAAJdq3z888ttvv0AAC95zu8/fxmSRPm/HPnd53bQAAH7kCd5zu83fzu7u6gAAJ287vN222/aAABl2rfN222/aAO1N2QkItaX2LFcuW+22/SakknikkUnskknsigBfbbf31vlt6B3vegFtttq23nPpMk5pd20AAAtt5zm+dUTvZ3uKq+Xd9T5DxIoEKpQPkAxPnPPO07095J3rved8POedXm807/nNmucBCqlSEooa9PexVa973vWb801SgSiiJ2Od3m7+d3d3v7zMkm62M3cySbrYiKt83bbb9oiIUBVvm7bbfvoEIxnbVvn5zMknx8c7u6/gAAHby3zd7u7u94AADt53ebttt+0AADLtW+bttt+0DbbbbbbY/XfuwBL7T6a9me95er3vev7u6NAEqAAgAvttvvLqpMkAIcurbba8ttv1SZIZMk2t5znOcWgDxoHwWsrVtveGnvm7bbftAAAmZLtW+fnMySfPnd3dfoAAE9jvOdrv3u7u94AAD73nO18ttv2gAAZdq6ttt+0AAC7V1bbb9oAAH9l8q/nnbmSTz97vnd1+AAAdvLq93d3e8AAB287XW237QAAMu1dW22/aANa1rWta17zZvPJO/vvve9vejQPh4jZvJMwHxABfbbfeitfNDhvve9ALbbbV7bzn3O3ztvQAAe+/n3798/v77n37baur9tt+0AACtq73zMknnbk7u7510AADt5dXu7u73gAAO3na622/aAABLtXVttv3hxIZs3cjdmzdzJJu9vO13d3d94AjJ3bzt+fmZJPO7u7r9AAA7eXV7u7u94AADt52uttv2gAAZdq6973vX2EYySSSepUdwReR9WdGcJWcdnffs53ve973XQHtQfP1u5MktltoLZb2G3IZ7NZkk99ngHI1rRmSTm+G9JNLbOAfBnvUmlNd73ve9RNE4iT2JtLU9n0gEPg+SaRwOeEOB76k0gJff2/Pfba99999+/fdfde22/3oAAHrfXvk87ZMk8W2339AAAu17r32237QAAOzvOdrutv9QAAM9317r33333+9AAA9317r33332/aBu6AFbV3vmZJPO7u79k6XQAAN7zl1b3d1nvAAAb3nO13W32faAABNXyrq222faAABu56zPGfUqazMzVEm8UKSIMxWsJS1rNESsZ9n3p6/XbRQVAW22W2gtttturby6tnKQeH93ve2+PC39e22/0tvWw6ckkkAAAAACSSfSZqZqAAumta1oABt3yrfO/MySfPnd3dL9AAA3vOXVvd3WfvvAAAed5ztfvW32faAABNXy0tttn2gAAbtWltt9n2g7U3ZCQjPO3u/N/dzJJ53d33um+oj2JrQJ53ncd33u6z3gAAN3Jzu3d7rb7PtAAAmr5aW22z7QAa1rWtazz3vJm+H3nh76AAaAAJ2KSSd722W2gttt7GwcKOlttt7bbbavbd85ztvSO973ve971sBwPGsySe++++/l9qpMkurbbZ9oAAG7L5Nq75nMySedvd3dL+gAB5u+d51Le7us9nABCMb3ncd1t9lnoAA3dLtpbbbPtAA83Q8vlpbbfZ9oAAG3ysmSXfzozJJ47u7vf0AADs7znl8W93d7wAAHbe7Xd8tv2UAAD8MmRfLS239+gAALu/lZ74++yca3L3cRcO7kEF79v3Z3Pu7u7u8gLWCBwLbbeyAAO9zve9d73vfej2gyZJ3ve9ttttvQAAArQOu673Wu9739da1rWta1rWta0Pu/frvzMknnvvvv39AAA931kyT7r799997O94AABnO47rff6egAAZ7vvp77777/T0AAD3ffUj333237QAAEq1J35mSTzu7u6z0emQzDUJpNm953JHd/d3d7+OjN2bu7m7kyRrt5Jkid3d3d94gh27ERZd758+bbbfz2pMk3WkREnvm9/370lZKwrCvNEnfXBW2zrEaKwr5+7Cv7CuxJhWFaK+fuYV0CuefQrpFs6cZGxBUQmDG0REcmReZdSAk7tqAEqJASbpx9dPHwyGAiY2NIoSDQEoEHDSC1SnIJKGoSYAXWB3vUqjAZAWgFqILZ5npeEVrmzCZ3q99me44CBvGtKSMjmp3Hd45y/e9taCKoGtAKSZkyeZmiW39bbQCSSQDzBpkySH4K733ve97393tttt3ayb0HCg9tt9+7mSZPZmP282fvO95zvdfsyZM1M1/gHe9713XeGgqtVAEjMmZqQQFjWitAkmTJNyeZuSZm9Dj3Hlr7JkzE1mZmTzez8PK5Db4H32SZA/fB99A89Bqc43q23lvDQEKgAIDhtWhLbf1u7QOG9g8x+aH70HwAW223dobcNDheW220EAFaD7YX82oPwA+tr0HoPrEk2ePA4B8HskySSSfSa1JMzfOSfJJvuZ573ud79BpNgdADwXe773ve9Gk2AAgIvpM3NSSQXqSbc1rmPmkkms00klvSWaWaaMADsO973ve96M6GGzZpAdn6T9999929d73veh9zm+c3znDZxw3wkttttoANdkzM17rW8ySSZznPefud70AEknk1mTWsmTNZoDh2d70Ei90pJJJOrvengIMbSR4AB1IAkkkkkEABO973ve9IA0m/vsSTc0m0nqSZmpMkzO77993ve3Jbbbb0AOc5znOcTABZGSSZq2228k7iTfe973vexb1J8vvPvhd70AAjTSNAEkk901JOQANCAA4GNpKAjgAACAAASyTsmSd+7Jkne9793vegAFttuZb2SSSSSSGaTTfySb2gPO+hsACSSXd6u70AsEWRBMqBJ3vdd73lggqZJmNb88A73ve96Lbbez8NTPAFae4Dn5uTJG4BxfPMySNdmSZne972973oANDwH3fJgH4nQAC23sB3ve9ADczJmAOG8mYA4fv2+5Jmd7393verbegAHQB3WZMwAoEAAABbbbbQAPS32220mzYPgss5dW214PMySaHr4PS227t3mSS0r9sJJJJvQLy222+FlwELvd3d3dz3eVyc8extE7VIWEB190cdtaAKgLbbLbQW223vZvSTSkkkF0AAAAAAA9A2k1LoLb+kyTt2OgDve973ve978Hq7u/e976yqoSAEgSAgyKpIKEwLZLYlbKVtE2ktpGyo2Um1VTYktm2xLaq2JbVspNk2lbUbTa2LajZSbQ2hsLaTYLZZm1WwWxtE2tosytrapslspbJtRmKtkbSjYVbSNqmyUZtiWwjYK2bG1bSmyWyWbZFshstpG0zKbQMY2E2I2A2KbbItoto2G02VNgbS2W0bNpVtJtmQbSpmothNkTaSzSDaTao2q2obK2RW2aDZNg2NhW1bSW02k2U2BbVbLaVbQtklmo2VsWxbWaTZVbQ2bKW1I2qbSptsS2LZWzYbIraG02U2kjabE2htU2BsUbK2bCm1NlDZVbStkjaW0NqbRRtmo2oTbNJsim0to2KmwbUWyjabVVNrabAWzYzQrVaqto22ltUyslNkpsq22hG1TDA2q2mxNlarKNVgmVkWyjazFNVpVZWENtjaW0pqtKmVlZWUrVaJtbMzZC1WDVaoMrFDaM02qUystKyWxWYbLKytZQ2otqjNsraTYBqtWKYZWFZWFaxW1sIytUrMbVs2mambYzJbbKFlarStUsrAWWq2k2VqtC2UzS2WY22W0osrVJlaotI1FlaRtQ2RZWqDZtbNtrWrNImVqqsMRlZWViYYrK1LKymVimVmq2q1IysVBmYzJkyGGYGQMyQMkIDaWyosVqSsMVpWhZVlarVZWpNVilqtU1Wq1WJZWJWViZWk2bCExEzAhJDIiEDESYEzDZQ1WCytZWC1WCNpsGqxWyktVimVqTVZWVoarSmqxRso2q0sS1WhZWDKwDVaTZmSGYSYZgYjIYZIYgmSDW2xtbCZqEbVFlYiarKjKwDaqNqtK0q2bVarK2lbZqmarbarKtC22iNViplYlqsTaFmbRs2bW21NiWyMYmWK2ms2JtQtVqhWqyrVaUjVaUysqmwNVqsGTYNVtKzVZVqslmUZmRsrSmq0BmKytVlWKarSamVrUtmqzVa2SEzIRGIkMEQkwmGGQkJIQgZkMMyQkhhkyEQE2atms2W02xo2WhqtBlYmyktMoGVkS1WlarQllalG2yVg1Wq1WVqtoaVlWNVlarVZQaqytpWMq1WoxWDStC2qZWU0rJGVlRqsqaWhtbbNqZtpmmy2Ga2bJm2jajNbVmg2Zq22pCGGDDEJIIJmQJDCSBBhBIkYSExhiMkQwjbLbTZWxtm0lZWKWqxSsMRLVaSMrRK1WSbCjVaDVakarKWVlSarTVapMrK1WlNkWqxTSsq0rVZWpMrVarKmVkZVpTVahttsmZLM2TNGxa1Nra2TbaTZtSYSYIkhkkECREMSGBkMzMJhhIEkISAZmQzIYbGw2jazGZtbS22kbNTSmyMrKqysrTKxoUbVKGqwqZlFarBDYBarVarEo1WC0SyqbbCtkNiNk2y21NpW0yYZmQQIyQkMk62/Ldz360G22222S3OE2pTaWwtkUbFQ2VBarSarEtlVLFqom0jVaijVZAZlWlaWDYMG2ZrRNoqQgZhDMwzJMJm1bn5+Zkk3p3W+/wAAH73fOt7u977wAAF22+/fff70AADPd99nvvvZb9oAAHv7fniy33389AAA+79d+aUCr1d33khIRjJJq8VO0oE8CF293e8AAB287nW2/1AAAy7XuyZIttt+0AADfcmtSd913ve965WgA1AW22bt3mSTvZJ5O97vul3S6LJpzTmjSSazRpmgNiO+dyZJqXT9mSTw4bsdyZJ1u3ore2/e53XWml3PNdk3APQ+nyTS8k8XJBHhoA4BJ5kk45JtQyE3ggA9Na1rWta1rWtAu+vb37mSTzu7ut+gAAdvj3l7u7vvAAAWd5qy/fv38+gAATru35Vltv56AAB936+7kyR9+/fv79AAA+79fe/MySb7+dlt9+gAAXf57Pb777/f3oAAHu+PZ1999/fQAAJ9j3zx7Pfetv9QB2puyEhISL7/eTyTyM+SSdqp3qB5j1kF5nm+4jzK8wV+wS/Yl/ahz+4K/tCX9iiTNJJGk02zSSSBTaEYAAAKSSBb0Nhtf1px53Uwd739Myd73vPsiNJcMmnNKh901KGJoWprJpT6XiaNJc03z7EaSRMbMxGml8GwxmmjSZpGkkaSPUmliaNM0aNLwAAIkkm0aabqZMyVltWW22/1hGTtyZJutO3nYvPG0lu2234cxtJZms1paWaWkK7zVVvf3d32fHAAHbzp3d3d/UAADLtXZMkW22/aAAB7fNWW22/1AAAu1e/MySb3d3db6AAB2+LLb3d33gAALO8107utv9QAAMu1Zbbb/UAAh8+5uPl/PPblvt9tv27bbb78/jR8CgBfLL+t39fb7ltv7X3YLbbbb3ven63d5ztvbb50He96B3ve973ve9Nm5MkB8NN5Mk0B1ms1rWgC7V135mSTu7u6/wAAHbzpbe7u+8AABbHfNd3W39oAAGe77dW22/1AAAu27smSbbbb9oAAF23d3vzMknd3d1/gAAO3u1be7u+8AABZ3m9ru62/1AAAy7bq223+oAAE+bft/JJmV0/P38/P3+mffe+/39+/v602A4aAKi2228W21SSSSSSUttt5a7Q89Cc70kjTSk8LbbbaAHe+d73ve950VoHe973e7bbb9oAAEytt15nMySc5M7u8/e2egAAPO747Xzu7u77P4cZDMMxu7N13ndv5vd3d33nsZuzd3c3ZMk3bO83td3d3f3DmgRidvdu73d3d9nOAAO3u3d7u7u+0AAC7bu735mSTu7u6/wAAHb3bu93d3d7wAAHb3b888ttt99AAA/v3+vzfm758fnv7+fnvvvsnvtu222+8NAFRbbbeerb70d73eZJO970fSAAABCSSQk72d70752SAASSSSSSSeSSckkg20mAZmAAdNa1rWta0AMu27u222/aAABdt3dttt+0AADu87t3fn5mSTu7u6/wEIxn2M7yvned3d3e8AAB73lebbbb9oAAGXfV22237QAALty7u222/aAABd9Xe/MySd3d3X+AAA7aved07u73gAAPH9vfLfy2/b7777vvvvvvtt73Xe973pUcur+t3Jkl4tt6Sp3UmSYAcJOxppZNb1AJONpL36DTSDzwA+nuZJNfRb7bv9+c5bQ/SZIPHIbg7zve9413vVJJBpJIA5vewAOzWta1rWtAC7bu7bbb9oAAGXbd3bbbftAAAu27u222/aAABdt3d78zJJ3d3df4AADt7t7zzu7u733k3ZCQkJCJOd27vd3d3exEOADO3u3d7u7u+0AAC7bu7bbb9oAAF23d22237QAAOeffn3vPHzzzu/P3u733333fQPOGh+CotYC/rbed9eDx+D86Heh8e22+3mTJOc5/XJklt41mJKaOBQPQAAAJJO97nfZA4HvQMzbbbftAAAqbbu73zMknd3d1/gAAPved27vd3d33gAALtu7tttv2gAAZdt3dttt+0AAC7bu7bbb9oAAFTbd3e+Zkk7pO7uv8AAB2929553Tu7uqMYAfs7y3d222/1AAAli+W7u223+9AAA/mtPHr2TJO673vlt3bbeuGgCo5dXve9+ne96KT3PpN8kk8nSAHG0kAYHoBb223tt7aOgDud73v7usySG1+/fv2++++223d2++++/3oAAHqb77u73zMkltt6/wAAHb3bved3d32gAAXb7u772TJLbftAAAy7bvvnltt+0AAC777u777777/egAAWXZ5bu73zMknd3d7+gn8NJCTdbfLd3fy222fsieom7mSTdaERFW7u3pMk7u77SMnNDO3u3b53d3d1AAAR+f0vv9f7+/Pz9/u++++5/c/ge+Nh3t73XRWiotttvFtt1befua/TnOKDve93773ve/NcLy5Mk13vZJJJBAAAAEkk73vSZJ2czTaStt+W23d2++++/3oAAFl2eW7u98zJJ3d3e/oAAF23d3222/aAABdt3555ekyS2330AADLtu7tttv2gAAXbd3b7777/egAAWXZ5bu73zMknd3d7+gAAXbd3fbbb9oAAF23d29Jkltv2gAAZ+3y3d222/1AAA/L+vF+EyZJMqSTM1kmRHTCBKQQYCCAEI5gJdVzefez15e89333EFuAC5slcq+3oBcqpEQM81gFTcEXpzUrjkBZikETMAXUq36G75bW7667ujwINASgBLolgJaAk/aXPPGIEovq7rzQEvQkPdmXcuM3Kd2nOVF35ho0q9kmbC8wbIZEQISAhgJMBLqyN+ASqfsqmgS11dX97qvvvvnfiAAP379+/ftfgHv2vvvq/T7zzu6bPgSUJgP2ho3pMRJDBIRruar3r9diohuILiKItQQGQBZEhaK1FlUucpOEpxhLjUTFtGxbVLaI1k1i2NGQYQEkYILIIRBYLJd3d32+zJmNLbbeTMmS6oC5mSbkxsC/v1FfmitVWKsK2RWsVbKRtCtZJi1VGWorb8AuSZiaBDeZJFySTLbf1trQBYzWs0Pg99uSZmRoe/Ak/aiKJERhEgCxBYgrPr3va967ymZMatu7ehw0CtZk1qTJmanmZvMzJNqgpJmSNBAsmRqSSSa0Lcu76XEVIAsBBTBAqXd8u67fUE3NST2STqaampJ53vZypNIAOABvu5kZJmSTmvDxxX2ZJI0NgOGrbbbywAEFtt5dWgAAAAOyTM73ve9Ftt8vQ/DYDhoAqAFsttltK0AcAH614B8HvsB78HweAnsmtSez2fbyT70+DySHUmlEk2aAA7222296ALbbba7GszMzWSZl1vJrSC9iq4xRC6QQrfqzrfve74O973ve97Z3ve/d73vtzWvyTJNc5znbzvQB6tvtttABJbbbbQAt7MmTPtZmZmW323p0ALGs1zetZN6mtZmSb1uTRzbLm1rfdxsZrM6Dablw2CimQqiVKvBhgQmCojGqqmqjI3CjEJJI1JFqUyFJIyGdVq7u7u7u7u1yTMN399B6+8VT8AIge5kkkknkkNAAZPvftfeffHSej0tJptJAcO973dttv63oAc5zm+c5y5PdPNuX9by5JmWSSZqTJl1ugfWnoBbbbbQALbeyXNZkmZrMzNNjve96Bu2239afHXuZJO733ve9W5MkuTJLkyS5kv333331vQAF5zk5rMknOZkmciRBGX27u7gIXd3d3fMAMUDYC+FEOgqaNFe9SgcnPe567vl3VxQLu7u74gtiLd3d3d9AWwESALGEyTM1oAAtu5bba1wBQD8PDWSTMgBVkmZ33XfO9765s3JkltvQAC2222gAD3AfAAAAAVoB+vckmZ3mvOz58Prb50GsyZgBbbbbaAPDeZJA9nsB8AAC2222gDhuTJO/fndPPQt6eAfg8z3Xvtn6y75znKAAG7bLb+tu7u7LvrTAVsigsVWUFUwECTMkkk1makmpJJmtAVZkzGh+Hi5JmZjQDvObnOb5qIe++69tvuXlf4E+7pAYcQG0aVPddDR54BOTsUkkkk7ne9tnXHehbbeg73ve96KLbf3OcW9k6akkkkPDgAHpzve95JUVK6V03zSQESCZDCGJjAyQRkJE0zAzG1TzzzznpKnXXoPP7+6Fk/cjEmGYyREMW+egAhGOY7Z53bu/fmZJO7u78noAAu27u++22/aAABdt3dvZkk63y/aAABl23d2/1tv2gAAXbd3b7777ftAAAqbbu73zMknd3d7+gAAdO87t3bb3d94AAC7bu7bfff70AF1N2QkJLoZmFaaVt3etXWtLS0tedcbWaeLTZ5my9853+h/Z3nne972uGgCoANXWZJPPbffrf3PpZvu+azJI+B8yS9kmQB3DeTJHZmSd0bcN3Uy23nPzy6vX0mj0Qd902kjDYQ1J3ve9771/d2smKeSQt+/3vnltt+0AABdnvvzd75mSS22+/oAAHfXd37u93d39wAAHu577u777777/egAAZ77783fbkyS2+X7QAALb8/fPLbb9oAACvfd3e/MySW2339AAA6d53bu93d3feAAAu27u+++++/3oAAGe777u+9kyS2+X+oAG2233QRNz2wqMbbiBh7Mz7N9efT73vevdtt64aAKgBzfOc5zv69Ho/SewQBANAb9CeyTc++++999798d7QADve22220AP7ve93vo73nda1rWta1rWtAl327vzpGZJOcnnf3X39AAA/enfO+7u/nd3d94AAC7bu777777/egAAZ7vvu772TJLb5f6kMYSjRs3mYAAJr7WmjEHM3eYs0lxZjaSurq02k/brXWrbvMxeW22zS1pswMySSRJzvZmY5WmkBsE0aSTeVJN7OLukk3vzV8tnbe973O973taTRVZbq22knUNAfrbbbTnOc5zjvQ+DveltvOc5+/frznbQA6CB0Ad73vd7t999t7oYZkkO7u388fmZJOd+91/P5hfdW3mZ7bbamiQzJJJEnO9mZilaaQGwTWfAbzMAOgmvgN5zerptJW28NJq61QuZbbbU0SGZiTSkkkbXupJzMyVppAbBNc1qB7BVJN73577v7x+eefe+Xn9/A8A/DYDhoBec5zn9b0C1MySO973ve96XoB3MnVvsyZzn2/vp3skkkkne974k0urvd9AIaAAAMzCSAJoAzWcduNpK6d1dGk1VaXMy222poAWZJJI2vNTvZmZWmkBsiakkzMAAE0AZzZdtpK27NJqXWrbzMLbbU0SGZJJIk53szJJJE1VNL3Mv7uoPIrSVeZQvMTpiHvEvNXz7yo8yJeaK80V5ifmWyZrRpFeZQeZda1tY3nEg89ckR5lVeaK8yqefeKlmskyf39f7+/t/39/fw4aAXnOc5zgRWnmqGJXWtO220+QSU9QBxAEkkkaaUk4kgAACSSQSacgw8U1JPPpMnO+pNINpJNBiaSfmn0DMJJImp3szm9y8bSVbdtvjS91pW24b35bbavUrQzMACDSulq23My22iakkzMkkkTUkmc3uXjaSrbtt8TVtuTey221NWhmZJJImrpaAMzAAE0LSumnppNzG8ZZrZmJrda6df3Xdko86evOvMSXttjaaauvdNtpAbbaRwrSa4mkAfAYWTck+k17JJI+6aaX2vtP77z476LTNe7SaWABzwRmNpLpvySServRppQTutLV1bVu1Y2ktW+jTSk+5ydmlJfQnsjw5Jkhs1bbzXP3FzLefHczJO93Mk+0AZmEkkTUkmZkvraSrbtt8TVtuBzlttqatkzMkkkTRpaAMzAAE1JJmZJJImu97mZZrxtJVNgHiattwOctttTR3uZne973ramtVgZmAAJrumn7pGn5jJnkSQ0TQCwObK9r3tfL78+Xd3eL7A/DboOGgF5znOc4Pbf1vZ+9kaaRJJIAbAPe9zvy+++CepSQ4ASAHf7ve9D+u7/TMhsc/hve1ttmTve5mdvjaSE2AeJq23A5y221NWyZm++++++zkMMySE5Hd3bu93d15ktt3MACJqSTM5uG20lU3bb4mrbcDnLbbU1bJmZJJImjS0AZmAAJqpJve1Xzdtt+t6AAbJJ3zve50kkn0mpJJF85Oc57zgB7mSTve7nez4OB73ve9+gW/re+W3oOhbbbbbbbbaDoBmYSSRNSSZmS+tpKtu23xNW24HOW22pq2TMySSRNGloAzMAATUkmZkkkiakkzMl9bSVTdtviattxBzlttqaFdSYsySSRNGloAxZgADa3rmpMkLvzunn3795zXvvfrzneg8WsPw24Dhp+Hhbegdd6B3JJ3oFg8k73vfe6mZI0PLbfe23oV3ve9C2222223od73vdze+gmQNa/u6/NpKtu7tvqaFdW9N7tttTVsmtSSSLJUW2lttsziJbaW22yWS3nc1fvm0lbbxNUCZgACal1q4GtAAIbu7qqv3ve95HU3aIvgF7AFoQYRb9vgrd4V0wrrsV199ffcV6FfuxXVX3QrdiXBW623M5nXOtsYTbJ2ITnZEJX89rvRk+Ue9F3U7US13j17NXOFSsASaQlICT76/vpJnJSj7Pr1bz8vJi+x6UfEj1RETUxUFYmsQgCURk13l6373srcWQkSAnAAZFQhLRWyK1SuTSkcSNIrEFooZLvN3d31AAbVOIoG6VEaQWYvHdd73R1BYqxRWILO9vN3d31BQNgjdXebu7vogJtYKoxo9AwAfZmSMzJB6rQmTM9orVUNUa/FQ91OOorIuBCJLvN7u7sEFbZxBZV3hze7u8eyr+0qk60pJ8ivp/dHeqor2de173fb1GBBkBSCiMURLFaFSCLBWQgykFlT697Xt+u8Ami0oQZEWkDQTACYoQWBU73Pcb9d7LUFhIQgQQYDAFtBZOXm6u7vaqmYgtgJUGhBZ3mOzXe96ILqGVPxygcqc5zCWhNUYqEgJIQINRUoIMu82Xd33aMLS2qpbUTSJcisc1sUe2uHQrnNLWttk2ZkVirQBIS7zey7uwBsBZCRRXiCwFal3m+3LuwQDaEZ2AiU3i83y7vStpvrSb00mpknJ73s3YLQB4ARJNJefb9wPl4SSZPg8A/Grbf1u+VoAqD9kmZbu22WrmZI0AAAAFaD62+W230HweB5h+G/wHDQDlltttCACgDlbAfh5sD5w9B6D41o/ehdv3hbwAT9zXOc5zgBd3wBezve9731+p7ERbuhNxwRknprXe9vey2222gBJ3PU3NSZJbX4dfgAJrMkltv63fK0HDaoD0HwAPJ9rsyZlvt+tvegBJ0NwFIkAMwqJCAJcVGqpu83fAACrbbbygfh4tt6DvegIAA79999998EJpJN+fLGm2cDw+DvZrVttt7WaAEyTMttttZjWTWgCyTMxq2228zMmfprMyS6PQXJGaW22h4BcaAPu5iSZmskzNTfZvvfe973taC28urbQAPec55z9+APgPpMk5zc5zn5d7AALkxLovfcaSSW0mljTS8R7xATpJJJJJsLmTJkfgCZkzJ+mprJrNaZo9AzJMwFt+tvloeZkzAPwAAA2e9zJmd73vff3Tz223v4eTJmAfhbbbbQAADyTMwD8NZkzAC5MzN6zJmbzJmW223lBJJ2aEm36k08bSQAAd73vZJPZOJtZnmZJGg/HuPZgfn4AAFt3anmZJA++D4PRbbbbQAOyZMlvXfN9973vfaHp4h+HLLfdx4HHAAHzTWZJLq222gcNprkkmTeSZN5maPXmB4x+H4fRmSTAiC2EVCDSKgRIIBLvN3y76bJZ0LihmAXC/UpuK/fHsQTecdz3V73+B4tt+tu6Bw0AvOc5znAA/smd6SBWjed73vs7poW29slt7WsmSDoW22239Jklu7bbQd70MzAABpgGZh+PraSttviattw3u222pq0MzAABJgGZgAAmgDMwAATQBmYAAJq225mW221NGmBm6ucu+NpK23nlxtW25nu7bba229aaTf2ktZbeHDmNpICcnsm53ve+d73OySSfRoHe9ausySXdt5+nmu3utyZIv6863vicBIA9jU0GtGm0kBJ92YutOebbSUzkgLmk0l4HOmpIIAOpNKaGAg9Ah6vdB2czJuSSQnQzMAAEmAZmAACaAMzAABNAGZhfW0lbby6TXqttzm92221NWhmYAAJK6VtuZltto7pa1rTaS1pW25mW222p225mX31tJW23xNW25mVW221NfK477m92+8OkNn7ve9873vevw2A/cNeAX9zu92379b3vvT8u7b1IePh8+2Ly66uTJLb0dJJJ2akn3dd6SSQAKeoA4AUA5ve5JJ1NCAMzAAEnJJmZJJ1NSSTM2CTLbd73/fZkkHkamQNvPA7nZitoeb3sA+TXZJMzJJIk53vczO970iaEAZmAAJrPFmeyTZ8BNSSTckknsjYsahw0Av3Ob55znHmBI+7gO7kyTsne9HBwDpa+tvQe9CSTve97JJAAD5JpAbADMw8um0lbbfE1bbmZbbbamrbczL4AHiaAM5vYAHU0BrQAANr7QGtcAAE1wDWgPSRNAA8zC/NpK23ifmtLSYGuAW2z+ZkkIZkke26t/bbfkrMkhDGktV4dvtnKvPMelnnvi37rnPfL7SAAbA71+XVttt4aB2d6stt5zvYtktt6O9ne970Bbb223tt7bZbbbbbeiSSQAD0A4Bgb0Aezqum0lrT1pJqLfy7u2232wkyREJMkJbbu7bb3d0JMkRCTJHd3a7u7p16EmSBCTJHlk7t7d3u7vs69CTJER57rO7bmLLbbK09LS1pp6WlXHbm7vay/fNpK/nd37+5MRCTETr/XV/b0ndszJ350mIhJiJ5nXu/PPJMk87ut+5MRCTETrQzMAAaelpaS1zin21knJ56WySSckkfLd222/hsC3nOc5wWy222rbbbaAdtt5zne227ttt/W9ByTJDJJkkkk+EAZmAd6mu973MzvejATQCM5mkF22kqYjTa4QM5gHoCaDyc3kkodTU90GGaAASc7JmoAAmiBmgABpkDONPNMLttJW3d0m6W5N7tttqa8+8Xqzdpw89+CSSTkkgekmSSd9n3dHb3R3ev0gg2d3fllfd84ppAdfvXe/B3ve913vdJNKSSdk605DYGzxtJAeHZmSd70AOgAAO973u9771JG0aAMzAAiakkzMkkkTUkmZkgwBNW23My0ATUkmZkh8k0gNtoAzMAttqatt5ve7QCJoA5vewAImqk3bbmZxW4rbu1NcV5q223ttAA973vXy3bAOcNgX683zn3OHt5z9zXOcLb9bfKO96i23nJ23pBaw73vennQAAJJJJJAA5vewAImgDMwAASYBmYAANVaTttzMtttLp603AJO7u3d7v7+zJJ3d3zPxIR3d27vd3W1NAGZgAAkwDMwAATQBmYAAJoAzMC/NpK23ia1herfM8bSfPMbsaTdv1v11dJWNJvLq7aTduNJvjTTvu2k3bjSbt+Sad40m/qGAE77ZMkC/rrXNc5vmpwe5Fvlv8fRrcmSdeYO/d9JIEnWml3va0m+zSioW2073ve973sUkkkkkkkc0u1pN3ZtpN70AZmHS21NAGZgAAkwDMwAATQBmYAAJoAzMC/NpK23ia8ttzMtttqaAMzAABJgGZgAAmgDMwAATQBmYF+SaVtvE1vXiSb+u0k2XnvN84vfvff77++/uf396D0Hy3dttv4bA+t3znPecI+XnO5bb29LbehbOcW2z20C2222gA70LeW3X9/ed73+/v7+mLtpreAACTCaMAAG5pmDMzAABNBNbNhfG0lbbxN+WmrltttTQBmYAAJMAzMAAFXpvVtuZltttV0RmbEZnnnnnOc88+fCPPPPPXojM2IzPP7vyP5uaK6JZVNm1usXJPaABxD0RDgCwBeREMz5usihOnDPEYOAJZZENMckwQ52IASYRs8ZUc0t1wV+98d51xfc6ybDQC4peTLJJCEUqipJEhOUCp0BJiEgq++WD2+5+36PVMR17HCEt6iSXzmiyHryJbhRVFFFNXLgBJiEWIUPYz3Pu7v3rAQ1KUCIqiciC7lvXDXGpkyY1JkgeKH4HhZmZkAuWXN33uc94CKlm6ABhTQCt6WSb/PH7gQfv2D31gAuNADaiJLu83fLuvKKTGPcnvez72+9veRBgqGdWggZUCIgON7zrOXH296/d931Xq22+9D4PBZMzJkzmZkmsmNOem130QG5d8u5d3roCyMVCCAwQg0VByZmZJcyZmpMzNatCF3Gwn0mLqTaU1JJOyZ3z72pNtHh4ffegRtZMyPt7D4eSTM3poHqj4u7bbf1NgOGhAVAABbbbWSY2kt9mpyTJsSTYAHgHzaS53O96eDb0HvA+DwD8NgfrdW1seqivQfEAFafh4OG+yTMeazJJvQO9d5mSTk+PfT4bemtE9rq3oufSkBOen3t9PeASzqSAnuuvc5h8pQK5zmOYNcuX72FA9z3vT2/HYoHe953veeN98DcqS4UpJPbUCtb373u67zep1QJjEgJnPX7ft6u2kgK309F1O+5z4PfCbCfrIBBXb9U/XDzwdt4/u28+hIDvo88HxvMkn7Tby2mmsySB6Nm8ySB7bq9eZkkDu+/uzreZJDh5vUhv81jyIGsFALpBYgvtqBjd7u79d9UCgQuru7u+WERTEBHcggRU7HJIyZJt6cfmrrMkjQHxvMknPTOfHn4ts4e+Dhvmltv1svlejR95mQJd3eb1ZfvbyoE1d3m/c8eVH0ZvCgT3vez73gvigTUUCdx3ve95cLzSgcl34fn5f3mZJN6t9tv1uR5mST948Pj1cmAJggCRioXlQK7Xe95jug4xe5Uk8PvRtcn7T3MkmzPnxo3mSQD8UmNpKSRST6LwTS8RxtJAfHxtC7jckCevPMySAfuaNnwe8bEn7eZAukKEKkLkL1vISA31z73q7u7u6+O4ffN+1j0/PivQAhz53JmTJLMySZnPczJNc5+75vd+9zJJ23v3wABZkmY2A4mSTMaAN5kzAPccH34eSZJaN5kkFa+D0Hw8zJjkncUyeyRc6JJpINgAbbSXe9XensnDcmSAOcazJJvV3bbf1bzJJWwX5veZJB58HuwHDeZMzwD9x+t3LdW2hYB2STO++u67D9+bzJJ0PTgAaOG5MkfjY8A/QDXOc5zn7kNB8eD8IbzJJaDn2njabk5JJ95Id02mw99YB976abSW/e991573zevc3NTTzb38FpE+tvlurf1PNlJk+knIHQ9ACSSSdTbTWNaTbbXrbCCq6ii3LvV7vt9LBHNXnCgXd3m88AJGCDo7q7u6wMYjGGNYxfPhnfauwxAWGkF18xgQWtau7PnzqC9ig0wxtpgbTSbNNJtLwNmmk2HoBs70fhuAX9dc5znAXnO229vS23oC222daOhC29ADjWZJGru+97rsUDyiJ2IpRAO99dZPtnOAC/v7+6iPMoeec/YjbbYjM2zGlbbmZbbbamlpaWtNvS0lbbmZbbaTmTEYZMkRO7u3d7u7u7pMkRhJkiO7u3d7v7+zJJ3d3z8QkyRGO7u3d7u7u7kySBGMzu7t3e7u7rJJnJmd3dmZbbba3bbmZbbaJoAzMC/NpK23iavy1mY1bdXzyGg5OyTkkk8kk3JJJ6NgW7kyTi2399B5Jki75zsnlt7T6SLc1JpJpABknzT73O+931QDzjaSggO1qTJCAAW3lu7rOne7/t7tstqatDMwAASYBmYAAJoAzMAAE0AZmBfm0lbbxNW25N7tttqatDm97AAiaALve7bbamqBmYAAJMAzMAAE0ePq1jDgegUADne96+Dw4Pw+/ennpbrnOc95w9ECf3e96tvOW3rve97O2+22zvx0Ftva1JJJJJJJ3ve8++O8JmZJABNAGZgAAmrbbmZbbbU0AZmBfkmlbbxtW25k3bbbU1bTMwPQDiaDA3mAARNAGZgAAkwDMwAATQBmYAAJNJd0kk2abbSSeuY0k1tbMACFDve9973vXweBfrbu209t55znOAttttq2222gW22y3+yTMd4dzzve9OAABbfrzfbet72f3MySd/v7+9mT+tuZN2221LqVtuZlv1tvE0GBvMAAiaAMzAABJgGZgAAmgDMwAATQBmYF+bSVtvE1bbk3u222pq33qqve973vA+ggInyIKB2IInoDV8wrtRoSeeuUV324FbNivoVAFE1vdTlY+Z582CF/PmLu7vN3d3Pg8Fv1t3bae2885znAXnOc5232TJO9fj94He9Oc5znJ21bbbbQaAk7JO973veikDMwAATQBmYAAJoAzMAAE1bbczLbbamgDMwAATVttzMtttqaJDMAAE1LbeZltttTRIZgAAmra7czLbbamhbxJN4mvMXNJJvmJZX5d22libX1tviVv27cXt/v7+/vv7+73wL8wbDi3nOc5wgcNiSSSgAAE7377STS+1998p3sg2myTs8zSabkhxJthgBxNps0mAAASSShaFzErZ82krq27TVC5iVtttqatt5ve0rQCJoAzMSAAE+6TDZmYgABNfIDeYAAJqIDeYFvUmlbdpeadC5lv1ttTVC83u0A6miQu92221tavBffb8b88C7a73pIQ0UPAIeAHfe9718Hg6tvkmSc5znvwe+yZID6RSSSSQAxJpAeoAxtJdaYaA8973f3Uml33o2m4Y2kuAB6AAzSAkLrSSbtorbe2l7bd83u2gdTRIZgAAmprWgOZgAAmiQzMAAE0AZmAACattuZltttTXADPN7C+NpK27SYBnd7C22pq0MzAABJgGZgAAmhed1NzVWvPfk937zz3SsvHQ2m39ppgbfLb9be3y0DgdJ5JJuTsn3da7999z772Tx6CAX+AO9DVtt5+47JmYED660km7idttvrabtoeNpsAABEkkgAZmAACaAMzAL1tJW3aattzu92221NWhmYAAJMAzMAAE0AZmAACaAMzAABNW23My222poAzMAvW0lbdtq23M7u222pqTi1p3Ery7TR00TJ65JQ89QB4AHJJJ5IeAtn8ttve96LegO3vfO973ve8a73PvvvufKd7IAbNJpsA4gAACcSTkknkiySSrqTSDLLbmZbQBNAGZgAA7pO23My220TQBl3u2+dbSVt22uW261bbbU1DQa0AAJMA1oA9ATRwMzAABNAHMwC+tpK3LptHmmrq3My222pq65o96WeYmve5574JN63vNd6/eeX735n3bVVy28lvfr7b5vS0nfbbby3uZJNa/tPg8Bbec5zgBh/Tve973s2dAD5AE7377X332w708nrabkgAANpsAPGaTbTQBEmkaQAvpMg+hkaNBmYBJBJgGtAACaAMTaWazQAAmjoZnNgXxNpW3battzM7bbbU1bbmYAAJMA1oADomjA1oAPgTRsM5veAXiTSty6SdtutW222pot0utfNzhGFeej08646iuufucNZ0RznIrjbjiLm25s/uJs5usK16cue+eagS1xEAJMySG5ATIz3qtpgCTLCAEocOKcIErqZILguffhRjq/VDwcjt3ACTG2W3tVfve8Y07xQhDiYltAoiKfqhnmQWEMBJg7ug9bH6oGAk694jfRYIGwEnkwOQEpZX3zyb18zeZ81n2ve9wmvX2gFl1gN5akl/OnBEjIqhutd3vnuesRaJiwADDBBiTVDJts0Ws7wXFVNFa0C1cSTM1JMyTWpM1p5gH6ZMyzUkmRsAyeSADmSZmpkmZJ5fLbXAH3gfZL+ttttme7yTMmM1NzUAQMAgQRRkJFVYJiXd3y7bE6iLAkRRkAVgKwgoNy7u7v7+38FeuFX5lW1Q2aKwrWirJX9FZVcmaK0TINgSQJAAJFBYABU972/e567ISQEIALoFKRU1r7e973e+9SiyAiwZFFhIoiRBbrve977V2gvUFgi3Wbu7vN2J2BEF0FAq4iAuGETIppNlUcwDhafvd1++fv3731+/JX2aojM2kDCsSwxBZGRJGSQiCxLqS73d3V2gn6Rv2IabWNswJsG1rUSIAcIlQkGEBFMVd8u5feCC5qyZMzWvLRYZMyWNAABWvAPzhmSZOa8PQ/GTI8A+D0t8ttv1HgH4bax4DjmgCgtttltfvh6+f3e973r8bttvX4eAfB6D0HweA+tu7bacNAF8xAfgQAVrdttv4bAfh4a0G9/vEvlttteeeeaAL0AdgPAv1tttdXczMzWsmbzJM339rfTyHPt6Pvvvvvvvgh7gB4AkIbSX33333053fQA5znPeLffHgH4tt9tlvoAHZ7r99NyTM+/c+3+/fc73oAZGpJJNayTJmtZmeazesk93bb9y2gATnOc5vlt3mSRo4Att1bbXhR+G93Hsbe7Xd3fAJXuSAl2fZP2/P33g8X73r7begBQBq1oVqmSZLoAuUA/DeZJAP1oD0Pbbe5kzO973vve970FtoHwAE17JknvOc995+4bAcBbbbq2goXd3nwC5qgQ105pwiHCj3t+5fed9d3YAFttttyTMXe3gHkmZnmZMz9mSQeHObPMyZnDZXAAP1u7bbQA7kmZzWZMmTve+9C229DzMmYB+Hkz3AffgAD4PQAABZznOc5xWpkzPMyZgH5X3Oc7MkmT3s7+/fu97220AAAA8zJmAfgOc5znOcAAFttttAA5e9353ve953uwHgH4iee6yZLbfvra+aHgBL5bbfrQF10YXV3d3wu0DpFBYgshEFkQuru7u7sQToCxVJFVYAsGQVWQjEuru7u73ve9+vd46Bn6zq8IJ3u/SXnzAtvp9bby228kknkkm+97375fT7776ckknkAAAAA8ADwne/ffffT76d73vZJUBea0km7WmlbbbRGtJJu2225VbJJ90aauk7vdvmZvb1ptLWm1biTSVvKvWlXnnCuqajBsqbJDeW3Wrbbak5JrUkkkTQBrQAAmpJmZJL82kgNpOu25mW222pIDN72BJCNIDMwACJOgZmAACaAMzAABNd4W8u2mHwezXZrLJ5JJySSckkng/Pb5bfL9b+kyR/fcfNd73v0mSddNz4PJMkdL8G5Mkd73w/ZMt+tkfu4eEazJIdB3Mkjve973vegIH4eSTMySWtpK27TVtuZnbbbamrq25mAARNAGZgAAkwDMwAATQBmYAAJoAzMA+V000rbtNcttzMtttqaAMzAAB/saaVtuZlttomu+4003Obh557w/D622gEnkknJJJySAegG5O3nvN877/X63ne/d97zurbu22nHuZJAfHe6+++++X0+7BtNgAgAkikAAACSKTJK207q22y5mW2SVNAGZgF62krq3E1bbmZ2222pq23MwAASYBmYSSRNABmYAAmpJMzJL82ki28TVtuZksttqattzMJJI2jWkgDMw8ABNdxBV5rT8tv1tsEkvbbb877bTh3vXoPfg8OYW37nO5b3ve9721MBIBJJAAAk73777473vRAHEwA8TabNNNgAAEkikkknEpJMzJ5JINXSttzMnvraSkm01QDJvdadttTXgSZze6ACT8aCTMzgACaAMzJJJE1JOze8EmkXraStu01S27m9gW1NUnk3vKACTJJmZ2SSJo000tTf3nJPvVvPt+/TnOd5znO3ottoPQAB5batvnOc4AB6D4AAt1dZkkvOc4/dh3uve973ve970ABA/D96N73bb2ZOwN72/uZkk73vkyehvewia73vczO973qaNKSTMygETUkmZkAATQBmYBetpK27TXLbczLbbamgDMwAASYBmYAAJruTPkjew8PQm7baDz0H4AeW9Lbzurbe973ve9O973vei223oLbec5xbaAO5ibAAAJJIpJJJJJmZJJIJoAzMAvW0ldW42rbczLbbbU1bbze0t20CJoAzEsC221pW25iy0+A27pqK3LzeW229TUQYc3gAHU0QM0AEbRogZoAImu6TTZDS4HtVtt7fs0YSf3e976AHoPPgl/nev0mSDyftd6P0mSJ036QeyZJ0l9tt8kyToEvWnJJ953O94NpuSQACBptNgdPG0kbAAaaXyNGm4pOSTqTSmvJJmpJIJrsmTNSS9bSQYq9JqluYstttE0Ac3gEnya6pMnN5JJL1NEDMwAASYBmYAAJoAzMAAE0AZmAACattuZltttbXnZvlzvN7STfnfr575bz2dtPZBgengGwD4mSSSSTkgHsmpvvZ9b330Lf4ejr63oegl3bec+47mTMazJmDve973q2222gQP7Ou673utAEK2krcTXbbrW72221NW3WrQ+A2mgLXveW221NULmW222pqmGaAAImgLd7y222prdAu97tttTRJMzJJQEmAZmAADS6RZmktGbAAlgff3f7+/v7z+/v7+/gAehbS234BJkh3vfu9730ttt6HPec5znBeyZmNbSaUNHDSabA22myE42mwA8bTZq60km7bbblVskn0kmZkkkhUlbbmZbbI2krcTW7bczLbbamgNm94ATqaADMwABJySZmSSSJqSTMySQYJoAzMAJE1QDMwABNSSZmSSEbSVuJPnwe7zxC00m9fKfec9Xe30S+++skCVAHEFtuwCDTYBgAfE87yTve9+5zmwQLbbVtttoOc5uTJOfv34/d6NpuGAbbTYAAEYAeNpsABAEoAGZh8AFTVt3d7ygBE0AZmAACTAMzAABNAGZgAAmgDMwC9bSQYmrq23O73bbRNBJmZJJIk5JMzJJWAmgDMwCSJr7UTaOY0mqj4BKfTuZwCWF2QV9vt3R6x/XfFVcbYTt3Uzt7O3YkHu118YerLh5H0e+8ZvAJizxCYAAsyoMAA77l652/XC6ATnrOCroR0yV1aGLrWyRwVto4qc1sE5SsbXDTLm4tzhzW2abnKRyJsStJAxBFq7u93d2AlgLBEZFTayh8F+yTM1kjJofAEN5kktvMz7VM22ktSbhon6dNdOIuNTeZkzPJvJJMyachwTJmHw9fB+Xfbl3dig6jQsQWBEQC7u93dt26sEBMGKvuu971Ed79wLvXt6973faQX9yK99d1B3VS7pXHbUk4SoobpyIuBFSCrPt73rv3btRa1BN6tv16/PskzD0+HzB6D19MzJjIiNCLIQsku97u7xcQWILaCsgK3EFqVd673td6CAEAAyYMKGJLacrT3JMyyY0PlRZGgCe/2QWKD73ve173u+0gsEBpIRIEhA1MkzNW362kbAfh4W32232h6D4PFjQ/DYDgbW239bQBoANAHDYD9bu2234PQeh7bb5Q8fhtAOGgCoACdSTM1oB3ugDhs1omhL77bfb9a873ve97zsZkk8stt++lvXvwei2222utZGsb3m9TPNSXU75Pvu/u9+8i3239b05rUNgTszWZJP379+/fd5JO973ve9736Q++tvvvKNvg4bLbbbaACazJJZMk+nfPt5Jmc9579zt70AJEz9qfv3733MyW+fv362gB8+3dc85bafAPxvMkgAoAJHmZJLbb9bR+9/Xs7vv77vO9ltttt7+Hh+Q8ttttqftD0FzJEyTM1Mya1bbbeZdACFttttAWT9GwHckzPt7saO873vZMmWJpvMkhbbZzUt3mSSgcBZMksmSb3by6t4lPg9kyQPjfOc5xbsB7MmYD5nnZMzJ999PMmTM1O9773tHe96AC2222yZkyAAAPAPw3JmYA4blu8ySW2+39fXr7eZJBx9p5MmZ2SZl1kmZ3v3vd5kk7yvd223rhuZMwBwADyAfhvMmYF/Xl8ttAAFttttam8yZgDldmZJnM1mTM7z7vf3M7+72/cNgAAADeZMwrUmSDhqbzJmD9JM5r79z9mc1wBY0BbbbbbbbbadyZkk73ve973t7qaQfOE2+B6xLb9qTJLbaADwR8chz8TwDhMmZuZMkZMiMiMGCC0NKqVGTRAEN4u61ckyQ4cg/H4+yTM1mnp60Oe5Jmc5v74nv3vOfhzzvfuhSSVJp1q2841e23dttfSZIHoPQtt/rd6t753ve97+ALbbbaDnOc5kyTnOANB/ZMk/v7+/v4PftaSTd3bbbbKGxAHVVbN8ST1rWtbzzzzna9d8706Zsto2DamwmyrYzzzzsg71mtrbNUm1FsTNbWtNto2ZmttVtQ/v7lZ4yEwmMjMwjEEZGQIMhiRkITMJkkmGGYAiREtt3MPQttTVt3d7ygBE0AZmAACTAMzAABO6ttzMtttE0AZmAACattuZloAmqAZmAAJqgGZgACa1euZs3wDa+Pid3qfZJBHwGwAnkknAehbb7JknOc82kB9Jkg8ttvsmSLb7bb5JkgrX2TLd36XU85vj220kkkimm0lJJJBtJEGmkcBC0AdDPZ2bzMkjlqSatxtW259vdoAmgkzMkkkSckmZklAE0AZmAACaAMzACxtJW4mrbczPrbbamrbczAABJgGZgAA+6bDZmYAAJqe8m2s36X7Sb0lppNL363thaAAeo+k1kkk6d7TAAOBJ2zJO953ockk872pzknkhOd7AA4AffZ9977wg2m5JOXWkk3bb42m7cuk03bQACSSSKTJJJJ9MzJJLW0lbiattzMttttTVtuZltvQxNAGZgAAkwDMwAATQBmYAAJoJowAsbSVuJqW3X3N2221NWzRgB0MU09aaMGZmAADumpp70+aSTd0kk3vPGr7by27obbNAHGjR9kmXgB0Lv+BWvQvtt8523veu3fegWrbbbRw3JkltvOc4t7Ma3Jkjve973t6AXWkk3bQAR3vZYbxJpW01cttoJoJowAATQBmYAWNpK3E1bbn292221NWhmYAdDE0AZmAACTAMzAABNAGZgAAmgDMwAsbSVuJq23Pt7tttqa79mQ5088U0+b9156r6l555180ta1p+3stttrYG0fScaV4ABbZJIehbz9+5zjy0AC2222g5zm+abSXvvsnne9Gkm0AAASQbTYASSdXe97W7DQBmYBKGJoAzMAAEmAZmAACaAMzAABNAGZgBY2krcTVtufb3bbbU1aGZhgHQxNB0zMAAEmAZmAACaAMzAABNZvm0T49+834H070Lbbbb6dr3JJJ9JJJJOQXy8/efvy2i2221bbbaDnOc5kyT776SSSSSSStps0027rSSbttttve913XV3ve2fSSZmSSFbSVuJq23Pt7tttqatDMwAASYBmYAAJoAzMAArqa09JJ225mW2yNpK3e0lbbnm92221NWhmYAAJMAzMAAE0AZmAACa592LNm+cDz0D7zVYbAKvtIN5JB/fsmScPB+Pnve9Lz2TJOa13eo5ztv5JpTud13ve99SaUiUnINAHiTSIaONZu6urfue877baADwD99LWO5kk8U1JPKl0CW5mW2FbSVuJq23My9tttTVt3d7oARNQDeYFttqaoXMtD0BJge5mAACaAMzAABNAGYAAJqXTtu8zLbbamvkg2c3mIAvUmlbia91FcWa3v2+W+29VuSQQB9Jkne9v3dDwHoWXXS37ne+Lb222361xF5N0AAD777f3vuyd73skkkkDSabAACd737774731Jd7N5d7QAFTVoc3sADqaJDm97SaQAETQBmYAAJMAzMAAE0ALMAAE0SGZgBY2krcTVpdZn1tttTVC5gHgAlUtK29WZb/f39/dmTWfp57q+53bvO9LGgDhsD4PQPhZec/fLxdWrbbbSAAJMk1bbzn7i23cmSAOHZ3s73vf5W97nfvu/eWyT6Zkk8klTQH2YAWjaSuk0KmXPrbbampS85sADqaOhgAAkyOGYAAJo6GYAAJokMwAATV3bbmZbbampJOb0t63qSQvqTSuk1mvlKi7aa9Qs1vOerjXvnnnl9t6rqSSSThsAAHx4stv3P3PJsDn1t89tt9W228uqOc5zzJkn79+Pra/u973ve97qTJOl7mTMFTMkC2239P4/vdyb33oBU0AYswAAbUWjA1oAATURoNaAAE0AcWaWABfm0ldJrLbdatttqaANaAAEnDQa0AAJoA1oAATURoOXe7bb91tJXSa4p5c15e6m+cvPw3pASrMmsu/e65x2Al3uyAEtgEFTlut0BLyFk1mRsdHe3c9EZV60CW5HPTSCnZsbFzt06d59v2bGge0RgCVoEr9P3114VsTcwUHVBBER07WM9jjj2xHmwFo5pueiobrWOUC4x3tX3Puev13cu7u+7vd2ZmZmd3d3TTqve2Lc+rdPl48aQ3ERLD3se97vr6h0RbEWCLQgCyAlaSucm2NsJhWis1KxmTbNZmzW5rmNpsqtFZtJFQkq7u7u+2IshFBgKQEIoLAFiSDCIYCVd3d327u7Lu7yoF3wEbIoBBQAutXd970UA4Tqjm5mZNakmZk1re922h6D4JJM8wD9BmZMyzUmZMbAXJqNltt3HQFq2WgvjFe373Pe7bIIsYAoNjROcWKTSVtsRs1XC3N/9P7ve9dy5MzO93sFXjbwBmTJmftZLkk+88evTgmSJM5qc82ffBUmSTyamZJmfa8H15bPLmbmSZN63bThvYC924pJJ7JJU3tNdYjAD4I22prXe9720bAfh4W32232h6D4PAPw1kzNgOTyvMySD9b+tt9ofADzBqtPwVw2A/W7ttt+D0Hoe22+79ttc/K2A4aAKgAJbbbbDQBw2eZvZBH1HvwffB8FttttAH5q6tve996d1rWazSe9a0s0j488DwDzSkk8kkkySQA6eKJNL31e++nyf2AAB2Sd73ve97TQBXLq222gBd6nZJmfamsgk/ZtRm/e+993d3d3dvkimc1LJyVQ0UxthMQQ1DWlEkEtEkQDbHKIbSmTUh5+4coAibuXnOfc4tABbbbbQAMttsttN/d73vfu9vfJZbb9begage23y7tt+l1G1fBcyZMj3aW363mTJJkuqAA/Dz0HkknGmlJJJJBNNgAeAHPZJueffeffRu73d3d3d3c4nEIMQgxCCUINqqq84AAH7l1u23y3eZJA9enhvMSU9m4zzS6ok0t+rD7PEGNpL46ST6SQAAZkmYAAAADeZMwBx63mTMW/W3loA97JMzf73yTJmdne9/VVttvQAGsyZgBQAAttttoN5kzAHC2222jw3mSQPezMk73ve973vQA1N5oBbqZmTJbbbeVJmYAAc5znOc4BrMmYH43mSRq6AKkmSY2kpJJ4hJN+hoOABvsX0mTfsg/D32z779mSSz3vnOc5e10VqTJAAAAFxNZqTMzWs1NZMzNZJmMK0VwwLiJykpwVaB9Jrfg/W8zMkybu7bSkgA5znfbfGp7PzJ37WZJHo50jQBw2LbbbaHwsvOSfv13xw3+cjRuTJAHLbbbaeuc85zJknOcAAAW2973vc73ve9972TPw3sACpJWhmYAAJMAzMAAGrpW25mW22iaAMzAC21NW25mW2ltTVtuZltthpNAGZgAQ0mgDMwAIaTQBmYAENJrn3s5vnfe+95+73v5o2DhsW2221Wnw5+/TyTJPvt9nb13vf0mSG7bbfpMk7dW+6tt4k0vpJzvcafe933pDwA4BIehsAJJO973skm20lJIpAzMCSQaSq01bbmZb6lbd3TautaSttzMttsuk3Wta0nbbmZbbZdJutattzMttsukndO23My22y6SaAMzAABNAGZgAAmgDMwAKhq6bVtuZltttqa95V3Frebtvvt/r0AcNi2/SZJdW7tD4cv8c98kyT9177dc7ejht+2eW28tv4W2+/v2+LbQAFrANOAUP7zzzvegRNAHN72ABE0Ac3vYAETQBze9gARNAHN72ABE0Ac3vYAEbQBmYAAO+6WJq23My/W2ibYBnN7DgF42krpNrNNN225meW22+1vnOal0rzzj91zy23p01JJJJ9JkAkGAEn0k8knOdv7nOd86Xttt5dWrbbbaEmSW285zi23cmSDyNDwd70Bb2PQfSSTMySSQSYBmYAAJoAzMAAG0Ac3pXnLbb3um0ldJq23Mz2222pq23m97AAiaAMzAABJgGZgAAmpJmZJJJE0GBve9b0gA8um0ldNqEX9/d95r97+n7Pffff7n9/VoA4bFttttfh+9P3Offc1r8qw5bb7Lbe/dHDa3ott8kyTnOcfW0ABbbbkyS2jckn3n13vfe970qarA5vewAImpJmZJJJEnJMzJJJImgDMwAATQBmc2AF+bSV0mrbczKrbbamvlbbmZbbDSaEAeb3sAOpqSbm95JJOpqpJv3ZiX28ne9/v39/WtAHDYttttofD9zn30+ScctWyW221bbbbRznOcyZJz+t73ve970CmsySAOBsBwN5ne970SckmZkkkiaADMwAB1LSDGG9ve8AJ42kjSaq0rbczLbbRNAGZltthpNAbN7wACJoAzMAAEmAZmAACaAM0AAJqedznqzN8E/W0ke+Br3X0OH2akzskn0mSSUAAAknk7tyKaQFOeCc7eztBBvgj3ve96+aQFu7bb7dZkkFtt5zn93ve972d7073oE70kkkkk1BSSZqT3sl4k0rpNUtzVvbframrfN3e8tAImgDMwAIaTQYG9AARNRoMMzAABJ9TDDMwAATXUwwzMAAEmAZrhpAF8bSV0mqW5jy2221Ne8MzafjSb001dNJvPPXeRDzHmRR+/edHmr+qjSDRWRQ7xKvP7lCdisQrrUV5iq8yK8yV6qNQh5qUTkVqPNAXEVgPM8xTyW8TSazeJNW2gQJJJJ5JPu/X3wS779297ZP7JkkwBe6tttt6c5znrnPPFtoBbbbbQCtO5JP6ZJma1kmZpvSuJtJJY0m9NppAGZgAS6TQGzN4CQBE1AwzQI+A2mvEQM0AA2haIGYsMAImgOmZgADS+kyZqSSxtJGnmkyBmgCAmiBmNNLDAOzSavoZw3vAA6mvM5m9amayeec4k2nWk3E173crpBYEQX5EF+XkQ+Q98pQee4riKeeedPMVealefIrg88/eeeppJ+ppt85bbbfvrJJFJ5O9+jaS+8885N5kk/F1X6yW221fbbfbbXcyTN97JkgXnOdtt75JkgPmrWAOD0J4NtsMVAMi3s200gN2pMAz3AD4E0HFM1JJImhEEZ5gBfW0ldJogZmAACaANZhWmlbZwxNEFs37gAdTRCZqSSRtdNawOGaACJqdkzUku7B7Ed5oRZg3jnaAXMHODGdzT8QbBT+1Ur375d0WCNloretUHvzlU+6oeqplTQ0p5/f3ncq9RWk0Vg0VgMK20misNFaC6886CrzI8yRpXTS+aTek0rbL422ru20Ak73ve987bfrz9+/c/c5b7zsyWdaB13vQLe223zJknOc7MkzOvw33vejlttttGjeZAu7vyIHxBYAKPz5T3NKB73vVWSKaWwaaQG71NAGaw+AtqatLmZQOzSaqAM0Aew0mskzc3qST1NSdkzUGmkBsbX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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
