#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_floor(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_FLOOR:          bytecode_floor,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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qnIpy1THEeJNyTbSavb7GzcyIhyeq1M3ablure7zO7zGlFTLLUpC2zepd5rjKdGjTKcJcpExE0iWWiaRO3J7DCXVySSQRNIptEoRNonUTgJwUkqZygU152X6TaTHoceeu/mk7NvFNJkT265v3O99wzoJ3mAmtA17gJaJoE2iQEsE1wE1eV45W9wEhvlFwIZy5t87JiffspoubEaVtKzNs2k2ia2zL945Jp+pfvzap9vK7fqTtxlOXWSbL2V4ZnMLZFfnWibF27k78Js+FOhE6qj1B6JewhJBHl72qbQyATNbKETRXWHVSqRLRPB2983rnPeFOGKxROgHaRNZTIpVApxE3SGgZlZAbyQgchdgo8O+N7FUSGjCgCoECICQPc7nPb573cyBcSgL6ptKfa8Y+HZpHC6k++SdNKcbQTiJ7l753ffe5U9GSBBAtWNREkWMAZ6ve973vQEiJNm9CmlHaEFE1sU6EMLuFtXRacSBKzVJZpqGqZDtBVqr4Hmt+173vZe6BICL4BQxgUOisvmDMCoCnFzI03PBSdmSCSec5w8OhwG6rFZrPK93md9rN72meno3AhJOyQ9urGcE9jwX5X2ZxO+TzfgAAASNaAABkAjPMg8QAE20CyTbewRWo7c1Nbrz3c3v3u3ZezYWABI1oAAEqpWcM6AXGdAAAm2qUpWdZ0WVnpfe1NRz3udpraRNb531l5zRoAAEjWgAATbK7N69ft976xQAACbaBZerznOc5zRzgRmdaHSAAACRrQAAMgEAAAeznfPcxnupz2LzM+ene69aAAAAka0AADu7NOlgAABNtAsyARKr2cczVazpo6WaoBYAEjWgAATFKyATFMgAATbQYV2+973hN9zqjR5YAAASNaAAAAAAABNtAsmm75yd230QAAAABI1oAAE2znQLAAACbXdu+vN5x3PcZ3rua1vecUzvupOc7r1a73vC4AABI1oAAAAAAAE20CyVrc3Vba2EgAB8APgJGtAAAtfJn2LVdbmalc5cSwAAAm2gWeSpXagz0PAu8Ina71cy+tFc8OjnGi3IwN7larPNcZrWc8xrLO6zvWc51rm98FgAABNtAsk23sEX2Uzs6AAABI1oAAGqAWcjI6AATbQLPDYEjWgAAABI1p73OzVe3qtZ3Ne13Wc91T3e29IAACbaBZMOarm9AkAAAAASNaAABnsrbR0A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rr4BgDAOc4VVbbaAMVQBsmR5JkrZAUB6vc+++v3fvvJ63Tbe1JN2t3d2NtttuD2aCTv2XmZne9LNVAACuq2q1VAL+++ZveTJ3kCAkkn0KyiXM3ip2anwJBTvRDO6y1ubuX9aw2nyZlLai14W4Oaua+wyEHrmq6tQ+zWBDLrWpugY4wdVCHaGVKqik4lndVciEOhBkIOTJsU+N/Tw209vW+53X3rmK/cF3kJC7gPMojrSdOuUOMKp5qpdMiA6KaEHXTtZtre27VX2crNaqQXW8UQDbHvqARTkAT0AHm/ezIeIqjapFS5pIqGsoRA973jd+1uXv3TsV1xk6clSTk92TfDw8NO67JO812TMTzO96EVJdampJIoDdCeN3Jw5JPODkkiE4T2TEb5wBeJJ4nwh813j18jex4SdrOpIeJt4aeSmdmzMk7JFRSzQ1NdktnTu4lkZHve97noAlxUyKm5ECQWInTxv2vXEvMaA6N1GcSSe7JOcUAEk7JNycGTtBxztJueru5OQU7QcEY7QcG5mmQzgeL9NVrWus+rPY/FUHbZnXBcyOqFCui7qckUnuPK9VinxvE5PdnFYF3Lk5k9Oo9Xu53h970NxTJNcDquVqTUnZOmdKGQav13fbso973ve973vNjQ3bwuFdybBR73pYiTsoUTd84qUcma7rnLrwDqid97xftxkBOQzOFannJ44qarpyfrreuX1hnBANhFUJEHsVNEflc5YIHQqa7z9v+T7801VVX11QoUDdChu69k+3ZI3Vtt7JNmfv379+98888888889/TJIB+VUA/gqgDZaWqFiqAMVe+fbm8tbX777z79nX739vPVCKqz77H3333z7WDILfffs85z7e977zmlULFUAYqgABXVf37zJzvrvvv7rz9++++Jd3f6Tc+V9999632wD7P13rvO/crioAAfKoAqoAqoA2ZkzM73K+zWNZqsYVrkkn5f374Oy9Xd3bSSSTseHnnnnvn2TJ1tt/AH1tttttAGKoAXd61rWta1rWtYoK6gqjCAmREHWUKn7RQiSEiFQewSRZcoFWa3vN7v939bm/vwpGZJJJ8+HTUnwH19++666+qqAMVQAAqqVWsl5bUOmhQ9Yqharj4APe8PfP777ZJJH73ve9PRvzzzz333333337MmZl+5Lb8AAFdV46FiqAAFVxAwe/Pgkn7fwtPNy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"
extensions = []
extensions.append(""" [ "-"   `2000 ] '+warnings' : """)
extensions.append(""" [ "-"   `2001 ] '-warnings' : """)
extensions.append(""" [ "-"   `9000 ] '.s' : """)
extensions.append(""" [ "-"   `9001 ] 'bye' : """)
extensions.append(""" [ "-"   `9002 ] 'words' : """)
extensions.append(""" [ "s-"  `9003 ] 'include' : """)
extensions.append(""" [ "s-"  `9004 ] 'save-snapshot' : """)
extensions.append(""" [ "s-"  `9005 ] 'reload-snapshot' : """)
extensions.append(""" [ "...-" `9006 ] 'restart' : """)
extensions.append(""" "File Operations" """)
extensions.append(""" [ "string:name string:mode - number:file-id"  `201 ] 'open-file' : """)
extensions.append(""" [ "number:file-id -"  `202 ] 'close-file' : """)
extensions.append(""" [ "number:file-id - character"  `203 :c ] 'read-file' : """)
extensions.append(""" [ "character number:file-id -"  `204 ] 'write-file' : """)
extensions.append(""" [ "number:file-id - number:position"  `205 ] 'file-position' : """)
extensions.append(""" [ "number:offset number:file-id -"  `206 ] 'file-seek' : """)
extensions.append(""" [ "number:file-id - number:length"  `207 ] 'file-size' : """)
extensions.append(""" [ "string:name -"  `208 ] 'delete-file' : """)
extensions.append(""" [ "string:name - flag"  `209 ] 'file-exists?' : """)
extensions.append(""" [ 'slurp-file' ] { """)
extensions.append(""" [ 'FID' 'S' ] :: """)
extensions.append(""" [ "string:name - string:contents" dup file-exists? [ 'r' open-file !FID request !S @S pop drop @FID file-size [ @FID read-file @S push ] times @FID close-file @S :s ] [ drop '' duplicate-slice :s 'Unable to to locate file' abort<with-error> ] if   ] 'slurp-file' : """)
extensions.append(""" } """)
extensions.append(""" "Command Line Arguments and System Integration" """)
extensions.append(""" [ "- pointer"        `226 "Return an array of all command line arguments. Typically the first two items will be the scripting engine name and the source file being run." ] 'sys.args' : """)
extensions.append(""" [ "string - number"  `227 "Run an external program. Returns the execution status." ] 'sys.run' : """)
extensions.append(""" [ "- number"  `4000 ] 'arg-count' : """)
extensions.append(""" [ "number - string"  `4001 ] 'get-arg' : """)
extensions.append(""" [ "s-s"  `5000 ] 'value-for-key' : """)
extensions.append(""" [ "s-s"  `5001 ] 'get-environment-value' : """)
extensions.append(""" "Terminal I/O" """)
extensions.append(""" [ "v-"  `6000 ] 'display' : """)
extensions.append(""" [ #10 :c display ] 'tty.cr' : """)
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    raw = base64.b64decode(s)
    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_NUMBER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
        parse_bootstrap(extensions)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)
#    parse_bootstrap(stdlib)
    parse_bootstrap(extensions)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
