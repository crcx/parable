#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 10

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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WjZiZYxX2smyOt8ywIR3emdahR3rw03ZWWoSUqEkKlahJdSahJcUW8vszeVzE0lEZpXWY3os3eb3d3VvL6788PR+DwHcyScnFyY93ztzqWKIOTCUypm2ojDmqIMq1JERzm6Y8vdFCStQki6p9zihJYoSVbd3puvaURu7umnn7zsPdUAC110AADcmP3brzr29p+/e/t7998bS+ccD0ABe3QNL37t2ZJPJkk55MknX6842zAEgGiAJ9mtZrvPvvesJ8eaMr73ve751XAaABa66AABzr3s4UPMXOPmLnLVvnX3dmudvNeup5tbq1atVVQ9fNrd3dN10oSQRCS5d11qElm9500p55kzvrfPb3evHXnn72k8B+AALXXQAANyZ6jt4AAAAvboGl3yZJPZkk68rv2d5M9TJJ5LznOc5ye++9/qtdZMAaAAAFrroBXADcmdnYe9+b5PVU1Ch2raXJZverm1o3pumSyoUQ8c7l/t3VdZM5vR2GgAABa66AABcvOZM66nnJOuOeBTYdAAAt8d9hpuZnv7kySfrl/cd99/m6dZMuTp0ClyV10A4AVd5XXXYAAW5M5zeuv3Tnb8aGJ110As78dh7pZ7zJJznnXW85yezJJ67fvW2v3eTA/Gn4PAABa66AVwAtyY66AIAL46D0W88ddhps92c5+873zJZkk7673qdHch8kA0QBmmcTbIsUIGufc3ec9929UJKe4oSUrMV8zeWSZvKHHKup4VOUoSWPktcznc5UXM52ISQ5RLq321CS3REqAMwgHy+dZTya9vN+deM+5K+iYkAWb2ISVTMzNlKtldVX3ZTmFy8zL6oSXemia3340OU12J2GIJbcuZRmXTogGikAQ8+7tJxzRANe1nfP2BzO60QDxANeyQrOX7PmTbpizf2YtsgHs+83uCvveXT48fOdDmqEkKd0lyNyoSVVfLkURMqI2oRnJV9U3r0yrrnc27wtDfRQkiUrqczveOzJrqhJTNmdvNWVfVCS5c0Ga27dnOZh3NiEjwvnmIIwzQABAmeb+78e+UbcmTIT9kz3vzwe6WOAF8dB6LeOdAOwPRuZlc6e++7yzKqipT2+PtZUKDbvuq7u+d3je7hu5xK8yZ7y+869/d5zJ4671SusmANAAAC110AADcmHQAAAAvboGlndnWS2d8967fu+/xa65t7vJmd85nl7/TnnvHn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DVeURoczZLSrQbL0VbltpesBcreo1HMNJtSI+ebgJ8hGWYWWkvsJJNq3txbQR0D4ANNMBsDlne9735tJdIW8pJJNqSdTYHwFttttttSttHzzayWamxQbVbVZsyNtqjapspttFNibVGwltDYraDYg2RUU2EttqG21DZmtkMxmqNmy1maKQBRRGAqsQRFCAjFO9ve9/emyKLBUYBJP1hKRYhGIqxEkUVSEEYpPNYR973ve98E999QJMC225MttttuZLbbbbmSusmB4O5lnMD8DM/cyTnM5znMmc5gBccmAFzJ3Zkk/uupMkS+d95nJmJNL2M4SS4cIB2oyY+SSzjJ772vYaftL33vZPZzjCabq75t6X1zkPuLtufupvf1x9MpK8yrgKXfVrObhr66tvzSadwu4MmC29uLFnE4m79bqq2ySaQlhpPGDnOcCJqf3WTAGzItoEyBbdzJeW223Zk3d3d3Zk11ky2232ZC2gmS23d3sh5+++++++6Q7IQFkA2hIW27fM+TSWMNZWt60kkmtTW5L7N8W369suPHfe972fe95AEA2dANcym7bbJOQv1ttlxbbbb8m5JDhznOESiT8sPCuFm5y09YdxHHMxyOTJt6W/rbsyOTnJeC2+ySTQACIQUADSxQt3ed7UKJW1s7Pd3iUdyc5zmFvltvnOczJxADMxzJnOZzkiUkkkkeMPGGnjJKt5WPa+en3OQN9zfTXTzzPDfmdeg++AADd3d3dBbbbZJJO9s42zh3veglEvYaeMLGG0qwPMMZA879fbp6+yBUZPe99r7774h43d223xKAAAUIAAaTUJutmFGze04dTIXVtsyIFtsmbu7u7sybOde+lqEkYuKFXOcu87HUslRk1mUD8fqdvdfIttltFtt8vltevWzMvL1ky3q21+AC046Lfbc+9+3d3UlzJb1/cyYej3Mmzn4GiZLbbu7Jm7u7upLMltv622ZLyusmFvl5MiFtCZLbbu7JAAAKFvMrhUc72GrlKEuv1pu7c+jfPPO8MCCfB8UO22222223vekkkAC/W7u7u622k3u+ZmZmeEQg9chQ5hAeojqxcknJzM5wHunbJnOTLai23JHvXQFsybu7vu7Mm67yZaHcnsyc7LQmLU22AlGZmqIAFCISScxCS5NT5KOJbX1zpffYTd1qq3U9k6qJaw0zS+s93a7jGJ1p6+1PsJv5e1fC74zyJu4ttttQpPlbbbw7bbTgHU2butdAAO9Ms5vPOcCZM9/upmby22/pk49WhMjNtu6sme7utuhQphqAAEvUqNUnlQobb6ojVEGYB41CabYAlGZmZgKFJMKtrx1yZlIzlXPeruVMpcmaEkXha9RED8H5vnlbu7vXb+zznL2fS+A2dA3wt+qbkknlbe3DTDIFtqskhbIXiEt73sOpqLEfstO22vZkubu223POc5JGZiAMTnJl4A2ZLN3d3bcyOZMttt9zJZu7ttsybu95zjauK25JJOprq3Ps5z9mTck9V44B9ya73v3SBJMySS3tve9JMyQAAAAttUn3cNPpDnN7OE7E1vCw08P2Gnbm223CVSANgoTWqI3d1txCJAAyImYajN3d3bcyJzJldA/TIl3dW2ZEtt3vUnW33ve971tZnJPs7+1vecbPc2EOCUyAWLikkkKFANtPQBo5mgSSSd6FAAC22zczPvffft37Zk/uZMtu7t2ZPrbRczuIC2Zl5Oczk5zmOW220UzMxESpg1NtsTlKZURMifOQobb3cSJTbbwFCNUQ22EQskANYoXMkShM+8Q4Q2Q/xDjmznNQ5Q995714oulFkOvekOkPf88/u8hsCAbqQChI+ujEuWn5bGKqcZeX0TO7PZwgHucZogHTCALr2yBw5tug9oedFd3SHXXVPmTcXM298Q8++L489ujcQyHMhu/75j7qhaawKaPk0FEg0bFzO89fZznNpv4C9vfc830PKyptJOmUuaF849rDDf2oE4Sb+peJEn4+vdBSQGfiX8qoeny5Q598iOmiOu/rj5V/e/fm1zP2d3v2om7jlmuSSXmc0qaSMACwtAgNppI3kKZOAJpICAaXIsd+73vQo2kgAEW8quLj620BRNNXGMJpKLdRcqFEVKShdmJlKpVTGyt87074aAB4/KM2AfGt4QhN4++73mt8AAAAt1JJq20Ow8OsttttoAJ777fpmSc2sYymmm5Jo4ACAAHOpJCw2sYaaeHhSSSdKIC23q1hc4a73oVAAIMtMAGBAC22220QFttttoAANNJWT5Jtr5NJYTTTMm9oAK1bbbaAttttoJgFuyXMyTlttFSGJZAAyFWsW2y9tEAABG3cW222h3DQGgABZacklty0+2o0AB999987l6dAfAAN3d3d0GYLbbZJJOSZTZvCTSEmkAcAD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qZltrnOSTmtBZEkuvPMmW2+TIgtomS3d332ZLznN3UzLbsydXNvxra1v7Nw07cy+NL6oMmGnsCBwaUN4ZhNgbrvXJ75t0SSO5PePe78Gky2gEnxg+htGPqKBxRNhkD6ySaX2ksmN+Xh4JQZ65CgA6oTyW222oWZoAJQG7czLbZkv6222zJZuvMmW2+TIgG7qhNsAEoANUQ22oRKGcSpdmZnOfLGte1nL5bzEvL4NMADgCBAH1qrxbfuW0ABN3Nttt7bbbfAHQPgtkk4m/c0d70I2p3PlMZacxML6T5NXWLbq0TJbd3d2TN3dZmW2zJf1tttjk5zOcAPN+pUPrYT5+fvt4LD1H3va973tegSSSTqTskkkia9hNJZG0lleWE0lrOjbbAxfezLsL9bbZJPW204IAAC1bbbdW220AfffAt363d+2ZEv8dfsmOHTkyW20EyC222TLbbbbMlttttmS8vK6yYD9JgATItkkkSckkkkbUm+32E0lv7G+fc1rRs4Hu+AAC25aaStttpZO2SQtLJJO/W7eW0ACQNfW2279ZktvefzrJh1jjmZAAmQW225k/ctttuzJu7bbbMl5bXmTA8mT9zg7AnuQASZbbbbZk9/uc96nczJPsyScmSSZZpRMy2TNaMUrZraxsNNpIw2001ltmve773t+9bbbam7fJexjD97nve97cRbbtW26njNvLb9bD5JW23FoFtlo02FvE3eK4SSfDvecJE1Jb/fsmB5MgoEyC222TLbbbbMlttttmS8trzJgeTIKBMgt8888p555555555HcW1irGstZtbK+NV8enK+MotoTcHx8er47wfG+M+9vx7hzefmY78m8gTQjOW0l2220qkjblT9jCwYDRr3llp49wG2Hd22+yUw2zltmrbbbbJMTTYmsHN84ETUknttOjyZHoBMi2222TLbbbbMlttttmS2nP2TA8mR6AZItttpOciwiw973j3ve94DnqE/UD8SZN0CjU0lhL7WdYXxyBkvi2220QIDCbAD7R2D4TMI8H334rgvwCvuvg/t9/t99/v7ZkS2v2TA8mSz2222zJYAAEoEAAKFrTbbbUJlG1ChtvqhasbbbahagABKMwABQmoSVTVeZAKLBfcLfrbaW5VtxbaS2fW22gW0O1+AvwAW2+/e/bu799Zk3d/vMmW2+TInoBMi2222TLbbbbMlttttmS21+yYHkyPQCZFttraUNtttvZmVKXKT18iI9TzveX6VzfrPK9P6egFC2yDSVtttIrb8lbbq4bdwBbbZbaAEMAAABbJJxtnDve9OrJ9bf5z3Jg7mS/rbbbMl3d3dWTLbbbsybu7u7sybu6/ZMtryZHoBMi2ySRJySSSRJ6wuelaaSyk0lhJvCTef4hqHXblDtD37vvajnaHb8gGpAKkA/NBJKQDVPb1gOvqb57Pua+1xnyEDm93hoN9ofriGh7+Fz82YGEAQgUgCffpPH7ZOHDQ0am/fabm/09/nz228emXtr5PFF7hrabGyxXlDayrUNlDUjkwFyhpRYq5cmTIGS4VPXKThQyK1D9nKGqtVGoc9iFyHE5VThoR32vTUmgaRWhrqgvOOqGI6hj5iU6oaUdW5Q/uKPuQV5oku6H09Do7yl3tYy2KZVWiXRwVYjKDZluUNwnHBOFbBwPhurrihj9x1UM2ZrFYsh0R70R5qHZzLlQyhgyp2ckXE5zmKsVczYmzGXNU4af3OpZ0psRW1DUDhVq5myT2tcOqHOaWa22TZmUMowjdc4lkNmyo6oZR/dCnUa3zJcfeJ5Q1X9/deMk+7gr5/b55UQkrURunOgWebdc3VCS5lbpvdFu7O5wCgIZMVwArgL+uzJJMfSSUDKUwkmlblp8w/sLCwd+53pw5ZJzf0kLbbRAA05e6+ckn24WHLbbbebu7u+2uh0GnU0AABZmO97sSaWJM9gAW221SdS3hJtYaw0ledck5OSTI5JkzrrrOcPDQAebu97ve222223lmZJJCgAAAFttskLbbS4TSW5F820jZs6BIsYkLbbK8WvN3e8zJJu7oLmOZOcBbsmZJeW20XMk9nMcPBdyS5y2209HYNy4kkkl2J1NJYbSWFkyGgAlxbbbbHAA/W3u22i3q0G21b1ky29uC110AW222/Td6mZJH337999999Avdtt/WgXJMmOAt3MkzP05OZOZzlzlvloZmSQDg9t6u2295MkC3lttskmtS4tvN8vLb98NNIAAAto9HcmSAelttttAAW223uZkloejmTJAW7eTMk75kyTvJklttXbHMmPAfj6Zkn7JmB4N++6mYAO5kyRZLk9999met09AB25ky23y21+geA/F8+mTJ53be8mX9bccHJfMa9Wkpir1WZcCWGsNJqZXyx8jmjtO/lcpTuV9unAmD3AtBb9kwB9XDrAPfuffAXB98BTFtttttsm5hpw4d73hI05JPxtp0eTI9AJkW222yZbbbbZkttttsyW2222ZAAyZeIO/MmB+/RO36222pppcwnUL4+x9942YaYHJt23Nw07b2h9noaADcSmLVcNO20Jq5Xqc00wgcPBbaIACpswAgGwNI5+59L1u7vv39c5yc5zmTOccAbHJLbbSzJe7X7JgeZk/RwAmRu7u7uZLJy9W222ZNkvJbbbZk3JeS1+yYHkxWSSSRNTD0GM/LU2dPeuPb0e8BQJJiSSZhvuu/Z73vbKCbBthwMhm222y4GnR998HN2e/TM3fd++syW2222TLbbbbMlttu7Ml5Ntv9+yYdRyZN/bu7bYhMA0FCabbYJRmZmZihZmZjBQu56mZf6fefN+6+70Ho+wDqZg+Gjxbbsttt5bQIGS222ySd73preN/ew0/ff77yZL/AEz9znMgeB45kznJzmTOccAa5kznJzmTOcAK5kznJzmTOcwArmTOcnOZM550D0rmTOcnOTM5wP37JgefuZM5yc5kznHQBLOZM5ORYR973t+973tiwiIoR/L789dH4MUq59vW+Z+xr5a2IyeAFbb24kkkktskkl+Pni2235fgAtt3d2/T3r333377+TnJM5OTnJM4AVOcyZycnOSZzkACc5kzk5OAFxmAFmQAJkttfsmB5MgAZkC22zJbbbbcyf3XN/T3vvzo8e6t/gC2222i2222r9u7u79fu/gehbbu7v0/PffffvrMlttttmS8t6lv93kwdyY/AGZFtttsyeW222yZu7tttmS22225MvMkvJLzLXeTB3mY/AEyed+/Tnffzx+8mO8vqPnCmD7eGnsLvckkhapJhNySSVdhJ63bTt8Hm373Av1tsxLbUrbN73+/ftfSZbbbbZkttttsyW2222ZP4ATJbbXszB3k8nMwHoeczk5JnOc5kALE5kALMlttttzJvk5/Tu/AEA9g2W3Vstym7frbbLzv0+kk924oJsAOS3622222gFu7ZJOpvq5e7u/fWZLbbbbMltt/vcmDuZPOTgAmS2222yZbbbbZkttttsyW217kwdzJ4AJkttttuZN6/TrncmSMySf5xcoZlDVX9xQ4q1DztX9/b6YMHszC8BpO2/SFu1cZTdvzoGezkk4Wlrbk82kpcK2+D3vFtttkk73vfsrmH5tJew2ksLpycnvRNSSSSRNSSS8yYO5k8AEyW2222TLbbbbMlttttmS22vcmDuZAAzIC22RbMzHqaUJLtKElvhooVXKXbvvbu34eG368CPwH2ffffffffffA8yYD8AAAAC2+zMvN+m/W2/LP7OZkALkmABmXmctte5MHcyABmQFtsyW2222TLbbbbMltttvxD777773IT3vYQ709pIB4kiARVUzvskgV/SAMAmO7aADpu63Y0DEtqKVKWrfXbhAEMZJxJMZByhAqJNJWAs3ogH7vQa3WKqKu1M5uZrIfENC2I7/p7+578vk6pbC+O/a1r3r3XggPsMM4Y4YQBCdinXSL7v0sCrvUPcqtYqo7eckozlwo/dc3vVx1fuvkS39JIPN72qEmd7CSGQjAkDN81vWps+/3IoPti2SP7IcxlaqfNIPsjKPu+zKX777/IvnhRe4mkcpdYs+afO6++73SLu9E0lo206id1oxrmzUwc58072/W9v1iaS5dNP63eplS25aerb9ft24ofNM6BgEdvzTzJ2S9q4JqYquM4w2sI40875wPgttiy0850m/vu7e7pt6O4UZxc5vi5075K1qlEXk46u75cn3v6/dZMOq7H46yZ7w6DtxvWTK7eFzblp2SakxCr5p0AycEdvzTvdNYWM3Pd9QmkvtrKaS42ksNpKbaf3ZwKWxkpJ6+97PvufMhDGQJxSAMIfJJz7Va9ccyY4Dffe7zJnTmTOP3Y3aE087Gue8ttt9qOzwcP3eTOdst8vtm0O7aeDYaDohpJQy857pp4NX62ydafXvMmcvfwa5HnWTN4dv1/W9ZM5eraPxwt5CjObzdt8YlCiFxSlMTD7Cim+N6+baTiYjewo5u33d6qZCyX2FFPLdvZ3ahRttt5VqZack3JO1bE9o00wOnT5CmWsts7vdto3h0fgx+O+ge8dZMPex4B713lvko2vwfg8B4tvltg0mkhJJJmAAA3tp226ttkzJba2zMkjgOrdkzJJeW+2jrJkhp05kxrx31ky22eft0B+AvecttvczEuSW1ctvOiTSQfLQZt7Rp5TdvbeW2uupmHYN796yZeW322+uusmHT8Hh1bbb71aDXrvJknh+hzr97bb7soOn4R43q/TM9HbT77rJgDeFd9SSeeye+e+e+h7AAAhwPx2Pd3St2oUaXoquFCVHr1kxCSPW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WyJs1l9+efPt7z753k8klreUsd5ennb0ck9bQG2AAAAW22SE73ve9slttt8gPaxhNJe973ve94RjCaS9775JPGEu473XzxhJPGG13uZU+buX+cDmA/zlOJtjbZm22s2athsFtIrd7313ve96Xe98ttsyW2222TLbbbbMlttttmS2232OZmHWTuACZLbbbbJlttttmTulCL7OEsY1hbE2LXc9O6TZBe8tjwAbTZaBlcAPk2AF4WibAA5O97ezChaAW2+DzT95t+973vBYmzve970kTVttv9uTHHJkHoEyC222TLbbbbMlttttmS221uTDqZB6BMgkkkf58NK2229TVWGk0p7awsPC3N+59U5577/gEf2fPt1/drbbQ7P1t7ttszDG5JJFINNKgAAW20AAN+TSUqzOd223+2ZN3d3W5MvJkvdtttmT+XLbbZM23Lbb7lmS2d222zJt3d1uTLyZLszt7u7uqEZmZmJRmZmY0QnnFkeoU9VzKWG3h0bcKrNejLVm31xQ6J22220LfgPm7u7u6l5kyoHkz7759+mTJDDAAD7s53Xe9CJrHYpJPRp3CazO973dmQnLbbbJnt3d3dmTd3d3bLMl6ttq5McmTpbbaTJy2222TNttttmTrmRDVi6XM+uZc3mc73qeP1SiDM5k54ea8bp8tou222ru7u7u/QPB9999998A37d3d37Zk+lttv9cmOSZbbbbcyW226syW20EyAvt5mTd3d3dzJu7u7uzEAACUAAAoT7mGTzvL9b6zdT83LbmJlttNfAHxbbbattttttttq20aaQAAGrzPOc4dTXe973vutOYScjbbbhVLbbeKE5AAxQszMzMSjMzMwFCAAxQszMzMUJgANxCqYhJSJU17orrGOZx3tDab9cw7exN+oGdhpp4A2mwIruSVN223ckkkkGmlQAA6UMNNIPe9tp+973vbTW973u9afsJqSTkksyW27vu8mS2222zJbbbbcybu7u7syW2222ZLbbbbMm7u7u7Jm7u7u7Ml5pjt0s538mkub5pCwuFDdnJM87O+knvAH31++6LbbbbmQOpmP2BH2TJLzJkgFtoFkkkknnznOc4eTXe973skbazJG23EIAAFCAABKAAAhNttttQpAAFCYADahAADcJRfpTPc8WLPnP373+8/Pt579tfwB8Xd3d1q2222/JtK4ym7bq4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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')
    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
