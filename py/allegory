#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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"
extensions = []
extensions.append(""" [ "-"   `2000 "Turn on reporting of redefinitions" ] '+warnings' : """)
extensions.append(""" [ "-"   `2001 "Turn off reporting of redefinitions" ] '-warnings' : """)
extensions.append(""" [ "-"   `9000 "Display the stack" ] '.s' : """)
extensions.append(""" [ "-"   `9001 "Exit Allegory" ] 'bye' : """)
extensions.append(""" [ "-"   `9002 "Display a list of all named functions" ] 'words' : """)
extensions.append(""" [ "s-"  `9003 "Evaluate the contents of a file as Parable source" ] 'include' : """)
extensions.append(""" [ "s-"  `9004 "Save the current session to a snapshot file" ] 'save-snapshot' : """)
extensions.append(""" [ "s-"  `9005 "Replace the current session with the one stored in the specified snapshot file" ] 'reload-snapshot' : """)
extensions.append(""" [ "...-" `9006 "Soft restart from the basic snapshot and Allegory extensions" ] 'restart' : """)
extensions.append(""" "File Operations" """)
extensions.append(""" [ "string:name string:mode - number:file-id"  `201 "Open a file. Valid modes include R, W, and A" ] 'open-file' : """)
extensions.append(""" [ "number:file-id -"  `202 "Close an open file" ] 'close-file' : """)
extensions.append(""" [ "number:file-id - character"  `203 :c "Read a character from a file" ] 'read-file' : """)
extensions.append(""" [ "character number:file-id -"  `204 "Write a character to a file" ] 'write-file' : """)
extensions.append(""" [ "number:file-id - number:position"  `205 "Return the current value of the index pointer into the file" ] 'file-position' : """)
extensions.append(""" [ "number:offset number:file-id -"  `206 "Move the index pointer into a file to a new position" ] 'file-seek' : """)
extensions.append(""" [ "number:file-id - number:length"  `207 "Return the size of an open file" ] 'file-size' : """)
extensions.append(""" [ "string:name -"  `208 "Delete a file" ] 'delete-file' : """)
extensions.append(""" [ "string:name - flag"  `209 "True if the file exists, otherwise false" ] 'file-exists?' : """)
extensions.append(""" [ 'slurp-file' ] { """)
extensions.append(""" [ 'FID' 'S' ] :: """)
extensions.append(""" [ "string:name - string:contents" dup file-exists? [ 'r' open-file !FID request !S @S pop drop @FID file-size [ @FID read-file @S push ] times @FID close-file @S :s ] [ drop '' duplicate-slice :s 'Unable to to locate file' abort<with-error> ] if "Read a file into a new slice"   ] 'slurp-file' : """)
extensions.append(""" } """)
extensions.append(""" "Command Line Arguments and System Integration" """)
extensions.append(""" [ "- pointer"        `226 "Return an array of all command line arguments. Typically the first two items will be the scripting engine name and the source file being run." ] 'sys.args' : """)
extensions.append(""" [ "string - number"  `227 "Run an external program. Returns the execution status." ] 'sys.run' : """)
extensions.append(""" [ "- number"  `4000 "Deprecated" ] 'arg-count' : """)
extensions.append(""" [ "number - string"  `4001 "Deprecated" ] 'get-arg' : """)
extensions.append(""" [ "s-s"  `5000 ] 'value-for-key' : """)
extensions.append(""" [ "s-s"  `5001 "Return the value of an environment variable" ] 'get-environment-value' : """)
extensions.append(""" "Terminal I/O" """)
extensions.append(""" [ "v-"  `6000    "Display a value to the screen" ] 'display' : """)
extensions.append(""" [ #10 :c display "Display a newline on the screen" ] 'tty.cr' : """)
extensions.append(""" [ "-n" `300 "Return a Unix timestamp" ] 'time' : """)
extensions.append(""" [ "p-n" time [ invoke ] dip time swap - "Invoke a function and return the running time" ] 'invoke<time>' : """)
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_NUMBER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
        parse_bootstrap(extensions)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)
#    parse_bootstrap(stdlib)
    parse_bootstrap(extensions)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
