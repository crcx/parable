#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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O973ve973ve9kkkkjbmSSSTvZJJ9JJJIk0rrTaaYsSTRppL775ppJv4A0QA7bbbU0mqW221q3TRibSMZiDTbALbE7iaSmTEk3MTaSLbQgAAABbOpNNSayQtJJJJO973vexSSSTve973sbckkk7JJJu5mZmabu7u7mZmZmpBmwhKsha/NENJJaTWc79zO8bSbaXOfcvbQBtgAcBJNgAFtptJJIADoW/XGk2rjaSn2sac02kpibSReWhAAApgFs6km25NJvJC0kkckne9fe97FJFJJ93ve9zDMzMzczMzLu7vMeZmZm5mZmaJIA8JtJtGJp408abaabVxJN0QAFCfINgdGFtttSutJtJXANoC/BbbJJpGJtJWQvLbQA0mwAAibTacxmRu7vaszMzNMzMzNEszd3d1I17u7u7md73sUkkk73ve97G3JJJIk5JJJEmlvBAcgbYYxCG0IO6b593e7zEu7u7bgY0zAAKTWNMO7A+C2tPVtvLSnC3Fbq4m7l3acAgAHOtNzSkkhZkkknZJJJznOc5JkkknOc5OSbkkkXe97mXd3e5d3e3uTezKQAFRu4833s95x3d3csaoAFtpttLZpABCySS26bSQW8tl+tAOAHwHEu53venGuc5ydkTkkk633ve97O973vexNySSRSSSSKSSSRTd3d3Td3d3dBJdEB6ZkEgQjGkIY2kmkkY2w+DTgUvbbbUklS22226RibSQaAO8xphtp7ttvbdNJphaBACAAABdrHmKNtNLFJOSHaskkkne973ve973ve973ve9kkkkkkkkkkkk3d3d3d3d3d3c3IoQHMQGuWhBmSsu2km21znL3toAGmmAAm2iVW2226MaTTMaSSYAcC22xXLQttttoAAAFiabaUzJJISSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSd73vYEPGQCfU+TRlICK/aKKMZFgpBQWo9ckNiaaZJKQCquwkeRP2xAWxkggJEBPtoQD9ld6/cAuSAczVCAo2hAemPVmdKKZ2kIpy0twgRx5qzapU6lcZxeXTDQg5hgY6CEJCSNVWLtm92aREmYXxnJB1a22zRbKTZW1FcnmbFnXPOYcEUDjURJCsnXGaIBogFXtp0TTjFGJbvCxVbr1gSSYa1SpMbGW15hCQwMJBigIsDTy6a7y5n3webqOO9EOeukOdJKAiHy+KBIh+o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kncuJtJXE00l9baE+TYAcANpu229SbTT/9/2v1dtpU1f4NNMGAETRawABNAO221J21W22prtulbe26TVNNMtv1um4hBsADqxPMeY0lmJW222O4nbbbYmomk3/BjMTabcxNp5pNNLSy6w0mmknNBwCdpps+V+9jAg9nvEP3vBTmgC9Pc+94OCttkkLbQgaAAC22+6km3mejbkk9U12/ttMz4NoDaaoattoJoLbbG1cy2221NSSSSJuYY06Js2AfJtFoAAmind3dyF27u7uiOrhAQNuQDEVKSEC8m8TbabMXetpIkD91+0eACfQNHvdAAA20mjH73tpexGNEbck73oW0MAAAMDbtvzdxXqb0mmk/TXrbfVNT9pp23aVt20kGqABGlrWlbJJImjMx2222JqS222tqmmmYGjFwD5fY2gPgA4ZjWJAAANO5bbbYmudi7Lv5QzGIcBDG203QkPKsygQAubaaSXOcOdAf73te9wA+SaUEkwPFkk+k9fcDpkk73oW2gAAAFtt40kl7PSST1bV/aaYABG0W0ABNAFttSdttttbVttttbVNNMAAjaLaAA2gD6235N22221NZc80yZreNpc2Q0yGld6R/mI6ZJb3iS2I85y2qNqHWqHMRzO923SGI+ZE8zrVHz9wk8Z3aQBIAkgIt+ZMjADtu04YbyFZpMWxyVtfIfT5gtGkBdXIsdVYgNqcIBZmNJHc1bh5W6T1Na1di73ix2nXNlDuUFXBhUrCEp/b/X9jN0n2zmECP0/aWX6EtpTG41+2fWZvv2vfne7+e6vzTK90B/Z7nN9Drpx9lnM2ajly68Efunio8xHdDcEdqHfMTp22xK6botJ1VqG2cVHaJpmSZRo6obzqTp1ScqS0YRiWUNd1XJypOv750/tHbTLTUNYrYTTyhjlcouTkjviv7+4p3o2kYxTzKjgrZS1VqGXHFHOaxpG2WMtZRypcicea51zXNCaTa1ziuLjXJftyyGa6c5TKGgzM2uI5w0+50xlskautVJpofOuIV0RpahjNVViMpiOOX7jrVDqfXBOLojT3LlkV3qr3r+qP33o1dNNLiKRyncXE0ldd7zvasmhJpaAArXBSKd3ySb3AN9wuc5wzQWErNl3e77cAwAbAuHAACwGmm5TTSqnSpqEP6jJ1hIGMgLIEUUPg+2mHPq3Xtc7z3n25u61JJPALZKUmo8rtC7jnOBbhQAACSJJJJIrmzIBwBgSSSRAGQAB3QZC7u00mu8w2uU0mu02m1qk3ily9a5wCwXADQO+trqpJLNPFL2YnNbFs1ks9Zw60OZb3332ywS7wDRsJfedrvel8TNwNhwABgAAEKAADJYRTkkcJDIADTa6qTum228Jurwnsh3fGFgtkk0AAqAAkuSSSABzOxCDgdstJKJNKkk2lTaSptpWkhVhJZoyEAtJ9qqaqmqodFGgDMjkk5JA52TGZJJvqVLuLrGbu7ucQ045hpJ4TSWaVaM70AEsqFAAFySSSQ2Amxtzh3IGwDUUmGnIABd3d3d3IYTYGwAvhhplF5u7u93Y1HSSatcNGg4BnkkzJyScWZItSToVtJGAABgAAU9HtppZ800sT94yB2ziVSTUkkh1sDIAB1CDIAHE8NNKnJMySXBdnctpq9LFNaFRnfAAYAABwqwxkADjSw00pJqSS4dPe99nve97AIGgpiTS6BsphQAAA6wNgAdaBGwAPPZ3b007rHmPXs9v3Cw4gDQAHElJEspRLCb5zSXObzySB1NAbAA67dW229A2AB0DXZxeS+IaV78/lc+/JfFDVeURoczZLUMBtOqG42ydYC4VlN02mUkm0WjLxKYXlCMNFYaSzTSTaCGAeAAAPmn73m/e90skk22kp6+Dp6235STqb942HgAAALbb59/U5mFsUG1W1WbMjbao2qbKbbRTYm1RsJbQ2lbQbEGyKimwlttQ22obM1shmM1Rs2WszWyGzZmjbbWMzYjNbP88vnnnnTcjEUiogBJ9MJSLEIxFWIkiiqQgjFJ61hH3333333wIW0ABJgFttadttttbVttttbVNNMA+A2nVjAOAA3zGlmPMzGnmMAAKzEwAAra3U0l+1pJpDvOZ983TaSaXqxSSWThYHYjBWUksYMmSmmaRkMQxiqabcXRt6WZjAZ4uyYeepveZSzeGnOYUoC9cRjLTzKa1Nydmmk05Suva5ngIYVay9TZsPhAW23i8ljSeZ6SSeqav7TTAAImi2gAJoAttqTttttqatttsTVptpgAdTVklttTVtskiaMVtttiajaaWY22lnNa5hTulpKqaxitYykkms3zd3PdzPWbMmiyFe933ve9j3veALA2dANcwm5JJd3yyZkgUwAABL5NgB62SSRNXF+WPEYtGtJJGIwxsxGJrs1RB0DqVTVw2FtiTStkkkTVzLd223iaLd7xp4rq5c+t2k9pZmY7bfraJHMzG1gfAANsxp1TqkkpLu7u7dU6pp1AWl7OX32Pe9vuP3r9A++zF8E8PXQA94AAAAAkkkkAAAAAALbbG34vgAqX7GnmJtIOYjmiWkHPn1QdHSghjS7u6u7hITQB9bb8k7bbbE1VbbbampNGNO5cuW6TVsltokJoAttqTtttsSO4id06xAWQC6YuzMVIxpY4zI7e+d+wC122q2gW236/W06dI25JJIAAAABow0FvbfWetttbUmv2NO228bXVltt7aJCaAOFtSf1tttqakkkkTUyGmnbb9RLSaC3lAE0AWSNozLbbbU1rnb9rT39v51axJpfX8QDmfjxDhQgsMECSSSSSSSTvel3d2AEyAABbZC33fSSSNqT9tp3GpJtcWJLFjeZfwBA0NPMTkgraNIGl3ACBamrbZ2RNVWnzTADia1bJbampN327AaIbN3fCXd3cI5AENICXDv5BtBhL86JliXp097TvsfNPfFTQvlE+7KO5mTrT+39N4m9r318Ke9rtTZgAALyCay06qTEk4bkkhwDqbNzWuySakwEy/TupJImvLH39pNzLbfk0csltqa7JO9olUnLbbImqnJJOpfsTDM1faaYB8JfBLczd3RGm7uZ2gszMzN0REa0T6PnRLRuTc1RWQ2EtxoG7J9SV587fnz58j2ekzq93nHOcnbzc8Bs6BvhJmJu7u78pJ2U0wwBJIpd3ZJEpALXEuc5znE0XVY1X+20wA4mo+97bbuv7MxJaY2xAAMWYnMttt6mou973pa2jGnbbb1NXMkkttTUkne9bRg27bbYmouazNW3lt/C/e75e9vt+km56+9bdW20IEk9bq2+8AAAEgCkzdNO+XZ3vOHe3201ulTTx/saYaADjS1kklsiaqE2AW1tTJJJOt5jqbkkktbQsadNABxNCskLamhW2yRJjbkkkja1eq3etbX3y+97nAs4JXgAlriu7u7IEANtPQBo5g971ttsnvAAAFttshetv3Oc933omv2NO2ySxNettAre0IAAE2Ysx4szErbbbaszMbeLHRAFiuJZibzCo++aYAcS7ikknZE1Km7bS1tTLbb9+Jz78/dfiN1xDhDZDNs/whpAbsemxIFIkCYgMOkQHUIDvueaSAcAgG6hAKEjwujEuWny2M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FbfrbfqAFtt4m7bvqDWjVt3cS3PLfpzvvFTVttt/XMTeGlgAAMbtttsTUkvzTomwOJogFtBNFttsbVzLbbbU1JJJImpJKm7bU18aOdm9rA+venqfte973vHQMgAZl3d7u7JLlRN3KTckngAAh4AKAgAJQC773veBLSd3ftNOSHyaF0AAE1JJJIk5JBN22pq23vbE1cVtPmmBtNCvbbbU1O96SRJyd7E33vU17As5zjsmPFHvTUDoGQJJJJISTEkkgBLu7uySABLJJJJ2DA973p3ve+9Yk5P22nC28TWGAAHyGlix4liWY05JIW1tW8tttTAACpOQ204Nu28TQ0dNgAJrqZdKSSJozrWat+VtohtX77ttk+/cksUyd54lL+94AC7u7u7LuySSAB26u7skgASSSSSBJd3doabT4c3s4k+ct+007jbkm00cCgAmjLO2TqaM+zVttsTXe973vUn3tR806NsDiah03QATXS2SRNDHu7u7oi++z914elJIS1ggKYkCqYPjEBQl4SgBAdNzXz5ub7r9V1fkgNZD3znz9vekO4tKfsF7iPvnvy7EA2gQFv1XMO5k2d3OuveemCAgQDIBsgDoNtbunX3dVkAUgGec577vwgHSeMO9uJeULzTnUrAXjMdo62t1xIcyGyGQ6+++fyHf7d/sSefLeNpK5sEseNYs7ndbLS+AAAA+Dm+673vQADMCz7747vvfNNLrxPGn8hH3UP2SOao2Q2mWoZGiq5wlyUctUcshqbDYtqlsoayaxbGxssxNrKG0NQ1BwuVDjUNEyjIYyhrKNkltIa0xYKyyS3nFHWun3+6IOsbCLVWaZDUMqHz3nWpsIz5XIr3KXzE7xJ+5xUyGoLxj+0hzJPe+k6InskxdiaSl2uXZA0pJJtTdRSTnADYHhNJewAC+AAD3gAC2222geaaPJAc4Q2kBzSQTMD84EC+RNX848NngAO0APe97no298md3z3vUQAAB9bb9baAAADAADgB8AAG+975lNpvlNpNcu9bACSSSLvGu7xVNYpVTkCtBCqkqxjxooIxEwAWDZQUClilo1vcMiCOFYRltstYs6lMRVZVZK2KWCxS3W9b6AAAA42ktYpJJ2GwAOgAgAQB80wA4B7M97lt3b2Z7wAHfLFiTaa973wAbtt8dAACSSSQ2AVr7D7XS95I2kom0sabma1C0DgB8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AAAKmySc8k0uW9ZsAJJJIrvqW6SbVNUklKWKSpU0mjG2nrWnmB8EAAAD6SbkkAAAk5Lxd3d2QAAAAkkku7JJJCUmkt9WG2kaA6BdqquySSXHUk13vcttJSSABWzGswALYk2lcttoFbS6sZgfAWNKvLbbQ6BsAI7ltttOebiaSptJUsGA0AFypJJJLlSSSSSW2220C3VoATkhbpp23dwC01oAAttttvlJpJNL3vc573veQBd223loAFaTTMAC2NpN8WLGseZXlv1oA20kABgHbdWW27aaQAHQALbdauVJOb5OSTORppAAAEkknJJlJpAAdC2222gAAAFttt2m0rQDoGNNIALZcTaW8aaW2mlbbSyoxpnwAcDybS402AfAT3tJsAADaaaR3nOcT4BToAAAbDTTAPgA4gD4AOAb+820gL7e/bad55ZpNLTb0p4jXa0lMVdqzTgSyxLrCyqyjmp2HfnMJcpY1AC6Pc4EzJJLsaYAB6mBpgHyDXs94ACsvgCmXwAABby4077vpJ30ackn8HGnbdpq8tttBNFttsSckkkiakkklqattttqaAAAGncEBv5pgHOJMNgACaaxSaS5SUQs6NVrXuHCmmQ7NsJiU05J2BnHQ0AG7SupKqU05JAvUwrm8tOTsnIBJIIACJsoBBJMqUUK8dknffq8xZmY08wwAAiMStttCpq7tONMA+bXEYAACaJJJI2qll1bbbU1EritttqajVxWnGmAfJotttu01dPRDFYzpbm99PeuY9ze/eAgF3dXd3dX3J9N6kkKeBthwA+8ABTAIGg97wBki75NydnvVNW2221J22221NW2221Jy2/uNMDaMTV7baWpowttnU1VJJJEn3ve9siakkneprfPybn5e+PT2vbgAdA8wANJsDwEA+ADngAOge96+9rwAAAAkgA56Sb/Y07f201LbbQE+ZmNAHwB8Y08xZjTzDAACGNPMWY08wAAKLGnmLMbYAAAsxp5i+1ppgBABZjTzFmJsA5xpgHOLMaeYsxpmgACDxY08WIA+973vWhMY2hMZ8fvnqPg02U1F3VzM1JqxGDwApJOyrJJJIBd3d3d3Im4B73r72veAAAAAC2097JuSSe/CTxYsxJ4sQAAAk8WLMaeLEgAABJ4sWY08WIAABIaAACpoAAATVtpxpgHyaAAAG0AW21NW2221tftZ9zW8AOwt/AABbbbbQLbbbaX1ttt8e2AB0Attkk35cN9733qmrbbbamrlulb+20wNpM4AADaLbbbU19bbbak5JLbamrbbba07jSuJXHabaYG22cAABNfbk9vNfb+9nxz5Nzk9B84QozumnsJvd3d3ZIru6Td3d3c7Zd3emndkg2w4QNAEl33vei3Oc53p5J22221NW2221NW2221NfgAAE1bbTqbA238sADoA39jxYk8zMYAAVIWMAAKmrbbba2truTX5fGjYWB6jZJNSXJhNyZkklznc3m7u/dlHgt+7Jv1vgAD3veDgW2+qbqnrbb6pq2222pq22/utMDaa+xYAAAmrbbbak7bbbamrbbbamrbadaYG018AAAmrbbba2s+ekmkNpL9pPTaMyhqr+4ocVah/dq/v77/b+39/nJi/AfJgbt/BxGaTYbZ73tS9tvfB5A27fzaSpiA/e9+/fvAAFygaEgLiuP82kv2NpLEW3tP1TVttttTVttOtMDaa+AAATVttttSdttttTVttttTVttOtMDaaAAAG0AFtqan7Amkt4TSWjs6mt63re9as4dm/akkU3JJIMAAAkkmmnJJNxtySSSSSSSQAC2222Ju5fK223xfyxrHjYAAVpu2220GjHgB3rTA2mgAABtABbamrbbbak7bbbamrbbbamre7vYhe96REeNHTEB4STAFUQ22VnYSEr9EAYBMd0tAB03dbsaBiW1CpS1by7wgFmMk4kmIRykAnb+7vb99FMYtZDQNhlCA26CrhpttFVZBK1EEgHSAMgQ0j35Dvsby5c2RCI+G+qq+ejXl+BA/WSTpLmHKGJ2Kd9IvN7LAq71D5lVrSqjt5xAzlwo965vnVx1e9fYl5+qm+eeebYrOvv2VO5ZKOvPnfnfd4/f3IoP1pbJH9kOYysFrPuqD9Iyj9v0yl7++fxDbQkCxgg+Z756n7pQs2pndr56/fBASzTTtHTWitc2alHOZac7MydmZaaS5NNPMm9XhXJMNPUkzMrclQMtM6BQImGnbZaQXb5JmazDFptYvdaeud772/eAKtNPWvk3vcOAQ4RfNPmldmvL6fewq0m+TO3XOc3zJ7vL7TTDVNgcDTT7gaANmHcNO5makmJMNOXd6u6siy04AYOCJhi9nkMcejb0+CAmyBAYkA0gOtCmXvvHgrT0mzQG7e3Gm1vEmn3MTSWNNXE32/Uh0wxpmABO93caejGnhzYElAFA+2BDO5bbb2iNh8Bgc208zHd6vlrpOaadQDQdENJIp1zLToJmBbGnruNPLvwBDEfaacwNnLy3TTy6toHCtG2n3ZsOXdjaTa2sSx47809W7tLs4lXjZ809hz4PlqxruX5p6veXlMDTTAA6K407bbbBc8nxe+afvenp7a8rpp21bu7bQJgaDgAznGnxp8afGn9egAdw00w7sD4ADnd/axp8q0trhe8l5QOAHwAZgGsAAPNNJrySSTKAADe2nJJqSS7xdySTtptJSpJC2JppK5bbQNNNIIGjGmQ+Madtq+kgABwAC7WW23bTS7aAugfTyTSXvbXvdCHmnpNgB0LTWk2GwAncady2229NaaYaOAHwW223VoAQ6baaXwcQZztttioAACAL5N9A2Ae9ppgAEwKY0zvalqT6SFOoAAAAAQYAcDYHQJoNNMOXVVXWmD582wgc+bfMrkUa5CX5bvz4EhNQQSSxNJIlpIMQkxJCkXvdOdpv4e/LGk0nmkmlm5U8X7niLUkk3dskkkgF2222lsknrl8Hve97wACbALbd975pAb+IPuQkC970gAvrECPrSXDQj3vABUnbbbbU1bbbbU1bbTrTA2mjgBbU0YW22xNFtttqakkhbUnbbZImu/Xf7SW/kBefJvvTl/d4gNpsIaxbEsySSFgLJQUmwAyHbvd3ckA20xtgIACSSS7uzZx84HU13vX3t3dTX4BgAJq2u06mwNtoOiAATkAOgHySFgABE1JJJIk5JJJE1d3d3d2mrXdpYRNZCzFmvBsLmpLt+knwB73b4AAPdttvaG/B73veACmAFtt933e/uNOT9tNCCAAJq0t5bdtq2222pq2222pO2222pq2222pq22nWmBtNHAAATRbbba2tYk2kvyxtJNrF73wB8WeVttv6u222gW2220tkkk/NpLwe973veAA6BtIAJ5W2231TVttttTVttttTX4AABNW2221NAAACattttqaAAAG7bbbQSWAAAJNJpmNpNJXGkm9JJaUXvzz93UPGQ2obF/aT3daaTTl7bee9303PxctttKrb4Pk2HvT3dAAB7ybADTaAAIAAAABwA+Xu973v7qbn79tNAAADaAC21NW2221J22221NW2221NW206mwNpoAAAbQAW2poAAASbV3pXE0liWtDzMxLMf2wC8P15yq3639VbbbT97wABb61JKSSQtPNNL3vH2Yk0gD5NpBo97PfJJNAG+xN/or+6B+/VNW2221J22221NW2221OYldW221NAAACauW0+adt2kw6AAJqySQtSd3d8u7ttdh7F6ullPmPYU969pvXve1Lu/aTYXcikkKXwGk2B1B6BgFt8X63zTSlNPV3dnJIAkAWmz1UmkisSSX+I35q234I0w+2kuJGwOACaLbJIk5JKk7dXKmrq222prfe9kkTVLbQBNfSSXrTobbRs6AAmv3TM7cz75cW8WN5iSWcE3949N63794CX8AW2gB+9ybkk1Ls5d3d326libSgBOeqk0kYTAA400j3ppppSTujnOcDraidVd327u01U7bZImqv1tv3WnbptbEkrly22prkkkkTRitttsTUklttbUnenGnJiUmpW5JJJaau6aSzSxwgKw57xJCQPAABTwABb62SSQt95t+9v2JNKQNIAMFgSd8vd73ne+9ba01Xe573vepqq2SSJrvam5DqSVuklbySS8qS1bbbEmSSSRNVW222pqZJqQ2m7dNO2222prebzZT7s2vuSRR53WsxY1mQhu38ettVt/fkAAFPAgAt8JsLb4AkOtNICSSSNNKAYNspJtMA3trmO8570TUktttSdttttTVttttTVttv6NMNJMAAATRgAWxNW2221J22221NW2221Nd/WfX2v2k3pNJT8/Z3fhhAMurQQyVkAoqQirRJKIgGTPe+19vNBA4gQDLlQOvuYhAXYQIBuZhICWyfSROTbNiKv1bs7mpAPa225tTaKmJ2Y0iLgILTfpgQDB3th61kRTGICob3jpEA6cCAtnfPPHvpwwhDcOPvz05dfa+xOffmbt/dqBAP7F8SDW1KfzfeiTqxWmqGTbZotZ+xcUmkZDUjZO6GZK+qx+OdUOiF8/nDjpedQXyzjCp1CYqtm1EyfeRyIxtA2SMozBN6Q+8UdMq2hbNQyGtKMR8oYTkzUM1bSNibGyTaoZJzlyxD4jlQ+5R1hGW0jNolqH7IcoYj+0cxqHhwPcS6sqyUaTYRzSThaf2ocmipmbVIyGVZahtbTa22ahp+512HNCy2attaC2qtmYtqTtpzNlmRXzih718EbmRtTX2JNvebxsKCbnffH1t5fe8AAGbyBvYEOgb3vYAEngAD094DAC3LLbaU8XSSazGnpps76ffSe770AO5O/SckkDgBo5ve97AuSSSSXKV3d3d3JQHwBToABaAAHQ1d223yuAtJpKZN7ACSSRt3dq6SSSqm2k6pt5p4xJc1bfqUAAAp9bb9bKdDTTMADZbby20ANgAdtAC7NED4geTSXJ3aaSO+7v3rfX2HQD4KABotqt7bQDAQAKWtNW22gDAALLlttpJJJJJnl3i73d3BNpcANABzd3m9Xd2AAAAhNibmINNPZ8AF6AAASTcknwAaDTTADgfG7jTt5byzyaSmtK/Hufd973jYBeW220ADUDQAFbSUaeXVtpsPk2l800tgFLaaaaVttvbUAAAAW221WhgAebSXcaTT9733vAS5bb4DbTSAA6Gk+26tvbQ4AfAHQ1bbbaAAAAWTJJIUpiTS200joGzofeTSUk2m2xHOd6HvAAABUqlznOHegAbaaQAHQAAAAAAAAt5v73PeyJv3U8VbeljbGobNQ2kshotqJkGJsQIbGmLtve9uTKvfoBNQDz57fn1SdHd36SANsAAAAkkl3Z27u7u5Lkku/KSe1VJpIA94IpVJpIN60knVBxPrWsigRZDvbISHU1CfVgFYAH1ZCkFGKoqqMWILJFkkFG20sA2AA2gLbbU1bbbbUnbbbbU1bbbbU1bbb1GNsNN7AACiSAACpO2222pqL6+q39vSWZrPJvy33McObTZBe8tjoA2myQDC4AZTYAThIJsADl972dulZIICSSQaYNsPeAsTZ30knrU1bbb+jTMMTQHQAE0Bbbak7bbbamrbbbamrbbSNMNJoDoACaAtttf8LGkAAFTXdaaTSv3FSp0t8rfuZila5z5SKeZDvZ7Mu7u7kkzJu7vN3dy233uu97lSxppQAACAHveAPc/JpKibzf1tv79U1bbb6NMNJo+AABNFdtttSdrtttqatVtttTUttpGmGk0I4AAJqySSRJyd73vG+5nMriyq81WxdqkqbdM424CJr1v8C0H4w96eTAAA8FvgAPEkknrRSmnBAGkwIbTTSKYEknOne9709aSlVtsjTuJrVkkkTX4VtttSfbbbb11NW7tttTVskhGncTRvAAATUkkkiTkkklVaTq7V28X7feZzut72jh+0m53u+530C9t1ctoFltttTYW2222IA0AAASXd3w4d73oWmqu7u79bTMSdttttTQsAAsTUkkLamrbbOwWm1dW221tWSSS1NZbbbak5bbbamp9yczevvx+8CvjvLcadttCHgAA8FtttpZJJJLbbaAHmml73ve973t/Hdb73vomvK2239WmYk7bbbakrbbYA0gAAqattt62rkkklUTUkkkiakkktqaAAImrrWZzE0lqJaq5PKfVXMV3tw2m/TFnZ2036AY2GmnQG02BUctomwA5ZJJJ5ppUAA9497GmkAaaYgA20pXOc5z1ttd73u+99aau7vvew0msAACiaAACpoWW222JottttTVttttTUkkkiTkkkkTVz9blm1jHMppLu+d2vKl3UDcvl3jnb767v3gAL72gttttLbpN221XzTSmNNIAA97xbbbbfz73ve99+TUkkltba1bbba2pJJJE1JJJIk5JJJG5JJJaktW22xNWSSS1NSSSS1pPn5Zn3fLq74znO/vuHpnfSn4AAPBZJJCFtttoeTaXswmwNFJNIsy00iBpppABtppFeqk0l+/OSTve/q2rbZJE1JJJIk5JJJE1JJJImpJJJa21dW221NWSSSJPd3d3dEbu7u7ojdyTWkBhVw4q/iF4PLKlMcbf0/fv2jFee7+kUyl+tt+tACXLba2rQOMAAPNNLxoDbTS973vNsAjADbTSjbx4kknfWNJK7u93d22rbZJE1JJJIk5JJJE1JJJImpJJJE1bbbbU1JJJI3bbbbKktfXxzOfq0g+tIDUgHpnwQErWfdqZ27cbdOamJl2ZPy88bIBvr+G88XxMZ3RvXE3fx+Sv2ic7dStE+aJv7OFH5F0xHVoYutbEuIbaOE5raJLCAgsoMElaRtCsVGNskByrYRoUyGSNgd1yrUNHD7yuRZttVaTdmnk6a6cK4zlI6chVyh5/OpzXRahphT3XXgF2D+/dnmoeeUP3Xch3UruRx20S4IyP3LsjoVaJpG8yfeUPfH7pB8ojojZnx0R1Q6CtlHWoc/cKHEn506R1uvKHhe48/kOyScZAMIEsEYIoh5v58zmhhPj3ul3veY6wlppIMFhWIBOTcvU1JMySSTAqttnEAfcAPi2222geMSMZrSSzTV4K1s2bxJi9Xd7skl3MYEkBu03XN757094AADiXxy3l7y/WgcAIAABbkkkkkXOc5zaLmE0kG8a2AEkkne9T+xfB98kmB9JAAAAW1JJ9JPgA4ABy3TTuW20AAAOuZJJIAAHfu0w4dAttAA6Bs10urb22gAu4B8FsbSqbSWJtZlttArMACRSSSEkkkkk6ltXi71d3cG0lvERQHAIm3ULDTTAABXEGmmAAJvlmpJJQAAOAHzTtv1tv1AIGgAEfJNIt3q7u+Cu7WUmkob5zgAAEkku7skkAADVtTTTtvbQAAADe7bb3tuk2kfBppgbhDZmzTT3bfrd9v1NNMIamUmkJpK6TSQZAwBi7vl2dkwk0pAAhq223tptAAWGjTTSDdtsvbQAAADVttvbQAxaaaR9emg+5NHm2n14k0lTD4ge8AAAGoONSck6K40wANNNIKAQMWmmkAASlbMAACow35NtrnF3F1N3WZmZhrUbSWKTwEbFpoq5OFOZt1ZK8dbaQFpgg986dy+87+fegSUIbRXez7nfdTpLbf362220ALbb9ZNC+tt7bbbbc82/e973t8qk0l73ve9701vDilYaaqlVVQviSo6u2BiopFCLCCwiwINra1+/fu5B/mrzNptbM1KbBbSZra1lttWzZma2yNkAoKRSCQSRWIqIKixVHabTGm1s2VsbUK2NhtsxYlixXVtttTVkkkiTkkkkTUkkkiakkklrbVt+ttqatskkSckkkiRu7u7uiPik1hDg0o7J2JEvv2NAM+b68TdvtySVN20OBdJu2lM7frxXFbqgAAAAAAB5p+ztyTWtST34battttqatttsbUkkkiTkkkkTUkkkiakkklrbV1bbbU1ZJJIl3G5rve960buX9iigqK9jEmDAQX9hQTfu9nfe3NL73gJ+kkkJVgEkknel4Td3d2VBppWBr1Umkve8baaXvY9STS97wABOne5mfMEZmZmdqW7O7u/eQmxtNjab6O7u7u1psbTfdu7uGtNtps4O6O7u44TbabG28B90nd3ac02MeAd0Hd3aubY2Hdu7u6ktabQ43hLu7uEZEAkKu++rfsTf2LvveL+52+Tdt/AfrJJJCgBJNNOS71d3d3JIJlYTYGUGAMk3JJ979mJpL9+/bUk73v6tqSSSRJ8kkkia72SSRNckkktbampJZE1d2SSNrnOc73AWZmbmCNN3dzBHGREW92jnRLdXQYmxttehBjQTd+99+s7Mz7ub8+9R3d1d3vTskkkne3d3d3JJINtpgAAEkGmkAETdebJfe+4NtcxznL71Nd5znOcSfOEkkTUkkkiakkklrbV1bdW2pq8kkkSckkkiakkkkTW+aWvft+94vj5p+9+/FtLbaAAAAFttshbbaAAIJJJ5ppFNtL1UmkseppgAGt1ve99g08WJW28ttbVtskiakkltqattskSckkkiakkkkTUkkkiattttrakkklqSe/xrwuvq5i79oKfqm77X2fl4Dp1NgbdttE2AfHmvB8mymA0+bubzwfB0+AAAAAttt+uLzTzPyWskknq2rJJJG1JJJImpJJJEnJJJImpJJJE1JJJLW2rb9bbU1bZJIk5JJJE16a+yYsS3v49i9+n79l/FkDVALb4AA6CN/veAAk9btN22+NdAAgAe9iTSAAOPnOc4VNRSSSfq21bfrbakcPu3d3DmNje7u7u6DGNm7u7uGtvMVtttlzMUkklVkkktxTJkkl4m8m4nrQfAd9+ttly22ggAA4AABZC3dtodA0mwA4Gg/IPe978v35ane97393ve973ykkkne973vexTFJJL1p5bbbe973ve1SSSTve973slttt7U2Sd0EX2/ms+1zO+5v737L+3ZcG2cAPgAQAAAFttshbbaABo/e973vX3rbRppAVN8W/end35uZhmZ6nu7u7pmZmZd3d32ZmZmbu7u72ZmZmabu7u7mZu7uzLr79rbvqkQFXHo2smq+9J8sEFZs+3wgMyJ3BATlR0OrKBDWu8bSWsvFtLEpk4JvZ99O7y5w9PPnxgX5dEA+SAV37qahUroS8s257fVu3E0lv58wxpLEdi7zW2vp96niUAAA4Afb7rvfu94ABmAamb2BmXy4PzT77HpHZGI5SpsI0Rzk2xtkZDUM0jGZNs1m2a3NcxtNhNQzam65zSNK0qZDRsNrs7VcaU0gZupHFTaStn90RcZK7dn71/fyHO7faH3rWxGsiHFC5xZJaI2srhb7ao5v7ukfdOw+ddLwuZ/bpU+sqH9nztJwp4WgaeW1Hu84aT7oOYFQml3vdd7zt4JgAEAZ9bb9y038AHAttttoAAAAAB8B65maut4n1YtZ6+5zvubEW3lt8Ae97Sfve8NvcuWfRT18aAAJATdttslA0AABLlt1aBwNAApJPJpLiTSrl3rIAEkkk7vjalK6eaWd5elTNIqGWlZWcNGFMYYWgqOQqyb2set287AAAAMy2222gAAAW2220AAAskkkKgANe973vEDyEAcAAANJst5bZ9d0DiuI1A4CCtJpmAABWkkmYAB9ppyT6Ql0fBJNySabckk3JIJtrYAbANcu8Xq7u4GgAAOdTeJvqb62txZ999JAAAAALbbbaAAAAfB87eW8uvdyozPe00+e9fe6AW2220AAAAtbaStttoAAABbbbbpppUACBjTSAKrZVbaAB95NJa79tNt+973b6lttt8AAABjTStttsoAAABbbbbQADTTSAA7bq28t006XYAAB5tgAAeAAAMWngc++5pJtPnAAgJtIAAAttttoBA0mw0aaaQFXzav4ICc+bxiFlCXu+CWrhpiQNpjSRqH9Q1DhpHFXKiuFGpPLiVeebu/o+6j3zlf2v2j+17oWsSXsSbmNfb5uTfp63dtt5bfW2220C221SFttoAAAABibtttvOc5x3vxAfRoO7u47tl82w7u7uzhhyG2K223txKtZbbb1zHJJJ1td73tk73ve97GZmVmccKu7uru6YbQb0+4p9Xb8wS+9HkAB+Tfve2MAOJsCnNAC+TYHAafJibmZANgAEgBkIUABDdJvmOc732pJJyTUkk5JqSSck1JJOSakknJNTd3d3VmZmZe5mTmavtIUMYhh3dfdz+m617d5Z7L9f3p72qAFvgAAEABeW220LaBsADoAAAATve94fl3ve2Tve973sUxfrbbZMadt+ttttkk7znOc1Jkk5JznOcnZM3kxSSfXGnPyzX72t+973PH6e9oC22+ttttoAW2ySG03baHQ+CSbkkkAAC/d73ve+O85znOtcrnOc53idd1JJOJ9zve972d73vb1pyu222SSSVdkkk73ve97Fybk+19pbz73Ofctn78FttttLbfAB73vettkkN22h0DRjTAA6CAACene977lXe933sSmP6akk/cbctttvczMzjOSW7G7s48zMzTd3d3cu7u80e7u3JdpvE0ltT2AC6fvwAaAAJbbbbQAttkkLfwe973va94tvbbaAFvZJP19+ltsnO973vYpJJJznOc5Iskkk5znOc6uxJKbmSS/NOy222dkkl6pmmn78Lnu7973i/safs5bd2hjTDQAfGGNMDYEzdNO7u2nq8XczJPGwAAskkkkCSd3zt3d+eMzM3dzMy7zR7u7u3d3d3d3d/dE5JJJ2ySSqSSSd73ve9m+bm/k62ksba2CjWimoYAf5qlcQ0qDWBJqGKDKGVPVJNJTs7Unvc972bkkkvyaST8AABMAC2WSQoBsD4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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
