#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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te8zS9Qml5UqvHpv1e3709xeymzm3vM3f3nWLIaO8ubZRx/oDaTdLNc9j1b77vvcSupTd81NSSe2U2bxkDWUYOjyt08033Pc97jnTMogaDAGQwnKu7u93XqSlLx7Pve97fqXve9oANgzIez73ve36ve9720sNOrvF1rXOXVLDadJpK02m20m2njeue96e37yx73va97z829EUqklSeUKsVrPMmKqD1sGMZNRRtumnRm2GZsNmk2psrNbAqjWiZaySIKDGLE/EpEYLhbVpWSIwijIgoosGDJGLTpKlTpUqqlT0qxSrBZyz2/e973ue973ttipFJSSST09JJJJ4HJJySe0Hvb973vb8GXhpzDu7vV0k2n2yaADZ7u7NLjTSXmm2k21n29dLNFe5hAGt8AObADe+STWpJIATyH2qqq9pY973PB1JpRN1VVlS4Va8KspirW3nOc735/Hx2fGqgCQu6ql6sSSSe8AAAHomigAAvvPepNJaptJU0vV7nu+9r3rTaXPeOmwC37we773va973oikqadLd4T57Dfvb96/etSvAG0mGGABy1flJNyT3tkkkkknpJJJJv/K0+Mi8m2kl7Hu8973syQA6Bn3vBo7ppgCaSEmliz4AAqaSE0kYaTTxXxjHveXqafve9JJckmp4A4AEkkkhkAA6Eh5e973ve97xzeFBJJt0GeGGn0D2wAAJJJJJPLKAAOhSb9SDIAEPeF73ve973sNNIkkk7MSYackk3JJJJJPB7OWml73vd973pu++SGkmklpp5w22k1oxkw0wCbkmcyYacknfVz3kqXkq8lS2AalST0nJDIQpNgFJtK7u7tX28tM8AHQACezTS1VLlYdKqNpOY5953nCOekJ40zjn9OVW687FV5U1DvdexOjW2Zp/wFgi2rIwYfqypxn6Zj4YlkIRGEAR+RzBMbKHcAqH7JgQMs04bW1MzNhu396vs54FOqH2XcalWMYMEEEVqGJOkmZJJCFVRV9mKvn7/H2c559OAInq9sva32OYkkJfchMgIpAixTLrL9zvPvBIQUpeZIJO4pJHUVd873vftQnr87ZGbtVqGRWSiLWTERmWqjEWtRixhWxiqxY2hWEFFNwkJAgmIqMFFLCawuCl1QWICZ9cwui2yyolVaWWiVtmOYlrQVVYtQxCiV9kk5zPa1Eu731c53ne857+/JVeQti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75fIZIU0q2zZIq0D9uWiWopqGyhpGkMRtImWpDUNtJahpRkMlP2/aSv2SL9gL9gp3vCr1A20qxVCxVtqxVpRXdFeFWEVd873ve94Ir4BaKtQxqrY/bm2MxiLIk8+9rEBGCqKQUBUDye9+6eTRLWFlDVSYDSrSrUWKsKw1O+VXjvfBd73vfCj/e/P583XW/ve5If7SpLmT/Yi0mku9v4/fuRJ+w9paLbepNKxt33hgW299xtppmJJ/Hxxo800tL2KeAAaSklNpKAAHSGQAyCbyAFhE0l0oxJ85Vql5i5zycxVznPj2qUuaF3J3XdQ7h3EndXe+E0nU2ksSTeNthoPgDiTKtAAEbVbSWGBowA4mqaxtJAAFaTVzGgGC+thPPk973vbPhgsIjAPez3veAUxN5jzEkgAApjzGnmNAAACSibSXqSTSSXve2mkvcwmkve97e2oGZJJJISRyQbSQAZSKSAJxNyY73ve3tN3V5SbSUmpIJpIsAAJLu7vGDnpO9nqmr+00w0AHzTKAEDSaC222pO2222pq2222pqmk2GmYjEGmY0kZQACpoLbbak7bbbamu/rs732exOJrs3WQA4AgiCBqCIG+5kAe8fcaTX49T2ve94Gk2y6bSUDSD4NBpMxNpAAHveaYaPJr24mkjhjaSMSbSW5JATSRYAACaSCSSd42mknVUd73u+mE16VhtypMSYUmGl86SjVIMnve94TQW2SNq5bbbYmpJJJEnMZjSVxO3TuAbaaqA2FtX2ZiSttttS5VznOc73vJcol9Mir5aU8xL6ZEkd5J/aXf92h/df33v+39kPMf3w9q22RtpNT19bfAkGkmYk2kYm17GkGGCaSwimEk3O413DSafaaTbL3d+IAAAW235NJez0kk9Unf2k2YjA0BttloBA0mgLbbUnbbbbU1bbbbU1TTTMDQBxNFoAAmgLbbVOc5znOc4+WOKL41Re+l75UtjzQGut/vCOwqL9ilJ7/codWdTSXfeOJ+xNnm3oACxtJGvY003jTKDkpSlKUpTtKmnJlrNJptqUykz3vcB229SSScyYm0lMTTSRbaE4mwA+ANpvbttsbaTT/i/a/V22+qav8NNMGAETRawABNAO221J21W22prtulbe26TVNNMtvLdNxCDYAHVhCUJQAkHd3d3bHIju7u7tINgIIeyL7oB/tftUcTRT11e86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Se8lUv2NNRZA8wPMMZA879fbp6+yBUZPe99y21NCAPrbtJySSSJqSSSVKpq3RjTM+NGBpNBYW2poQBbak5JJJpBopb3CANZRBNTmNxYNENS3O73zv2HwXbttVtAttvLy2nTpE3cumnbq20+AAALQw0FvbX7vpJIJVtW6/Y0w6B1tRZ8AEATVttkiTkkkglU1bb9bamrlNNMLeXE0ILaAJq22yRJySSSJo33W5p75x1fYk0uX8QD7P0Pe9zvs8veu/e3496AAAAAST1tt973vGwAALbUrQ93ve976NqT9tp3GpJ+b4urElixvMADsDY08xO2iLbWkd1oAC1NSSTsiakNtO0A2l1NZsLQBNCttkiT73om5JE1GklcbSW1K+I2gwr02VSIj13496++z8098C1BHyyi94u5mTrT5vk3ib2vcvhT3tdqbMAABCu8qSSTh2SSHAOps3Na6AAd6YZz7Xe996tPv7SbmW235NYdLQBNDltkKk+yS26iax1OSSRL9iYsntNO23ibE3O9knqmqrbJIk+973vZE1kxrRr11tJBrqcV2W5SCkp0Dce4fYiN75vfPfPk+AOX6713vSXdP3ve+9Pe993wbE3bbfyAkpphgCSRS7uyS7JxCW972HU1aq37DTAA6mq5JbbXzMxJDbEAAMWYncAAImqpJJLW0Y07bbetqqSS21NSSd71tGDbtttiai+u9a1vVv1t/C/e773t9vJJuevvW3VttCBJPW6tvve973gAJJFd57TT6Wc5vZwvtprdKmnT9TTDQAfNLWSSWyJqoTYBbW1Mkkk63mOpuSSS1tCxp00AHyaFZIW1NCttkiTG3JJJG1q9t3rW+c1nPfu/e9fdErwAS1xXd3dkCAG2noA0cxALu7tk94AAAAALbao2/d730nomv2NO2ySxNettAre0IALU3cWY8WZjM7u7u7RJKIhCjfHd3dpyBIiEtOqoI62h1KYrbb2RNQTdtsja7kkkLE1v35I4+8Q4Q2Q/yHHNnCNQ995714oulFkOvekOkPf95/d5ANgQDdSAUJH10Yly0/LYxVRqJXoRLs9XEAebRZAGlEAJX7CAb3xug9oedFd3SHXXVPmTcXM298Q8++L489ujcQyHMhu/75rjfWSBcw1oKaPk0FEg0bFzO89fZznN6+XKL2+N5ze5ysqbSTplLzQOEmrDDf2oE4Sb+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NltGwzMy22LNsRbSsGFNhVpVhE1ozUNZDZJJtSqyGokMhpSWaqBkNRUbKqTQaVaVaglpVhGhVpFbNpshtBsRsjaQVUisgoSCyQUhFEVRUIoKQ73ve7/PWAHysVSQWALFIqjaFtNq2NpbA2Uq2IK2VlWJTYJNkojSNUZDVS2CBgaVVNpDYrIZRUyGoVlaEmazBsQ0GyGVrIYjahqjaNpshsgtptmJpZiTazEksxs1ppgAdTQi20ATVttkiTg27bbamrbbbamqaadttvU0IttAE1bbZIk4Ju222pr5Rq6V4TeTvgvVIpbF3LlNww28UUihGBBsbZo60wh6e5pe82/BsPe94zDR2296vAYAAnZxNyaU1ILYQo2U13mOc5z3qmr+007bbepoRbaAJq22yRJwtttqaskkkTVptpgMCTMSSttV7bqtvMeY08xC6ABRLGqsoAETWSUq81vW20mmnuk200nuruZnbqeACbuyamZMJyGpttKSTm2lKSkwUyl6e9ieTfse973kUUgMpopIpopFJImGzGEU0hBkMMpopMpFJOUmpTlSk0mm9nO/e9E1J+207bb8mrZBt0ATR0AtqTskkkTVVtttqakNtO22/Jq2QTdAE0EAtqTtkkkTV2vZ+IR8T793fPc74RfHgALc8gLb4tt8Ae9A0AEkAMgEkku7sgEknMbOc4Fprve+007beJq2wTdoCagAFqTktkkTVVtttqakhxp228TVtgm7QE18AB3HhBAlHd3d3dyEJCXlft9ZAHl30h73zutc3uzu7i8AAAB73ve94GEkkniBbbbbQAttttoe94+TYE130731/CNrabXOc9PbJzHOc9fLW03Oc9c7He9E0Z8FtsTVkkkjauZbbbampJJJE1JDjTomwPk0fAAAmjLZJOpoXMbrORt5Sk1Odk9AACFEkkgEkkku4AEkl3JIBwAAAkkkiW5JNWm/cttt9UnJJJImpJKm7bU1+A3xpltPk11YjQAFTQi222pOSSSRNSSVN22pq2nGmW0+TRAOgCa5hl5dJu+XfCetbsRSbwcOGx7lxYpp7mdVANfGmn3YNsPvj3vfP5W3ltvKAFoB1Ngb6oa0atu7iW577OenZ70TUkkk/XMTeYrbRNgDGwC2lTVtONMA4mhEAAE1ZJJIk5JBN22prltttlTV3d3d9TVzE53Hak1fOQuewAAdAyABmXd3u7skuVE3cpNySeAACHgAr3vHve9QC3k9bb6pOSfuNO23ia+ttE2AJq23vbG1cttt6mqpJJIk+96cacLeJq9tom7amrJO9kSckhbE1Z+0LedazC9596j3JqB0DIEkkkkJJiSSQAl3d3ZJAAl3d3d2QYSScxs5zgVJyfttOSQ+TQAAcVaWLHiWJZjTLbaANq36jbABM6ABUnYbacknE0DWBsABNdTt0pJI2vmsk2oNu2iG0c5AsnP30limKd+8Sl/e933ve5623d3Zd2SSQAO3V3d3dySSQAAAJLbfNNp/b99970Sc7X+407beJoQFABNXLO2Tra3kkG3bYmp9JJIk52o407beJomBugAmu22SRJ970Tckiav+5/vd45VK/Yh1lF1876fch4rtRIEAbWVfva3Xdd/PRAGoIA9kvl6iA7i0p8wX7EfPO/LtDaIeb7eVKyqPVuvsv3haMgCSAFEAYQArDbW7p19uqyAKQDPuc97fxAOk+Yd7cTl5n3vu++90Nfec4lYC7ZjtFixzhScyGQ6+ffP5D753vvE3fWofc2CWPGsWdzutlpfAAAAcD7fdd73oAB37QHdnfNNLrxPG1xNtJTG0kYmo5qjZDaZahpWUHOUnEVxhXGlWLaNi2qW0hrJrFsbWyzE2sobQ1DUHC5UONQ0TSMhjKGso2SW0hrTFgrLJLeckda6fOUDmNhFlTNMhqGVDz7zrU2EZ5XIr9pL9id4k+84qZDILxj+pppLFJpqCaS3pNaaSTQBiSJpLcu13VkDSkkm1N1FJOcANgETSRUkkL4AAPeAALbbbaB5NtDaSuaaym0ldNtLOcKpWEknVIxnWy1E3CSSTlAD3ve+9G3uLvd/e96iAAAOW28ttAAABgAB8AcAADfe98/Y2m+42k1y71sAJJJIu8a7vFU1ilVNtLFYSpFVJVjHjRQRiJgAsGygoFLFLWt7hkQRwrCMttlqAlRVZRWStFLBYpbmtd773ve973ve9OxpLWKSSdhsADoAIAEAcaYAfEhVBu7vN3ztBJJJwVKkm00BqSSZu7fHQAAkkkkNgFa5hzXS9+kbSUTaWNNzNahaB8AcAttttoAAAW22208k2l73ve973vFttttAAPg8caZjbT208tPLT0AEmpJJuSSSSb3zbT7d/fc+kKANNiaxpt4AAGYBrug6bk0JsTSVJNJCTSwAAWVJhpy7u77bQAK2khJpYAFtTSVTaTxNJY8WNpLMttoAABoDStvbe2gAAAFttuNtp20AAyppL3M20/c973qW223wAAAFttttAAAALbbbaAAAAW22XLQAMBABPvNJOppIM1rgB7wAABjTSOpc3zgEA4GmmBsALbbbaAAAAfDnU3nPrftb5dWUcaoaJuGuKm0kasSpNtPFNJJqyzC6YkV8va1Tpp+WHuk/HTeg96e6AAXd3d3YSpJJIBJd3d2SQspplIC5UkkkkkSm5TTk8vJtMUUVViCsBQWLEiCkFWFstatZsTaay1kc8RHtzkepfJWsgFbSG1tTc9/n7AtArGSCAioPrCcTBCLPfa1qE+tvE0IC0ATVltkiTnZBN22mZiSyEACpCSsOcadtvE0IC2gJq2Sd6mrmZJBN22JrVcu/c+XPt6MaYap+NLMQYKaewLDg0rN0yk2BuOdd3ht3EkpzECB3IaTJIAXeSjNm0VmCsOK02GAMy7u9LOksFbN86dSfeey0+973Savctttqa70kkiTkkrbttTV+tttqaqkONO23iaEAAAmrbJJEnJJ4iO7uINRvbQSWkk6oUXf25mH7zXefvoaYAHAECAMyR1JM8kgACbmJIAQAA/e970972/eC23qb/d56Se9W1Zr8rmmncuLdu00cwDgAJq2ySRJySeiI7u4g7O7u7uPIShIA8p6SUHTMEdly37azGjSwDgBwaVtttiTLbbbU16k0lgTSWF5UmktY0bbYFT3sXNhMwAtt/AB7vl73ve973gLbbbC222gAAe94ALZ62T0TQr+DXzTMDRiattoAJoC221J22221NW2221NXLlNNMAPkmAAAJoC221J22221tXe++E0lvNbxvOeGzge74AAJJhppKAAeLYW2+DxbbZ62XLaAAAAkAQ9bbbPVNW3b/GmmGmYY2gAABNAW22tr7LbbbE1JLbbU1ctpxpgHE19mAbAAXWgAAEnbbbbU17/tveOlH9QyCsyomZbJrMrURtZs1bIq+NEl4PjXvd972/ekkkkTcnkvVVP3ue973t2iSTagHL+9oOgbC+2kgAwPe8BQ8037wdTZ1GJJPvpO99amrbf3zTAOJoCgAJoC221J22221NW2221NXLacaYBxNAUABNAW22pO2222psxq1DVmmazNo/2H+6uH+0U2NtOsNv3sr0w2/V6nn2/HuHN4yyu5TeAL0IxhtJdkkkIru23cT9VKigM+8sNOv33vNsJ8AftePY2/dAvAAALbl5cT8ms9OyT1TVtv75pgHE0dAABNFtttqTttttqattttqatoZ80wDiaOgAA0i222gsx5jTzGgBAAJJ36gj6gPiIqHIEikgBBVzaK+bvz5Pz3iSSSQQICk2AB2SZkkhJE3IpoD3vgpgF8AAU9rwAfrP1kn6JoVtPmmAcTVXbbbamq5JJIk4pJJImiq222pqzUNNO23iaF2222poUkkkSfeySSJqppLWs9r3vePLPH7vg2AHg0gMAPULsAD3vW0A2XwAF8AAAW29930knvVNST9xp228TQugAAmi2221J22221NW2221NW2nzTAOJo6AACaLbbbUnbbbbTMxYlvCuXlN6r1a3va8tVr2zHrzfrAgSS7GkoAB6oDaQBwxtme94AKAe973r7PeAAAku7vjbOHe96dTRd36VxpyTKav6222pqySSFSdtttiakkkkTUkh807acTR0AAE0W222pO2222tPm9/339EcIYrFZ/kNQ67codoe/d97oc7Q7fkO6HMh/dlESQBcnsugV9Jj9XO+uOQQGXc4WGOyoYPPFz2zAwgCECkATv4fJxL+WTp00NGpz3dNzf4fnLpfpkYaTc+gRfAa2mxssVwq2aGKtpDUjk1VTlFkU1Dji0tKq0nKF1yhwoZFah+zlDVWqjUOdpU4q5LgHhoR32vTUmirJRlWeii846oYjqGPmJTqhpRurnKH9xR9yCvMkl3Q+nodHeUu9rGWxTVVaJdHIqxGUGzLcobhOOCcK2DgfDdXXFDH7jqoZszWKxZDqh70R5qHZzLlQyhgyp2ckXE5zmKsVczYmzGXNU4af3OpZ1FtSjYqxVXKGOa2ku2uHSHOaWa22TZmUMo0RuucSyGzZUdUMo/uhTqNb5kuPvE8oWNv3t/LE01c0km57J7TaS+TYTfJJ9PH2tgmkt90EOEQGHcAAoAAgaZTAAApgAX6xNJXN22nve0lcSTSkw2uU80qVHc8704cl3fN5u7JJJBAA06Tm3bbv6+L7oAAZJJJ200BoAgaUAAAAAAKmySfeSaWW6l973vHve97x990NoSDBgHmoIgQ8whLdPMDgQAAAOSTckgAAAdLq222QAAAAkkku7JJJCUmkt9WG2kc970971qzLfABR4BySbbaSkkACtmNZgAWxJtK5bbQK2l1YzA4BY0q8tttDoGwAjuW220+8mJpLG0li17Xvc973vUwAAKYAAAfW3dttAt1aAEtpbpp23ZgFprQAAW222+Umk2kj3vvve97yALu22/WgAVpNMwALY2k38sWNY8yvLeWgDbSQAGAdt1ZbbtppAAdAAtt5ymAd+5OSTORppAAAEkknJJlJpSSScku2220AAAAtttu02laAdAxppABbLibS3jTS200rbaWVGNM4AHweTaXzTYBwCe9pNgAAbTTSKlWu971PpIHQAAA2Y07beW2nyAOAB8F55NNc3bdtO/VZp6bem11t4trE0WodGtOVSaZJ946bp/e9/3z96fxGkrNLfx7vvXPfu+8AAW+aYAB6mBpgAd9nvAAVge973j2AAAAW/XGnfd9JO+tadtv8PmmAcTR0AAE0W222pO2222pq2222pq2222poAAAadwQG+NMA++SYbAAEm0u4kIWTNZz42U0wOXtyTEppyTsDOOhoA99UrgIxpgHvXhpU+20wgdPe8AeXgAibKAQDYGkVuhXjve94et1Sqqpp5hgABEYlbbaFTV3afNMA42vkYAACaJJJI2qll1bbbU1EritttqajVxWnzTAOJottttTVx897NbXL3k6e9K9vXfeAgF3dXd3eLN913OO972XATYNsOBgMSSSS5Uk7JiQCSSu9XBNydnvVNW2221J22221NW22yJq4pbf3zTDSMTU+kktraskhImqrbbIk+973veprve97ZE1zv5N38vc8T2vbgAdA8wANJsDwEA4AH3gAOge96+9rwABbbJJ7n2fb/Y0+9/e4mr+AABP7MxoA4AcMaeYsxp5hgABDGnmLMaeYAAFMaeYsxp5jAACmNPMWY085oAOhTGnmLMTeYAffNMA59jTzFmNPMNAAAqsaeLFmNPAD4APlmNOlSqknRiExpCp1SxTvPOb5WK1pa2IweD3kAQy2220C2222l8W22+L4AAAttkkvl3Xe97734WYk8WLMSeAABRZjTxYsxJ5iAAAFmNPFiwAAKxsAAKmgAABNW2nzTAOJoAAAbQBbbU1bbbbW1+1k+Xd75oOHYW/gAAttttoFttttL6SST19vwAdALbZJPL473vfeqattttqauW6Vv7bTA2kz4AAG0W222prltttqTkkttqattttrTuNK4lcdptpgbbZ8SSSRNazwVZyTU3pNzk9B84QozumnsD76223wK24m7bbRS+tt407fB5t+933jYBcoAkBfvvvvvoeSdttttTVttttTVttttTX4AABNW206mwNtcWNgB0A5jxYk8zMaAACoWNAABU1bbbbW1OLPy2b973r73v2e+8BwKGk2GwAp2bu7bf0MPeTfve97tDYAAAe97wfBbbE3F0kk96pq2222pq22/utMDaa5iwAABNW2221J22221NW2221NW2060wNprgAACattv379+0+c8c3RH6h/uLlDMoaq/sJtJYTbptJb0mw30oo9i6XgNJyTN34PkZpNhtnve1L2298Hgbdv5tJUxAfve/fv3gAC22STel3H+bSX7G0linu3t/fqmrbbbamrbadaYG01wAABNW2221J22221NW2221NW2060wNpoAAAbQAW2pIzMf7NJpLmk0keh1NY3SWt7zvWrOHZv2pJFNySSDAAAAA40wA+AAAAAAAAAC29TdyeU9bb4q/PG0AAFaTAAAG7jy2060wNpoAAAbQAW2pq2222pO2222pq2222pq22nWmBtNQVW7yH5VgtttnXz91Uc3+Q0Lp3bQAdN3W7GgYltQqUtW+u8IOXWq9yutTdcoczLvOaNjztAfreg1usVUVVkErUYkA6QBaSeYk0uHmp7UrruYtaa15Q5znjU4JM37p069dbp0hidinXSL7v0tVSu9Q9yq1qVR284pRnLhIHsrzJTJ7OwITf0kg83vaoSZ3sJJ1LRR1573533ePv9yKD7aWyR/ZDmMrVT5lB9kZR932ZNMvfJpOfJppPuJNL3TxzC7afZze5OLx8TyaS575pi9Zzns5373Lnu920yGwhsqaS6caew+5dKgaafANm/gw97bT9PeKBEw07u+3c7FwTV1FKxVNqkcaeN84e37wBVpp61xN73D4CHxL80+7W9nlvk4Upawm98rl43ved105uzDTkxczJNyYafKDQBswmmnTZwDQaaZbeW5fC20z3gwcETDTnI1SrEx3fUJpLO1hNJcbSVNpK/NPcvfePBWnpNmgN29uJNreNpPuYmksaauJvt5SHTDGmYAE73dxp6MaeH2wJKAKBzYEM7lttvaI2HCSpN5adZju9Xy10nNNOoBoOiGklZh61ONPPcNgWxp67jTy78AQxHNNOYGz6/W6aeXVtA+K0bafdmw+u7G0m1tYljx3jT1bu0uz5KvGzjT2H3A4tWNdy8aer36/UwNNMADorjTtttsF95P5e40/e9PT215XTTtq3d22gTA0HwAz4N6ADuGmmHdgcAA7rbt4qBKfAG5JNSSSXd3d3Y0mkhJJJlAABvbTAOAFurQAlTaSMADVsTTSVy3toGmmkEDRjTIcN6adtq59IAAfAAXby227aaXbQF0CeSaS97a972gh5p6TYQOhaa0mw2AE33TTuW3tt6a00w0fAHA1bbb3VoAQ6baaXA+QZr7ttvYqAB8Ajgavk30DZA97TTAAJgU3pJLnUu87zvQDqAAAAAEGAHwbA6BNBppk+NRfNNLJ77G0jf5t7lcijXIS+t+8EhMgyEk3GQhjJA3CRJITCe93Oe6d/Z7sO8IECaUmlzdy/p+/d/eFwAPrX4AA971ttttOXd3dkqEgBYAANsJJJJ3o20lfxpBpNJgbTST/Y2k1+xt1Y00AAFSdttttTVttkiatttI0w0mry222tqySFtTQAFtTUkkkiTkkhbU1zP2qBPuJs6fX935AbTYQ5qvyWwAPWAslBSbADIdvXe9l2SbaY2wEAe8AAAHu96+9771TVtdttqa/AMABNW12nU2BttB0QACUUAOgbTVWW222JqSSSRJySSSJq2222prtqiZyHTAa8Gwuaku36SakkDlkkkkgJuSSYbU7AyBYBJJLlSSbu7yjZv7980+/v200IIAAmrS3627bVttttTVttttSdttttTVttttTVttOtMDaaPgAATRbbbak5jaaS/LE0k2tZpe9zvve9zxeVW3lv6u222gW2220tkkk/NpLwe97wW229vgA395dvJJ71TVttttTVttttTX4AABNW2221NAAACattttqaAAAGgAABNd73ve973tKTuKVcyo8qsinffPvdQ8ZDahsX80n7daiXz722/e9303PxctttKrb4OJsPenu6AAD1tt+tu/AAW2220LbT3dd7391Nz9+2mgAABtABbamrbbbak7bbbamrbbbamrbadTYG00AAANoALbU0AAAJNqW7W3iaSxLQ9rEsx87wC/H68qttv6q222n73gAC33bUkrbbS0800ve8czEmkAcTaQaPez3EkmgDsTf6K/gD9+qattttqTttttqattttqcxK6tkkTVAAATUySXjTtDiTOgQATRbZJG1Wstt+ttbUPZJzaf2vaV+969Tf3vfuetpxNhdyKSQpfAaTYHUHoK2yT1vLRppGNPlAPTwWCQBabPVSaSKxtKSTU8W1JJNXxp26TV+tokw0YJo1bbbUnZJbbU1bbbbU1vkkkiapbaAJrveyXrTobbWJuS5JE17ouyq1rG6bqkkq3sTe5C86379+8EvgC20AP3unwBwt8JsLbZauxNpQAnPVSaSMJgAcaaR7wbaaXvevO97973U1cE9a1bbbE1E5JJImv0knPmnJpNGcEkjDACpr6SFtqTttttqattttrak70+acmjE0Z8AAVNWXSSXMWvc95QO/vAH4A8AAFPAAFvrLbbaF95t+9v2JNIDaADR73vBN/l+k52T9+ra41km5JImqrZJImu9qbkOpJW6a3lu5JLU1lskkSZJJJE1VbbbampkmpDabt007bbbamt5vNlOdm1z6SKPO61mLGjXQt/Hi2q2/vIAAlwkUkkuy773pd2SC600gAAAaaRYYNspJtMA3trmOb2HU13vbu7u0nd2221NW2221NW22/o0w0kwAABNGABbE1bbbbUnbbbbU1bbbbUz7rrfk/ZIiSAMzPseU39KIAqbmQUSqimQCipCKp97RhJoSAJvO7/Wv1vnSBG/YQCnNbyiNd7hANYFIAtZAJQh+omnWI2ZvPWPIIgxZbSmoq4Lqc7l4W7oU3F9lIAg77sPbOW6dNIAp3jrIAVqSAMR3zya31MZMCUqfvz1PL+2fM519nFPfaRACc2ygBQlEEQaJ9EnVisaoZNtmi1nzFxSaRkNSNk7oZkr4rH5zqh1IXv5w46XnVVPbcYVOoTFVs2omT5yORGNoGyRlGYJvyHzijplW0LbUMhrSjEe0MJyZqGatpGxNjZJtUNVS5y5Yh6jlQ+ZR1hGmxLNolqH3IcoYj/aOY1Dw4H7UXVlWijSbVDmJOFp/ahyaKmZtUjIZVlirZstm21irLnnd6hZbNW2tBbDZmLYl7WXmtprSpOUkA9nAIDUgYdumQk3q6ZPe+90b2Zku73YEkkklZrsgmktaAs4BnOcgASeAAPT3gMALcsttpTxdJJqqaeGm5wznYHQ1Ukk5JIHADRze972e9QAAKYrbbbQwDgBToABaAAHQ1d223yuAtJpI37773ve8AA27ariSSWY00nmNvePWJL7Vt5SgAAFOW28tlOhppmABstt+ttADYAHbQAuzRA4QPJpL6d2mkjvu796319h0A4FAA0W1W9toBgIAFLWmrbbQBgAFly220AAAN9t1b9bTybS973ve973u/W7vLbQAAAEJsTYmxNibG1xc5pp85wAL0AAALby23lANBppgB8HDfHdNO3t79Z5NJTWleHvud973jYBfrbbaABqBoACtpKNPLq202HE2lxppbAKW0000rbbe2oAAAAtttqtDAA82ku40mn73ue8BLltvgNtNIADoaT7bq29tD4A4AdDVtttoAAABZMkkhSmJNLbTSOgbOhzyaSkm022I++70PeAAADnOc4AABtppAAdAAAAAAAALeHPc+M8m/dTxVN6WNtJY2ksxahsiyGi2omQy2RNix4nZ9KTu9s7fySXPtJZOk9+YTztv4IA2wAAACSSXdl973vey7kkknkB7VUmkve973ve8Iqk0l72cpJ1SXa73WXVC2p8+clT5ncv9wOYD/cpxNtW21tttZs1bDYLYit3vfXQAbQFttqattttqTttttqattttqattt6jG2GmtoAABNW2221J22221NTivqt6xLM5i+8m/Lk1PTib9fL3lsdAG02SAYXADKbACcJBNgAcvvezt0rJACSSQaYNsAAJabOyST1qattt/RpmGJoDoACaAtttSdttttTVttttTVttpGmGk0B0ABNAW22v+PjSAAImhY0mlf3yxY8X1+/d2Izne/wBH5+PSH7ZbbaAbD627u7u03I27u7u1djTSgAAEkkAAPffk0lRN5u22/ompJJCNO4mru222pr8V222pOWu229dTVq3bbampZJPbBHIg7yXs973veINbbbCG22+Ng50cfmq0t1SVNunBt2RS9etkixJ6VA6JgAAeC3wAHiSSSQVxp0QBxPwQ2mmkUwAAz2+d13vQtNV21d3fraZia1ZJJE0Cy222pPtkkkTUkkkqqaurbaVpmJrRbbaCay2221Jy293dxBKiI4zS9xL7TxY5qqOzvskRrdNP0C9t1ctoFlttpZJJJPIA4B73ve94AAnpJJPRNeVttv6tMxJ22221tW22wqattoAJoAL242pJJJamsy2222pq222xtXMttttTV53s7m+b+/H7oK+O/W407baEPAAB4LbbbS22222222gB5ppe973ve97h3Xe976JqSST9GncSdtttta1lttvU1ckkk6mm222ENtt7pBu7u6yBtttkHbu7u9zaxTaSrqWLXuimqrmK72BtN+mLOztpv0AxsNNOgNpsC1N3dxNySTd3d3d3Y00oAAHSBTTSANNMADaa3ve9+60/2Jq23ttqattk7MTVttttTVttttbUkkkiattttqattttqakkkkSckkkiauT2Q4ta+2mku/d4vLF3x73xe267LP1t/fve973r72gttttraANJs+YEUGmldNNICSQCXd3d3d+fOc5zh5Ndkkltba1bbba2pJJJE1JJJIk5JJJGrbbbamskkkiaskklqakkklrSf35ZnO+XV3xn33f3Pj0zvpT8AAHgskkhC2222+TaRmk2BwxJpHvbaaXjxpppABtppFeqk0l726Xe57znPW2ru77JE1JJJIk5JJJE1JJJImpJJJa21dW221NWSSSJOSSSRNSSSSJqTtGqIAZeSpvPkEeD4Lg1RsRF79+/Z8js+d/SKZS8tt5aAEuW2yFttoAeaaQYAy00gAbYBGAG2mlG3jxJJO/r5pJW2/W2tq22SRNSSSSJOSSSRNSSSSJqSSSRNW2221NSSSSNVXu7u7iBVvzeaf3lEB9mYgDtRAE8b8IAolch9lVs5irbtVdTVfJZt3j8SAP1/B6nHyEIn51bzmsvD4vREcoCCcqCIUBD5lG/s4UfkXTEdWhi61sS4hto4TmbRXJGNrhplzcW5w5rbNbnKhyrYRoUyGiNgd1yrUNHD5yuCzbaq0m7NPDprpwrjOUjrgVcoefzpzXRahjCn9rrwC7B/fezzUPPKH3ruQ7qV3I520S4IyPvLsjoVaJpG8yfOUP3j70g9ojojZnrojqh0FbKOtQ594UOJPrp0jrdeUPC/Y8/kO1XuodIuTNKlVKkpswc0qaZXbTSV7V3fcWgLTSR7Xr72aPe90h0Od4BsAAwKrbZ8gDnwBwttttoHjEjEjWm94ldHtfd5977QavLb9fAWmteSXveqb737773p7wAAHyXD6369+vLQPgCAAAWgAAC73ve/L1Pe+1vnve94ACSJ8xcDnEkwOSQAAAFtSScknAA+AA+t007lttAAADrmSSSAAB3naYfHQLbQAOgbNdLq29toALuAcC2NpVNpLE2sy22gVmABIpJJAAAAIlctttsG0lvERQHAIm3aiqYackkkiulJhpgACbskkkvwBwA+AONO28tt5QCBoABD4k0i28tt75S1bSaSPc73vve973veAC23wAAAFtTTTtttAAAAN223626TaRwNNMDcIbM2aadt3bu3lNNMIcNpNLyaSuJpL3t+973vattt9A0k0gACFttttNoACw0aaaQW29ttAAAALbbbaAGLTTSOUwD6Hm2n14k0lTDgB7wAAAc5znARjTAA000goBAxaaaQABKVswAAKjNeSbckkWsUTf2szMzOeecKtSewjYtNFXk8KeZloggGsSiAMhBAfPnVrzvLX8++kiImDMa+O9/dv7U6S239+ttttAC228smhct3fJJJJJJ5t+973vb5VJpL3ve973pulFKsgKKovySo6vzAxUUiyCkhtLaI2trX3797gP9l5mxsbM1KbBbSZra1lttWzZma2yNqGxsthkyttZtmFRYqisFggwUFUkUFIBISBIBJJCBCOnu7u7iDt3d3dCN3dkkTUkkkiakkklrbVt5bbU1bZJIk5JJJE1JJJImvPamJazSi4r3c1tN/v2okl30L8m7fbkkqbtofBdJu2lM7eX5XFbqgAAAAAAB5p+ztyTWtST34battttqatttsbUkkkiTkkkkTUkkkiakkklrbV1bbbU1ZJJIhqI2W23EG68+zdhd+aIhAgIC/sxJXSnb+s7PWTvvJ/gAPGX3veAAk9dJu3d2VBppWBr1Umkve8baaXvY9STS97wABOne85w4muc5znL61671d3fbadU6pVUJHT3d3c+hIShI7t3deqEkoSFwd093dvQIUIRDBd1Hd3ccCSQkMDuk7u7SDdbb7YiNUJQKd4iO7u4gcyQ0RCT+v31b9ib5i76+L++7fJu2/gP1kkkhQAA40wt5bbaAeT9mk373tr3te97fj6279+zE0l73tqSd731bUkkkiT+kkkigb3dbINzd3d7oiBy293SCdbfbsQNt62ENt5hAxtvd0g42Zlru+4csLSx2GwkJJR8mAagKzPnz79Rzb+69+fes7u67QIAAA07dAbAOAB5ttP3ve973vet800gAqbz83+LJ39PNtTUkkiane973qT730kkTUkkkiakkklrbV1bdW2pq/SSSJOSSSRNSSSSVY+Ys9+3z3r7xxp+9+7+NWlttAAAAC222QtttySSRSSSTzTSKbaXqpNJY9TTAAOfZ9999DzbVtv1trattkkTUkkttTVttkiTkkkkTUkkkiakkkkTVttttbUkkktST3cKvn8vsX7mgp+qbvtcz8vAdOpsDbttomwDh5rwcTZTDmpi9bb9fAAAAAWgB8YvNPM/JaySSfq2rJJJG1JJJImpJJJEnJJJImpJJJE1JJJLW2rby22pq2ySRJySSSJr92b+zeLEt71w/Yvfvv37L+LAKAW3wAB0Eb/e8ABJ63abtt8a6ABAA97EmkAAfP77774qaikkk/Vtq28tt4xCQlwu7u7u0EIW7u7umpJIN3d3ebbbzMzMZ27u7vcjVq3d3sIhbWkTPvWB33622XLbaCAAD4AACyFu7bQ6BpNgB8Gg/IAPy95a73ve993ve970W7u7utttt6ajd3d5wQu7u7ubbbfG7u7utttvd7u7u58RH15vvaXVwK5x/Mu/n1X9uy4Ns+AOAAgAAALbba07dEmZJNSSTE8ABYEkg00gIm9rvrz3d+62xt+tbu7u6Ntt5mZmc22293d3d5ttt6bu7G7rb3Td2vlzn273M66IAvJm9k/XfvkmlzsINpKRNJa5zV1nOygQ1ruBAdhYINW54iK9d66XLPfPd75U/LIA+SAbd+zTCpeXYmZZt8+N/fJAM1NvlpLEdi79o48eL6/ePQlAAAPgDm+673ne/AAH2AAsvl9g/NP4aQk0uJNLCOUqbCNEc5NsbZGQ1DNIxmTbNZtmtzXMbTaahpG1N1zmkaVpUyGjYbXZ2q40ppAzdSOKm0lbPf7si6yV48Pv5/fyHO7fKHzrWxGsiHIc4sktEbWVwt8tUc37tI+adh710vC5n9ulT41BP7Pe0nCrjv++f0u4/Xv7Gk7v0+15Z5NKSck7Lr2jYAIoZy23n1pvgAfBbbbbQAAAAADgHrmVi8ZpripYos3vhvMUu73d2SSAYTAI2+S5dyKevjQABICbtttkoGgAAJcturQPg0ACkk8mkupNLO28373vz8/Pe973vd3yQ8nzMTN5NDDSKhlpWVnDRhTGGFoKjkKsmYMuffb533ve8AAZlttttAAAAttttoAABZJJIVAAa973veIHkAHwAABpNlv1tnLugfK4jUD4EFaTTMAACtJJMwADmmnJOSEujgAfAHG2AHwB5Ntfe973vve97turbbYGgAAPttOcafGmNPd7bbaAAAAdLq222gAAAHBawQg6Aa8hezPe00/e9fe6AAAAAAAAAA20kAAAAAAAAAYY00gACBjTSAKYFEAAAcz7fk2373vdvvHgAAAAAAxppAABQAAAAAAAAADTTSAAIGgPg00wuwAAA82/e973ve94AAAxaeBvfNJNp84AEBNpAAAAAAAAQNJsNGmmkFW23zyaSO/dj2Xvavv38r4fWso2s1RqH9Q1DhpHFXFFcKNSeXEq883d/R81H7zlf2vuj+1+0OYf2KmNc39uTfp7tvN22/W31ttttAtttUhbbaAAAAAYY0wC3nOHJ5OLG1+FAd3d3PlySDu7u5wbAkiN3d3XBsC3d3u7Y5R3d3d20iDd3c3ZbbtuW27b4qfLbeW3esxJcyXhVzO8s/dTf66EAB+Tfve2MAPk2BT7QAuJsD4+t5bfB4AAkAMhCgCXNUm942c4Y73ve773He7u5uzu7u5uzu7u7uxu7u7rbbb0iG228ne933v7baUk5Lbn35XW9+4d7bl5f3veKAFvgAAEABfrbbaFtA2AB0AAALe/ffHen5SSSTve973sUxfrbbZMafd193d3d27uvMzMndW7ubuZmZr3VS1G7s5cac/LNfva373vfeP097QFtt9bbbbQAttkkNpu20OhwA5bbb4PeD1/ST6b9+a229gabbeshbO7u7hDTbbettvm05XbbbJJJKuySSd73ve9imp2c3mlvnvvvvrZ+/BbbbbS23wAe973rba07dWm+AHx0DRjTC2/Wq2hb33fvd776rve769DVF7u7v3YiN7u7u5ttvh9ERuzu7TTbb03d3d15mZj0W7u5u9REIgCjfi973jp+/dA2aAAJbbbbQAttkkLfwe973va94tvbbaFsn3ek/X36W2yfd73vexSTd3czMzN0W7u7uZmZjHoBtat3euCO3uttnZJJezNNP34X3u7973i/safs+tu7QxphoAOGGNMDYBu407buSFt/Hve8AFkAADpJLsvve9Iuc5zve85zm986q7u7u5mZmZmZmfdIjd3d3X27u7xu7u7rbb99+ed7r5zrtfaGqW0KNhTUMAP9lK4hqSGtKiahUk226TaSpNt7ptJKcnak973vS5JJL+SSSf73ve973vGABbLJIUA2BwAO973nOc53ve958D5xVsVY1qFYksaafsAA/d73ve97JJJCNO2222SSbvG7u7utttvTd3d3W223sEajd3d3p+fW37731JPKGLUMZQyP9pPDaSppttU2kqSW8JpPCZwLD3vRNwAAC2222gBZfNN6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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory-main')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')
    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
