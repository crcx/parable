#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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ySQADjJ6Nt5THEJR5QoSOdQBYXmzMyklCmdLBH0jxVIEzERA4dc53zXOc+5CIbBQ79NgoHQAnRIK913n9u+ec59znbbu7qqxV5r2M4HBLqrqkyyB+zdVYbRUfN731ve/d+gfgRCUAPiGoqzH5qqaRGftd75z3ve9qk6ZjLGZRO4hHqLEasDRI/tQ6KJUEf37Ot733ve/QFF6PgVHPwZDEIJnu7uze1IAwYJIC+ue7O93u+xeUREQdAosM/NWrd3d3d24bjOLi+fW2yrq6qMAHTIHv36fv37X79+/fmw+Nv67u+3dv5ttutDgBQciIVh8dAnxu93dvbgs4HIiEFB77MzMzB45bbbbtvIH73fe9r3ve82Hwa7pp8Nom/3ufAWUD42227enAAAw1TiSSjVu/burUNQ2m229AZIAA7c5mZmDth8B7zYfSSAbG/mxx3gyA697IAAZtSQB4AG02223x45bbtt23kD97vve173vebkmpJJ8DYaCbkzmZmNu2HAAA3JW6vgADW022228ctttt23xttsLA+DA5pQB0AfW235tv5ttum3xttt293ft3d3d3AADdnZ2dD4AADCW2227b4222Fj422m54+D13Xt+973ve81JJHBkB17DbbbeTuoAAZsIEAAAoGSAAO2+NtthYHwAPzbfW28CvvqriqepITlV51zmc5zn7lvnFQeq6yb97n79BkQfQdAAy9DWTmYWIA4ZmB9POud/uTSmLmb5vNO93iTmPs5mdzPZKg36+m79vt39Z30LGiZhHwN82kiPlGOTu6efdHbH1QfEhwLDwcJjkRCly95EEoD4Zu+2d3d327updCD4D4A32zu7u+3d3fQr+zPlChC5K92EohcURELkxPO9+beP2i5u7vd3d3vmzdJVMXlhFWTuXqqgvbEmZfzRZmfiTooioCIoCiRKUoAiaAqiywjqylWCmpmlrhhgxJXRmZNhhCxI0TkGBREUkkLNTJFURRE/ieTE2esPA2bW7u77Z1byN3Tqglt/RChQ23obukQkkAAbofAHgDfaAeAD0EpNv5tt+epdw8uxxRCS5HFv2+9u699s+riBJ/d823XmwPFgAicy7vNuLmZrPvx19znnOc56Km0EKBaiIEA+SMgaiMFWRGZmu9/u9735dzJbY223MytngBqAPIAPaBrUIkAB3sXXBSkko7KhJRMJScKL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SsXMc1VVee794BXU8iElh8IAC024SgUapJA+BciIUhRsJQGebTfMzLoy/sLSUN8bbbbltttJN582JREQHIhJElgfAF3dVCxmqnYAABNST6T9JzlzOc473nLlAAAcv6Xf11d33veb3frAAA9i/pMT6VJyt/v05AAAMzXZ773vVVb3v3PAAASfST6SVVb7nGM1U7AAAJqSfT3quns5zir5y/UAABOr/X9f11d33lfv19sAADuL+9c+klb/fv0qAAAZ9rvdPd2XVV2c2222222222kQ0KWSv0EbK+U/QlCUpO7twvbl77dAltt/MQAd972fEpijpgAigAUAIwAdMgOO973V82cnPU+e9WKqoAAMA+bxzWZzME2xtvMzDMzBttm7u7u7u622/JKG2+6AHwBde9CUe8WAAATXpPpJOc5cznOOd725QAAHOX+u7+vnLvve83u/WAABeve996Sc5yt7nYAABma9MSfp+k5zlVnOcVU7AAAJqSfSSc5zdVU7AABi71d39Lu+TvZ9nOcd5y/2NsQw0znONa1rDDGJ8v67v6+cu+97ze795YAAXqSfS7vnOVvd9gAAGZr3vfeknOcre52ABgwevOMZxi5W3301v2691gAfAA6bfG223bctttt40BsPqAEYAOmQHHe97zZJ4zT1A6H3h9QHvT3shJJ6STwAABsPve973te973e95vc7AAAJr0k/T9Jz7jPLmc5x39jOM9duUAAB+4zjF/ru/r5y773vKqr9YAAF6kn0knOcre52AAAY8T6SfSpOc5W9zsAAAmve996Sc5yt7nYAABNekn6fpOc5cznOO9xjGO9uUAABvl/ru/rrl33veVVX6wAAL1JPpJOc5W9zsAAA8wn0k+lSc5yt7nYAAGMV9iYqrq9dzjDX32/ffe37vfeBoDgyA6YAIoDpkoPe973nse95tt23xttt07u7rzeZmEJJhAADQH0Ib+cwoUOXLb+YB4hQHAbbptthYHzbbpJQ2/m5bbbbwAD4Au7r3jAAACa9JP0/Sc5fUznOO9xjGPu9ucAAA3V/ru/r5y773vKqr9YAAF6kn0knOcre52AAAY8T6SfSpOc5W9zsAAAmve996Sc5yt7nYAABNe9770k1znLmc5x2sZxnvblAAAcv67v7F1d337veVV+sE0xrWGMaZtcn2Jd3znK3u+zDBYAGIX9d39i6u+c5W932AAAYxtqSP5EYgxBnMyIyI1VPndiOd8EdxxI91SP6I2gkeygEBKBB6IIhNwMIh44cxQ5+g1qxiEH0U+uaucgswcQeiLs9Xqi2ssrJZZNrwCBpCCQED7T7p+ld8CNkNaM+9jut3auLz2qUxSvXrE1JA2obcAb9gMKEgRKEA37s+vPu+pLmk2NzEP1SssRYQyVLKkaMILQlhKMSNNV3vO9773upFXan4pXuhBqI3U1ne8773vfH3UjVVlKMSM13vO913vfklOEO673ne933vyJbrMkslFZU7k+AobD5urqrVVXY+Aq6uq4iMUKypZdVSek02kYhBIAND7qvd3RAIRqeIEDjdrs7u76UfzKErbBJX6I+P7ZzIUHN/u99737vXcQQ0CkAoEqo/KOCpCIQKYghmENiCFn83vvfe973+BNG0wQChBxV0F0AvRhEYazved373vfXZIxmMYYgyWRHUjM/d5n3333gi5kR9RayvvvvO573veojyqxUzpkKaKa1hAIEqjKixkUCUQQ5KmjFne8673vfvVY6lmIkxkKwUGojJrLMSXrLRuI1rJZYZmYmYxiIwoyqDM73nfXe96B2IzGZSj8kZKNZ3vO/dzve0J7GWfZVLV3fee/fa+5FU/JFMRCjOZnXTb+1MUgHgBxEQoX3lxtvrou7ur2GgODIdM9MAEUHbqrqpiSSpJLqqtgAKAAODXIw0CVJJPpIbDQHBkB0wARSSZ1mSScpAEYEknJMyA4NZB9K5Un0kj4Gw0BwZAdMAEUEYBQAjAB0yA4NCSSTQaPuBsNJJNyTMA6YBJ2SSQCgBGADpkBwaA2HwPgbDQHBkB0xJJJOygAUJJJ2YkA6ZBJyTPZjEmbu60B3oABoDgyA6YAIoAFACMAHTMkkgaA2HxJqSSbg0BwZSSTkmIAigffV98uqqrCTxAa0IF3QkIWNSNN/RZZ98/tn77t3c3ZJwaB72/Maw3eKqrxfs8Enp5oASSckzIDpkJJJJIABzfkgFc+r1e99993d3d3aGMSQ0MApkNGKxVVdMXd1ec5vGKpdVepOSSQAUR5mZmZeNt02/m202AAAAgAAd3d3dmDlJJR61yIhKDoeLAbUttttt3gAXdVdUpJJJ27mLrGIAlXV3VMEkk7d1VUrF3VWwfAl1S8BqTKzK+zG28hy228zooxJJRMJJRK4Hwe97vvRgCdmJO7mZGwAVXOc5znAkkA3JJBm7ujNCRnIM1d1vqXzYm+QklECSiImYUKLnPeYAm222+973vT73u0SSFzzu7u7tQhJYMaGN8sC6q11V57yrqrqvuc337o4NAaqruqArmKkkknYyA6ZK+9VXVX73veb773tfA4NXdXVAcm53POcd6kAAEzV3dVKzV3Xe97zruKq7qoAjF1d1WsVV3VaqruqAnYBsPvVVXV8qrqq973vve97wHwaqqu6psODVWBwAAAG6D4Gw+DAfXd0HwAHru6uq973ve373vfAAAAAAKNh8AACsduqurxm7urxd3g+Iw0urqx3vve98OyKZEdMRYtBUyYCEPuru7u0wfGhzEHzLaD5n1Qkj+MV3FXMVdXXNan0+3i7up+/fvg0BwZAdMHTIigAUkkknZgA7b42226d/Xy/X65vkRCbrG9UQYAAP2PezfjVGWA8dqpJJdVfmLqrPAAAAAe973var3ve73vN795isYwAAE173vseknOc/hM5zjvc4xnvblAAAXq7uXd3znOVVX6wAAGLST0SVVVvc7AwYMmZr3veklVVb3OwAAD2J9JJUlVVb3OwAACa973pJVVW9zsAAAu/sSSXd1VVVVfbAAA3NZ+kk5UvF9739Wc5x3ve73aAAAGKvV3d1zmueeeeKnnnPuVVVVVVKgakEPcVzua1+5+1r0+7Pe64aA4MiSckxJD3veer3ve8GSs3d0kn0k7MAHTIDjve33ldxnmLu6Ce9nPfaA5LqYemUlDbbd4+JnvoiFLefZhk3YCAPDSUEgHQAPKpLA904AAGAfNuqo96dgAAGNpP0k+/SVVe3udgAAE173vp71VU3udgAAHsT6SfSpOc5cznOO859c0AABWb+kn1yd5zl85y/WAABepJ973qqpVVOwAADM1JPpJOc5VVU7AAAJqSfSSc5yqqp2AAATUk+kk5zlzOc473vblAAxzWNFru/ru/3ve+973v3Z+IiIUQkiIcDUkKpd7cu/2fv3tWgAAfAA6eTmZd3TyczG8y8WYszGCkngRj3vfAnGQHGO+kne+84mZ6STUDbYIx49dVfveE73vfdk5jtvjYAAAaUgDoBoB06AZl1VVO4tAAC9Xd/Xd3znKqqvsAAAzNST6STnOVVVOwAACakn0knOcqqqdgAAGZqSfSSc5y5nOcd737HbnwAAF6u7+kkvve85zl+sAAC9STf6STve1VVO+AAAmpJ9JJznKqqnYGDABmakn0knOcqqqdgAAE1JPpJOc5VVU7AAAOzuPfffmvnsfVP2+VJAaEm53He973vJMSQk7KnZiQCgBGADpkBxXe97zZJ6x5iqqwknfSSSSeePpPE133e976TwDbbYAAAAAfAF3b2YiFmZmlTMzIAC9Xd/SSc5y+c5y/WAABeru/pJOc57nOcnqAAAmpJ9Kkne95VVPeAAAmpJ9JJznKqqnYAABmakn0knOcqqqdgAAG59JPpUnOcqqqdgAAE1JPpJOc5cznOO9725QAAF6u7+kkvve85zl+swAAF6kn0knOc9znOT1AAAY9z7nfY/Pu++xXOVJtuq9zvue97zInd97jvepJ3zAPURQPbD6gBGADpkBx3ve96J4yPe9773vG5JJJJ7wurDvpJUknnBpttu0lDfGAAWkoA+QHAOgF3dVVTvgBemNaxgwxa7v67u+c5VVV9zLZUzLCcxUzLHmc5zrnOc8881rWub+eYqZlhOYqWGcznOdc5znnnmta1zfzzFTMsosaYYvV3f13d85zFVVX3EWAAdx9f6739d3fOb3vd8sAAD2J9J++kk5y5nOcc5zl+oAAC9SX9JJzl1VVfbAAAvUl7/SSd7ve9znQAAJr3p9JJzm973OQAADHOeYm/b3v3kk73Xe9792Sak8ODISckxJIEAAoARgA73uO970nZJIAADQ8czV3UkkuqvfsSqnqyA6AAAHq973va973u93ve5yAAAen0n76STnN73uTrBkAk+k++k5J3v7FXrOc45zn2L9oAADFX9Jf13d+72qqr7YAAExf0n7f6STn79+/SuAAAe5ifvvT6Sb3+/fpUAAAz7XvT73vblb3yp2AAAdn1SfSSq7yqqdgAAGMTUnvvV55nPGMcZnb+znOO979i2YAAAvV3d/pJfOcqqvtgAATnrxwfd+uvdAu7u/rt4OmB8AN02+VbfPsysrncd6kkUOmaqrBQAjAB3vfXCXjWLu699JOc96SSSYhiqqwQh73mru6ElXV993sxJ497XgcAPe973p3Mmp773vVU5VVOwAADHjM+1Pfe96sVOVVTsAAA9mfakn6ScxznPqqp2AAATXJJ+klVW97nIAABd/Xd3+u75jGM85z6qq+2AABNckn6Sc5zlzGMZ73tzbFZa1rDWc5xrTRrWsXq7u/13fOc5Oc5frMM4poL1d3u93V33vK3u++AAAmpiTc3JOcre9znQAALznOb+u/13u7vnMc5qu645frAAA1Pa5y+evnb76e97nvfvevzYaA4MhJyVzuO9SSKABQAjAB3ve95wk7MRJJIGjwbbTbYZmZdqk7u7Y2DK4AAA2/e9Xvanve97ft+9Ocre9znQAAPYn2ve+970qt73OQAADHU+kn0k9Vb3ucgAAE1Pe+970qt73OQAACakxJ+klVVzOc45zl+2AABTK/rk+klXzlVV35gAAmp733veqc5VVOwAADM1JJ+knOc5VVOwAACakk/STnOcqqnYAABNSSfpJznOXM5zjvcY7c2AADe1ekukgD9kJfvhCDMz7fc/mF6IQRu30IhzmCIfkQOa6EQ5zBEOc8BSW9UKEvr3d37d3B02+Nttu2sWZmZmY6ABQ02HyifSSfd7nuK73mqsmdzNcnkTxJQB2PREIAfqeYNttwlA/11V1Swn6fu9739J+AAHZi5ifqtQlvz+UKEvpbemdDbu7qkq3NmZmZmZmZAmpJP0k5znKrGKnYAABmakk/STnOcqsYqdgAAE1JJ+knOc5VYqdgAAH7E+kk/Tk5znLmc5x3lz8AABMVf67u/19vnOcrd9sAAD0+kk/Tk5znK3OwAADM173vfvSc5zlbnYAC9Ma1hi0kn6XfLu69uLZnUlHOTxSuTPElHOTzeAHTdu7s2A++oPvP2zVYA5lhGVgDmWd3SDVbzVVdV7b2MU39vc7+3uc/JPwHwNhoDgyCjqVjEkA3QAKAEqSSSTvc973vQk9Y973ve8CSSSpFSSZurk6lTkk3DrbQBJ5vMzMvMxt9bNzMy7vdETPElErkzxSuTOAOZZzOc5z9znPPPPO9a5v45WAOZYTkWI0c65znP2+c888813z3lwnMRsownMRhb3d3e7e3d3XtwnVMc4lE8meKY5xKJ34Df7fOb999932qe+c33dk5gNlYTmI0Fzre97/b5zzzzzvUqa57u4TmA2VhOYjXd/ru7/Xy+c5yqq+2vDGmGGDRm9Xd3+u75znK3fYAAB7E+kk/Tk5znK3OwADBia973v3pOc5y5jGM95c/ZAAbg/V6JtLXMwCAXNfdCAWR67zfJCSzM+1QuZqIxVXgjmvf2uKGc1reHudGEOqsiyHIqYv2cOnrrrrEEGp70ghU4eTCT649SQgi9rO9fl561CKyMhKDvxBDo/fhMpqoiA9nPnDGm2JCXkCBiQCs9Hy6ReyvSerSN9O/XUzxjABdxBL+fqf2JoYyCqeALETwovN885/f3v39/dinmaqZBVXfcXdXVGnJUkqruqpgZAdJJOiiffax993vfO9+kI8eaqljVqVXVZuqq8Wxwd6SSSSRVACWwMtZOZ6IiIUTmZ1u2+ERCiJ++EABWY66gwqc87STlTIlb9955xy/5P7+7/d9J7XsA+BsmZJ2ru7uqquVdVeKu5jfV3R3dohAufd7ufd16AgaYxtCQyRlDHWd7z7rve/Cq7SMlGYAomaZB1hipVXd0wCGfp3n6oUKEdPF3QDUQoUR113vzbrzefJKEpl4B8DYaA4MgOmBWARSAAADuTN3daBymvVVVV+973vd973bu6MhsZfA+6Gw0BwZAdMSd1nE1JNygAUAIw4NDpn1VVVbWLq6qs+z73lbVHLu65W5PvvNjL4H3Q2GgODIDsDQxnGTahsPhSSSSdmGw+OmZplJOSbu7r6SNubD4HwNhoDgyHTPTABFAAoARh8DbpmVVVV8ZPjg3d3XwbbD4HwNhoDhiSSSdjAyCOkkkkqQBGGgm5JDBkGru62Hzmw+B8DYaA4MgOmB2jJFAAoDbeOZzMzMx4+AABQHIiF83mZ2szO4x8DYakkm5JkB0wNub3W8Xdnd29u+0z5HNLnDfRAwGwf2JIi5zPvvvt93ex2kjqmMSRMdXe7ervUkjdjpqpyO6u6HJAC9e5PujzuT5IbET9uZv0JI37M9obM3d1zDLWJIYdzd3Q++GTN3abbfsbA7EQpAOFCHyIhN2236E5FFVv1oF9BZBZ4LeVPH2/vvu/331TQu673ve9/dyU3kl7mIYLuULid3NvZjWkjX3d3uvuISR6u6nWP1PK73vKkfaHTPcCTclTUn0MG9Xd1gOumx12IhTxt9btpxERCJia+iIUgHQCXd1nmLu6aBGKfZu7ruDRxwzd3T2vd3u8HSkjJ6e7sfV2pAIUjSBNMuqt9d3WQTSXLxVvru60b+GUuuYfXd1k2zRgzd3UnJHFGbu6A5K+9d1VfU+u7odd9qvVM3d0FfNHe93jvc97sPusgV2uc5znOYZu7qOaDeAFFPgbDYfCz11V3VVSrq7uqr2Pe973ve3u7ug3sMc7cxmSTslVdXVMZA72iQIOfd6PZXgDpoEgaBX55fb7d5waqquQZu7oRJJJOzY1VXdUJlPjpy33BJKIgPuhxgfREJtpt03bfFVWD6t1jmLu6z3tZ73pzrN3dRkE2zm7uhrYuVJJ3vTNVd1WgOdcGg+bbbp28l/e6xQoSahQlKhQcK4AByLunQdDYfMHTNVVuGRoDgA0ODreODQBGA3gfMHyUQk2227lsyYhJQHwI45fT7meS57iz7V3db1s++ECMBso+cGgDoeALKBt5mZmZmehKEsUREKPoUwkohQkCYIEWwQg5919nb2nAgH3d3d3aIBLEgOjuru7uwDzEeaPNeYvmHfxH4Zrpgl1fhviCIeoEE5AIQe99KBDzW/ediIbgQE73ioG976BENxEJKPB8SoiIgKAPgG3Tb4m22m7aypJJJFAAoASpJJJO97iSTMdPGwAAAbbeZmNtvuWZOZkJReDAbeY223mZl3d3dihQlkqEoS4+QoiG96e9933v4X3vec5dxgAAD1/ST6Sd5zlVip2AAAY/J73q9z05zlVip2AAAftT3vfvV6c5yqxU7AAAP3se96vV7nOcv2c5x3uOybAAA/Xrn7Ek+nZfOcqsVfYAAB+973q9Xuc5yqxXOgAAfPLxMSTs9Oc5yqxXPAAAfd+Y73v7td5znKrHOgAAa52Y373vvd53nOXM5zjvce+AAA7j5WL9v7f7WBVU9vvJfvd97373ve9sNHTLgyCjqpJJJIoAyZu7pQnXdPkYAO973td72tVVWHx6q14HRWmPexVVfgOz076SSbu7owbabY5SUZmZd3d3d5mXkuuMDwHR7fe97zsAAA9mfa53OMd7vternOfYreOeAAAx+y997GM+e9+9+7VV+xu+eAAAm8ZxP3ve+9Uqq3OQAAD2uc59z3qqr9nOccu5+AAAvUkn713znOVd+sAAC9e9+97fr5yq3uTvgAAJqSXe7vnOVvd32wAAL1JJ+kqqre5OwAADM1JJ+kqqre5OwBixrODGmNK/O+ncX9up2Ou6z13OvmgAdAH5tv5ttum3xttR0wARQbD4oARgBu7u7u7xy33za0KAG+ZjADA7EQvheybmZ4b93073vp5iSTve9SSB2qqzMkkk/SVVVvcncXec4Naaa1owC9Xd3+u6qq3u7ns4toA1f13d/rvdKre7vtgAYMTUkn6Sqqr9jGM85d/oAAAvV3d/pKvnOVV36wAAL1ck/SVVV2qk9sAACa1JJuSqqt7k74AACakk/SVVVvcnYAABmakk/SVVVvcnYAABNSTf7e9a1rvve/d1VVVVVIIIG5EBZMREQkp58HTxMRCA3oAdAH5tv5t0ODGQUdiZZAigAUAIwAd73ve9JJJEkkkgkkkkTve/rqrqp30ns1d0J5ymJJJJF1VsG35t2/P4AA6FVVa4iFd7p6ZmZmZmZkC9Xd3+kq+c5VXfrAAAvVyT9JVVXaqT2wAAJrUkm5Kqq3uTvgAAJqST9JVVW9ydgAAGZqST9JVVW9ydgAAE1JJ+kqqre5OwAACakk/SVVVfs5zjnLubAAAvV3d/pL5znKq79YAAF6kk/SVVVvcnYAABIjmSqr+z/ZBGsoR/sKo6FGEFHveKCHbT+rFBCzDIcZsQNpsbAPmU0CSFnvZM/q99+/fp7u7nwNhoDgmmRR0mWQIoAkqSSSEYAO972TckcnG7u6+bbKOpKACwv4BttvMMu7uk6d3dvMbbbbbbbltttvBAAdCqqveDCZmQACakk/SVVVvcnYAABNSSfpKqq3uTsAAAu/ru7/XdVVb3d9sAACakk/SVVVvcnYXnWBRJlcznOc/c5rWtd9857w5AOZYTmAOZYRy5znP3Oa1rXffOe84A5lhGYA2YZzrnOc/c5rWtd9857vgDmZhFmCmZYTnM5znP3Oa1rXffOe7uKZKNZlhGVgBmWFnM5znP3Oa1rXffOe7uGQuZYTZIOZYXMEoSeciFCXku++3b3NcQle7u+S3b+3eKt39+/b/fve0Bwc0PlHTAMiKOgkqSSSEYAO973va70NgD822A3mZmZCUE5d3dwlFMSiEmxnuTEKEgDqiISDgB1JRCRKgAAAbbe73znOc5z9zmta58qatc58a7AczMInMyKznOJf13e/13VV7e7vu2GGCwC9Sfpe7vnKre7vvgAAKxPpJv9JVVW9ydgAe1oDHE+/SV+kqq/fpOQAACa970/SVVVjGM73J2AAATUkn6Sqqrr2MYzy7n4AAC9Xd3+kqqq6q79YAAF6u/13uaqt/pJ3wAAH6fe9d23dVv7t3ywAEzMy53tbP333sXfKe3u72FmZoabO6HgGd8AHaACgD4Bpum3xtvjbtuXbbbsk5Jmqq5AoA73vUkn31VVg2AD3vezVVZug6Y96SSdlVV76qrhIT5EQuttugAEiQGzZmEoS3dN3b7dy7u7vd7uqr6Sd74AACaklfpKqv36TkAAA8J9JK/SVVfv0nIAABNe96fpKqv36TkAAAmve9P0lVX79JyAAAXf0kv9d1Vfv13ywAAN4n3ven6dqqq95znFXfvwAAGZqSS9y+c5zlXfrAAAvUkk3KxVVW5OwAADM1JJNyqqq3J2AAAcrutXb79v9W97UqtzfRu79EKMlRG7v0d3dvd3N9ugdANhoKOFMgOmBsIojYc2UAd73qSaSSVIkk/B73iSZOZg23jNlKISAALyZhKEjig3d3aSiEt3Q8lEJAAADbbYAAeKqqrxOwDBgCakkm5VYxVVfs5zjl3PwAAF6u7u9y+cxjnOVd+sAAC9SSTcqsYqq3J2AAAZmpJJuVWMVVbk7AAAJqSSblViqrc37uqqOY5mY4Z8c/c65znfNd99/uc85zHMAbKwiIzZc65+5znfNd99/uc84REnLK5ku7vd1ve/eznOKu/fgAAMXqXd3uVdVW7vtgAAc+vfsftfv37GKl8/Yzi93A5UAAepAHugB31xEJy5d038/m2o4MhwT5gfve96KEknhQB3ve9SZSSePB0Pe8SSSTwE885kxChLMzOobAAG222223qA3d3bu9yt73+k5AAAM+n0+km5W97/ScgAAE16STcre9/pOQAAD2J9PpJuXyqr97Oc4q79+AAAxvF/S7u93VVVbu+2AABNSSTcqqqtydgAAGZqSSblVVVuTsAAAmpJJuVVVW5OwAACakkm53nOc5dZznHL1c0AABjd/Xd3e7qqqt3fbAAAu9U5694xjkwvX8RERPqu+931VT3dWr27vd3cva3ffSpV/ufv379++/fvxsNBXDr5kB0wA7KkkkgUAd72SSNySfqPDTptlobzMzMwbABp0lEJZnczPsOJtKISAD0EwklEAAADbZAAAB51VVW/e7AAAMzUkk3KqqrcnYAABNSSTcqqqtydgAAE1JJNyu85zl7xnGeXc/AAAYvV3d3uVV85yrv14MGQL1dyTcqqqtydgAAGZqSSTe973uTsAAARJJJve973J2AAATUkknarVVV/sYxnnb+v7QAAGb1d3d7lVVVzXOfcqqqqqqO6BGQQ+6N76x6QQ6w9zF5Y/kBsxBDCsMEAyrMnFHIBC3by1rfXehEPCzDEEJ83/scFzXvzbmYEYcNCPtNbcxqBBLiG+lSOq6SnVPm6WMxmCEG6bJryF1vJdhjZ4QPvVNNoFDh6/VDyIGXzNrzuoaBAwcT6La3G6duECB7pW0JCT8UyJQIMGX86cFsmv2ab9PdW3+/ejPVnp/WwAT79M+8wYwTY3Mb8kINALNCo95r7Wvd79+EQi6+QBOmQYSyoYmZmMiwxzKVqKSYhB3d3bvacgQNCATaQ33d3d3JCDRiAXR3du7qJDd3TWkjs7u1AisXdVVVemkodJImWQuugZEq/NCDtjTAk2qjKqrMZkEwt53v3v318n5SMMxUMwUYxlSvs+++73v3c/oLzAWlR1iqhaIRCQQmQEhENiISqamZEYSxEzJMwzAmYRCQEy3vfm9+b+fqQGEEOxEwVHvs/re979893vFEKREIaREIpRliR/a73ve9871I+SMSO653ve953qfMMRHhpVG8RG7FSwJYpmVKtYhNFk7rvve/d33qR9MSqYxmSSYIwhixIKaSmqJBCH7K++1999n3yI/CDEV9goklBBUSIAUAUzUzIT8yaxmLGKKzvefu9zv3yJX2VVdXVYxoEou6u5TACgBGNAcdLu6q8ZAciqq6aA2HwPgbDQHBkUHTABGgOUFNh8AARgBwaA2HwPgbDQHBkB0wARQAKAEYyDveSpWfvsySDg0BsPgfA2GgOSD5vbWBvvcEYCKSSSSSgBKYEkkmZIHeDQGw+B8DYaA4MnTJ0wARQAKAErOWsAHYyA4NSSQHwPgbJmSSTkMgOmACKABQOmR+89j0572ve2AcGgNh8D4Gw0BwZAdMAEAAqSSSQxQB0ySSbkmoDYfBqSSbkjQHHdHdvZl3fd3bu6fdsCQJtJQkJEfY5+oCweZmZ9mY3yvnbf3pTeO0RN1VXZwwYAkm5j6TUmnA4En0kn0gBt5AvTdLiSSinle7g7BttttOYhJKZu6urxi7vWLziqr7Kq737ne96AArve5793ubu67g6AJMSSSaiDgyOsZWZ3MzBJJR66+hJKHRXxZOGDVZmfZmZABGO973vcdTAIVdVVVMMpJJLkgHBpXe973veg+BtJ67qqvYfHveAM973vd96ABrkqquVVXJ9d3W59IYTgMwDoDg0wDu8kjUC1Ap6q34AFsQIQdRv11n333wASSSSQACrq6pM5a32ru6rtVd1Wru65zmjvcxqqu6rpklPuhskk3JNQAAeuqqr7i7qquq96q0BJ4Bqqu6oDn2KvvZXe9433oAbD47Xe973vQBJiSSSIxd1dVqlEJNttub5j9d2KFEJLoiq7QA2222AAAGqq7qgOAAAAAAAAA7Pezr3ve9vvvPgSAAjFVVgODQB0zVVYySVJySTMq8UyDpdVUrFVIxIzGRGYSd1zvdVO/a++onwBCVWkEWQQhoAEoglZzMxtt3d3YUfffn3czsQlGZr3duN3d3aO/v3799+/fv374Gw0FHBkHSaYAIoAFAHe973vSqk8HgB73ve8AALqrAP1e9799jF0oS3YSjd3d3REzCUJboko2d3d3X52ks+9r965JJN73ve5O+AAAMZiSSblVVVuTsAALzrWMGMM4td3d3VVVVV33GIvWM5xrTWGGFru7u973ve7vtsMMFgF6u7v9GcYztttu/eznOO3fPwAAGav67u/03ve+XV36wAAL1d6u/cqt7upPeAAAmpNSSVW973J2AAAZmpJJN73ve5O4gAAE1JJJve973ORAAAma+9w2t3epRW5pZLJ4N+bb71tt98234mZJKk5DIDpgAigGTNxCbTelAGZd3N2dSUCVZh8+KmwS+SUAA6KA4koOnx0DzdNgQDcJRmXfe+i7unve973veAB0yMA5ve9/v2c5xy7n4AAC9Xd3c3u6qqu/WAAAxetXckm973vcnfAAATUkkm973vcnYAABmakkkqqqqqTsAAAmpJJN73ve5OwAACakkm5VVVdxbGcZ5dz8AABu/ru7vd1VVW7vtgAATUkk3KqqrcnZg/naABm9Xd3e7qqqt3fYAABXNYxpnOMZxj7X3Zvc/b/m5y7v9973vGw+B8Pe9z3mRKk5PMgOmBsPooAFAk5+73qea9SSSZnlUHQAGQHXqq7qiSTMMwTYAAAOW229iISWzum7u7u+dVVVv3u2AABNSSTcqqqr9nOccXc+AAAvV3d3uVV85yrv1gAAXq7km5VVVbk7AAAMzUkk3KqqrcnYAABNSSTcqqqtydgAAE1JJNyqqqv2c5xy7n4AAC9Xd3e5VXznKu/WADHRnM5znOd81rWtd85s+gojmWVlmYZmRzOcu73dVVVu77iW1ppoaGmt7Y81e6xRm73dDccJLd3d242t3ToA+ttvvm6z72dypOQyCckxJJBFAAoEnOEXdmGZd4ozMbSABttgCAAG223mWLMzOqMGzySiEiVCgAAAbbbfve97973ve9v1VVVv3uxbQ00NNF6u7u93VVVe9nOccu5tsaaGmmmr1d3d7v3Oc5yuc++uWZjGZZhlhkqc65znOd81rWtd857zmYYZMaaM3q7u73dVVVu77AAAJqSSblVVVuTsAAAmpJJuVVVV+znOOXc/AAAXq7u73L5znOVd+sAAC9SSTcqqqtydgAAGZqSSblVVVuTsAAAtnGcXnk9PSu/fZk+52ft73v9zj9+0BsPgxQBJmSKUdbjWQnJMSSQRQAKBJznOcdd73ve9kqgAJJJJiYu7qAXd139XjQD3vAAe973ve973ve97fqqqrfvdgAAE1JJNyqqqv2c5xy7n4AAwbv67u73dVVVu7vzIAE1JJNyqqq3J2AAAZmpJJuVVVW5OwAACakkm5VVVbk7AAAJqSSblVVVfs5zjl3PwAAG7+u7u93VVVbu+2AABNSSTcqqqtydgAAGZqSSblVVVuTsAAA1n3M41N/p7nveANhr4HAEzJPKOvez73ickxJJBFAAoEnHfSTcniQCve97wD6ST6SQEne97x3r1Vd1Qe973vLqrBoDgT6b3tzZPAAAVPpJP03vfKv2c5xxdz4AADF6u7n7297urq79YAAF6u/13dTnKr9JzwAAHp9JJW5VVV7u+2AABepJL3KqqrGO1J78AABNSfpJU1zlVuTvgAAPT6TcnKnOb+krwAAF5l/pP0vvmtd9c5rgUFBQUVBzBHnX33N875rWtae+c95comyVMywjRhuQQ65HXOd+RCUbm7ubfJW79oeAOttttt9bec7mYsqchkfve96e9j3vAmlA4CnTNVVpOc5yuYd63VVcnjO8FPaqqsKb3J5qqq/pJNySUDPqq7qiSc77sqYqruq8wPREI6AFIkklQ22236E231vzu7vnK971mL0yZMmTJkyZq/ru7rd1W/eVO+Zy9goHvMBgyyq5n33N875+1rAM17d32wAAL1J+kupzm95xjP6cnfAAAVPpUrU5U1zm/0nPAAATXez03Kre/0nIAAYMewn3JKn7cqt/STgAAJrvZ6blVvf6TkAAAmq96T9uVW/pKgAAF3971y93qq3+u+WAABiTntz9Vy11e72EoSE3nPU992nhpQAFFgfAHgAfHvV73Peexr3mRwZ62H3TABAJOcd73Xe8ST8Pnp5uSTxJJJqRJueqruqmKq7qpPC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vvvgAAAAAABmZJknsmdTMzJJ/JkmSfysLVMqGC0WC0oaoSIMqBADub35+e+BBSIiKpsLpMJOZSiwtQq1TFUjCxVe+++e+EUubGLTVEnqplDGWqmUNUNFWqe+++e+hehYjoYsyqchWoGFqpheeed+eVQ4NTWKr2oZSue++9e+KoeiMLC6nC0xUOVDAVhYVGC1TULKGiMUh77757qqKYJCp4BgewD73N9oDlELTFmqVeeed+eVDiYUeiyLC0CeaSOVK0WFlQ1TCNUyS969898UlxNJB6LSp777574iXotUMLVU8mTqZmZPczMySZIyZ3JlG+P374AAtt8ky85xq20AA5JnJMTML0wq+1SX1RWKSwtSYLSqqwtUwsB69dfXvsUrvSJ6LAu15jgVc6FyVMLFRMLCNhKmqapDVNUrv3z3uRObRpA8qYLCwsLVTC1UMLVPPPfPcXgk/YLiZVJ777374VOJgL5UMKsRMFgsFqmFWxVFhaSS888787UTwLUpcyyUXELSKsLAMqaqGxLC2JWCwsqVqmFWQZTzzzvztBXinMuJEOAtRqMC0RhGEZQ1qphapqmhYWSvfffPfIQei1Q1TUF1tGqVTgLAapgVeeed+dxVxGRV7SGoWEe+++e+i9KxWC6TlVOVDBYWFosLC1VN777577BcT+dxRPxc/ffvm79+AAAFttttA6kwD589qHqmC5plT7Kn0Lnvr6+vKpwSFATd3u6qo5SECr4AYCaAnOceaIW3LqRAitdEECK182T4L4LF8+fPPnznu+cLODko+fPnfzE73vO6DnsxIGD3vc9GgwHBAT6ikzMyfp+/GuP1AAAFttttAANSYkzMnnnZ9JneTqTOsn7uTN7280QtuXRC25dELbl0QtuXQDo0EVrohbcuiFty6IW3LohskIEA73m/db/ffgAAC21AaAB+/fijwtKHZaiXffP37L+bNk1+2E3oJznLzRC25IW22QzMyQzMymh8QeB973VOc5xDnOc9Cd73nYTEUTJ5JnUkyZJJTmtb5+/AAAC2222gACZkyZO++zqT6dTOpM1rVdELbl0QtuXRC25dELbl0JoDQRWuiFty6IW3LohbcuiCYBJISe2265fvgAD6TPvvvvvvi8ky9W2/AAOSZyTGSTJJNyZ1kmZkmtdt9ZN6h8EW10QtuXRC25dELbl1ImorjoghFa6IW3LohbcuiFty6gmoeTMyZmSOLdbr4AAAAAAAbkxMySeednUn0mdTOpM1rXrqS25dELbl0QtuXUTUiuOiCEVrohbcuiFty6IIrXRDYEIB3vfPNb4+AAAAAAACE6AAZm+90Q+CK10QtuXRC25dAJoVx0QtuXRBCK10fuBvRDWiGoShKEoShKE973fWiUJQlCUJQlCUJQlCbu7uiUJQlCUJR6DIShKEoS973u6JQlCUJQlCUJQlCUJxVmTPvvrdcv78AAAAAB+/fv3379+/YLnOfPv8TZNk2TZNk0JQlCXzi+gfe09dEoShKEoShKEoShKE3d3dEoShKEoShKEoShKE3d3dEoSkL2LkJQlCUJQlCe97vvpBzwlCUJQlCUJQlCUJQnve760EoEoShKX4zBKEoT0D73fXRKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlCUJu73bR9mCUJQlCUJQlCUJQnve760ShKEoShKEoW0tpbS+u+dJgtKZTCJhZRNqmFqn8yX86cK/n3sdi6wuHFTuX3fy/OaphVhdQuJDmqcUMLVVcFwLlU0KtSaoaFhGirEfVOf38n379+4AALbbbaAAAAAAch2AAAAAAAAAAAAAAAW2220AAttttoABbbbbQAAAAAAAAAAAAAFttttAALbbbaAAW85znOLQAAAAAAAAAAAAAtttuTLepMAKC2222gAFttttAAAAAAOSoWBYWF6WLovhfi+F8L4XtK6qfamkPC6+FgvBHhMsmdyZ5JMk783zWt8ABbbbbQFttttC22ySZ5Jnn8n8nUmTrMmTrrMmTZU2EZYq2JGwLZSq2Q2pDYjYjNmqNtoTaU2VNtkqbBbIWykbUWyLZS2VBsCiGaFRtsqTY2qWbNM1KxgZqswNmxaZas2qNrRMgQ1DEERSCxUxG79X1d1lgiJaJlEXkJQlCUJQZOQlCUJQlCYhTIMBFUxKRBQUVEKtBEFHvYD7fXBKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlPpyE973fWiUJQlCUJQlCUJQlCbu920ShKEoShKEoShKEoTd3u2iUJXochKEoShKEoShPewH3fXBKEoShKEoShKEoShN3e7aJQlCUJQlAUehyEoShPe931olCUJQlCUJQlCUJQm7vdtTZNk2TZNk2TZNk2HVmZHWZkySfT9+/ffbfUALbbbaAtqTANi236TOSZyTGZmTJyTOpIPvZ9Pr5+hDIShKE7mCUJQlCUJQnvd4D31glCUKUJQlCUJQlCUJu73bRKEoSlvYhkJQlCUJQnve760ShKEoShKEoShKEoTd3u2iUJQlCUJQlCUnoyEoT3vd9aJQlCUJQlCUJQlCUJu7wHu2CUJQlCUJQlCUJQlCbu920Sg9GQlCUJQlCUJQlCe97vrRKEoShKEoShKBKE3d7uiYQrQlHpMhKEoZ11MnsmZmdzJ1JJM/X41t9+AFttttAW2220yYW2puTPMmeK+mTrqJQlCUJQlCUJQlCbu8B3cEoShKEoShKEoSkKPmTBPe97QQe973dEoShKEoShKEoShKE3d3dEoSkL2AZCUJQlCUJQnve8juiUJQlCUJQlCUJQlCbu8B3cEoShKEoShKAvYBkJQnve9uiUJQlCUJQlCUJQlCbu7uiUJQlCUJQlCUJQlCbu7uj6yEoShKEoShKEoTrqZL98OPvwAAABbbbbf379++/fv38XOfv37fxNk2TZNk2TYlCUJQm7vd0GBzBKEoShKT5shKEoShKE973fWiUJQpQlClCUJQlCUJu73bRShKEoShKEoShKfQZCnvc26JQlCUJQlClCUJQlCe3e7aKUJQlCUJQlCUJQlCd7zvQchKEo9BkJQlCUJQlCUJu+O+tEoShKEoShKEoShKE3eduiUJQlCUJQl7FyEoShN3m3RKEoShbS2ltLaW0tpeVPXz5799+vf19fPnwAAAFttttMmFtvsmdSXN9+/d/E2TZNk2TZNk2TZGtQFaoTc/b3JznM5qBbcuoFty6IW3LohbcqE2QVx0QtuXRC25dENkmfvvuc1vn78AAAAW222073ve973oTMzO6IW3L8E2QVx0QtuXRC25dELbl0QtuVCbhoJqCuOiFvvnvUye+++e9TJ3JmZbec1v76222gAALbbbUmOgD6TLJlkzcmbkz7zzf3mg3oluZfQm8hNaNALmOiFty6IW3LohbcuiFtyoTYCuOoFty6Ie+++e9TJ3kyd9STMW85rj6222gAALbbbaANyZ3kzsdTJ777579JnZBXHRC25dELbl0QtuXRC25UJsgrjohbcuiFty6IYE73vl85373333333oAAF5znOc4oBJnfR1Mnc9u8vwTZC3d0QxLl0QubzRDM3miGwmXeVCbIK46IW3LohbcuiH3e999988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SqhqUoESlGiKqKFpoIligniEDQi5pNjNW0TaDZTatjNKtaW0G1QbJFNhUtlbNIwE2UlW0kq2hFLCaDCaEtklRkmRRWwTZUwmqUVhNBTUMgG20jMqWUtqlqGwrCthWFbZrNmTaKBChVShaWiliiooAoEpRpWkPe9vtBwTd3mwne952EtuXRDYS3eXRC25UJsgrjohbcvUye+++e9Z31mdSZz77nNb/frbbaAAAAAPJMBZM3Jn0mJM8kzkk5z7x0QtuXwJsgrjohbcuiFty6ktuXRC25UJsgrjohbcuiFty6Id8c5zfHwAAAAAAHe94EwJmd73RC25fgmyCuQjoiE0CuOhCaAVyEdELbl0QzN4hNkHWvNdTJ55351Mns9989smdzJ28vOc5x8AAAAAAtttvUmdWupmTzzefBPgmEOc5nNENW2yGZmXRC25dELbl4E2QVx0QtuXQFty6JBAne999vK+AAC2222gAAOtd73RC25fgmyCuOiFty6IW3LohbcuoQQmlcdELblQmyCuOiFty6zJbec5vn3wAAW2220ADve973utd73RIW3LohbcuiFty/BNkFcdELbl0QtuXRC25dBvRLcyoTZDWtea6mTuTPJbee63z74AALbbbaAAAsmWTPpMSZyTN7+5zqZPfbl0QtuXUlty6IW3L4E2QVx0QtuXRC25dELbl0QtuXRDAnfO+Xznnfu970AC21AaAAA1JmpMzO97ohbcvwTZBXHRC25dELbl0Q9Fa6IW3LwJsgrjohbcuiFty6IcXnOb598AAFttttAAHe97sJvfe90QtuX4Jsgrkg22yGZmSGZmXRC25UJsBXHRC25dELbl1DUmdZLbbd374AALbbbaAA6kwDrJnRepk99989+kzuZNa15rqZPbcuiFty6IW3LohbcqE2QVx0Qt767yd999d5OvqUML6LlSuZQwtVK0WF2LC7F04qfwXPOlQ4L2QrC0omFkllDC1TQIwtUwsqpJ1JM6kzJJnXk9mt9/c18oABbbbbQAAAAAAAAAAAAAFttttAALbbbaAAW2220AAAAAAAAAAAA6kwApbbbbQAC2222gAFttttAAAAAAOQ7/gAfAAAAAAAAAAAAAC2222gckw7BbbbbQAC2222gAAAAAHkmWSZ1JncmJJnkkzqRYrC/F0XpdCPS6LlDwqwsqYWqYWF2Xch0XheFwuqnhfS+i5VOxYWqidTMyeyZ1MzMlvnNaoAAAAAAAH6Z/HUnXXXXXU6k666mTrqSighmKhKiGgiSJpUJjWU54oHP19fXUvFFrbEhLaRWsjYS1kMrJTNbZMLSMDEFBcExEyE972+0HCCuOiFty6IW3Lohbcuib0FuZUJiHK3c5tlVVVVVXe5ztlAwHe+ee9ZJ3Jg5zW+fvwAAAAAAAsmWTLJn0mckze/uc999993Jiq/BNiuNttttttt4EVXgRVb77779fuc5znwAAAAAF999999991rve8FV+CKr0Iqtttttttt4EVXgRWttvAJ+khmwJuBPu/e3h+/BbbbbQAABbbbbetd9zM7fwRVehFV4EVW22221COta17777777777+zMnup99957bf34LbbbaAAALbbbb3JnfY99999/SZrWta99tttttttttQiq22222oBD9JDWSSZmpM6yTMyTO8kwNj9+C2222gAAC29SZUB+ySSTXnm/mgiq8CKrbbbbbxVUJgu14EVW22wltt/SQ5JJCagTVCed73r3v790AAAAALbbbbZM5JPgnoTwJsIT3zz735CKrwIqtttttvFVQiq8CcOc5zlttttv6SHPf3vvtv78AAAAAC22228hNhHWd6oRVfwRVbbbxbaEVXPPPNyTPfda17777777777+zMmuHltv78AAAAAAAOuh77777+kzWlbbbbbbbbbbUIqtttttqBPffOc5z7634AAAAAAHfgJgTM+++ttvAiq222222231VeBOBOc5zlttttvmAEskhoCaAjJHBcFhYWqap9+C6qnQWVPe+xdC7qGi/gTCyhqE0WiMLFDIcqGFwuVDlTlSsLCMLKVhOBYLJWFxVOhcqdC6ylXBYUjC1RMocJc4FyLcFgtKnKnAXCjItgtFiWSrkicFotUwXBaRYWqHKmqcC5STlTRaqORfRci/nn3wu/Pvz58oAAOQ7AAAAAAAAAAAAAAALbbbaAAW2220AAttttoAAAAAAAAAAAAAC2222gAFttttAALbbbaAAAAAAD+AB8AAAAALbbbaAAW2220AAttttoAAABqTA9Ach2AAAAAAAOZMSRfqi9L4XFJYuF0FpDwvZD5U+i7VOFyS+ReqVwmdZJmSde+791XFoAAAAAADkmckzcme+m9a1rWv0mbkze973bbdlu7bbbbbbbbbbeBFV4E5JJPZM7c57zl+t+AAALbbbaHe973ve+hPAnwTgRfufW2222/Cq+BFVttttttttttQiqoR+935558e/fGgAAC2222gAakzt3rbbmZmW22234Iqttttttttttpve97+W/AAAFttttAHe98Cb33t+CKrbbbbbbbbbbbbbbfdSZrWta99999t3ve9/fW/AAAAAAAdyZ3kzse++++/STNa1rWpJFVQiq22222oRVbbbbbfu9777bb8AAAAAAAKE4EzO97bbdlu7fgiq22222222+++++++++6kzc3ve9+eSZw5rXOX4AAAAAAAWTOSZ9JnJM1r7f1tttttttttuglty8AltrbbmZlvvvuznOc4+ABbbbbQAAd73ve91rve22222220ttvwRVbbbbe973ve973vdB+IB+wCpAMKkAyo8A/fgAW2220AAA73vfAngTwJ8SAL995bbbbbbbbbb+CKrbbbbbbbUCfc5znOBOBNATySTqSZZ+9/ffffffgALbbbaAB3ve973vffda999+AiqoRVbbbbbUJznOc4hFVtttttttvAmH2jugJ7ohJehYL1VM+wsqfbrsXNU4DRHahqn8LUqTsXUh+LwXBXapwsVU4VojRZLc4FhaIvxfS+fwvSz+F/C+ky81ve92gAAAAAB1JgBQAFttttAALbbbaAAW2220AAAyYAAByHYAAAAAAAAAAAsmOgBkwAC2222gAFttttAALbbbaAAAACyY6AD+AB8AAAAALbbbaAAW2220AOSYdrbbbaAAAAAAAAAAAAAA1JmpM1JmpM1JmpMSTOSZ+L8XC/F6Xpel0Xpel6XRciL8X4vxfi/F+LwXpVPSxQ8qdl0XtU7L6X0vhfKHReVPpc7F7KGpZRfhZQ5/RZMmTOt859zlX4AFtqA0AAAW6kz6ZkmedTweyZkzP4nWZJve98ttttt1bcqExdrbbcurbbbaW2smeSYfrdW/fgAW2220AAAW8kzcmfSZqTNabdZM999896n25M3vbxFVttvgTznOc4qqqqqqqr33nOc5x8AC2222gAAB3uBNhM1ne222229FV+CKrbbeKqqqqqqq8IQAKE89177ffffvu970AAAAAAH0kz2TLCW/ffeBOc5znFVVVVVVVVVVVeBOc5znFVeEkgB+Amgkkh3ve9H78AAAAAAAEJ4Etveqqqqqqqqqqv78E0QEnOc5znMBCQEcTnNpznMBCQEnOc5ziIiI5yTMzqSZ+/fvvvvvvr+AAAAAttttoNSZuTP2ZJma1r777cmfupJnOeeeeKqqqqqqq9Cc5znOeBOc5znF1rWta1rWv3kmdfuc5rnP1tttt+AAALbbbaCyZyTNyZ9mST9mZOc5+v7WtKqqqqqqqtVV8CKrbbwV1r39ZMz6ffg++ttttt+AAALbbbaD9mZP2Zk6mZk999/fe+++/tbkze973xVVVVVVVXzwJ555554qrwJznOb35JhznvOc/W22238AAAW2jve96973v0kMzPvvlVVVVVeBOc5znFVVVVVVVeBOc5znM9988vnnn33e970AAABbbbbQfZkmZ555998qqqqqrwJznOc5sVxVVVVd3d3fA+973vfID8Km90RmQaAYgt93FDWFphGZLNFvn7ipz9C7FzcqawtYXdTKZUwq8o1GpTKYWJXEL5TipxArVTQMFgWFhYWC1TmphcVNRgWKsqfCuC61Q6CwjKmqYWCxKaLCiwtVMLQTYE1CEJsAmwCbIEwxfPz7+973vegAAAAAAAAC2222gAFttttAALbbbaAAAAAAAAAAAAAAttttoABbbbbQAC2222gAAAAAHIdgAAAAAAAfwAPgAAAABbbbbQAC2222gAFttttAAAAAAAAAAAAAAeyZZJMsmWTLJmqfKdlXsXsXdMLgXYtC8l9L5VPtTBelouCwLVNMzJ/GSZ7vXNOVfgAAAALbbbaDcmfZmTUmdZmTUmakzvMyfx1M5zD3z8/PxrSLSotIi1NUVVE0wULSqUCCV8fHx8fHxu7u74H3ve5xVhF4E5znOcVVVVVVVVzAnznNa5z78AAAAAAHe9730J6E9CeBPgnnnn3vvAnOcXiq2222oqtttt4EV5ziqqqucJIed9ura+AAAAAAAd79JD8BLb+/flVfAnOc5ziqqqqqqqvAnOc5ziqqqud755fPPP37ve973vegAAAAAfTJknnnn332lV4E5znOc4E5znOcVVVVVV4E5zm971rWta1rWta3JM9fffffb+++oAAC2222gAA1Jm5M999Gta1rX0k5znOc2K4qqqqqqvAnOc5ziqrrWta85997Ld26vwAAFttttDve973ve973v0kMhMz775VXgTnOc5xVVVVVVVVbaqr+8Cc5znOcCeakhuSZqTA5o/fgAALbbbaAACyZZMsmfpkzN73Puc1r333cyZrWl8Cd5z3zzzgTnOc5xVVVVVVVVXWteXMycW6tr4AAAAAAAfTMydyZ515999uTN73ve9a1rWta1pVVVVVVVVVVVVc9988vnnn33QAAAAAAD7MyaCaCSH6SCv79+VVVVVV8Cc5znOKqqqqqqqqq8CYakhdBJ7333W7f34AAAAAAA6hPoQC2/ffKqqqqqqq8Cc5znOKqqqqqqq5AmSQ+Aj733YE9CntU8qapxFwWORGkWFkuqn0uC6FhYrC7E0RhYSuCVcVOhapyI6oXBcEaqbgsoYLByLmpguKlcC4FqnAJqmddzMknckkz6TOp7o3soAAFttttAAAAAC2222gAFttttAALbbbaAAAAAAAAAAAAAAttttoABbbbbQAC2222gAAAAAAAAAAAAALb/Ftt+HwAttttoABbbbbQAAAAADkOwAAAAAAAAAAAAAACyZ7JM6mZkSSZ1JiTPJMk7hHlDwvanpdFT6Wqdl1U8zMnJJJJ1kmScmZk/STPpMW3l2++AttttoAAAAP4zMyfpJnUo1Vd7g8i78/PzqGkUtKUqUDSg0oFBMqIUxAU0xLZkTZGyG0msbGMttgppmJqBCmgKGkhYQoioqIKIqqoqSqJqKKpoKAhlaSlBWgpYiiqI0a0a0aNHnnnnniqrbaqrwIqt4KrbbbbaqvAm5aE7331ee/v3e973vvvvvttoAAAALJlkyyZ9Jm+c+88VV/c5znOKqqq+BOc5znFVVXWta1rWta1rWvJM++5z3nOffgLbbbaAAALbbb3Jn2Zk/ZmTqZmTv33779uSc5znOKqqqqqqqqq8Cc5znOK61rWta1qbyZJC2239+AttQGgAAC222+yZ7Jn7MyayZrR9rWta0qr+Cc5znOKqqqqqqq7FcXhM3ve97Oc5znP34C2222gAA73vfffffffUJ8EkMCXV735VVVVVVVXgTnOc5xVVVVVW228Cc73fvvtv3wFttttAAAAB9JIfpIZn79+ttvgqtttttvgTnOc5xVVVVVVVXQTvfPPPITnn793ve973ve970AAAAAsmWTLJn0mb3z7y22u4K4+bIK4vAmEOc5nObIK4uyCuLsgri7IK4uyCuLsh3vnnNc4+AAAAAAAO7CfSQ1mfffcCYQ5zmc5sgri7IK4uyCuLsgri8CYQ5zmc5sgri7ILrzWu5k1rXmtdzJq3nNc599aAAAC2222gB7JnmTPPB3Mmta81ruZNLi+hMIc5zOc+CYQ5zmc5sgri7kVxdkFcXwJhDnOZzngTCHOcznNyFCeer7rnPrbaAAALbbbaAd6gShPpIK/ffbIK4uyCuL6EwhznM5zwJhDnOZzkJsgri7IK4uyCuL4Ewh6eeeXzzZBXF2QzySGgJoCfC/nVT5VP1T7+67F3z6LCwugq1UwXKmVMLEuyzgsLC0WqmS6qnJQ4LgLkIwtImEnJDiRhaSSZ31kyTJ7Jme2e7PXOUAAttttoABbbbbQAC2222gAAAAAHIdgABbbbbQAAAAAAAAAALbbbaAAW2220AAttttoAAAAAAAAAAAAAC2/xbbfh8ALbbbaAAW2220AAAAAAAAAAAyYAAC2222gAFttttAALmTMyakmeSZ5JiTPZMSTO8F4LmncL5TynQtTqnCVcC9U7F8p6FXgvYsKtKcIknckmdSSZ1mZk6nNc81eVbaAAALbbbaAHffY7mTWtea13Mmta8X0JhDnOZzmyCuLsgrl0QVa6IW3LwJsgrnObIK4uwPffPLzne0J77773QAAC21AaAFkyyZQn4JznPvPNkFcXfNQOc5nOfBMIc5zOc2QVxdkFcXZBXF2QVxdkFcXcya1rzWu5k7kz77nOb3z4AAAAttttoAd5M77Hcya1rzWu5k1rXmtfBMIc5zOc2QVxdkFcXZBXF2QVxeBMIc5zOc2QVxdkM9988r55993ve970AAC2222gB7JnmTPPBsgri7IK4u4CuL8EwDnOZzmyCuLsgri7IK4uyCuLsgri8CYZOW26t++AAAAAAO973ve7CdCcCITFe92QVxdkFcXZBXF2Q9Oc5ec2QVxdkFcXZBXHX0meTJ1ve/d77mTWtea13Mn8ZmT58OH4AAAAAAANSZ554d2QVVkFVSCqpBXF/BMIc5zOc2QVxdgK4uyCuLsgri7IcCfffDhfgMmAAAAAAGTOSZyTOSTPfTe+8k+63vfm99zJrWvF4EwhznM5zZBXF2QVxdkFcXZBXF2QVxdkFcXZDOAT8BNSSSGqjQtU1BWFoUtRkWSTrMydSTJk6mZk6mTJPvjfD78AAttttoAAA6kz9mZJP2STA1JDUkN5+/fv3AmEOc5nObIK4uyCuLsgri7IK4uyCuLsgri8CYQ973PewTd3m7gnfKnwqpAMAwqE6kmSdSSZyHenD9+AAW2220AAAfSSZ7JnWZk88++++7zNa15rXZBXF2QVxdkFcXgTCHOcznNkFcXZBXF2QVxdkOBOc5ec2Q4AR/BcVDC1U1TKVhYWwWqGFlDCDCwvv795++fv39H9H4tttttttttAAAHsmfTMgfgCahJIbLf379+2QVxdkFcXZBXF2QVxdkFcXZBXF0E2QXeXZBXF2Qy7t2QTySGpJDndATz93z9JITREBIATanaU8xQEg6dByBHFufBw8QyyKvH0fzeejD0rzbyWayzUYXn/MKGHslSUBpeesD0QWvSdNZtTZFPrpalYdfSO7u+H7fHEn9D7v9L3n4/K5He6SpdvCddqyy8K0x/f/p+J71jLK7uPP8rJd9qr86W+a6o3Z/iAERAgAQDuKAKCd/f/BAn4P4cz+br/Pvd71U4AwDoDwXf8NU6FqnVTgXku6nIXIci6/xdi5U7Fyp2LVTC+YXXOZLvcqdqmC9qnYuC4LC7F3U+C6C9F6LzrvnBcC6F2LsXYvAvamF4LVDVTguhei86FnvovlT/DU+VTlTC6F6LwXPtTlTlToWF8F8F9F8F1U7qfanQuC1T5UwsLtTkXPYvQuanZRvdT+QXIuhfKnYtU1TsXQuIve99i1L7FwXVTp0L5zip8FwL4LsXtT4LoXXuqdC5VO6nBcqYXBdVO6ntTKnYuxexci95wL0XlTC8F5F0LdVPBeC7F9F9F0L39+9eufs+vnJVbUPh0z146dw/qY2CGyCEuqnzwXxU6i1TguexcQvguxeQvsLoXyp2L0K/c7Xzfel777vvOHvc4YBOSYBNATWruBcF0LnYuVP1TlRHBdsLuLypwLqp9tIvt0LoXYuBc0ubUv5vsX4XBfIvecVO6n8FqnKp4LgvtU6F0LqLVOxei5U7F/BcC7F8qd1PRfABFAvx+ztDJ/X6nDeph7Gj2ST8h9wrIfM/on0SAJi5WMAvr/X3G4qH9nprsmKC4vLC4Fh+JSyV2wT6se6I9/8p9MosB7Sogew/N+IIrA9w4uLAO86MkFdEYOwXoaaKm8iCvGIBNUlLFYwQoQuzXQ7X1ZXC3EyL2uMEdNdnZJyBCpR7Y4eP6u44b9NFh2deqoWbtlmo644EUNRFrPUERWxXBINxBtYWWjV4c7MLyCq24HYKdJzcpqnE5FEyAvfK+NZyuM6oGcWD5B3C0hU7L4k1GYgVFMRGyik6zTBIBTKeYJKdgYZa5axkM+NOriRFAGRQioOoHeUaQk78Zm5KhRzNJM0kmHRhNwoz4bCCpUkFFCjetpIOJEleWddxJPtUaINE5i6F2fVstwzAoQn9jUCAOezeeEhkhOa0TLqXgNQtQJh1YS20oKt8BffLiBUXBE8DpxSeoDnt1u4dNYWeXPc4WQCLaUrFDhJ1niBE2tUj8zaiC86NEyii/ISdL4dVJpoErwkLtfsExcHyJExuImIkTDoOxxEBRgIJCqwuOEBoGDQKzpJIWbITCEIpDjQPElE/JJ5ghZECjB0ebmHA41J1jSWe7JiHTy8ZgZCbDfVuWN94ljP8imKW4QlIw6B35heKDaRuGy56DsAOAy8shq5YSwllLfUL03jmL5sScGCsqvcdYDZBRbq40OVwXqsA9bi43Pg4FSNUtUagYddrKASQGoM1YB0AwBgJjMBUGwEMDNNEoHVPOUHCAIGHRNwrjABMhj/kiydcCjoJEcxtu22m57WWtaeSOJTkKUYCoYa8b0ByNyxzaqTHQRtKBiRAlzO0q+IzUWFZMyqCCjgsCgIwFzMWlTlHSbzpIy5szoQyOo1aWlvoMWB2BhQLkVmo0NbDO2JD85URmV8NxDCSjEEIUB3G4YYslQpwEqiPE76cJ2G4EnkOMhrSOGlyZ25EnU+Aw02eWwnMkYZ6DSRfXIAEAvs8a5OkJvBVwFBOmFwFa+T12TWASmgI2LkHCEK+uwJH7kcpd3/zFBWSZTWSOQ7mcApo4bgFAEfFAACqoO3yJgCZ99FFFUoJAQhSJRRKJSqViIAAAA0FGhoAAACjQ0AAABRoaAAAATUqoBobUAABSUlEaYQaZMj1OFQlE7aKVVPHQUUZ7/V1uK5cps0rJbWJYrCglNUiVQ5BRR0S4pEqh4wkkeZNE3nKikVklKNROaKrZCNiVNpBsBLYQtaVOjKS2RFzFUmmoKc1EuYKrNFIbQlG1VUNgUtEylXJNJ6dc63Tjvd6FFGouMQELKWColZSypTNE1JpJkTFNExVaJhJomkmpMiaibRNE0TETaaJhVaJkDWUspaoMQyKZSxJmqmiZE0TUq0TAMpZSVqLUpZSwhkmyTRNE1KtE0KmxZqJomRUxE0TJNVDKWpS0lpSyllBsC0TKQbRNE0TRNE0TEmiaipomImiZE0TQGyZgI2omiapVomSatE00TGSY0TVNE1KsiaJgRsQspYhlLRLYaaS2pS2IbKW1KW0ltiWoNaUWiZJmibJNKaiyTSpomlWiZtjRNE0TRMiaKaJkTRMsRMUxVayTRNKLNE0TImaJmkmZsTNIU0TaJqUjRNINEy0TEpkTRNE0TRMgaFlLSWSlZSwGUspZSwGUtJSyliWUsotlNLCFlLBTKWxS0DKWQZSyKWUsQmpNJRomRNE0TRMKaJqJomRNE1ExJkTRNAbIm0JaJqqtExE0TRNE0omiaRbbM1bBrJVFqTaGhQ0TFBomIm1Uo0TJNE0BtRNEyomRNRSylgplLIplLCTYlq0g2opZSyDKWgUylillLSlMpaCwmJA0TImSYk0TQk0TRNE1VWImRNC0DKWUspbKWIZS1VFomRMialWiYk0TEmiaJom2G0pmVVomqi0TIKaJsk1CGUtIiylqDKWiVMkyENE1KtE0TRMiZEyJomiaJomiaSpkTUq0TImiZEyKylpSyDKWIaUsimUsFMpaKWUsi2iYpqVK0TSQtEyBTRWQqspZKiylgMpZFNJaIZSxDKWRTKWSWUsBVlLKWUtENE0TRMKrRNSrImRMiaJompVomiaJoGUspZS2UtQZSxKtpTMUTRMomiYJaJhVaJiSqaJoUTRWIUaUspbKWUsCTCYqtVQyKNoKjRNVAmUspZS0QLKWKgaJgpWiaCNEypVkTImRMBkmiqQ2S2ijZSW0W1TbWRtw1RRR06yFFG7ez+u3z7t+u3w7vj0+fr3eQoBIaBYl9LfxdyRThQkIb9pZIA=="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
