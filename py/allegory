#!/usr/bin/env python
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_floor(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_FLOOR:          bytecode_floor,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52', s)
    add_definition(':', s)
stdlib = []
stdlib.append(""" "Name the byte codes" """)
stdlib.append(""" [ "-"      `0  "Does nothing" ] 'nop' : """)
stdlib.append(""" [ "vt-v"   `1  "Convert a value to the specified type" ] 'set-type' : """)
stdlib.append(""" [ "v-vn"   `2  "Return the type constant for a value" ] 'type?' : """)
stdlib.append(""" [ "nn-n"   `3  "Add two numbers or concatenate two strings, remarks, or slices" ] '+' : """)
stdlib.append(""" [ "nn-n"   `4  "Subtract n2 from n1" ] '-' : """)
stdlib.append(""" [ "nn-n"   `5. "Multiply two numbers" ] '*' : """)
stdlib.append(""" [ "nn-n"   `6  "Divide n1 by n2" ] '/' : """)
stdlib.append(""" [ "nn-n"   `7  "Divide n1 by n2, returning the remainder" ] 'rem' : """)
stdlib.append(""" [ "n-n"    `8  "Return the smallest integer less than or equal to the starting value" ] 'floor' : """)
stdlib.append(""" [ "nn-n"   `9  "Return n1 to the power n2" ] '^' : """)
stdlib.append(""" [ "nn-n"   `12 "Return the logarithim of a number in the specified base" ] 'log<n>' : """)
stdlib.append(""" [ "nn-n"   `13 "Perform a bitwise shift" ] 'shift' : """)
stdlib.append(""" [ "nn-n"   `14 "Bitwise AND operation" ] 'and' : """)
stdlib.append(""" [ "nn-n"   `15 "Bitwise OR operation" ] 'or' : """)
stdlib.append(""" [ "nn-n"   `16 "Bitwise XOR operation" ] 'xor' : """)
stdlib.append(""" [ "-n"     `17 "Return a random number" ] 'random' : """)
stdlib.append(""" [ "n-n"    `18 "Obtain the square root of a number" ] 'sqrt' : """)
stdlib.append(""" [ "n-n"    `19 "Round a number to the nearest integer value" ] 'round' : """)
stdlib.append(""" [ "nn-f"   `20 "True if n1 < n2 or false otherwise" ] 'lt?' : """)
stdlib.append(""" [ "nn-f"   `21 "True if n1 > n2 or false otherwise" ] 'gt?' : """)
stdlib.append(""" [ "nn-f"   `22 "True if n1 <= n2 or false otherwise" ] 'lteq?' : """)
stdlib.append(""" [ "nn-f"   `23 "True if n1 >= n2 or false otherwise" ] 'gteq?' : """)
stdlib.append(""" [ "vv-f"   `24 "True if n1 == n2 or false otherwise" ] 'eq?' : """)
stdlib.append(""" [ "vv-f"   `25 "True if n1 != n2 or false otherwise" ] '-eq?' : """)
stdlib.append(""" [ "fpp-"   `26 "If flag is true, invoke p1; otherwise invoke p2" ] 'if' : """)
stdlib.append(""" [ "p-"     `27 "Invoke p (which should return a flag) until the returned flag is false" ] 'while' : """)
stdlib.append(""" [ "p-"     `28 "Invoke p (which should return a flag) until the returned flag is true" ] 'until' : """)
stdlib.append(""" [ "np-"    `29 "Invoke slice p the specified number of times" ] 'times' : """)
stdlib.append(""" [ "p-"     `31 "Run the code in slice p" ] 'invoke' : """)
stdlib.append(""" [ "vp-v"   `32 "Remove value and invoke the quote. Restore value when execution completes." ] 'dip' : """)
stdlib.append(""" [ "vp-v"   `33 "Invoke the quote. After execution complets, restore a copy of the value to the stack" ] 'sip' : """)
stdlib.append(""" [ "vpp-?"  `34 "Apply each quote to a copy of the value" ] 'bi' : """)
stdlib.append(""" [ "vppp-?" `35 "Apply each quote to a copy of the value" ] 'tri' : """)
stdlib.append(""" [ "-"      `36 "Abort the current execution cycle" ] 'abort' : """)
stdlib.append(""" [ "pp-"    `38 "Copy the contents of the first slice to the second one" ] 'copy' : """)
stdlib.append(""" [ "pn-v"   `39 "Fetch a value stored at the specified offset within the specified slice" ] 'fetch' : """)
stdlib.append(""" [ "vpn-"   `40 "Store a value into the specified offset within the specified slice" ] 'store' : """)
stdlib.append(""" [ "-p"     `41 "Request a new slice and return a pointer to it" ] 'request' : """)
stdlib.append(""" [ "p-"     `42 "Release a previously allocated slice" ] 'release' : """)
stdlib.append(""" [ "-"      `43 "Tell Parable that this is a good time to scan memory for unused slices and reclaim them" ] 'collect-garbage' : """)
stdlib.append(""" [ "p-n"    `44 "Return the last offset in a slice" ] 'get<final-offset>' : """)
stdlib.append(""" [ "np-"    `45 "Set the last index in a slice (can be used to shrink or grow a slice)" ] 'set<final-offset>' : """)
stdlib.append(""" [ "tpn-"   `46 "Set the stored type for the value at offset with the slice to the specified type." ] 'store<type>' : """)
stdlib.append(""" [ "pn-n"   `47 "Get the stored type for a value within a slice." ] 'fetch<type>' : """)
stdlib.append(""" [ "v-vv"   `48 "Duplicate the top value on the stack" ] 'dup' : """)
stdlib.append(""" [ "v-"     `49 "Discard the top value on the stack" ] 'drop' : """)
stdlib.append(""" [ "vV-Vv"  `50 "Switch the positions of the top two items on the stack" ] 'swap' : """)
stdlib.append(""" [ "-n"     `51 "Return the number of items on the stack" ] 'depth' : """)
stdlib.append(""" [ "s-"     `55 "Remove the named item from the dictionary" ] 'hide-function' : """)
stdlib.append(""" [ "ss-n"   `57 "Search for substring (s2) in a source string (s1). Returns #nan if not found." ] 'find' : """)
stdlib.append(""" [ "pnn-p"  `58 "Return a new slice containing the contents of the original slice, starting from the specified offset and ending at (but not including) the ending offset." ] 'subslice' : """)
stdlib.append(""" [ "s-f"    `59 "If string can be converted to a number, return true, otherwise return false" ] 'numeric?' : """)
stdlib.append(""" [ "p-p"    `60 "Reverse the order of items in a slice. This modifies the original slice." ] 'reverse' : """)
stdlib.append(""" [ "v-v"    `61 "Convert a string or character to lowercase" ] 'to-lowercase' : """)
stdlib.append(""" [ "v-v"    `62 "Convert a string or character to uppercase" ] 'to-uppercase' : """)
stdlib.append(""" [ "s-"     `63 "Add a string to the error log" ] 'report-error' : """)
stdlib.append(""" [ "-p"     `64 "Return an array of strings corresponding to names in the dictionary" ] 'vm.dict<names>' : """)
stdlib.append(""" [ "-p"     `65 "Return an array of slices corresponding to the named items in the dictionary" ] 'vm.dict<slices>' : """)
stdlib.append(""" [ "n-n"    `66 "Return the sine of a number" ] 'sin' : """)
stdlib.append(""" [ "n-n"    `67 "Return the cosine of a number" ] 'cos' : """)
stdlib.append(""" [ "n-n"    `68 "Return the tangent of a number" ] 'tan' : """)
stdlib.append(""" [ "n-n"    `69 "Return the arc sine of a number" ] 'asin' : """)
stdlib.append(""" [ "n-n"    `70 "Return the arc cosine of a number" ] 'acos' : """)
stdlib.append(""" [ "n-n"    `71 "Return the arc tangent of a number" ] 'atan' : """)
stdlib.append(""" [ "n-n"    `72 "Return the arc tangent of a number" ] 'atan2' : """)
stdlib.append(""" [ "-p"     `73 "Return an array indicating which slices are allocated and which are free. Each index corresponds to a slice. If the stored value is 0, the slice is free. If 1, the slice is allocated." ] 'vm.memory<map>' : """)
stdlib.append(""" [ "-p"     `74 "Return an array indicating the size of each slice (in cells). Each index corresponds to a slice; the stored value is the length of the slice." ] 'vm.memory<sizes>' : """)
stdlib.append(""" [ "-p"     `75 "Return an array of slice numbers which are currently marked as allocated." ] 'vm.memory<allocated>' : """)
stdlib.append(""" [ "vV-vVv" [ dup ] dip swap "Put a copy of the second item on top of the stack" ] 'over' : """)
stdlib.append(""" [ "vV-VvV" [ swap ] sip "Put a copy of the top item below the second item" ] 'tuck' : """)
stdlib.append(""" [ "vV-V" swap drop "Remove the item below the top item on the stack" ] 'nip' : """)
stdlib.append(""" [ "...-" depth [ drop ] times "Remove all items from the stack" ] 'reset' : """)
stdlib.append(""" [ "sp-" swap : "Attach a name to a slice" ] '.' : """)
stdlib.append(""" "Symbolic names for data types" """)
stdlib.append(""" [ "-n"  100 "Type constant" ] 'NUMBER' : """)
stdlib.append(""" [ "-n"  200 "Type constant" ] 'STRING' : """)
stdlib.append(""" [ "-n"  300 "Type constant" ] 'CHARACTER' : """)
stdlib.append(""" [ "-n"  400 "Type constant" ] 'POINTER' : """)
stdlib.append(""" [ "-n"  500 "Type constant" ] 'FLAG' : """)
stdlib.append(""" [ "-n"  600 "Type constant" ] 'BYTECODE' : """)
stdlib.append(""" [ "-n"  700 "Type constant" ] 'REMARK' : """)
stdlib.append(""" [ "-n"  800 "Type constant" ] 'FUNCALL' : """)
stdlib.append(""" [ "-n"    0 "Type constant" ] 'UNKNOWN' : """)
stdlib.append(""" [ "v-b" BYTECODE  set-type  "Convert value to a BYTECODE" ] ':b' : """)
stdlib.append(""" [ "v-n" NUMBER    set-type  "Convert value to a NUMBER" ] ':n' : """)
stdlib.append(""" [ "v-s" STRING    set-type  "Convert value to a STRING" ] ':s' : """)
stdlib.append(""" [ "v-c" CHARACTER set-type  "Convert value to a CHARACTER" ] ':c' : """)
stdlib.append(""" [ "v-p" POINTER   set-type  "Convert value to a POINTER" ] ':p' : """)
stdlib.append(""" [ "v-f" FLAG      set-type  "Convert value to a FLAG" ] ':f' : """)
stdlib.append(""" [ "v-f" FUNCALL   set-type  "Convert value to a FUNCALL" ] ':x' : """)
stdlib.append(""" [ "v-c" REMARK    set-type  "Convert value to a REMARK" ] ':r' : """)
stdlib.append(""" [ "v-v" UNKNOWN   set-type  "Convert value to a UNKNOWN" ] ':u' : """)
stdlib.append(""" [ "v-vf" type? NUMBER    eq?  "Return true if value is a NUMBER or false otherwise" ] 'number?' : """)
stdlib.append(""" [ "v-vf" type? STRING    eq?  "Return true if value is a STRING or false otherwise" ] 'string?' : """)
stdlib.append(""" [ "v-vf" type? CHARACTER eq?  "Return true if value is a CHARACTER or false otherwise" ] 'character?' : """)
stdlib.append(""" [ "v-vf" type? POINTER   eq?  "Return true if value is a POINTER or false otherwise" ] 'pointer?' : """)
stdlib.append(""" [ "v-vf" type? FLAG      eq?  "Return true if value is a FLAG or false otherwise" ] 'flag?' : """)
stdlib.append(""" [ "v-vf" type? BYTECODE  eq?  "Return true if value is a BYTECODE or false otherwise" ] 'bytecode?' : """)
stdlib.append(""" [ "v-vf" type? REMARK    eq?  "Return true if value is a REMARK or false otherwise" ] 'remark?' : """)
stdlib.append(""" [ "v-vf" type? FUNCALL   eq?  "Return true if value is a FUNCALL or false otherwise" ] 'funcall?' : """)
stdlib.append(""" [ "v-vf" type? UNKNOWN   eq?  "Return true if value is UNKNOWN or false otherwise" ] 'unknown?' : """)
stdlib.append(""" "Stack Flow" """)
stdlib.append(""" [ "vV-vVvV"  over over   "Duplicate the top two items on the stack" ] 'dup-pair' : """)
stdlib.append(""" [ "vv-"      drop drop   "Discard the top two items on the stack" ] 'drop-pair' : """)
stdlib.append(""" [ "?n-"      [ drop ] times   "Discard an arbitrary number of items from the stack" ] 'drop-multiple' : """)
stdlib.append(""" [ "q-...n"   depth [ invoke ] dip depth swap - "Execute a quotation, returning a value indicating th stack depth change as a result" ] 'invoke<depth?>' : """)
stdlib.append(""" "Slice Functions" """)
stdlib.append(""" [ "np-"   [ get<final-offset> + ] sip set<final-offset> "Given a number, adjust the length of the specified slice by the requested amount." ] 'adjust-slice-length' : """)
stdlib.append(""" [ "p-p"   request [ copy ] sip   "Make a copy of a slice, returning a pointer to the copy" ] 'duplicate-slice' : """)
stdlib.append(""" [ "p-n"   get<final-offset> 1 +  "Return the length of a slice" ] 'length?' : """)
stdlib.append(""" "Simple variables are just named slices, with functions to access the first element. They're useful for holding single values." """)
stdlib.append(""" [ "vs-"  [ request [ 0 store ] sip ] dip : "Create a variable with an initial value" ] 'var!' : """)
stdlib.append(""" [ "s-"   0 :u swap var! "Create a variable" ] 'var' : """)
stdlib.append(""" [ "p-"   0 swap 0 store "Set a variable to a value of 0" ] 'off' : """)
stdlib.append(""" [ "p-"   -1 swap 0 store "Set a variable to a value of -1" ] 'on' : """)
stdlib.append(""" [ "p-"   [ 0 fetch 1 + ] sip 0 store "Increment a variables value by 1" ] 'increment' : """)
stdlib.append(""" [ "p-"   [ 0 fetch 1 - ] sip 0 store "Increment a variables value by 1" ] 'decrement' : """)
stdlib.append(""" [ "p-"   request swap copy "Erase all values in a slice" ] 'zero-out' : """)
stdlib.append(""" [ "pp-"  swap request dup-pair copy swap [ [ invoke ] dip ] dip copy "Backup the contents of a slice and remove the pointer from the stack. Execute the quotation. Then restore the contents of the specified slice to their original state." ] 'preserve' : """)
stdlib.append(""" "Number functions" """)
stdlib.append(""" [ "nn-n"  over over lt? [ nip ] [ drop ] if "Return the greater of two values" ] 'max' : """)
stdlib.append(""" [ "nn-n"  over over gt? [ nip ] [ drop ] if "Return the smaller of two values" ] 'min' : """)
stdlib.append(""" [ "n-n"   dup -1 * max "Return the absolute value of a number" ] 'abs' : """)
stdlib.append(""" "The basic bi/tri combinators provided as part of the primitives allow application of multiple quotes to a single data element. Here we add new forms that are very useful." """)
stdlib.append(""" "We consider the bi/tri variants to consist of one of three types." """)
stdlib.append(""" "Cleave combinators (bi, tri) apply multiple quotations to a single value (or set of values)." """)
stdlib.append(""" "Spread combinators (bi*, tri*) apply multiple quotations to multiple values." """)
stdlib.append(""" [ "vvpp-?"   [ dip ] dip invoke "Invoke p1 against v1 and p2 against v2" ] 'bi*' : """)
stdlib.append(""" [ "vvvppp-?" [ [ swap [ dip ] dip ] dip dip ] dip invoke "Invoke p1 against v1, p2 against v2, and p3 against v3" ] 'tri*' : """)
stdlib.append(""" "Apply combinators (bi@, tri@) apply a single quotation to multiple values." """)
stdlib.append(""" [ "vvp-?"    dup bi* "Invoke p1 against v1 and again against v2" ] 'bi@' : """)
stdlib.append(""" [ "vvvp-?"   dup dup tri* "Invoke p1 against v1, then v2, then v3" ] 'tri@' : """)
stdlib.append(""" "Expand the basic conditionals into a more useful set." """)
stdlib.append(""" [ "s-"   report-error abort "Push a string to the error log and abort execution" ] 'abort<with-error>' : """)
stdlib.append(""" [ "-f"   -1 :f "Return a true flag" ] 'true' : """)
stdlib.append(""" [ "-f"   0  :f "Return a false flag" ] 'false' : """)
stdlib.append(""" [ "f-f"  :f :n -1 xor :f "Invert a flag" ] 'not' : """)
stdlib.append(""" [ "fp-"  [ ] if "Invoke quote if flag is true" ] 'if-true' : """)
stdlib.append(""" [ "fp-"  [ ] swap if "Invoke quote if flag is false" ] 'if-false' : """)
stdlib.append(""" [ "v-f"  :s 'nan' eq? "Return true if number is #nan or false otherwise" ] 'nan?' : """)
stdlib.append(""" [ "v-f"  0 eq? "Return true if number is #0 or false otherwise" ] 'zero?' : """)
stdlib.append(""" [ "v-f"  :f :n zero? not "Return true if flag is true or false otherwise" ] 'true?' : """)
stdlib.append(""" [ "v-f"  :f :n zero? "Return true if flag is false or false otherwise" ] 'false?' : """)
stdlib.append(""" [ "n-f"  2 rem zero? "Return true if number is even or false otherwise" ] 'even?' : """)
stdlib.append(""" [ "n-f"  2 rem zero? not "Return true if number is odd or false otherwise" ] 'odd?' : """)
stdlib.append(""" [ "n-f"  0 lt? "Return true if number is less than zero or false otherwise" ] 'negative?' : """)
stdlib.append(""" [ "n-f"  0 gteq? "Return true if number is greater than or equal to zero or false otherwise" ] 'positive?' : """)
stdlib.append(""" [ "nnn-f"  [ [ :n ] bi@ ] dip :n dup-pair gt? [ swap ] if-true [ over ] dip lteq? [ gteq? ] dip and :f "Return true if the number (n1) is betwen n2 and n3, inclusive or false otherwise" ] 'between?' : """)
stdlib.append(""" [ "vv-vvf"  [ type? ] dip type? swap [ eq? ] dip swap "Return true if the type of both values is the same, or false otherwise" ] 'types-match?' : """)
stdlib.append(""" "numeric ranges" """)
stdlib.append(""" [ "nn-..." dup-pair lt? [ [ [ dup 1 + ] dip dup-pair eq? ] until ] [ [ [ dup 1 - ] dip dup-pair eq? ] until ] if drop "Given two values, expand the range" ] 'expand-range' : """)
stdlib.append(""" [ "...n-n"  1 - [ + ] times "Given a series of values and a count, sum the values" ] 'sum-range' : """)
stdlib.append(""" "Misc" """)
stdlib.append(""" [ "p-"   invoke<depth?> [ hide-function ] times "Given an array of names, hide each named item" ] 'hide-functions' : """)
stdlib.append(""" [ "ps-"  dup hide-function : "Remove the old name for a function and assign it to a new one" ] 'redefine' : """)
stdlib.append(""" [ "p-"   invoke<depth?> [ var ] times "Given a list of names, create a variable for each one" ] '::' : """)
stdlib.append(""" "String and Character" """)
stdlib.append(""" "Note that this is only supporting the basic ASCII character set presently." """)
stdlib.append(""" [ "vs-f" swap :s find not true? "Return true if the value is found in the specified string, or false otherwise" ] 'string-contains?' : """)
stdlib.append(""" [ "v-f"  :c $0 $9 between? "Return true if value is a decimal digit, or false otherwise" ] 'digit?' : """)
stdlib.append(""" [ "v-f"  '`~!@#$%^&*()<>,.:;[]{}\|-_=+"'' string-contains? "Return true if value is an ASCII symbol, or false otherwise" ] 'symbol?' : """)
stdlib.append(""" [ "v-f"  to-lowercase 'abcdefghijklmnopqrstuvwxyz'           string-contains? "Return true if value is an ASCII letter, or false otherwise" ] 'letter?' : """)
stdlib.append(""" [ "v-f"  to-lowercase 'abcdefghijklmnopqrstuvwxyz1234567890' string-contains? "Return true if value is a ASCII letter or digit, or false otherwise" ] 'alphanumeric?' : """)
stdlib.append(""" [ "v-f"  to-lowercase 'bcdfghjklmnpqrstvwxyz'                string-contains? "Return true if value is a consonant, or false otherwise" ] 'consonant?' : """)
stdlib.append(""" [ "v-f"  to-lowercase 'aeiou'                                string-contains? "Return true if value is a vowel, or false otherwise" ] 'vowel?' : """)
stdlib.append(""" [ "v-f"  dup to-lowercase eq? "Return true if value is a lowercase string or ASCII character, or false otherwise" ] 'lowercase?' : """)
stdlib.append(""" [ "v-f"  dup to-uppercase eq? "Return true if value is an uppercase string or ASCII character, or false otherwise" ] 'uppercase?' : """)
stdlib.append(""" [ "p-s"  invoke<depth?> 1 - [ [ :s ] bi@ + ] times "Execute a quotation, constructing a string from the values it returns." ] 'build-string' : """)
stdlib.append(""" "Programatic Creation of Quotes" """)
stdlib.append(""" [ "vv-p"  swap request [ 0 store ] sip [ 1 store ] sip "Bind two values into a new slice" ] 'cons' : """)
stdlib.append(""" [ "vp-p"  :x cons "Bind a value and a quote, returning a new quote which executes the specified one against the provided value" ] 'curry' : """)
stdlib.append(""" [ "p-p"   :x request [ 0 store ] sip "Wrap a pointer into a new quote, converting the pointer into a FUNCALL" ] 'enquote' : """)
stdlib.append(""" "Arrays and Operations on Quotations" """)
stdlib.append(""" [ "q-v"  0 fetch "Return the first item in a slice" ] 'head' : """)
stdlib.append(""" [ "q-q"  1 over length? subslice ] 'body' : """)
stdlib.append(""" [ "p-v"  dup length? 1 - fetch "Return the second through last items in a slice" "Return the last item in a slice" ] 'tail' : """)
stdlib.append(""" [ 'Found'  'Value'  'XT'  'Source'  'Target'  'Offset' ] :: """)
stdlib.append(""" [ "q-"   @Found [ @Value [ @XT [ @Source [ @Target [ @Offset [ invoke ] dip !Offset ] dip !Target ] dip !Source ] dip !XT ] dip !Value ] dip !Found ] 'localize' : """)
stdlib.append(""" [ "vp-"    :p dup length? store "Append a value to the specified slice. This modifies the original slice." ] 'push' : """)
stdlib.append(""" [ "p-v"    :p [ dup get<final-offset> fetch ] sip dup length? 2 - swap set<final-offset> "Remove the last value from the specified slice. This modifies the original slice." ] 'pop' : """)
stdlib.append(""" [ "-p"     request [ pop drop ] sip "Request a slice with no stored values" ] 'request-empty' : """)
stdlib.append(""" [ "pnp-n"  [ !XT over length? [ over pop @XT invoke ] times nip ] localize "Takes a slice, a starting value, and a quote. It executes the quote once for each item in the slice, passing the item and the value to the quote. The quote should consume both and return a new value." ] 'reduce' : """)
stdlib.append(""" [ "pp-?"   [ !XT !Source 0 !Offset @Source length? [ @Source @Offset fetch @XT invoke @Offset 1 + !Offset ] times ] localize "Takes a slice and a quotation. It then executes the quote once for each item in the slice, passing the individual items to the quote." ] 'for-each' : """)
stdlib.append(""" [ "pv-f"   false !Found !Value dup length? 0 swap [ dup-pair fetch @Value types-match? [ eq? @Found or :f !Found ] [ drop-pair ] if 1 + ] times drop-pair @Found "Given a slice and a value, return true if the value is found in the slice, or false otherwise."  ] 'contains?' : """)
stdlib.append(""" [ "pq-p"   [ !XT !Source request-empty !Target 0 !Offset @Source length? [ @Source @Offset fetch @XT invoke [ @Source @Offset fetch @Target push ] if-true @Offset 1 + !Offset ] times @Target ] localize "Given a slice and a quotation, this will pass each value to the quotation (executing it once per item in the slice). The quotation should return a Boolean flag. If the flag is true, copy the value to a new slice. Otherwise discard it." ] 'filter' : """)
stdlib.append(""" [ "pq-"    [ !XT duplicate-slice !Source 0 !Offset @Source length? [ @Source @Offset fetch @XT invoke @Source @Offset store @Offset 1 + !Offset ] times @Source ] localize "Given a pointer to an array and a quotation, execute the quotation once for each item in the array. Construct a new array from the value returned by the quotation and return a pointer to it." ] 'map' : """)
stdlib.append(""" [ "p-p"    [ request !Target invoke<depth?> 0 max [ @Target push ] times @Target 1 over length? subslice :p ] localize "Invoke a quote and capture the results into a new array" ] 'capture-results' : """)
stdlib.append(""" [ "pv-n" [ dup-pair !Value !Source contains? [ 0 !Offset #nan !Found @Source length? [ @Source @Offset fetch @Value types-match? [ eq? [ @Offset !Found ] if-true ] [ drop-pair ] if @Offset 1 + !Offset ] times @Found ] [ #nan ] if ] localize "Given a slice and a value, return the offset the value is located at, or #nan if not found" ] 'index-of' : """)
stdlib.append(""" [ 'Found'  'Value'  'XT'  'Source'  'Target'  'Offset'  'localize' ] hide-functions """)
stdlib.append(""" [ "s-f"  vm.dict<names> swap contains? "Return true if the named function exists or false otherwise" ] 'function-exists?' : """)
stdlib.append(""" [ "s-p"  vm.dict<names> swap index-of vm.dict<slices> swap fetch "Return a pointer to the named function if it exists, or #nan otherwise" ] 'lookup-function' : """)
stdlib.append(""" [ "p-s"  :p vm.dict<slices> over contains? [ vm.dict<slices> swap index-of vm.dict<names> swap fetch ] [ drop '' ] if "If the pointer corresponds to a named item, return the name. Otherwise return an empty string." ] 'lookup-name' : """)
stdlib.append(""" [ "ss-"  swap dup function-exists? [ dup lookup-function swap hide-function swap : ] [ drop ] if "Change a name from s1 to s2" ] 'rename-function' : """)
stdlib.append(""" "Functions for trimming leading and trailing whitespace off of a string. The left side trim is iterative; the right side trim is recursive." """)
stdlib.append(""" [ "s-s" :s #0 [ dup-pair fetch :n 32 eq? [ 1 + ] dip ] while 1 - [ dup get<final-offset> 1 + ] dip swap subslice :s "Remove leading whitespace from a string" ] 'trim-left' : """)
stdlib.append(""" [ "s-s" reverse trim-left reverse :s "Remove trailing whitespace from a string" ] 'trim-right' : """)
stdlib.append(""" [ "s-s" trim-right trim-left "Remove leading and trailing whitespace from a string" ] 'trim' : """)
stdlib.append(""" "Text Output Buffer" """)
stdlib.append(""" 'TOB' var """)
stdlib.append(""" [ "v-"   &TOB push "Append a value to the TOB" ] 'to-tob' : """)
stdlib.append(""" [ "-..." &TOB get<final-offset> [ &TOB pop ] times "Push each item in the TOB to the stack" ] 'show-tob' : """)
stdlib.append(""" [ "-"    0 &TOB set<final-offset> "Remove all items in the TOB" ] 'clear-tob' : """)
stdlib.append(""" "Scope" """)
stdlib.append(""" [ 'Public'  'Private' ] :: """)
stdlib.append(""" [ "-" vm.dict<names> !Private "Begin a lexically scoped area" ] '{' : """)
stdlib.append(""" [ "p-" [ string? nip ] filter !Public "Extract names in scope" vm.dict<names> @Private length? over length? subslice !Private  "Filter out the functions to keep" @Private [ @Public swap contains? not ] filter  "Hide the remaining names" [ hide-function ] for-each "End a lexically scoped region, removing any headers not specified in the provided array." ] '}' : """)
stdlib.append(""" [ 'Public'  'Private' ] hide-functions """)
stdlib.append(""" "Vocabularies" """)
stdlib.append(""" [ 'with' 'without' 'vocab' '}vocab' '}}' ] { """)
stdlib.append(""" [ 'Vocabulary' ] :: """)
stdlib.append(""" [ "p-"  [ invoke : ] for-each "Add words in a vocabulary to the dictionary" ] 'with' : """)
stdlib.append(""" [ "p-"  [ tail hide-function ] for-each "Remove words in a vocabulary from the dictionary" ] 'without' : """)
stdlib.append(""" [ "ps-" request-empty !Vocabulary @Vocabulary swap : [ dup lookup-function swap cons @Vocabulary push ] for-each @Vocabulary without "Create a new vocabulary"   ] 'vocab' : """)
stdlib.append(""" [ "ps-" over } vocab "Close a lexical scope and create a vocabulary with the exposed functions"   ] '}}' : """)
stdlib.append(""" } """)
stdlib.append(""" [ 'invoke<preserving>' ] { """)
stdlib.append(""" [ 'Prior'  'List' ] :: """)
stdlib.append(""" [ "qq-" @Prior [ @List [ swap duplicate-slice !List [ @List [ head ] for-each ] capture-results reverse !Prior invoke @Prior length? [ @Prior pop @List pop 0 store ] times ] dip !List ] dip !Prior "Executes the code quotation, preserving and restoring the contents of the variables specified."   ] 'invoke<preserving>' : """)
stdlib.append(""" } """)
stdlib.append(""" [ 'zip' ] { """)
stdlib.append(""" [ 'A'  'B'  'X'  'C' ] :: """)
stdlib.append(""" [ "ppp-p" [ A B X C ] [ !X !B !A request-empty !C @A length? [ @A head @B head @X invoke @C push @A body !A @B body !B ] times @C duplicate-slice ] invoke<preserving> "For each item in source1, push the item and the corresponding item from source2 to the stack. Execute the specified code. Push results into a new array, repeating until all items are exhausted. Returns the new array. This expects the code to return a single value as a result. It also assumes that both sources are the same size (or at least that the second does not contain less than the first"   ] 'zip' : """)
stdlib.append(""" } """)
stdlib.append(""" "Hashing functions" """)
stdlib.append(""" 389 'Hash-Prime' var! """)
stdlib.append(""" [ "s-n" 0 swap [ :n xor ] for-each "Hash a string using the XOR algorithim" ] 'hash:xor' : """)
stdlib.append(""" [ "s-n" 5381 swap [ over -5 shift + + ] for-each "Hash a string using the DJB2 algorithim" ] 'hash:djb2' : """)
stdlib.append(""" [ :n over -6 shift + over -16 shift + swap - ] 'hash:sdbm<n>' : """)
stdlib.append(""" [ "s-n" 0 swap [ :c swap hash:sdbm<n> ] for-each "Hash a string using the SDBM algorithim" ] 'hash:sdbm' : """)
stdlib.append(""" [ "s-b" hash:djb2 "The preferred hash algorithim (defaults to DJB2)" ] 'chosen-hash' : """)
stdlib.append(""" [ "s-n" chosen-hash @Hash-Prime rem "Hash a string using chosen-hash and HashPrime" ] 'hash' : """)
stdlib.append(""" 'hash:sdbm<n>' hide-function """)
stdlib.append(""" [ 'when' ] { """)
stdlib.append(""" [ 'Offset'  'Tests'  'Done' ] :: """)
stdlib.append(""" [ "q-" [ Offset Tests Done ] [ !Tests false !Done 0 !Offset [ @Tests @Offset fetch head invoke [ true !Done @Tests @Offset fetch 1 fetch invoke ] if-true @Offset 1 + !Offset @Done ] until ] invoke<preserving> "Takes a pointer to a set of quotations. Each quote in the set should consist of two other quotes: one that returns a flag, and one to be executed if the condition returns true. Executes each until one returns true, then exits."   ] 'when' : """)
stdlib.append(""" } """)
stdlib.append(""" [ 'split'  'join' ] { """)
stdlib.append(""" [ 'Source'  'Value'  'Target' ] :: """)
stdlib.append(""" [ "n-"  [ @Source 0 ] dip subslice :s ] 'extract' : """)
stdlib.append(""" [ "n-"  @Source swap @Value length? + over length? subslice :s !Source ] 'next-piece' : """)
stdlib.append(""" [ "ss-p" dup length? 0 eq? [ drop [ :s ] map ] [ :s !Value !Source request-empty !Target [ @Source @Value find dup -1 -eq? [ [ extract @Target push ] sip next-piece true ] [ drop @Source @Target push false ] if ] while @Target ] if "Given a string and a delimiter, split the string into an array"   ] 'split' : """)
stdlib.append(""" [ "pv-s" :s !Value reverse '' [ :s + @Value + ] reduce "This leaves the join value appended to the string. Remove it." 0 over length? @Value length? - subslice :s "Given an array of values and a string, convert each value to a string and merge, using the provided string between them"   ] 'join' : """)
stdlib.append(""" } """)
stdlib.append(""" [ "s-s"  [ :n 32 128 between? ] filter :s "Remove any non-printable characters from a string" ] 'clean-string' : """)
stdlib.append(""" [ "sss-s"  [ split ] dip join clean-string "Replace all instances of s2 in s1 with s3" ] 'replace' : """)
stdlib.append(""" [ 'interpolate' ] { """)
stdlib.append(""" [ 'Data'  'Source'  'String' ] :: """)
stdlib.append(""" [ "-"  @String @Source head @Data head pointer? [ invoke ] if-true :s + + !String ] '(accumulate)' : """)
stdlib.append(""" [ "-"  @Source body !Source  @Data body !Data ] '(next)' : """)
stdlib.append(""" [ "ps-s" [ Data Source String ] [ '{v}' split !Source !Data request-empty :s !String @Data length? [ (accumulate) (next) ] times "Merge any remaining items" @String @Source '' join + clean-string ] invoke<preserving> "Given an array of values and a string with insertion points, construct a new string, copying the values into the insertion points."   ] 'interpolate' : """)
stdlib.append(""" } """)
stdlib.append(""" [ 'interpolate<cycling>' ] { """)
stdlib.append(""" [ 'D'  'S'  'L' ] :: """)
stdlib.append(""" [ "qs-s" [ S D L ] [ !S  !D @S '{v}' split length? !L [ @D length? @L lt? dup [ @D duplicate-slice @D + !D ] if-true ] while [ @D length? @L lt? dup [ @D pop drop ] if-false ] until @D @S interpolate ] invoke<preserving> "Given an array of values and a string with insertion points, construct a new string, copying the values into the insertion points. If the array of values is less than the number of insertion points, cycle through them again."   ] 'interpolate<cycling>' : """)
stdlib.append(""" } """)
stdlib.append(""" "?" """)
stdlib.append(""" [ '?' ] { """)
stdlib.append(""" [ 'Probability' ] :: """)
stdlib.append(""" [ "f-"   [ &Probability increment ] if-true ] 'check' : """)
stdlib.append(""" [ "s-s"  head uppercase? check ] 'initial' : """)
stdlib.append(""" [ "s-s"  1 fetch lowercase? check ] 'second' : """)
stdlib.append(""" [ "s-s"  lookup-function head remark? not check drop ] 'no-comment?' : """)
stdlib.append(""" [ "s-f" 0 !Probability dup length? 1 eq? [ &initial &no-comment? bi @Probability 2 eq? ] [ &initial &second &no-comment? tri @Probability 3 eq? ] if "Given a function name, try to determine if it is a variable."   ] 'var?' : """)
stdlib.append(""" [ "p-?"  &head &tail bi [ remark? &drop if-false ] bi@ ] 'describe-func' : """)
stdlib.append(""" [ "s-s"  drop 'Variable' &:r bi@ ] 'describe-var' : """)
stdlib.append(""" [ "s-s | s-ss" dup function-exists? [ dup var? [ describe-var ] [ lookup-function [ head ] [ tail ] bi [ remark? [ drop ] if-false ] bi@ ] if ] [ 'function "' swap + '" not found' + report-error ] if "Lookup the stack comment and description (if existing) for a named item"   ] '?' : """)
stdlib.append(""" } """)
stdlib.append(""" "unsorted" """)
stdlib.append(""" [ 'stack-values' ] { """)
stdlib.append(""" 'S' var """)
stdlib.append(""" [ "-p" request-empty !S depth [ @S push ] times @S reverse dup !S invoke @S "Return an array with the items currently on the stack"   ] 'stack-values' : """)
stdlib.append(""" } """)
stdlib.append(""" [ 'vm.dict<names-like>' ] { """)
stdlib.append(""" 'Pattern' var """)
stdlib.append(""" [ "s-f" @Pattern swap string-contains? ] 'matches' : """)
stdlib.append(""" [ "s-p" !Pattern vm.dict<names> &matches filter "Return an array of names in the dictionary that match a given substring."  ] 'vm.dict<names-like>' : """)
stdlib.append(""" } """)
stdlib.append(""" [ "-n"   2.71828182846 "Mathmatical constant for Euler's Number" ] 'E' : """)
stdlib.append(""" [ "-n"   3.14159265359 "Mathmatical constant for PI" ] 'PI' : """)
stdlib.append(""" [ "n-n"  E log<n> "Return the base E logarithim of a number" ] 'log' : """)
stdlib.append(""" [ "n-n"  10 log<n> "Return the base 10 logarithim of a number" ] 'log10' : """)
extensions = []
extensions.append(""" [ "-"   `2000 ] '+warnings' : """)
extensions.append(""" [ "-"   `2001 ] '-warnings' : """)
extensions.append(""" [ "-"   `9000 ] '.s' : """)
extensions.append(""" [ "-"   `9001 ] 'bye' : """)
extensions.append(""" [ "-"   `9002 ] 'words' : """)
extensions.append(""" [ "s-"  `9003 ] 'include' : """)
extensions.append(""" [ "s-"  `9004 ] 'save-snapshot' : """)
extensions.append(""" [ "s-"  `9005 ] 'reload-snapshot' : """)
extensions.append(""" [ "...-" `9006 ] 'restart' : """)
extensions.append(""" "File Operations" """)
extensions.append(""" [ "string:name string:mode - number:file-id"  `201 ] 'open-file' : """)
extensions.append(""" [ "number:file-id -"  `202 ] 'close-file' : """)
extensions.append(""" [ "number:file-id - character"  `203 :c ] 'read-file' : """)
extensions.append(""" [ "character number:file-id -"  `204 ] 'write-file' : """)
extensions.append(""" [ "number:file-id - number:position"  `205 ] 'file-position' : """)
extensions.append(""" [ "number:offset number:file-id -"  `206 ] 'file-seek' : """)
extensions.append(""" [ "number:file-id - number:length"  `207 ] 'file-size' : """)
extensions.append(""" [ "string:name -"  `208 ] 'delete-file' : """)
extensions.append(""" [ "string:name - flag"  `209 ] 'file-exists?' : """)
extensions.append(""" [ 'slurp-file' ] { """)
extensions.append(""" [ 'FID' 'S' ] :: """)
extensions.append(""" [ "string:name - string:contents" dup file-exists? [ 'r' open-file !FID request !S @S pop drop @FID file-size [ @FID read-file @S push ] times @FID close-file @S :s ] [ drop '' duplicate-slice :s 'Unable to to locate file' abort<with-error> ] if   ] 'slurp-file' : """)
extensions.append(""" } """)
extensions.append(""" "Command Line Arguments and System Integration" """)
extensions.append(""" [ "- pointer"        `226 "Return an array of all command line arguments. Typically the first two items will be the scripting engine name and the source file being run." ] 'sys.args' : """)
extensions.append(""" [ "string - number"  `227 "Run an external program. Returns the execution status." ] 'sys.run' : """)
extensions.append(""" [ "- number"  `4000 ] 'arg-count' : """)
extensions.append(""" [ "number - string"  `4001 ] 'get-arg' : """)
extensions.append(""" [ "s-s"  `5000 ] 'value-for-key' : """)
extensions.append(""" [ "s-s"  `5001 ] 'get-environment-value' : """)
extensions.append(""" "Terminal I/O" """)
extensions.append(""" [ "v-"  `6000 ] 'display' : """)
extensions.append(""" [ #10 :c display ] 'tty.cr' : """)
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        sys.stdout.write("\t" + str(i))
        if type == TYPE_NUMBER:
            display_item('\t' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('\t' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('\t' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('\t' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('\t' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('\t' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('\t' + "", "true")
            elif tos == 0:
                display_item('\t' + "", "false")
            else:
                display_item('\t' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('\tCALL to ' + '&', tos)
        else:
            display_item('\t' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_NUMBER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        parse_bootstrap(stdlib)
        parse_bootstrap(extensions)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\ninput> ")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input("       ")
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    parse_bootstrap(stdlib)
    parse_bootstrap(extensions)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
