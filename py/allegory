#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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JljW5rN6B03WgdAAtb2AADW/uLJl++nOXn05z2HPF9a3zz35V3rjZERN732rxsHTQBTzyTOb759eXfjfnnv1IAAAWt7AAB2TPkceAAAALxsHTsmc75rWta1qHvBa3JgDoAAAWt7AAB2TOHA+553yfTetyZfZ7ZOavXnnG3bXTQBW5M13ZwOgAABa3sAAFy61Jm9zzUm9NeBTsNgAAvGwdPhwDcmXJtsFLkaAAAtb2AADsmXXd7921x6dDE3vYC8bB0vOOAtbkwB0AAALW9gAA7JhsAAAAXjYOmta++1ZkyTMknHnPX3gdszIT2TOc1wOnAPhWgC31zg+FaAOzM8OO977z377e9+bxXe+HvJxJl7vuL332eZuW7um7x3En3PbzvvJrJ43wpW5MAdAAAC1vYAAOyYbAAAAF42DpZyzeSt84Om9dvt9yZ5rWeufTXndeeb+FofgB+Atb2AADzuTPPt+HHvVPcMYzycJM9afetPzu96TyeJPfO7cSfdafhimvPPPNA9ndfSZ3U755zetam/ObnNz6c3fu96ABa3sAAG+yYfb3wfdAAAC8bB0trnOAdnJMOB08QPQAC1vYAALZM8c4HQAAAvGwdNAFTcmd3uajvXnLfPO63LryyZx5tvfHhVrewAAdkw2AAAALxsHS5q5M85N1znB039dyZrxt6LQAABa3sAAHcmb+faevXygAAC8bB07ZxvgK7yTDgdAYxPJvYvzewAALJmmwHTYAALxsHT4cA7637kxzXD50AAALW9gAAWTPNuB0AAALxsHS844C1uTAHQB99E3b5rfks15q1zzu9Tcmee88993yPNSZzmTHOeR598oAAvGwdL3e5JmZMmZk3848ehckyZMknJMbB0AAALW9gAA7JhsAAAAXjYOm5MvW3B03JgDoAAAWt7AAB2TDN4xiJcmex3CY3TntZ68973u+8nzd/SabretPXcw65vRmXDPtZl3duUKpvRvOxR5mLmMNlStyOV35oe+uPwxoy3vMXzzZmc1ZpvDdp9N4EDd06M1jU1QYkBYBxMEMp7D25rhr7McspevroHMqJq3XMKbZmzJyXe7puZdQ0ZJjCfffX51NK9N9hw5mytDucuGiHLho9Nl7re5zn3s1riYzkya9qH2bZJim9nOYXU3slnMqc3yYdZRJzpOm+0x0qdv2B3Tzr3ae+5NHuXRXeV+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G13TS89feJ532845UeSduVFLvG0008xNNttpcxL3y2y3fGnuL2230uDTE0kmkaAANtMaNnjSXuNptNGNsxtfGjDbTDUm5imNttzJiSbUxKZkkAdaw2D2223vZkmTIl1N5Hy227JAA9AAAAAkkkgAACAAJJJINMAAgABE2m0l3G2l7kJ7qpT9tNnO++6kp7qIvvvtn31pFtttsyZmUAGnMzJIB9VttttDw+H3gLQLZMmSF5ltt0AAJJJIIAAkkkkkkkAAATZgABIAHoAAJtJXnGkm2STnOZkkmYDbofW222ZJkq222NSaaMTaRjMQabYBJOJyabSUyYpMy6mZJAHQC22297JkyLvVtt0AAJJJIIAAkkkgmwACAABJJIIAAkkkg2lDjTfs4zGk1qaz7fv2/mmmk19999NyACbAA+BpNgC21ySSQD4SYetZJmQ+5mSR9vUmN5kkamZJPXodALLbbe9zGm3t408ttugDAJI5JBAIA9kkkikkkJJJO973smSSSEkkgm2klqeNJtGNp4k8SSaSScxJNwQAG4E9nrg+YW222S73MySXQ5BfC225bbuNTMkgHwA3kwA7mSZie3jRy23RySSCkkkGnIAA2jAACSSQQABJJJBNgAAkwAATaS1pZmJTGk1mNNK3wuW3buNO22l0akxoB81Jh9weFuu973s67Q3Fu83GnuctvttLu7u9jTZxABtMAAgAB3ve96GAAd73vSHAABAAEkkk73vekBb6U7z1pJJKeeWZLd3cttt9vclAttczJONwHV73v173eZJFts3bu7u7e23fd3epTJJJsakkkBMACNySSEkkkGmAQEABFJJJFJJAEAEiTbvOPVnnnGkkmmu4mm8WJpNJKY25PYafAhNySSJJKEkkkk1GpmSQ2H3upMOSZy29973eSZMW2httttt3bTVjzENtNLEB03oskkoSSSSSSSSSSQAAAAAAAAAAAAADp6k0lM5lvEmkHUHU0m21777999aBuTAJmZHbLbbbdtZJkxrJJJgPRJgedl1b5baFoDTbSNJtpTMk0NAAAAAAAAAAAAAAAAAAAAAACSAm4B+/r/gAo45TMogEVx0Ej+uftkA2iJAMIBhALzCAW93772/e+AnpAHW7IB9wgHNaz28dd+yG0+4WGnEDYRx5qzaKVOpXGLzl0k0IOYYGOiQgEBqqgu2b3ZpEZMwv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bbe5kutW222zJ3ve973szO6akysmOB5kyLQEyLtttqToAAmr+7qaS8WZg15xtppL808SbabuL673aGQkknPZIH0kkknjUyXWDkjUayOzM73ve96L26tttDQAPWzEDT0mmk7zUkksTXO6Sck8SlvMkhQGSb3u3ve972ZGtatttvZk72222zJW5MaNtT0eTzWZB4D1rWLEgAAEnJJJJE1eQ38eLa2tJaxZmY8xe79+3800knMaaa+++Pth0NBJJuNuW1e973vneq9Plkzd3bu216AAAD7JJJ+13ve97+syX+3JgDsyLaBMgW22TLbbbbMlttttmStyYA7Mi2gTIFttky2222zH+c/b/K/vu51qL91zIaZDIPdI41JbriS2I75y2E2I6ygPKYhAwTnLwdEAYQNIQhtMTf9yR80k9Z5YjIZRm3O+rqxJOsbfJww3kKz4y7Rw13X8+ZDgyAaPbyHHWtkA7rMIBZmNJHc1bh9W6TzrWszYu8weVS8ZdlDWUFUimMISjxY7EtpY1rzOZn3O+3vXc9vL9nPbDccdy3M2ajhy6+CPnTxUeYjuhuCO1Dvmk6dttJXTdFpOqtI2zio7RMmZJlGjqhvOlOnVJyKWjCNJZQ13VcnKk6/e9P2jtplpqGsVso08oY5XKLk5I74r7idaNpGMU7yo4pbKWqtQy44o5zWNI2xjLWiuCcUuXrOdczmCsVsznJcXGuS+blkM105ymUNBmZtcRzhp7rpjLZI1dQaBZYedcpR1SsmKtWtA0jExHHL7xI5PjkqXF2RoeSWJAk0yE93myHWEDZ5PcZne8znvzu7x5wDXnyW/ee2332nOc45oDXL3vfO/dpoB22220d0cBlttttE8W3y5zHu/ffStAC2223t8cD4FttocAB3vfd97zvRXoefv18+U+MHWuZ9mJzWxbNZLGJcxpLmJ5babdnd3fd7u2kMA2xP27vh8DABWgG3Sy/W1a4D6TPtZOOnv2FeLb4CAW2220D7XohBsOQjaTEmliSbSxtJYlGlqSb04UWTO61rJrWTWo04FttttPum+A97Jqd3db5bbX2Wa368enwsrQCgDwZMTMZM9yYyYyYzJ555549DxDcmAO973ve9tbyYeA783JjQ5Lbb7fp5a8Phz4ce232cts8p0uZJGgKAK+k3kyTXMmSamDg7X0mh4B9kHAPohwD7JvJkmsHAr37Mqac8AAH06b4B9km8mSDwK+DzQNDrVvbqTJPbbxWlALfctvLaPsh9p4ej6ZZd222/QcA+kg2xnMmffSe/ec++D6ZBwD7F3bbb9TgPc972dT7foS+1CdJAGSbkCAwCopMVaDZdFW5baXWAuVuieNNmJptBp0y2eKq6umkvMaSbQcNF/PhwHkmGYPb3ve97zMknVHzve973vfsmDgAAA/d/pJuSamom000lmJqSSTnEn3GmkZ5iTwAAjyLaBmQLbbky22225kttttuZK3JgeDkyzWB6DM91kmtZrWtSZrWAFxqYAXMnLMkn9N7kyRL5zjeJtJpdzWNu/XlpEW5429avfe+9xJ99XfO91e5rG02LnU36vDWrfNrga840/vDPJpJG9Iy2z3autGNeHoaaTTmLeXRhJOXCLWTbTPA9EAABtVLGk8znOc5yxNT+3JgDsyLaBMgW22TLbbbbMlttttmStyYA7Mi2gTIFkkSckkkkTUbTS33zxttLPNa5lx3Fv5LWNefb8SSTXn19+tu9dJJ5NydN223VtB0eujnu8mW29733q8tFaAHmJgB2TnOc5Ik+rHiMWjWm2YjDGzEG5k7R4CZKLbbJlttttmS2222zIOc1Jmo2014cazJ5JrWtYHgPdZjawAABNmJPMeY2wAAB5jzEnlq7rT53Xe9+5rvfNkPX6HI8+kkgAAAAO973774ttAAOQHszP623777ofkIooT8k8wPMNJA8+fap6+xpcxY3bb7bamrbQBNbitttomgDve9mS28akxppo3Mlve22sTIcLbUnaAAmrVzwL1NJfNreHshJ3ne82a/gty22W0W23y+W18+dyZZM1bfO968ttAG2mwdPy2223Mne7/tSO229bUWW22W69TW75u7bUnaAAmqrbbbU0YbxJ22+3E1aBbdeprd33dtqTtoAJq+TiWcquJNLy/tm339Lu76QCgAAd73v33xbbwD4AAAFskkkja5zviTmNc5zxfLElix5rVtt+tZxJmtTLb6gMk90Lb3syFbbS1NBviTttvU1y0Lbr1NW32gBNd730J9998Q7AD5kAxr/J3AvuaMxaZ4IOTt4iveJO+rwnefLmZk4k/fPZ5jT8XfTtXO3W40zAAAVUniAA3eAB8BtpnwffW23dvLb4t83rnOc40/u6ae85zh+fU1s29u7upotJNG1uYW20TVTkkkS/YnVh9xJ22+pv75p0LbU0ICSqdCc5zXOd6QesL6/31xUOczea0a5VDHIkufc6m/t37doaAD2fTzW97OTyHbb9eX9+9+/HGTLbbbfrqTDYCAAN/RKSSRNH2Zyv9xJ7u7vU0OSAD8zMSQm4pJIJDFmNayYABtNcUXOc5yRtbiTADraFJIFqaAJI2s3mpu22xNUWdXLb7afv293d8PJJ5NN228ttu6He973vegAAg8akwP1+73ttKmvcWJPH+xJ28u7u9aXuYwC0TVWtO20G1MkkmxvMdaYAFra1Yk7vN3d3qa1UDbamtVtoCT1NgADa5ZZ5r7z377693u2XfMAJxbXOc5wgAHqT9AePti27ky3dtr0AAAFmO73vnOXia7iTknOcnE1ZJAI34hAAAmzFmPFmYlJJJJFmZibxY4IACIxLMaeZEeeJMADaXMUkk3JE1Bphu21tGW220TXkEmlzE0libSf5NJcc2c5qHKHnnOdqLiiyHn7pBhAOft/2kgGwIBupAKEj66MS5af1sYqpxl5fRM7u7IB9vbNEA4YQbbv74j1763QeoedFd3SHXXVPJBpKi82QDf2yd3yYDSAJAKyAOudp1NBRINGxczm/r9nM3r2pNgwWyS+1onMqdS04+dq68453qy/b9z72cUa/Zz9xUPT5coc++Q0vFjSaXntXENvZTqDz3k2+exN9psttfb2Amp4Qc9K2+B0eT7uu873vQBFttttHfjjxe973veqAcanEZM15zz7f3nvwADy23y20OAfZbbbbQAT7777774ABneJJCxtZjTTx4pJJOABJJ598eb3sACG5MDB0AAFttttAeAnoMgAAttttoJgFvZLmZJq22iyJNAbE80FdABZJLbbbQAakzve9tu5M7XAAvbq220AAW2220MwAFtv1u8mWTJKAfDi323cmXVtBXsySakyTWpMmw+XsmZJLMySd1u8ttAIC2223UygrWTK0B8OZM1uAOgANjgeABG5gDoAAAAAAtTJkgDpvHngPr1bbbbQAGeyeeeeBTWTJAClttttAAIH1u8me915Jka7JzTb9t1b7O99PQ+D75dm7vlAANu7oAPTczO973vegAA0W2339/cpbK2JtWwNpbUW1NabDJsmsmKyaqyapk1MmWTFMmTJksmUtqZNVZMmk2GYsUyZSyYmTJMmI1NVW2aiyYmTKZMmjSmTKZMqszZWTKGTJlWU1kwYTJkGTVVrGysmRZMoaNVZMomTSZMhssyg0aoyaqyZVoxW0tSyLJZLZDSwm1tmWMVWTJk0hoyZMmjJoxMmTUYrKtTJkyaTMjJjJpLJhLJibLNsqMmCbVGTUlsJk1UyYmTVWTJkyZMmTSyZGaUZMWTJk0mTVDEyrYW1IyaExZMmlZMJkyoyZUYaFmqGTKsmkyZkxMmKZNDNbSzEsmkyYTJkyaoZMTa2bFsWwU2irYjYrSyWwbJjUlk0msJkwmaFYmismoMTVDJqLJhMmotkbURkwjJlSMmUyaimTFWTIZMKZMmTFhMTJqrKsqyaRZMmJlWJhMmTJpNpGTKsmErJkVZMiMmUyaVGTFDExMmJiYmTJkyZNCYmVZMTJiYmTE1VkxMTIsmEyZFk1GxNiGlqo0tLZItLFEyaFZMhMmSZMmTKGTKsmRZNJkyBkyZMVZMmTUWTKsTExMmTKsmTJiZMmTK0tDSwmyaxLS0ppZQNLAlpaKVpaQmhkyYRZMJlDVU2+fPnz5+/z4lR9TIJZMmTVJMmpVZMorJirJkDExNJk1kyRvcmAfTIi20Jkttve9kfBNySSRNSSSSRNQ0k5JOfJoMJJd3U0AEiTlaYBtqaE7ivGnfv33x9iuL7enMbhpN6wxGCNSaib6eHUnbL3vkXam6HgATMmpznPbNW6tttOG2mHq33d93bub3d418cAPhNH7iTADqaqoBd3U1bbQEmbbbbU1QABNW74kwGBzmYklJIpuTUTeY8xJ5iFsACaljVWXd3d0TXvAxZ+anexJpppzGmm0nvJ8HJh20A+knkoaTC+nzSQBv5pGJBq47i6d7o608ttqMMQd8bVxK41cVxJXG7dK40qrfLdO41cTuK4kzE1uPc3NxpppufBJ8JoP3iTttvU1aGpu7u6mtm7u21J0AATVVtttqaOuSZbbfZkt71kyhMh0W2TLe973vE1PLndzSfuW+2LksAAJMknOcJznCSQACSSSgeW2222gABJJL5u85zlia5znfUnJJ6mpJwacgCa4ABIk+FoAmqrbbbU0BvqTtt9TVtNadugmvgAJELEmsxySSSTFizFmGewmvU0kZ1P73z37effH3svPjoAAAdtttO38B/fh3ve973oAAC+ZMtt/cPqBf2tPMWYnmK2+P3EncbtvncWYnlt8utPd3U1ud3bbRNUAAbVzLbbbVk73ve972ZO968kysmD2ZHoBMjVvOc5tNC3r7zypv1IPTfA7QAIYAAW0AAkLbbJOc5zloAgAAACSScaf3p9bb9UmAACaAK07bU1+3d89Se23epqLFvN3d3amtW2221JgAAmu9725MttmS2vJMW17Mjo+CZPPZ1n08afv0m73i4Ixp6PgPh/EFrEn8ee4W9t9Se+Wpu3769t+fy5zznOc94AAAG2nu75Fu85vLb5bxL2/TPfrLfhNAAH65izNaltrJgYzAtqzJbXkmB5Mhabu7u6mqAAJMA1p22pr2222lWS2229mStvu77o8v3z9/AHTYHJJJ9JAIYNOGNMA7bbbbbgAZJySR8gE77JJJYk+c531JySepr6SQaZu6mrbQLUnbbbRNVW222pMDfUnJJ6mpuSDTAE0STnOSJOSSScTU75qrzyW673J3s9DYg8AkkkkJOgAW2kkkkkAAAAkkk5wl19d73bEnznfEmAb1Nbu7sadvqrSxY8SxLMSe2027utq2W0E6rbd3akw3xJkniarQcABNd3GreI22trrWB4ipu26tbW++gezfvfpJPOZzf1OQ7QACSSSQkkkkADkySSSAAAASSSc4SpNp/eX760SZK/3qTtt9TWrd27u7qatJQG15gGpu2iaOgAJMlW+pO231NaZu+Xd3dTUtoAk5JqbAE1f187PwuJJNvuJDrKLrrj7kO1eK4IfOvOu/37565n32tf3iAceoQD3L3b7CAagRIB1kJPIQOu9bmEAWBANv2t5XeYezvefb17z04QCkAZANyAOhTb7LnKfO91WQBSAZ9znvb+IB0nzDvfQM0l79gb+45pKwF6zHaLFjlhIQqQBMknL5732TWayamrr6b59baEAHla98nJNDm7u7vezPNN2+6LzvrTaZjaS7jSLmFbFW00xVkaKrnCXEVxhXGlWptGxbCtlDWTWLY2tlmU2MobQ1DUHC5UOMRomkZDGUNZRtSWxDWMWCstUPdQ57yR3rp7xA5jYRaqs01DUMqHvvOsWwjPK5FfdJfsTvEn3nFTIagTYh5hAKkIe1hDAAh73vX777vTfeqAR7pB98PAALbbbaALbbbaAOy5MoD6gHj6ZnPvvueioAHltvltoAMAPQ8AOfffPO974ABO/ZO+70wqLJArQQqpKsY8aKCMRMAFg2UFApYpRb3DIwRwrCMttlqAlRVZRWStFLBYpbnnnegAZ3Mkm9Tve9791wD4EBA8kwHoh53ved793QB8OW23ltp8Ad73ve964Fyeaeb+X73vcySdmZJrJmd1vfVo9DwW2220AFttttAAttttoD03JhyTNyZuTOSZbbb5b7T56Affd3vve96DJmJk1kzM0ANN6HoeJMkAK0bkwtt+ttBcySJMk0BuRNJRNpPE0ljxY2ksySbkAAA0DcW/W/W0ABbbdZmZMttA1kwAAAAAAAAAAAAAVoA0QCq0AADWTJBzzzzwHhuTBwAAAACz7Jnq853N2qONUNE3DXFTaSNWGJtp8xpJNW037dVhYu48Sf5ccxL9D7y3ve0AAkkkkJQAC2hJJJJDhiTMQAASABPZiT3OrraaXNNte9jV1HgzFCjNTffn+d37S91X77197Sdtvqa1bu27u6mqW0BJkDWnbbua1JNddBZEkvXnkmW2+TIgtomK0CRNXMwDWnbRNVl+855zm4k93m7+PV4K3VxJ/W2W7rSl+x3GnbfhnHJ3xNlbd5q97277b6nQLbZPLl8l+VzwqlsVae5u75Q+vq89S59nfuw+EmT94kwD1NWZbbbU1JoAJMArTttTV7bbbU1UG+pO231Nat3d3d3U1bQASYBqk++++IXtO/dwKaVd5g6/Zuznvcfvc/e9kAA2CBAHko8A82Bbba0zQABwAA7bbymgkjkpxp957znOWxtTmuqZxJ3Li8t8TW+5u77u7upq2gAkwDWnJImp9JJJEYsx5jbM1NLWJTWknMmSe8mtZG5oeB4yS2229kzve9TMttmTuJpLVbSWl1Ymkvde9+bfe9w73UPrRb9Dxbb/A/fp+/fgBbbbbQAAACSSLl59ZJLE1Oya9ScyTUxNCDd3d3U1bQASe2222poAAE1VeXK3JgeSZbbQTILbbZMttttuYpPuHcTSWvvt+b99vt+t70AAMkrTSQAQpJwkkoUkkklCGSSSSQAkk3d3nOctiaknj6aSYaZhjaAAAE0G222truW220TQFttqauW3fUnu7vsye60OAT7IAJMttttsyd7/a8386d+KP6hkFZpRMy2TNZWojazZq2RV9aKLg69ff3zve/d6AADTDqXczH3u+973v1kkEAe9tDYHkktSVtqACSSlabtDbTNoxJJ7vOb3ZE1JJ35JgHqaAgACaBbbbJlttttmS2222zJdW15JgeRoCAAJoCSSRJySSSRNmNrMWNgZZKMEYopD8gfslD9uyQhUkieeNvvfF3ek33O4/O/d78fe68Zm/GnoCemdbSXAAKKSJuCfcxZct9veraTzu7U3bz4BHaXE3fpJ5JJACSZPW6msu/t7tiakk78kwD1NGwAATRJJJIk5bbbbMlttttmS2mvZMDyZHwAaRJJJAWY8xJ5jQAgAEls0k+4m9P3SS0s0mksS880rdy3VO0AAAQGsmA+tvLbaGTCPAelaWgA5C6tdtvZznN773iaFJD5JgHqai3LbbU1WAAJMQAAmtqtttqapw3iTtt9TWqW221NagABJyAAJqppLWa1bbSrLO7A8ACSoDAC8M4AAW2SAAFtpJJJJACSScvLJJLE1znO+pOST1NC2AACaJJJJEnJLbbZkttttsyW2vZMDyZHwBMRJJJIk5JJJIZmLEvNKE8bfc8998+6vs+7u67rneUIAElaSAALEB4kAemNsy2gBAC22xSSSSUCSScTd5Zbb+syW3+a9kwPJkfAEyLbbbZMttttsyW2222ZLbXsmB5Mj4ACaJJJJEnJJJJEn7nM50aaSxJpLFYrP8Q1Dz3x0h4h1933tRztD+8fyHlDmQ67KuUM/d9dDv6m+ez7mvvb6zyEDZvvTQZv7NM/OkO+Lv+2YGEAQgUgCeyYfDQbae193jc5v5eXeyutzsCQ+kkRSKAsGQOUNrKtQ2UMUcmAuUNKLFXLk1MgaLhU65ScKGRWofc5Q1Vqo1DnZRcVcLgLlaFXzt1YllDVFaGuqC8cdUMR1DHuJTqhpR1blD+4JV3kkuqHw8g6O8pd7WMtimVVol0cSrEZQbMtyhuSccE4VsHA9N064oY/cdVDNmaxWLIdEe9Eeah2cy5UMoYMqdzhK4nOcxVirmbE2Yy5qnDT9zqWdRbUK2oZA4VauZsk9Wcrqhzmlmttk2ZlDKMI3XOJZDZsqOqGUfuhTqNb5kuPvE8oar926SfNwV7+3v7lD3Jlveed733p7vj0deEGn2gKAhJgAAFttttBs8Pvbb3322g9Dwkzt5vO973nvVr4A13ve9790GwE6AAAuTHe973m+AAAAKTiX2JNrGsaSM1iWLEk01Jkze95rR4dAB53ved73oAPl3bbbQALbbbaAC222zWrQKzQ873vMzJJ3veguY1k1oBJxJtKZJJAIk1tYzA9AnGlHkklp8OA7l1bbbXtjR4CtAFaADve973vRbu0HfVu7dyZbeXQrQAxbbbbQCA5bbfbIAEaTTMAAnG0m/lixrHmR5J7JBmZJANBu29t+1eZMkoPqBbfD7Q+9+fDgC3dttvw5JkgHwAAAAA5MyQD4ayZIAVqZknNZMk5kyQC9sakx4D1XuTMDwdN5MAHJkyQe++zPffR8ADhuTA8B7A8AHwB97qSeJOfRZp6bek1tN4vFiaaTZAMBiFAJBgwIdpg4fc17vv3T/PaSnDxe6v1LM13YAAEnWmAAWGBpgfu/vwC38FaAAt9upMv7685zdkackn58kwD1NGwAATRJJJJJlttttmS2222zJbbbbZkADJl0g55Jg88kweATJknupln6cc1550+MSYd3PmBoxJgcDV5b7bbfolMBGJMAtnppdLv1J2y29tkklAI0zACSeKYYK65znN948xZmYk8yZJJJ3iMSttt0TRwL1J23xteq5bbbuprQABtVLLy222poSuK222poauK3epMA9TRJJJImp5p+2/a8+8n1l70w+9tAgEkySSah9z3nmuc5wh2tO1N27tvkkkklA4GgAYBnKucafOb5bE1JJJJEnJJJJE1JJJJEnySd+SYHiMTU3Jbu7ra220BNVW222pMAAE0ABzia931pzqvtOXV84AGwJJJNNOSHA30eA9/AL+t+t3b+AC23nmvP3cSe92+pqdAABP7MxoA9APTEnmLMSeYYAAcMSeYsxJ5gAAQxJ5izEnmMAAIYk8xZiTz3QAbCGJPMWY08wA++SYTz3EnmLMSeYHgAAuYk8REI/fffb++++0KERFCP9fvfaPDFNY9e+e/eee+2q6vaAgDhkkkkgEkkkkJQAJbQAOAAAEkkLzXOc5y9FmNrFizG1gAE5FmNrFizEnmKSSSSLWsyamprUmatttKmpNQAsyABMltr2TA8mQAMyBbbZkttttuZO/3NX7vOe+8c8fdW/zwHq2222gSSSSQlkknLL5JJLsAACSSr673vdsTUkkkkTUyTSk74kwPEmfAAGtrbbbbU17bbbakwC22pq2222tOY0piUxyHiTA8bZ8AACa983VnnlPT71pmzpXvdLl8+xJ/Wn30kklBSTGnJJIckodt+SZ22pu3Yd8AAAkknxve97Kk5JJJImpJJJImpJJJImugBMlttfZMHMyAB5NZmtZqazJrQBWpmtABJAC5k5O/0b8ttm6dy/UD0IGmmHgAQ3zyeSSd4YWtO227geAAABbbbba6Bxp1c5znOWxNSSSSRNSSTu0mB4mvcWAAAJqSSSSJOSSSSJqSSSSJqSSG1MHJk8AEyW2223MmvM3JkjMkn9xcoZlDVX9xQ5K1D+7l/f3y5cvdcxdNh8menknQ+RmmmHjLbrk3JNgakTck62ku22973vegAAAEknmlvH1tJdxtJYud3NzvYmpJJJImpJIbUwcmTwATJbbbbZMttttsyW2222ZLba+kwcmQAMyAttmTuVNJe6TSReHE1979759599qXl4fd9AEfAAV22222gB6kwA+AAAAAAAAACSbaczlXLJJSJ9WNZiAABGZgBZkhvNB99Jg5MgANoAJJE1JJJJEnJJJJE1JJJJEz777773Anvewhe9PG0gHiSIBFVTO+yEDjMfxAGATTy2gA6byt2NAxLailSlq367cIAhlsk4klZDt1hAFKiTaaywFnNkA/c0Gt1iqiirIJWoxIB8QBhCGs1LNTS1zIX45vWtd9e/b2Y5JCDhAnX4IwFXeoeZVawCdvOSUZy4JA+yvMlMn2dgQm/4I83vaoSZ3pJI6LRR1573533ePv9yKD7Ytkj+yHMZWqnzSD7Iyj7vsyie1ZCBMQge997untCb57M73Xvb96hOj55415968ae7kx84px65Jg98u5RuTPBxz00bkx8NEdckzdvbXUakwDgXsSZvfmTOc69HXrvkme7l43z7jV7N5M9+193fvvvPddfe1uTDdcHpuTPtGw407uTK48GzcmLb5bq2bkyht8jrkmO+ZNTW2++9ndSZ973oFkzeRmgPJNzGm15iTT3mJpLE2pjT3PYcNtNSY0Dv33LqTNtSZp7wd7QnTzg619q2236o4eDR7yTNcZb5frOn3kmaeHh1Hu5M0Xltt7Jm/tSZq8B1qPNyZ3Rx7fbdyZq7to9XI5Jn3HD28nEmm14sSx456k9SeSE8Pko8bPUn4H3h5N3uT7V8kzd+9vtaNyYB8nl3Jlt9tvU5G5MB1yJdyZbZy8ttHdGz0Me923bb9q7kyvuDwB3njU5L7b72+0eh4DxA9CySSY0Ae+yYHoW7todszJI0BeyZkkurbbTeTJDptqTHXhuTLbOd73tB6BeR4DkzJO/KT4CBe3kmbyZbbfi1veTDgOtSY0ttr5vcmG3oeABsB185kyTw9hp90FgGwg6fDgG5MAd0VrJj333fvvo+gAAQ0HpwfDuzcmHpwnvcmSbf3b5r7m9czWpreuSOfXOfPqidLSHtiXWFe0d8hP1PV55vvFz8znLttJpP3G0l76Yflnd9ovQA+kdAALbJJJJCTnOcsyULbbQAE2ASSb3W03z86Acb73TTJJJJEsttttsyW2222ZLba+kwcmR6AZkW222zIAEyW2222TLbbbYmvfe6gE+9afNn07v5AeNMOHuo6l4ABbRW5bjTttvlvJ7znCS9t2k+pvverve9tAAGAXe9ve92xNSRySSJroDATJbctfZMt3mQfICZPbe9973cqxVZbbu6JoAkiTkkkiaoBbamrzKeeW8urfe2/Ww9CR9A9ALdygAW3VaYSTcp4BbbQAhhoCSbl3d778pne/3JkQ6BMlq3228zJbbbbZktkkkiTkkkkiakkkkiakkhtJgeJo+AABNEkkkjbTS6sSaTaxW/AHpOVSSSdjkkkgEkkkkJJJJJ1tJW2222gAbAAPDdXD6SSxNSSSSSZLbbbbMn8AJkttttsyABMlttttmQAJkttttsjWgD9Il+1EPuhXAyHNST97597EeshtQ2L+0n7daiXz77198k3bLPOdJkkkhFJKHrTC3l3oAALJznOc5ZAAAAACSS/Xe9920+d74mgAzIC22ZLbbbbJlttttmS2222zJbbX2TByZAAzIC20h73ve973vBIfdpv6kASirnpqILN89Dk+Oz2KSSdikkkgEkkkkJJibkkkCHWmlbb7cSaVtvqbSt1S5fUkmgDfGn3inQDvYmpJJJIk5JJJImpbbbbM7qS7tttsyABMl1ba9kwckx6ATIttttky22225k6/a71r3xP7Vls9aftvfZJO+tMJ5zi5znCEoGmmBtBZBASSyeyd600rdJPdtvd97balbbGne5iaSuaAJ04mrJIHEmHGvbltt3dTW22W2pO20ATVatt9ttTXnqQHgCau23bampJqTLEnd7vra88NgAJru6tzDX32t43mJJZv5p+0vPNc/f34dv8FtoHt8tt8tpkwtt7dWdTaRbbbzuYmku6T73ve9200u96etNIDnt3ve7eNoTzJJJJE1GvskkkianZLfYk7eNrzW3cuXd3dTUtpbak7baAmqrbbbW1J3fUnJy4mrnbbbRNaW4kl9i8vt2g+6SSdAOgAAWSSSSEkk02pJALE3b5cSaVtvqtpgHgmS++fl8HpP34bXrWSeaAJqq0AE1JWmGxt28bVvQC1PLQC1tbbbaJrVbbbamjA4G+NO3jTttttqa8zzPNu97vnv2/t84vN61mLGjYSdPbJPVJO9QAAFkUkkkJOc59zmiQrTStttttrTS4HN9bbTtt3rU5O9++E0Bbbak7bbbaslttttmS223+7JhuTAAmRoNtE1bbbbUnbbbbU1bbbbU1+J4fc/UkpAN/jzzPxhAMurZjZjkxkAoqQir5wYTBIAms9v9r9vnZJI2kAV3m8ojv9wIBrQUgC1kAqm/YXOZtO2637XNwgb39vq5mw1uG8ufZelu6FNxfZSAIO/th9s5brtKQDdHPj7RAHm7hAOb3vR8WC1v77uc3r+1/b+53W8/taeBrZJet10SdWK1qhk22aLWe4uKTUMhpRsndDMleyx9c6odEL364cdLzpVPbjgqdQmKrZtRMnzkciMbINkjKMwTCZqraFiNQxpRiO6GE5M1DNW0jYmxsk2qGqpc5csQ7RyoeZR1hGNpDNolqHzIcoYj+0cxqHhwPmourKtFGk2qHMScLT9qHJoqZm1SMhlWWobG02ttmoafeft0qstmrbWgto2Zi2JerLmtlmRXvFD916I3Mjp853qV8735rMHzJnu7e9770AGua6c4OvhznOAd7bbbXQBbq222qt8c4HTzQPgeh4+99999FAFaltttpoeBXwC0A+N3ltt9gAAAAJuSKY228xppPMbfmPWJL3dt8qgBXltvlva+NyY0Di23220HAPrQbHTx0u33FFafB4UDa2y362hogJ23JktttDAF7dW22gA59bu322gA+9t5fLbQAIyYyYyYyYyYyZ5PPNyZ554C/AA73ne9750Nm5MB6ebt3Jlvtvt+0PAOAfAAN9Nh23MknZM1d223h5MyTzJknAq2t5MkW2362UABbbbLa0AUbt7dW/WjmTJAPhyZ26tvtteh4HwAtoABbq222q1JknMmSPhx8r1B4AAAxjLbbbaHMmSAfAAAADxu6ZMdman0zNzWZg1DZqG1FkNFtRMhieYmk1mLHiYdP2k49l/JJenEsJp9+Z39lt/gTMAAttttW222gAB1W3vuYmku22hFMxNJB5u85viS5nEn3S742tY8xsD0ABtASSSJqSSSSJOSSSSJqSSSSJqSSTaMTYaTXABmW222kyAFmTvmr+s83qTWe5lTdWt63d+tO1dq9HgB80wA6t22+NO22m6FadttvOSScmKWQAAO29SfetPvdd7QkaZvvOc4SJqSSTvEmYYsg+AmQW22yZbbbbZkttttsyW22uyYbmQfATILbbc/w1kgAETWY0mlO/LFjxfT7u9+iM+5+bFOshzk74SSSAHgfSTySSNME3JJIpOtNIttttoSSc5znvU0l2NPPLJJ3sTUklv7smG5keAEyLltttky3LbbbMlstttsydttrsmG5kR6AmS970ASYAAJrvF1/ms1dzEsbePb8m9++VPe9ItSEyBypgAAUJKABTnOc5yyVGJMqtt9Ttp6mmkYwBIA85N895zlsSXIpJO8SYeeN4SSSRNCkkkkUzttttsyW2222ZLbbXZMNzJwDd1NW220bVy222iamNsU8XTq/eTudk8999Vl/caZJ5Mnx9tlvLlt3dpbbbpZJJAlVttttoAEkm7u85zl4muc5znP7smXWZP7QBcyUC/SzJby2hMW7bSGJrVltttG0AACaAALUnbbbbU1nshMfnvnf2/pUfXoYkwAtPvgD8W222r3ve96tQW2239kyQtAKHPOc5yxNc5znOd4k5iTEAAA2rbbQaQABt3E983d3dqToAFqayySSRNckkkkTQSSSRNGeZcTSWhLVX02j3M3rOFvrT7NcOTkadA79b6k8tvzTtsR9JBpgB9Oc5znCVppFtoBAxppB29+SfbbfWkZ3e97sSfcTUkm5JJktt737rcyABMgBcyd73ve97GrbbbamrbbbamgAI2jAAImrk/Z7L1c5PE0lsh1fliPu/fd2y3kKfrb+/fW22W6CSSSSNMJjTkkikrTSmNNL7777d3dofW22/nJJJ+TUkkgJP9ia5bbaNqSSSJqSSSiTAABNAAA0sAALjWAAWpoAAtST7+WZ7PlFPtzvZ+97vxk+Lv7d3d3d+3aABoABbdqbSuaadvhiTSLb600qW+tNKy2/NNL7P2Ymkv37ueYHp2T9W1baAJoAAEmAACaAABNAAFqbV5bbbU1QABJgAAmgAATQKeIxtJRe53nve/JPUvlniRjE36fv37m4r36fgRl2+2yeyAByZJJznOc5zkkCtNK0PWmkACbC0YB600om9dJ0DnZUklJJ9JI2rbQBNAAAkwAATQAAJoAAE1bbbbU0AACattttqannnofc6nO/lkDv7MkAyQB6c/iAZOp77WZ3e293rl1vVzia5cOa/ud9mnU+iJ99e+3c3v3edclaqPP2cKPiLpiOrQxda2JcQ20cJzNorkjG1wGCStI2hWKjG2SAWSKBAYKZDUjYHdcVqGjh7yuCzbaq0m7NPDprpwrjOUjVStQ8/OnNdFqGMKfddegXYOHWoddUPeu1DupXcjt1EuCMj3l2R1UGiaRvMn7lD94/dIPaI6I2Z66I6odBWyjrEc+8KHEn106R1uvKHhfsedSvNQ5RcmaZrU1JwfeTUmNd753vft9gHTW6Hz1fHgAurbLbe+wPPQ8W2220eeh5693bu+W32ha3s27kznvnvPToAPZPHtvt+9vlo9AttttoAT777753uwAHe9meanh55JMHne9ABOTve9873vgPQPbdyZdW20AH2d13ve96AegC20D4cb+Xdt+toJ9oeFvcySzMkmpmTWrbaLjQO9ne973oAHZLq222rPWx6EzMsTTcmAEuobkwBky973ve9oA9DzJi3y23y0ACPJMkvuZLb75bQAAAAAATJkwAABxbb7bdzMkvhuTBzrrjXG5MW8t5b5buTDrxyTJAPrQDpuTJAHTdttv1vIBett5MkFt+ttoAC2222hqbyZI8rQ97VaAAAH2Z999999GpMA3kyQodNTeJpSSSb5I2YAAERhPZJItYo0/tZm23znPhVqT0I984Wmiro4VKxejCBp2sgG4hA+99neb+895++/Ej41mNdND9v479AD9ttttu7u7bbfaHN9kk2AASStvttt+3mJpK97bb0Qie3qtvj/Y3uNpZiWY8WJO8tttqaoAAkwAATQAAJoAAtTatvtttTVtABJgAAmgAATXz8RiXM4heqzw540/37g258betO37wArTtu73dvGnbVa+vl9l19q3fAAAF/j+kz99c/XnOBP26m1bbbbU1bbbRtAAAkwAATQAAJoAAtTavLbbamqAAJTGzkkkbQTv6+d6/Fne6Y28SxJNL3unrlL9O85vlnObKn0ACmS20AAbUlNNM+QAitNKW33uYmkrbfmml39z9iTS/fv33327tmz6SfRNSSSUTQeAH6ptXltttQsWZaARGLMWYsypW8ttLizFmLMUSy3xW22rMWLEsUSVvFbbVVjWLHaAA08M4s5xrOFadttTU5xOYm0n330b+xN7in1+2/u35pgfrb+oB3vVAPJMLfLbbbb+mNbyYOQ3+/fefb3d3z79mJpL777vqn7ySfq2gAASfQABNSAAJroAFqbRwAtqa5QAG1JJAEmAEiaEAAJqo5zky31DdOt82DFFWesDjAze/e/fk+5zn7vO/3771SSeyAcAADnJJJJJJK22mAW22gVppW20aedbpOc33lTa5rnOc5xNc3JJEnJ8ACaACRNAAFqbRwDgCaPZJQSYASJqSSSJrnvFnPv3v279fnkmfv39/LattoABbbb3q2220AEBwDrTSuNtLuYmktdxJ973ve9779ne97fvzTVtvbb4qnbbbRNABbamrbaAkwAATQAAJoAAE1bbbbW0AAWtteLRev1bi+93bv6tM+57n5bumzbTA8ckkGmAelaoetMhh7rmKySfSSSSSUAAAD0zudSeZpLWc5znOxtUAAbQAAJoAAEmAACaAABNAAFqbVt9ttqatoAJMAA4mu817nMxLzz0uK953uTpOAQAklAANgjztoAHOWTxpySTPpJJOUAtxJpW222/P77776ia4uc5znOxNqSeySRNRZaARpSSSRXMxYsQAEYsWZbbbS4ABVQALcRhgBetPDwb5zd93dn7+tt7dW20gB6AL3q3ltp8GmmAHwaDqttt6u9Wt73ve+73ve97q5znAJJJJBGIALEnltttkkklQABJJJAtttsrT+nTdF76177zofTvfv2b+8tv6Zj0PAQAC222yZbscA9ADQABwAArTSto0/lzs85zneb3FJN9wAAUkkne973tkkkgABZJJIIAAkgAHnvf37297vviaS97znvgfr591Jpew01tJAmks577y8zsLu6bzk6k0r1epYlzOfCb8Pfeb8yZ8Xkt1V6mkq2kueTuu+7qFSuhL9Zt4/G/vkgGZkPtb/u/e9vkD0APQ2Bv3zN5vfu9/AaA+M3fLbd2a/v7a7Lz9H4jsjEcpU2EaI5ybY2yMhqG0jTMmUViKjGsqCwWDIAwgLIOc5pGlaVMho2G12dquNKZQM3UjipspWz50RcyV27PfnLyh5zGxGsiHIc4sktEbWVwt5ao5v3aR+x2HvXS8Lmft0qfGoJ+z3tJyVm543klzzuskz7h7tNMkne98737t2bBA15bb57a4AW2220AAAHgPeWW2+20OAfWZn3dd73s6psB0yZ3ve973obAHbq27tHpsE73ve970AB337MjUus5qc9yaGDqiGWlZUOGjCmMMLQVHJN61mc5NZvlvv3QANattttoAFttttAC973ve9UAFtqA9ADeTFtt+t5R7LqN9PSFyTJjQBckkmNAebkzve+d67dvAeh5mYD0PAehbbbbemwB7yTO+SZ5JiTHjoAAB932TPt87zzvegAPG9ER8FjzezcmDp8AAAABmZJAAAAAbyZIA6ayZIFFQKAAttttoAGsmSLbbe2gAN222/WgbyZIAA9NyYXgALbbbaAGpvNB99JmTPfffR0mZIAC22ySAcDTTDRpppAE+Te9+74vUn405vkvb41lG1mqNQ+0NQ4aK5DiUcorEvbih79708V8xpT7TZjmNK4zGk7iTfMa88+85zy8u5PfLbfbb+ttttotttnerbbQAAGGJMAA++++++5U0urGlJJJOKZmJS220arWZidtttGq1ltttHcdttdo2gAQckkkikkkqqdtttuGNLNimc95vu2n2a6gAOtO2+DAD5pgQ+0AL1pgfH0nskoW222hbb5aXLbbT79ONM4E/SSSgAAHAA6HAA6HAA6HAA6HJJPZOQA76F8SfuJ23tlutd3ma1Q5uTJ7O20gASUAABAAT2222ltHAPgADv33333zf9OgAOSSQUxfgAqDEnxtW3ttoEk777e94GAdDve96QM8wxAHtxJn5Z++98+ttO2ySSSQkkkkgASSc5zh405JDZu+7u7vd3d3d3d3dPwAH34kkg1MkkhE8OAB1OZJJISSSxJldttoABVAAJJJII4Q57xee9+kktv79u2222wkkoAW22SSJOTUh56AfGwNGJM3d3Zurd3d3dPiST7tUk8kEjH6AH4TZbbbZJJKpU2HAPJkkkEAATve9+3xZznOfc5PGniaS8WWAC4d7sDw0AAckkkkgASSc5zhJ0LbbdWgBwAN3d22AH6/fi20OySSCAAO973vQWAAd73vexQbZ4YBfUnS220gAWLEnexF35baTuJO59JPJAxJhoAPTDEmB4AeTEnJPOc4STpbbbbQttttt+3dv7f222/vlJIBJJ3sFgAHe973ve973ujTAAJQAqAAJJJId9zzOeJ1tGUNqgtQ0Af5qlcoYhVmQpYq1A0VaDzNpJGzmB3ve9IABOtttrtttttMALe3ve9UODwHoABf2Zn9MwBZAGRGEkBkAYQn8+973vfuc5znJAADRJ2222gAFQABJJJBAAEkkkEmYgALz6rMPOJNNetpLEnqGMoZH+aVyhpVNQwrpt6xtJYnd2y3vejTAAAJJJJIBb+yZhbb+LfwAAAL+kbX62238AAFAABAAEkkkAA6HAAAAAJJJIIAAJ3jTShxtJ/nvPe9572fqGVQ0rEWy1DSJosLBqP8wnKGJqGDUMkyG2JqGGoZNNt42ksTS3jSe97tO97ZJJJK2igAElAAkiTk1JPJ80wKm0lu7tttoAEkkk5W211tJY200lJJJd73ve4AAQAAKAAAAAAAAAAAAAAAAk0v37ic931rzzmc3eZfeppLNy5e0gGOeH775+efc6QBS/azTDdJM7yVe7boG/S/lff50LYURL3834+otpie/H+Yv7vUzOuLCsizMqtJP9XCD3vmQ/0/EPaHTOvnPyHzIb4huIdfEOu0N53u/3OdIfdwhsgEyLwgGskAWE+aknLskTsJp6Q67Q3fxDdodcQ55zrdodoXfMIBkgDm3JS2QDCAIkAzMhB8+ocxXO+udlcK52lzO++++ahhAHZAM4QBzV9kkDN2ECmwkvaVIB8kl6QD7Te70YbutXNa30hOb3q5v70RxD9lfqHXFc5xD79Q4h11uIbpDfHEO/EOfvEPOc9Q3NdkA+2JfsMRUUUgHCAX2TJANM6cIBebXeZMV4aw93kgHukAvCAc0QDvPdsDrL9IBwgHt5vffikA34gG7hAOZvPu6kA1h8UgGfXXfn7fu5czbteXmu2c9ve7fX7xANSAYoBH4gD96h70h2psyG/IfOkPnvaHC7zxDPFc4hz5Q54h1kNziAYkA4kAzXPuyH3N0CPPEA89vJA74h5u0OXTfEP2VtcQ/fkPKmkpE0lPYscBedXpOEXvJt3h3nmtvqh+/dKHr4hvqGyHXaG+Ib1DxDnaHPOr358Q++0PKh19Q6Q66xHEPfn72r1D38hvUPcIApAHpANUgDTwu9+0a3anwlF8cy65zXBUVUUVO185xFIBtIb94L7zj8h3xDfPirmarecV33kN87Q74hufPfhXt1+Q/VXmPfpAO679qnnj1NteC6s1zM1e65Ta85UR59hrd1bj83msTPvs7vbCPLoYie7mLNmx7p13MX7Rw6N3rWFTHzmXrmb7r7l28+KFd71k9q/DUU3vX2tvXf1WV4nXmrcptJJCB/owJIQm2KLp69e365D5WvVa8t876azb9yzi77zv2/urxxp2rTbes25vMq4/ZCB/O+ePk+3312mmuPX7/NYfd/sbIB8SOL1uyAfY2mm73SAc1n9zhjwVV+tY/akmzp1K7IBzey7W/2iS+da7vtfqa74gGbV2QBqvM3r2U2vrXmvaN6ovssU+eL9vOvyun5VetfsvkV1zNW22220X63Lbancd666fc+yu2vOty3T3sgHCAPiAc2QDaQ9Q9+/EPKHztDr4hvh53557+8/d9678eTV333j59u95Xzfrev1rblzMsHMK64Ae1mGuV8nSnvZN84919vYbyQDrly+5gzUzvTjd6Be3fcIBeNd5v31FneFMzna7K83rgm66ze+kl7oDgzzo199934gDogHAOsOPzvT/Pc0+/3/X+u1XN/znQkzeLc809tf4z753dv1V7bl93X2ZneTjeb2aRd3969kA+51wpTTvd28Pu9mST7npAN3fQ28tXenYz2Y4dze7Spx9rph1gdIunSHye9ZJ9bOq81n1v3xAPZxOM26dLtqczXdG+g65ms9oz2/YPdezxAOHuc1m3N4dzdSb2cgaUHFf7sgGZfc0rcObmnVzF81+eb06pqZf7ev5UqpN+7cnUz1riueIBTju6z4gH2+8IHSHh7iGfUOcQ3nSHXSHrnEObr1DziHXaGyHXEN74h4rriG8856h9K589Q54LnXSvch52hxkPUPKHXqHXxDr4aSzOc9X0/j9v0X6/4z/39s/j9f+/3/f/Xn7r//Nnnk7+i/j/ZigrJMprIYgYCGAAACNwCgCIAgABVUGJ5EQACoSSEaNNqPTSBSqmmEwINMHfhIpIsnti9NEikiwpCQhArjFOhyCXNTBXcmT0nbeR+LuSKcKEhpBDkAgA=="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })
    with open(filename, 'w') as file:
        file.write(j)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        load_snapshot(snapshot)
    else:
        bootstrap(stdlib)
        home = expanduser("~")

        try:
            src = home + "/.parable/on_startup.p"
            if os.path.exists(src):
                load_file(src)
            elif os.path.exists("on_startup.p"):
                load_file("on_startup.p")
        except:
            pass

    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)
    else:
        print('Initialized using embedded snapshot')
        bootstrap(stdlib)

        home = expanduser("~")

        try:
            src = home + "/.parable/on_startup.p"
            if os.path.exists(src):
                print('Loading on_startup.p...')
                load_file(src)
            elif os.path.exists("on_startup.p"):
                print('Loading on_startup.p...')
                load_file("on_startup.p")
        except:
            pass

        print('------------------------------------------------')


    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
