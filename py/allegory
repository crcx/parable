#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        tos = stack_value_for(i)
        type = stack_type_for(i)
        if type == TYPE_NUMBER:
            r.append(format_item('#', tos))
        elif type == TYPE_BYTECODE:
            r.append(format_item('`', tos))
        elif type == TYPE_CHARACTER:
            r.append(format_item('$', chr(tos)))
        elif type == TYPE_STRING:
            r.append(format_item('\'', slice_to_string(tos) + '\''))
        elif type == TYPE_POINTER:
            r.append(format_item('&', tos))
        elif type == TYPE_FUNCALL:
            r.append(format_item('|', tos))
        elif type == TYPE_REMARK:
            r.append(format_item('"', slice_to_string(tos) + '"'))
        elif type == TYPE_FLAG:
            if tos == -1:
                r.append(format_item("", "true"))
            elif tos == 0:
                r.append(format_item("", "false"))
            else:
                r.append(format_item("", "malformed flag"))
        else:
            r.append(format_item("", "unmatched type on the stack"))
        sys.stdout.write("\n")
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "QlpoOTFBWSZTWVByHp4G3cZfgGAAUAd/8AABAAquZ5w4YWy70AB9AKhl4uQCutZWAYHEGdpxau5zq7mBoORzpbFo61xcWdrjJQluXDoAe8wJE9gehyAZOFyaOqlJkHJuYOJs7mbWbVm2ACgUAAAGgAAA0AAAKAAAAAAAUCkAAShQooCgtIsEAAAAAAgUAFM0YAMm5UGdrFCk1YAABoNoMBOzB1ahQVMMBoChLTMY1QAACzAABsDo21xk7rtG5sB22pq9bLlxu9CoQ8gghewNADe5vByYS2BiAUaCRoNjDQoBQCzANAHddUm2sbu4SIqV256ABaCAQ7zuedWNT07yN7048oSKFJARCiN6OdCUgIqioQilCixTMgBoTqsA9aV4wMAAY9ztAAHLi2Z6ABz3jgABmrPgfffPrw0feL4pin1rmYuAAN3xtgoO9jbYdU1fAPc71vB0vPPXh6OEA9jAPYx6DOMAxtTmziAQgO+PiXj60DQBFrezK7em7DTXwCawD43NLgbjAPZzvINxgEzDtnMwDCA7uTcC+PgbT7FfZoAAYue3TS3u6dDr3Y+AbJlB9x3ALGHoY7Ad9LzzwfT53o4BZYBYwCEA+fBC7a+EpW+8AAi9ZOm7Hdg9sPgPsMA7GdBjsAssAxA6xzAM2Ac51wHYc4H30+l90rtvoAA427suiy2k0Ou9j3wDMwDEA2MDn33j7z4Lc9vALlgFiwCxgGyw80fXwTb7DjsxuAAPQUK2yh5mT4DMYBjYBjYBhAQj6HcMA2MA2THR93lwD3nzL7bc33ZegADkAU9NDrRfAMbnUZxAkBECIFAIgkBIHvoL5Xte1vWgAIsgaaaVyDBECIEQhAiCIO4bq2C85wM4biB568AUqpBQUQAFAAAggyST2m2pVSkhgATJiYhCY96qUqoNDIDQNAJEBNSVU8kJoyDBPIKf6qU3lG9KqpNABoyAAhSiehlSpTQGgaAAKUiBqSlUMAAmAf3+779/d/H8/0u7u7/v0R/KEJJIAEj/BiSQhDSiIoRB/6D/J//f5vOf3391dwf5f5IqoaoEAfztH9H5oQBDCcgge1B/RggDHkDmL42tKmdmthrlpsGP0XsenZgnYQgCZvPVF9cVbz091qXntEkKxUefSRlS+9bEkJjmcu5ednOsIYQAgGNA+mUQ0AQOu6Zu49Ny5xJJag83vcJLzqeztlzm5luotbEiADoIGseQ5xW57cy7IuzQQBsAgC4kzJlTlSzxdXXrzXt5bjx0ThsSsi4z1iPWQHY/PpoJABnZ7xDjPXvdETkbUNzd1MVLdRDbb72ZrJ3T3obh+mG3MQ3sQ2223Dhv3vX2ero3Zzcl9sxG1TcdubGxDbcy222+3LnvNjbze8N6b55Bsw2X6N5jr0xl1HbePM2L896ai6zJmvPt9mTzi56Y5kDbqPeutuB06pkGxQuZn3PX322N+EHOtalCS2gAI0EAcJAqwrd2b5z6oKMEkKQQBfEAgDxtqfRCcXMj8zcce26iCiGm2eBAEQ24hnRQz1+kEAbMNc1ZzXpMlPnClthbVO23UG2L1hQ0nMIqSCQ94uHdPYyfe0IPC8YPPHSQoZpdvsi4fQedDJFGC9cTMzNCmJ9Xr9hOMmfS9kjakyqp1LqPVU1u+6fY3L3NJmOdG9UXyvJmoy3VVD24Xe2vBjQ2sTYXrH3mdkGyD7yQZ67wjnZK3jwEAPb2uZHgSSjQEKW7kEAVlmZ2aUNKHW8yzjYjXzFDzz57ih155qlXW8ZmYzvVIaqHW6p7u27e47szfipk3d6XFVNzuoeKrrah8w8SaVMSYIxme4SB09WOWURRWYdXV+x11kFPRNYDH4gxywICIM/D0vQdEZBfqIGZo123dKG0m1Dah1mRGVVXVcrlVVVW8/wrefTjqveAOmQGQHTg0BGAAAOZHwQAAAfXV1VdxUxd3VVi6uqrGtSGhDWuWRPcvMkOtSHjwEGUkhECQFj3bQ0c4YpsgcWSNTUsqB3R7KmxxDQIPMlJCJEI1JAd3mHSR5UO7Xh11JNbUPFDfnfcvknzv1JruQ17rHTzVQ2bYKGqJZ3WZMz5Q7K3kxKts1jGSGjcTOwjbfS7s3yxuBdMKHmpTZpvzefZph1lYk7qrUh1IZnSh7rSVjJ3iB0+KHW+mUhl2kPJDXfPlQ88u1QxFZeFDz4R1rU3MVkICxCIpPqkJSyp2jWphmuGiWK4IeWZlNqGkhpQwR5M81ihKIEKBVnfYYiBCITDWgFWj3zo+79w2zYjrQWpDIRuBGVQNPWuJs8sCXIRaiCE2NCF4UOt6xraVNyGM9tVDp5hL7fe+vvPURel/EUwEyLQhEBETFUYAh4P4+ygxVJECRSJEMqi52kNRG8YzNXlQ6U0qU7AFtMnSqvfqqfa6HUFFfru5ivKWaRbr0KcZWttICE2Pa9dGMGwDEYxMaUtWMGyPXTUQQyKkkwkW1sAg2hDoB1BKUDGzHjSqcJEOoWMtgsaSIdlQ2gVCkdFmWQ6guYkqIlKcMG206IgcDQWUpjsCWA0wlohMG7l4UMj0Gs9D1zkVUOpiKrJTYZpfZnl4Vzbx5ExJKtg4dvxBJKIabjwiBVUJQWXA2Q4G9cTECSLEI2kqMkZZjLqU3XShiTwoYSdqH1IdKG6pvvnWb0701d81vetZ5j7rTvWupKfSHgrtIb6yFhTyQ1IeSHshuQ7kNdb6YyQyQym/dWdshWqVvmqhsdZpou6hvGid7+UOl30UPru7rerq6qs6q6rFTLc32EYAOmQHBoDYfA+BsAA0BJi6tVySSOwAF1zFfXWrzqKr7u6kdtbkPMpNd990N4JrOt9SGNSG/pDp5IakNKrfUh3ncl0Red7zah3akN6UNyGRG8e5uQyQ3IfSGVHv3e87tIeKmlQ+kOtdSGPNcVN6SQVFkhCk5sZriBICsiAxm49mHVTWnt0vCYglwXJrp6Q7cpIGJATM+SCHRVQiHn5U0n5bFoRCJBZiRmSzImY6EdJDanMo7RSEFLsoUCRAnEzJ+sCoWeoKerqywslpxgzMEkCMgLzVXdVWqurrFXdVWe8z9vnBzA+AACrvNgOgAUAGgOAAM7D46AB36u3V1VYq7qjEQOjJEDrBcmAkfXtvAqLSQ1UPLuobb73MwR1ua14dSRgT2aBSEGkVSJNASi9SmMzIjcprRsLFkhlKtKDQgGChYhAMSA8hdc7W53u7u7u7ucGgODQAAdMgMxgHQAJdWwAABMy7u6zmQXJzQKYdWXUqB+X67jBVlEjMEClWhpKAAKQPn0UD488kOzrDzGGbTvU8bqrtbqGY7VAuiiIMzJg6gx6jrrKnMrEyZqpWqVWpDShkhihjzsSAkUSkkDc0kkqS3rjs93vd3ufd3dwAVL++++bAAAAAq71oDvQAIwAZq6uqrV1d3hJkhnJDVK0oZYzLNKGzXenu26Q21W6m8dE5bUM3SaKNCOtO0WeqHUTuzCSbkMgt3jrah6dSHJDUhmmlE8VWFMz3Xecx3kofZEa6nAsPWSHmz11nShueOVU7aUEeggkOmynESSomoggcQDCNUSKJNNat5vrN70SdJViouX1rJpMwoZekmKyt6t53ktsbzrXNusHdQ66nOkh6Ze8Y6UNSGorJDkrMjzJVx73tboveJDGZKvZDVU8VNzzhQ4qdd4ZKJaL089liamEpU/dvnSgeX5QcZgUA80ECmQoGarx0dXVnxjDDzXRVvheeslDp78zqqW8M2ZUMUMsyoYodZ1tosbKYiTS2Qta66xoodPc6diNTJma7udnTIDoAHcmgQAHc3VmgQAAAd+NDh3d3d3d3CQFIQHrI3yE6AQe9TbbeM/fffZq7u+XVs/b53nQAAAxGAIAAAAAAA7ru7u+7u7iy8peNQkeAJaEJECBOQ+uqh5C3zChm8VVtQ97vvsb+nO9iUwAABLq2ADTndY3UY7pU3vk3EABOMnwAA3dXoNnQAOqqsVd1WLurqsVizvHU0ofYodyTpu2obdbNNoENa5tIQxeunKmdZTJoY4lNMAUzum7O0rFDT3qQ7XeKjWGpDKoawVrIm5iLvbvdoVqqumNinmCq73SPG+6JmXUgSiFAZZmKgYT2kQoEaETHSh075h1gjPCE13UNCjxAJiSEoEIjJsON1TrKzC02XENKGWsZrGm2UhiQ0oY7UnvVVm6xWququ83VXd6rutRERgAjABGACMAHwNgAGsAdAAABWru7qrmM4r627qptEt7ea4alMSh31KHmRWAMKBCgXUGRQ4KkqBiKUIjIgR+9x7KPXVBigjpkDuVAyU/Sdp0Yh2R2wZKUhk4Ch2EXWN2zx6oe9VK89b8UOnV3VXeKq7quczt3qAAjAAAd73ve96AAAGaAdMUHd3e5d3d3d3dpSbaSAaEBECQDQlfOZm807IPkl6QdkHnveyApCxAJQ7gyZ9GdGXEe4EAeNBAFfVVHSCugQ978BVlh0KBgVJEFC0ZCeSF110qhIgWAJUqB8/hTR+/QzTdY4iBV+FQsKLAjKiruqmMzvVoxnShnVU1128ZW6htJredKHcySd4mCQNBogmKsBQMRQnzFwUB7QQxwXWL1dBURjilKpQUMkMZioayQ0qZUMCNIhYD+kBh7IKYRV6Tpqi1Pfedd0ViUSdTURFPXUlOVMEydA45L1HTKtrrDvMIsjvqcmYxXMeswpozGAswnozoFTxJVsHuTWdJWonSh117p0673HeFpQzUoeyHaQ6kNZqe+BGldAKz9E34UC7FAxUCSWTICBAvJgkBKEgny2Mz297u7u7u7u9TAAAGw+B8DYaA4MgOmACKADtV9iru6vG4Qkrkh23ENotlwhATLaTqEKWgmdK1mlKa0IPeVR2odZzrWLsoY5ihpQ+dJJulOSrSQeyh113TfX0hvVQ6RXdU6uY5ujRqQ6tMsWTtjMzOlTd3RCIRI6AKkVHAcA7mRgpn0T3ImnWKjo71C538UMxQ+7eTL5ifYoeDsodSGSHYj5Q7pSu6zJQ3M+NNrZ1u+YoZSHfeUTES7qmup7iT1rUsylWlDUq9yQ1IZnN5IdbqrPinzVFYUORvETcT3dyWj3HYZIe5leTM01IehfTmZM7yQ6UMdHjE2Zyod4qHtQy60k10crGdNada1VYZPcE3ih0oYoYoY7BqqSVKmmmkur9PT2ZJk/+SSSSac0AD3BoDYfA+BsNAcGQHTABFSvvvvtVV1cqVimKurrOazeaqGCRsnuhHahtrtqZkq8EeVrGKrqle+dSfIrtdt4ofNbqMy717vIRjLM23jLt3qxBnNteZPNlDbSocqGuuiTOmppr5Jih7kh1IZnX3gWOlDZplvvW963mXTUdqGlDoodOuYtX1Urfd7c7EYAOmQHBoDYfA+BsNAcGQHTAc5zn3HOc5znOc5t5tIe7UMkMkMkOaHeMkMKN5IdakMkO7chtUNE4oZVq3rjLZJVdredfOIjAB0yA4NAbD4HwNhoDgyA6YAJx3d3d3d3q8kAKk02hJCPGwLlEhAqGV2FuaCMWXeGyhhWq77zWMxkoZIb5b6Yb7qmXahsxkpvCpvShue1VvkqW8hR9vp7dBe6SeGrp1CNS3KGpDUVaskLLvrKPVTNQl6EaPuwDxJmTCRih5iTEELp6TpTqCZIiJGkUCSm5DKTUh7HlYFXjEW5KdWsawyiZiJZKdSGtZKYM1gTzKTahkSHV48Ot8qnPJ5n1Twk8MqTZUO3Nfe+8++5GADpkBwaA2Hyt73vew0BwZAdMAEUACVW0hkg6kMUNymBLGXXTXW5DXWInmwOm+0mrSDkyIa4lGsyQy67xkjLp471vMZpmJNdSG5DMqHa2b3o1lmGKGZIZNSGXchqoarWm2zUhjrWVihXmm8eMmnVIzp1RW/NqHd2k6tG1DFW1DAyQzyQw1jrDqnWCNLXZLUj8KuhM05EnRZYdDgSB+lKOkFmqkQNJKC9mg1jZPQZ31WYBroRihnbcsO2wsiaMUMDUh3tqEZ10bibZmb1eu9HT1+TCxvCC2xtJ44dqmpsUzZ6Ly4hxAocwGTRFRLCKIbZJkW6YyVFVky4gxqVUKMuCYGQC6L9GMzTHLG7gBJac3dRLVISNwgSQ9cBNDbZEiQEiJpAa1IZkhkpZmbTeOzTJX2vo52IwAdMgODQGw+B8DYaA4MgOmACK5znOc5znPXffchuQ+qmtWlSzxUyi9KalNKHfTre8Zm9Pc1nWsVEVLpCAsmxw5vC6lzkQSEyY6SQSiHkh5Kb6kM85r191pmRGs7M2RqteSHshvxiK95rWGedd726axmZjrT3chpQzahvXch1rNbO0+CkqGYglyMMlQgEisFGTIrFDMkMlWeffJ71ZijEVHQZOM6IUDGT899dBhZCi4obUMlvUhqQ6pOlDerPUEOwkUvu5qP2OedVmRTYRidJ1gd94p1g2MIlXw5ioEqBOn8Nj3Ch0eVToO7BmQxmYzIplaF7BP0Io1Sov46QTEQKHvHNdMw5a6w6PcHOhQIAWRGtNeOhG3z1UN1jKU66tCMNk8SGakNy1xCxQ66c17twjFEhA1qjpblk1EN2oI25qqupe5EuCCHUkqWgykDlVV1VXeg4CyxlqHDpmtKG5TpQ7kO3Sh1IalOalNazW2ZrrW0hpVTtQ6KHOkh97IZIeyHdQzPNa837nOlQ98t2FxQzFDK+yKcDNvOUW+8pDozO1DFDJDjzXvHZEYAOmQHBoDYfA+BsNAcGQHTABFA5znObefIryU+kO99d0rvvJDnsh1IddqHch1Ib8kO9vOt5rBIDJgsv2yqiFCuJZLcAIxCAaEB6gPwqBKgZSISrSLEVSKVKgSqSiBNUPZCgSfDz6zFQ9u6dPX0odttXWVFmV6qPvTQWWt6swRqU9dZSmYXbtQ79kMx8I2oYocakMBPmIniThRwu/pmZlI6375EeJ1gzrxhQ6a4dacqG9Kqq+q7qqXXeufd4GADpkBwaA2HwPgbDQHBkB0wARQAXd1Vdv66vFXd1VSqqpmrh31qzK1kwLSoeqHmo6Mt6xBngW8SDyNSHZmM8e/PPPFUQmj8YoYCMCBKJMR9I4Zrc+650jAB0yA4NAbD4HwNhoDgyA6YAIru7u7u7p86YS0QAg8kgG0kgPJWOezoyRqW1K+7iNvJDGYZUh4Xt0g3Id1TMxU49697+8+IwAdMgODQGw+B8St77vbicGQHTABFAB3cd+L2ZoEhXFuvDhgkKoqIzW1oIAcQ7IOKPSDnW8sxhkqsYqEkmENsTTWMBJQej3dnd3ufd3d3d0yA4NAbD4HwNhoDgyA6YAIoAMXV1VYq7ozmqp698qHhR7GVIZv3pKYJAcsQskZdRBKmYJRomhxNXIWw7dtY21a0azTTlm94YidwtMhOZSBCYJAMEjhABub193d7n3d3cdMgODQGw+B8DYaA4MgOmACKADH2OZurqmSHpTXWSO5DvUYU+kNVAy4CJqJMNQhLONiu3PZmZmZ7t7o+7uHve9oDYfA+BsNAcGQHTABFAB2uKafAjAB0yA4NAbD4HwNhoDgyA6YAIoAJiquqrHdq0+OCMAHTIDg0BsPgfA2Gjvfu97nvQdMAEUAG1D4EYAOmQHBoDYfA+BsNAcGQHTABFABqruqrFdur+isaE6RgA6ZAcGgNh8D4Gw0BwZAdMAEUAGq4aAaGAw84QbkIk6+zs3u9z7vEVUfNhwaA2HwPgbDQHBkB0wARQARWACMAHTIDg0BsPgAB8DYAAAGpyU1l84JGcgKuwA2HwODQAAa6ZHAAHbq53ve967AFDu7u7s22awQBoIAfr84xyCAKQFVWKq7q/n32u9701kDqAAxdXjIDp3nT7XwIwAUAGQHQAMbD4Rm6vtfZ3nPPtarf31GX0kN3Vh8AAAA30y+AAHbqzIAAKAAAGO4yfAABmg7vve970AAAAADIDpgAigAUAIwAdMgODXge973vgfA2GgODIDpgAigAisAEYAOmQHBoDYfA+BsNAcGQOVN73tzigAUAIwAdMgODQGw+B8DYaA4MgOmACKADt1cruazVKxl8CMAHTIDg0BsPgfA2GgODIDpgAigA7KVjICMAHTIDhznOTnE+B8DYaA4MgOmACKABQAjAB0yA4NAbD4HwNhoDgyA6YAIoAIrABGADpkBwaA2HwPgbDQHBkB0wBztd73vehOdrW7qDzog79zPta88UXuiDog2+8+VvXJAjAB0yA4NAbD4HwNhoDgyA6YAIoAMcy+ur7iuTcz85Xxjaa05vv2ahvnexGADpkBwaA2HwPgbDQHBkB0wARQATOIrOQRGADpkBwaDUrH33zfwNhoDgyA6YAIoAFACMAHTIDg0BsPgfA2GgODIDpgAigAisAEYAOmQHBoDYfeD3ve97YaA4MgOmACKDe91vewIwAdMgODQGw+B8DYaA4MgOmACKADt1eDta73tTtdj5JEYAOmQHBoDYfA+BsNAcGQHTABFABFYAIwAdMgODQGw+Ge973u+9NAcGQHTABFAAoARgA6ZAcGgNh8D4Gw0BwZAdMAEUAEVgAjAB0yA4NAbD4HwNhoDgyA6YAIoAOTBoIAixz4EAPpPX71W933d3dvdHd3ccGgNh8D4Gw0BwZAdMAEUAGbq8bml5NnSUwAdoyA5Q0AAG6D4AAAAAAAfA2AASmAAANh8D4G3Oc5znBkB0wARQAKAEYAOmQHBoDYfA+BsNAcGQHTABFABFYAIwAdMgODQGw+B8DYaA4MgOmACKABQAkkkknTIDg0BsPgfA34e973ve4MgOmACKADt1amQEYAOmQHBoDYfA+BsNAcGQHTABFAAoARgA6ZAcGgNh8D4Gw0Su7r7uK12pf2d431OwigAUAIwAdMgODQGw+B8DYaA4MgOmACKACKwARgA6ZAcGgNh8D4Gw0BwZAdMAEUAHJj6quqqu9lXdVeN4qroDMrouUJt7eggC/NtttsEhPTNq4RGAN1ve97ODQGw+B8DYaA4MgOmACKADN1fVMh0jAB0yA4NAbD4HwNhoDgyA6YAIoAFACMAHTIDg0BsPgfA2Gh37ve573odMAEUACgBGADpkBwaA2HwPgbDQHBkB0wARQARWACMAHTIDg0BsPgfA2GgODIDpgAigAisB99998HTIDg0BsPgfA2GgODIDpgAigA7dXz7KmWzpGADpkBwaA2HwPgbDQHPHve973vdMAEUACgBGADpkBwaA2HwPhznO85wcGQHTABFAAoARgA6ZAcGgNh8D4Gw0BwZAdMAEUAEpWACMAHTIDg0BsPgfA2GgODIDpgAigDGsc+zVXd3zjWZXN673kiMAHTIDg0BsPgfA2GgODIDpgAigAlaurxXM5rGLrLJ8dFAAAAAzhQEAAzdWA6AAAE0yDpmwHTN1YDoAAAb61W95026AAAAACgAUAIwAdMgODQGw+B8DYaA4MgOmACKACKwARgA6ZAcGgNh8D4Gw0BwZAdMADnOc5x1QAjAB0yA4NAbD4HwNhoDgyA6YAIoAO3Vy6yrOgEYAOmQHBoDYfA+BsNAcGQHTABFABKtWACMAHTIDgkkiSPgfA2GgODIDvnve973veigAUAIwAdMgODQGw+B8DYaA4MgOmACKACKwARgA6ZAcGgNh8D4Gw0BwZDuZ6SCTjxZy4444444444vdEkLSrqqrkrX3V/Vq8zWca3IHTIDg0BsPgfA2GgODIDpgAigAzdXMczmRX2tbOkYAOmQHBoDYfA+BsNAcGQHTBrr77L4AARgAADt1ZkBoDgjADvRxHd3d3u8YmIEu8QGggCIcx032cZurAdpXc5PgCMAwIwIDVS6vLIdNh8DfwbcEYHd3ds1k75zftmKVtMEATBPor0VPOqSSA8wQBYIAogtrZMcjHzgmDM902R5547Ym3dkzQkhXPZuvaqseuZyHOoQBD9AIAk3RxU1ea996aBAHdYkAMEAPV2zu+g9ShkMEAQwQBdRUQ2d18CAL9ih3ZvXrUYZIxy6HXSoYMuIqJmBqY10CAKqQQA1Fvr1sWuaBAFdU+7o6A2fVgIAsEAU0EOIgudnWW0aCAOnGhvakluIBAFvrnnhwkhYCAJPXm7U3EdsdtRLjdngQBg+7X56R4EAR65qsBIWm22reZW8zMHG9t9sHor3ezfWbHejQQBEworciIi6mtce3cjYJysBAEufVt52eugQBV5O5tuh+j2VRXqjzgEkqgh5pnRfvTDHWjgEhQ07m6zZyYrfdfd6UlnT3V3b3X6OybA5gfAlYZAOTrL74El1eWtAJjjR8CVhkAnGSvh3br9cMSY6jHVRM5kc7nu33uhC7u7u31b+qVnuLq8c++39Vfaz1qb2wkBGADuN/fdrd1c7jdzusb+13X2fm9zvdTsHAAARgAmsYqZqu5+mdVj7jOt7ENVdz7OnwdjFDwR8PNnDLADr7u6u7u7xIz0Jt3m1fN4hU1DkpqHkZrVZzvVZrWec++c33ooAABGADn3ZpnWjgG7q+6v6sfG3QBVK5nJ9TAAAGb7dWZDpug+AHwNyZxiY7jmNY3jda3vO59U3dSLnjMHjRiHjSx5RndGTNYy99Vd5+93e6Sdl7b39sRrVM4rNVlm6t9rI70AAAJtkbABGHcVi6vWcZzRoIRgAACMAHO4qq9kuXMzQcrCAahRcRUQXBUV3b3dCF3A6RgOTve6xXK53O661r77O/rq9a5NfKzre+87Bnkl1eN9rr7fHOSODQAATTIOnOyqzvP311esaxnNc41v7pqRmrvuuKfPiQAAASM5AABnt1ZkOgFAAE0yDpmZ7ed90+a+cg1dXgDp0yAACqkVWarNTON3V5ur51V27jPJ9dKN3ecelCib1oVcJeg9uRXZ3b3e8/W5m2dfCRjN1fTIdgjAAASM5AAB26syAAAAJpkZOk3K7rNUzrTYZurAdAAACRnIAAO3VmQ2HwABzc799vPOa7m9bq712bvUuwAkfPOu+fGs9UIQBGE6+SQUkkmce+Crr3zKg1v3bjL4g7156QIQa03zBADzY9UtaCAPMEAOKqFlQdkJ+dbUNWCAKBAHTcggDQQNkGiDyKtSDMT7NkHnxB4QbFXCDZB3vwgwg0Zm2azU3ms73v1zAH3nV4QcCAIUSCAILcVsggCWUt4je6K6Lq+cSHQAAAGc5AAB26syAAAAJpkHSVJu6vOdZrLWtDpm6sfBHAAACRnIAAO3VmQAAAdMppkHSd1Wca5Hfq1d8xvl1VOOcqTnN1DmIkmeczFxFthDZdFzqbHkEQ0XDUREqJh3zgO09NORjeSSpjdluujcIly1LiXpUAgdPaJqnA1UA0xA2IMZIwmDpOtVhXplzAQRsx0yDmYY6iKySC2pslYou4pxMxSKJSloXvej1Qym23peowybIcBs5ElCMiSjlZG1dhme6arGS1ilV1I9JbAJYy7MySKV2KFkwzLxbSIGLNFpewFU4NiDJd+o2dlne1UdkUQ7mHwRBSohWNzFO6ezLTc2yAhlzMqvSyYbGpdZA+NW3k4QFOGyIgnWZpQtKTYm4tyOqHGVDbxkxE7c81wbFvELzAUMgyGJu5R1GMjMnmtqAHsOZKohjaZuJzDRzRDYPXJGvKTIqYl+iTBqAdURJLIhDZkLs852NJ70Cki5GPMNZKvOiJJcmwrtmsLipafmTRBKqJTVMHKm4qanGIOyEvPWmIbNlxpUMyE3icnsqRA46Nn10wyoC2VE8SESx02urZm5mIyJl+ayHGGYNky4MgbgaiVGTkxOZhYFMPHrWbN0Y/KyAbB5eeoibTBt2TUUomCkQyYhTbgc0TI4cN6UUZcub2FidClks0q6bcOjYiDKmryxqTGQXjyiGjC3ETUxsKS25m2i/DhW3NVJ6ySoqAhJNuIGuoSVDaKgk5ZNS4IIqSBpnjYOipRs0E4NhGWGMHYd70wDFV+JUlICqKJHDuCG4pBEsdwcSd1EzvRu5g2LzgsG7tWUbZHmUzEaON4NZt15t56rZJbNMNGtu1hkTOOWZJK1GkHsK0iVszl2YXShqYaIthbXTtkZY3tF57cRuExBIh442kx+DFDiYvdwYyPOH7EyTp9zqqlz52WVcOyqq7atMlpsrYi5m1QKBtY1Ns1xdXCUMUQ4GOAbbYyXGstzsRjgrXM7MEtsiEa7qFAyIhbMOEiMbIlW8sITbcDyQiHbpmzN0NkshmYbLBlMvQqdZeRsq5qZlOSWNjmbhy222Ntttw8iJuXIQ1Rlz6zpxm9Elwk2n7p2ZIg6lZXQU6Wsi9WFCKaXOkWk4NIs2omKaifM03ZzudqpVS7vVYgOgACRnIAAYdurMhAAAAmmQdK5fK7mq3Kuqzi7q7pj7Wzpm6sB0AA2efCRnLwAA7qq13va3V3vk1i8arDWe966ABgAgAMzdXdVXKrOM5u63irq7+ZO9dgOzNQs7THNXJI2ze0zpEunJ2Oy45oVa7We1rW8uzuodAA5dWNAdrhp8Dne1mqkzbW9b2HcGgAAVdgAAHTIAAO8NPgABu6sPgb73mM3V7NfcdQAEVgAAAAAKpVKpVKzld39V3PsZq7mMsaN8iaZB0lfYk5h99o70zzF1Y+HQAAAkZyAADOe3VmQkAAAE0yDpru8dxytd3vPSb33sjPMXVj4dAAACRnIAAM57dWZCQAA5zk+rlcrtVEPKimVMXy2ciutRHpJQsjPVU3bQqzpkOwBQAkZyAADOe3VmQkAAAE0yDp9mquqO/M8+2Qdb1tl3r2gbm2Iq8IM+akGrwgzrenWWyDnu33uuZHTUquBAESzPDLGTnaAknJkggDUoc7INWc5sg4z4g+IPog2896IOutEG9NkGyDUK0QekGdc1lRekGXXXudeLvfc5xV8w1vU52RnmLqx8OgAABIzkAAGedurM6HQAAAmmQdOVO4ZvXZj4ur1rt8zneu950zdWA6qlUqlUrGAHaMgAAz27veaPjjoAAAd0aDp3X2c4mKxUzje645zh1FZrGKqTN1cy+zodMxgHQAO0ZAAB26uMZAAAAHdGg6aqruqrl9Zw1o4N9+ur0fOEMgOgc5y8fXuuc5r7FYurk1X32FR2a5dX2sV1rW512AAADujQdd5UeV4blTFFtlZxBEw4gcwYOG5yIvsyXM+vrIwik4Mq9i6zd73QJb3R3d293cAAB2jJ4AeBLq8MgAAADujQdO3d3Wqu6qvomSnihihttQwTdQ1qj2RQsxELFAkQxwzKMcMIUKkUwUDzQWd9EF0QYUSaRBqqu68lTihpQ8RYoYoPBQP1OPmBTkHVSmWdCIHZ0KHyhpQ+Yk32UO8vMzGs1vTjAuyh8oYk7xJ6oYoa8qlY7xe5a1ih3IdqGy0+JZKdbtebfZ5SGZvUhjUhlBqm+t76wcqrqzJTdU8+09orbzn3etzsJq6tkHQAAA7RkAAHbqzNUqlAADNA7t7sPMt7BLyqqCHTbG2y1EMYDbG6x3re3ZxVTTES74ifeSmoLMIVDKu5lm1Cp7UOqkVuUoTNlC7hXVVu6u61V1VyZ5O8hm6sB0AAAM9Mh0ADt1ZkAAAAZoB012pus1nWO/fXX332NYmKi3LJUOI84Itzm9dXfb73XKF3d1929wAABnpkOgAdurMgABzeNd1dWrVfYretfbd0+qc1z7Wtu9M3VgOgAABnpkOgAdurMgAAADNDu7t7vbwAq7bbFYYQpqedkACcDjN7ze0Rm6sB0AAAM9Mh0ADt1ZkAAAAZO7u7u3u9pdVPmG+e5NbcFMklZEA0kksHSxy1QIAc6JAEHnY0t2biO8I34Qa15rd2QZog3r7Ot77zWKqyd312ZgIAgpIRwIAoEARzqbk4QdnRBlUfEGWd9Z1i828393vSufSdvkfb+k5WK+ick7ANdv66vGDQ70AAAM7D46ABu6vpl8AAOSs3V3e83V1VZxisarDHLq9ZlfJn7W9kjuDQAAKuwAAD4GwADvDT4AAT7l1fMvjnODWKnMVMx99r50dMgO/Y+mcZurznmmbq87+5vPCdhldXMMh0ADIDpgAgAM/b5Ma1zrjvO8kABq6sDgADIDp8DYABng0OhgA5dXDQE7WOsZ1rLXwAA0oHAAAFKxgKuwAAGACAA7vXxs67AAZ1M3V4pgO9IwAdMgAPDPBo90ADNzF4rF1i8Yvnbq9ath9s6AByXuXV6p9rRwdwaAAAAAAVd5AdOqfaTt7u733nfs9QAAms9+022OwAE+ZDgADV1YHBvvxps6ABr4G+AAPrqwX3d1CQFoYgDWJJZG7lZXds17Pd3dwDKgOgAKuwAAAAZ+Bt0AVSs3V41y6vO6u+6lXdVWZWV3ed1d4zV33n3e81uORABtV2PgaqgOAAG8BsAA+ur0DjprPGWuVV1VUzzN3dXeyDuXpS8IMIMCrzM9znncp49yldFrKUahopEETg/JCOAQBhBv0g5jPaTefPRBhS9IOvZ86dKl6QdkHZBwpa9eEGfed4odJDpQ0oYk7kOSHGuxV2IYoZKckMkPNqGBdN1DZQwVp31Pvu932AAyoDoACrsAKAAAN4DYAB9dWDYbnZr7uvu3V9Te4kgAMqA6A7m6vd1e943rOvvjpkB0AAAM/A26cmKZaAAAAPrq+xjJsAAyA6aA4AAzsPjoAG+3d3VWSH0hqQ0zWZIdyGSHkhqQ9kNSH0hkh4B20dWdSKXyoWXhkWAjroAe5RIyqu6qn11et779zsgAOmQHBoAAMxgHQCvrq93V5zdVSrt6hqrIZ1ihqQ1IeSG1DuQ+kNyG+pDkhkhyQ3IZIbkPaQ9kPEh9IakPKGSHch1IdyHkhqQ3IdSHUh3eddyHsh5jHc+97LRFmyRIx1NXPpqsItCAcCEHyQ8kPddOc0rqrzNF1rCx0WEAnAJwCcAmQCcAuCJdxntze7u7gAAAGqq7qq33t3V1XKqrquCEEIEDAQMTEo7rvO9vu7u7u7u7eZAABmMA6ABLq9Mg6ABgAgAOV92drlVV1Wrq+cvru/kdAAzQDoAAAABjN1YDz3Nj5t4O7u7u709GX6elk40BG6wEEnCkBB1VV1Wq3fPsXV6259J0AABnpkOgAAAAHbqzIDIDp3ueqqrqtVhvXwO4NAAAq7ABQAADOw+OgATlXbJ8Dg0BOVM1Lr7UoEEgINgbGwSAaEBC7Lnc7e6H3AgAGcXV9zRoOnBoqlY5qVAjJSXOPJKZSXpSUJKjYQtjmc+rotC0qujp3WRkJK66YSTWtC6/JIBz1efZINdEG/CDdvN9kG++ee/Pufc76++77+7uiDCDfZBmnpBnhBqquqWWWLD1v2QdEGn3xBog7IMIPCq59z7Q6761VVXeZ01dXvO8b27IgAFXYAb6ZfA0BwABn4G3QAOV9ma3dXy6t823OgAdMgAAzGAdAAz2XV5zljIdAAADNAOlarGLq6qsXV1Va53dVV1WaPtCRm6vYfHQAAA30y+AAHbqz6tSsrq3fq5x21G1B3Z3u7e68A8QKIKFACDgEUu6x9nWxGbqwHQAAAz0yHQAO3VmQAAABvQbOkq6q8V1poDN1YDoAAAZ6ZDoAHbqzIAAAA7o0HTsmqqrqmvvgM3V5ASIwAcKpd39rO61nX2dgUAGQHQAM9Mjt7sSQGN0eAQYIQeQumMzs3u95CbGQAAcGgMgOgAZ6ZDoAAAABm6q6pVVdV9VVdVLq8sjnTIDpkB0AAAODQAAAH3d3d3d33b7nHZLxy7ya0Qg4BAwBAwEEl5PreTkX7buttCv2ZmWYz0nhKdViszO/uxB3hp8AAN3Vh8Oc1r7FD09poRuI329wRzrnfvgABFYAAAVdgDFcxet75jgc72CgAAHdmjbu7u7u7u7nnjqHMCARAQCAGNjjo90ZF5uxBU5YJCbtbsJSmhQnCUKOC9OyDDXxBpwpaINTsgydyD0g14QZ60o8Kr0pd3d6cINJPSDTNaQzzXVVesXeKq7rG+a1txAAAAAH11eua1GG20MgOgAd2aNgAH11YNhytXV4GiqVXapRxwl689dXdTuJK4pb4iydJslR4jUlPVly9Yq63zf2+AaA4AA+oF93d3d3d3d2I9nCnQEDJAQQAgaL1823wAB0yAAD6MDYABLq2AAAOmQAAfLq6ur53PavN90fc73oAGbqwHQAOmQAAfcGmwADl1Y0AAc3V12qq6qKxWMXV1VYurqqlVV1St5HOwAfYBwAAq7AAAAAz8DboAH11YNhfMVVXVS6q6rNMtAABlQHQAFXYAADIDoAAAd2aNhPs1jNZuvs8l1cfa18nQAAAz9dX0ybdMgOnSSSTPewOgAZ2Hx0AC9Tqqq6qXV40++cAAABuMHwAAl1bAAAHTIAAM6A505Q0AAAAdlVu6vLWRwAAAHeGnwAAlVy6tk+DwA9K1VVdUyfb3vexAAN4urDYAAADvDT4AAAAAEnPpmU0kCy64EAaJBBt1eD7PN5WP3KVNq2QautvCDz7ZhB0QbQ6KrouZU8xL1RnWSDWW2/N/Pu19vLTv2iMbAdMgODQAAblXU3f0b3rhDtX8aHBKrUlarOmtfDp284waBHanc6fabBNcZq7z8/lnP3OVjXu+93wAFZ6zrL4IACMAEYAJznOc5xgAjABGADg0AAErl1bJ8Dsq2MgAAzwaHQAJda7dW00OgAdMgO0YxkB3JoEABi6sAgAPgbDQHB0yAADOw+OkyyBH0veOXVsmx3vewHTIAAM9Mh0ACu3VmQAAUAEr7DAcFAAAHMj4IADVbcZ7Xbq86O9kjuDQDIDpQAABzt1f2NmtnOgATV/XVtBzoAGQHTpkBoBX3333dk6y0O7u7u7u7uyRIDQhiQlKSEEAmGKqhrlr5MVDHZQ7vdHXc1OKGrVYoaalVZ6JXRl130taub2wkNZWZKHl56I0d5UzKNzdI71d1DI2odVzprzHVtjWZDbpK7UO1DLMSHVa6VDvJJd9XuTo8lNeyn3LJfCrzKqfhTS0gp2d/YZEimUYVSoEd7hM8kOaO1D1jvrZQ3ioakOumUGCo6tTDeaX1U7lGZ1Zc+3PHShzQrWFWdu4nuWbY/aQOHEwClHCQFLBVltjY2OTxaBDrvzy+VT8KB2LqqCgmKEGePsqDtrSq1NvtTrenTySOsAIFIBCIiwNKLh4NL2QoFV3dVXLq6ut9uN73dX3ndd27AAdMgKADIDoAHIw0AAEurYAMgOndUqXi7qrvCw91xjPaNNAdCN/ZSHVqqaqhvKddDChpIeKryQ6Xqt1vvzkkUAAAcwPgAA3i6sNgADIDpsPnd3d3d3d3dkIAPMBJSJAO2OFUHXHkIhY6emzDqQ6gAcJLEQMlRRAJAcxyQSQ04PGxVJEJ0wgiBih0mSGlDuTESxjAHgg3YQoEpDCPtoUCSfrFDShoLx5mSGKGZIZIZnTd7C7RO62uwtrJDSqmnHk6ox2K7csM1oodMtKGGdWhQJICkJBTkAQwAQYoyqz2573dwBj766szzfN7AAAzwaHQAOXV6ofDoAFABW8kMX33/5UkUP/4v37rtfjemtutoQKnH50y1cWFMmKI9EC/Wfv3dR2wnLR5yDkhOTjsu+fOedtLzFDUOBlN1EDZ0RBbczFyilUREOIGRS6PUenzwHUaebGOYm37unrjToz1VB031AkLKgyoBASWVLUjlXJJRSgnCoKG4rn0kUXzgaF3F4LsJJJypu4q2XmT3dOG5nr6G4PM2UV7rJYHosLdCkMSgEegUeioqK1dx1QSpmZGMZl9bVVQ9ig+z/bjvFBjnX3R5id5rzVSnH8kqlJAFNNgwY2LzUI2HX2fTXXF+mv2/naRF9Co6uurEjLKli9cwppNgz94+tz7WO029okui3MQYk0CAPPMFAOV5sUDoVR6mkCigCgKCFAoUCfd/u/db5z5VV0NSpMpGKGVKbwJ1tT3DdVWAVVTUEII7zEUDYhYZv9vfv2/nFTKhmM7SGa5znPOc58RJzOSTknGnJhTbSSgffcAmSP1JJpdbTXAWsxliyzb1Q3IbkMwS+RFsIscyRAcYczf7evN/b2qBE22w8B8BjaaU/Lktpz6Q74OeL5RR0D4PRNtdTaSOfgDwezaVNpN1WriTD0jwRIEzEQA51HOfua5znqoHwCCtOSACUJBIxAl9cfzf7f37v1mL1iAGKDnDr3s9794SA70dHd3d36AQHwgR83vfW97936B2CgSAvxDUS0eGJNFDPdc5315znOVUcmZljMCcyqDyUxGrA0kNahjMYQN5VDN63znO+c58grbkJa6NYMSAme7u7Pd4SSwYhAF9c92dvb32HU2mz8BZ4M7/NWrd293d3zxylySSSR3dVUqSSSTpkD379P379r9+/fvzYfB9OySX2ST6SSS5NPgAD0KAAPSawA6GgAEkkkkkkknpOSSSaeA+AmfszM/ZhBM6AHQDd7u7u7e7OSSST004AAGGqsSaSWrd+3d3d/SKSdkk/fpGG9ySckyB73fe9r3ve82HwbbG52SclSSSXJOSSST0DgAAZt1SAP3ve97ZZ8AWAdMgfvd972ve97zck1JJPgbDQAzJJI697Pve973vT8xX79Wve973vSV+AIwAdMge933va973vfvcGgn3g2GgODMkkk9N3ft3d3d3AQAAGtoAACABJJmXmcJJIHgPgDP2ZmfszAaOgB0ATPwAFhOSSST0DgAB5GjAAIZpxAAF3Pe9796iomk3tVVc37hRRve+97UEMr7KPY/d53gZQfQdAgECdNMVmOFkWIgGGWScjl2dfuv3nNra2kVs4936fk6qXXLkn66TLDS95zaUpKs4n9u/d2/HVvK4j8B3zOSp+34D4OEZXwcalKSfTeNgH7d3d7tbu7vdSrWnSzHmZl5m7vdrd3d7u7zd637M422xcq671tNviaSS5TPrvuBDu6ubu7+3d3e7urapqqmL2wirJ5L1VQX1iRUy9jGXZJhRFQERQFEiUpSBE0BVFlhHVlKsFNTNLX7DBiSujMybDCFiRonIMCiIpJIWamGKoiiJ7LJznvNe83u7xJtM3d/bvEt3d/aqSaS3eLd4pJJJJugEgAZsrykk7Ju73QDoAdRSVU8zmZmZ3NSw/L5cSTT4+Lft73d3d7tdviASO2AHd297u7nd9unZBipKST9se1VVnM5zmuc5z1BPhQKoUKikQoIuKGFWlDArFDM/tb/fv37nPU5VVmZmEklVS2uAAE/KSSdkhsTRQAAZrz3NVJNJL9TbSSppVu3vt3dEk0ir3ft3b3dm693vUAFgGgAG7N3m6AZg5Umh1JhxgAHzTEGhw8AAEkkkpp7V3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JJJJJck+kkkkkkkn3OZmXmLD9Whu7u83d0il+k+h5mSQDalVZkUHQM8kzJOSJ8m5JJAESSTve/v0MKqqqqqqqlVI35STMztt63f2uevffPz3mZ5+gAAOa2bNTX29ZWszzM88+qqzPsAAAnMTve+3l1UnfgADQa9n7rskr9r2ua3uqk+gAAE5Ekkv67qpPu/CqqqqpDeZvM73vN9u4DyVNSa5hq+X+3jWNbgAACtZ+iTMy6r6qzMgAACaz9jMqS6rzyT6AAAanOu9kl1Xnkn0AAA7+qtVi8VjVa997NXfvb957HTAN0NKNBGOSSSSRGADpkBwaAAGmp9rVPm6u3vPbY97RJ2cmZ94RPagCSvcq7YmJJJIAkkkkgd73vJ3vXe997dVWt7quz6AAAbnIkkl/a3u1rXfJO/tAAATkTsSXVZVZncAF8a5zWjTWIkzMuq+qszusaaaLA1DP2Mysy6rzzM+gAAE513skuq88k+gAAGpzrvZJf297u6qTvoAAGs0z9EySvM7VZncAAB3n2eeJklee1VSfQDQAGt71vU5E73teSqqT6AA222226K3qQIDnGGVcXlr6d3fvu77u7ABFACSSSSIwAdMgODQAA1jOMBqm0aVx1bISQBxV2ACSSSSBJ3ve97377ve973vZ3vXe672vPPPO9n0AAA8a1ufone3Tet+Sq8+k74AABORO98/TKrMzuAAAZzGZJNXVVVSfQAADc5EkleeeeST6AAATkSSV5555JPoABoDUciSSX7re7a1a7ueTvNAABqciSSXVZd3mdwAADOYzJJdVVVJ9AAANTkSSS6qqqT6AAFVVc9S/fffcSOnCwA9JUkk600lJPopwzV3VUDYAUjAB0yA4NAADXte9Ve+YddjJ7wSSSSTbFXcxMSeD3fMpJJPASSSSR3rve972b1repOpJJdVVVJ9AAAJyJJJed3rfvvvvuZPgAANZzEkkuqy7vM7gANejms5jMzMuqqqzPd0FPMwacnMzDMRzLHmcuc5zmv379+/Zn0DTescM5jMkrzzKrM+gAAFzn6JJL1ec3rdtW777+zOQAABrOYk72vPMy7zO4AABnMZne155KqT6AB9zgG5yPJJLqqqpPoAAA3re9a1butftNaT9+kq5JJI95tzA25QBF1eMYUAdwywAdMgOD74PV7t+973ve9Kffe+reLrinGmKuV9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IjHSXV3XMkMkMqotsms5znvOa+59EOYODSVdXTA3JNfququ7B973vexV0u7u6uuYGhG6qqqqYGQHTABFAAoARgN1JO/TMkB0yAD1VdVVe973ve972gOAkkkkgwARQAKAEYAnJMySQ4NAbD76owPthrTmBp3o4MgOmACAkkkqSN7DbmADpkBwaA2H0kgGwB73ve9n3ve8dMAEUACgBGADqTGJJJzpoDYfepVXVVXse9773ve9sNAcGQHTABFAAoARgA7MSSSTg0BsPve973vve972wAEkkkkYAIoAFACMAHTIDg0BsK+r1VdVVB73ve9sNDnOb3sJMSST1zFVV1VYq7qqrExTTSWfcdI4200uFffugBIpzM+lxSfZPGAVQB0M+zMtDVVJ9DoAAAs4szMzLySTskn6WvXd3cnskAAAD4TaaSrYfcHgBKYvHc4xdZxWMXd1WcVmqwGVDlM3thQRBEdAFJY4FAYY0ZhZn2HQQRdGSM5mY5k0/RBIxttqG2lDhNkIbTZAVc33d3u7jfwKu6qs85fOfc1vnBwAVXe973veySFAABZXve973pYk20mgPwAH0mSd5MyQAE+73uuXX2O46bkkq7qql3dVWKqqvF1d1i7u7mM5hJPpJPoADt3d3d3u7u7u7u74OEwQAxDSQAxXV1j7IOHg0FHFXckknow97Hve94RQPgbABJJJJFMXVlJJcIaSST7u7u5iWZmZ27Al4EAfCabaE2kuABYcaZUnve933ueppySST0ocqGc5znHviQ9kMkMkqsXisVd1VaN72AZoBjpJJ2SR3d3d3cwEhd3dwe33ixgiRL7wIAe8Ku3Xvd572au/AAG+Y5znOAAA73ve970AAM5ywDYfYvBpNJI4futOgPBxp+pLkbeL3vX2/HKqrqtXV/Y8173vT3KBsPmAZM3VoNhoPrqzIAAAEkkkk9dVdXvjVVdVVez72+e97wAAADAFTskkkBQABLzeKtHGVDCjNGtBZCZiVGV4qqxVVV3jAESruqpgAl1d1dUx57e++++6DcG4MJ9l9uo9kxkNkbgb+7zt8f66v3793r94D+K8pbu838t3fltLaMPY973veIoAkqYkk6pNaaYAOmQTck1JJrXvu7973vVXvUkiSSeFe973veAHve94HZiT0kmJKkggd73uama1jWMzM5mZLuqrW90734AAB1rne873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3u7u7mZmaEkkWqqqqq222224gPyCxCsoTQMVVoGBkFtVVDAygYGpUl8+fPnz5+/fv3nnnnnn9QVe0v0DihO+9ttttttttu+iiO4GSCwNUDQNQLaVTA2IVoGBkqmBkFkqWpV8+fPnz9+/fv3nnnnn9Ap+pV11ttttttttt0QqXUDUq1KtQViFYhWIVqCtaBgYGBoGBkle/fv37/fv37955555/KCX4GQWBiqq6622tm223AA6gZAIVJJKhCSQu7u+973uZmZsJJBaqq22222225VVL9ILKqrILAwPfv379/v379+88888/A/Uq1KtA662222222226oHSC0DAwMqrA0qtQN79+/fv9+/fv3nmZnYQAFqvFqqqq8Wqqqraf37xkklrLuqu7q8+b3d04AAAAAAAAAAAAAABJJJJAEkkkkASSSSTzzzzzzzEF0lgdJaB/AfhrWZm/39/f39/aq/fNa1rXvoAAHuta815rzW973vve97VXfNeeeeea899AAA9VVP0DVVYHv379+/379+/eeeeebbbYABmZmV+a815VV9AAAD91rWtfuta1r777f37+/v7+1zgAABd81rWtb3+b33ve9rnAAAD91rWtfumZmTDFa1za2c5zjGL3lhh3SSSSSSSSSfvnnmvPNb3377ve97V5Qd99AAN73md73va5wAAA/PyzKqrnDuvNeK9rzyqqqqqYQVWq32+wJITaAkkl/fv7f36AAAAAAAAAAAAAAAEkkkkASSSSQBJJJJAHt1rz3zzWta1me5X1VVAd15rz33330AUwh77777u7u5mZlVsIKrVVVUwgqtD3e9733ve9qoAAAzMzKqqoAAAzMzKqqoAAO++m97/O973vOcoAAAd15rze9773ve85zsAAAd3ve9973vaqeeAAMzMyqqqAAAMzMyqqq/mvNee+gAAe8zzWvPNXV3dZjNAAAAAAAAAAAAAAAAAACSSSSAAAeeeeeeaVT2lgqeksIq9euevPPOVVQAHgHdea83ve9973vaqAAAO73ve+973tVAB330A+81rz777e+972qoAAA3re973VVVAAAGZmZVVVAAAHdea83ve9973vaqAAAO73ve+973tVAAAGZmZVVVAAAGZmZVVVACSSSSST0s4DMwECBgYACXximLYxgAAAAAAAAAAAAAAAAAAAAAAAeVdVVVevz89/Kqq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yqucqAAAL3v5188zxvO93TgAkkkij4BJJJJAAAAJJJJIAAAAAAAAAAADLq/M15rw/PyqucqAAAMzPMyqqqAAA8Znv5VXOVd15rx6AAD3e8zve97znaAAAMzMyqqqAAAMzMyqqqAAAMzMyqqqAAAMzMyqqq7rzXnvoAAHu973vve97VQAABmZmVVVQAABmPffz2qucqqqrnOc5znOQEkkkkASSSSQBJJJJAAAAAAAAAAAAfbq62rut3dEA88888888AAzMzKqqoAAAzMzKqqoAAAzMzKqqruvNee+gAAe73ve+973tVAAAGZmZVVVAAAGZmZVVVAAAGZmZVXOc4AAAXmZmVVznOAAAFmZlVc5zgAABu3/N7rP5c5VUCSSSSAJJJJIAkkkkgCSSSSAAAAAAAAAAAA9urr7dXX379+/TlXlUAAAZmZlVc5zndea899AAA97ve9973vec5wAB4CzMyqqqAAAMzMyqqqAAAMzMyqqqAAAMzMyqqq8PHjQBmZmVVVXdea899AAA93mZ3ve952oAAA/MzMqrlUAAAfzPv+Lu7v5337873p04AAAASSSSQAAACSSSKPgEkkkkAAAAkkkkgAKqqvzXmvLXmvN+73vdVVQAABmZmVVVQAABmZmVVVQAAB9ve97q5VV9rzXnvoAAHvu97/N1cqqAAAMzMyqqq/dea899AAA983ve9973vaqAAAMzMyqqqAAAPt73vdXKqvtea899AAA93ve91cqqAAALNO6815mf3d3c4AFXdAAAAAAAAEkkkkASSSSQBJJJJAS6unkkkkkAAVVVrzXlrzXn3333331VVAAAGZmZVVVAAAGZmZVVVd15rz30AAD3+fffffd73naq+15rz30AAD3e973VyqoAAAzMzKqqoAAAzMzKqqoAAdee+b3vM73vec5zjQAA7999999VznOc5vXmvPfQAAPd73vfOc5VUAAAS7l/PzWta1+61o1VXEsoTlSrQMDIKYGEJqVZVQsDQXV+Vd3d+XdVVX9urrfPff0/fu/AAAAAAAAAAJJJJIAkkkkgCSSSSAJJJJIAAAZdXX66u7uv11V3d35d3d+SSRu7vve97mZmbCC1VVVVRVSqfffffd3e9qoAAAzMzKqqoAAA+3ve91cqq+15rz30AAD3e973VyqoAAAzMzKqqoAAA/Pz8/KqqoAAAz7e97q/lVX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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        sys.exit('')
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
