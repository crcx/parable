#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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5998UqSLqkki7WHqqkbPu4B2lVJGassAA0y9jbfsY6pKuKlSRraAOh30u7tIErhYI+keKpAmYiIHDrnO+a5znP7Ej8Ud/PxQ2E2yKu8zvXX7nvT3u3N3d1VYq80xnA4JdVdUmWQP2oj9Kl7+/ft/v37798OiRlA4xZmMrMetVTSIz3XOd9ec5zlUnDMZYzKJzII8RYjVgaJG8QOiiVBH9+zre9973v0BRej4FRighjEIJnu7uze1IAwYJIC+ue7O6+sxcVVVUbAw6HpFFJJJJO03XtLS+fAVdXVRgA6ZA9+/T9+/a/fv3782HwPlBsNAc/e9n3ve572bu6772jYBJuSSdo6aDVVSDAM22222/O22DpkD97vve173vebD4Nd00+G3n7kM2B0wHpttt9cNAAB4ivySSqKT6QQpBUCAPAAywAB9b022373fe9r3ve82H0kgGxv5scd4Yknve93waAAD0yygAA95e8NtvT87bbo6ZA/e773te973mw+B8DYfNtt429NttvrDQAAT1qRfAAEboARiSSSDIHvd972vePzYfID222+Nt/Ntt429Nttvrkn0kkkngACS5cuB8AAB4ttttvrem22w75kE3PHweu69v3ve973mpJI4Mg2+sttttv1yIAAZKQIAABUMsAAfW9Nt9bPugfAA+Nt7bb8GffZmGr8AJyq865zOc5z9y3ziIPVdZN+9z9+gyIPoOgAZehrJzMLEAcMzAd1PpzerxXXbvupqG9zSTuvX72e9z1qifd2SfTkk4marLpffapCWa07uqpaK135PH87b03o3R8WGg6HA0XWqqlbtzVUWgPhknJckk5JIlsKPgPgCclySTkkk5S7O7IhHxDLpAkQJJENOKqe7t6/3xH79+5+5znOd82bpKpi8sIqydy9VUF7YkzL+aLMz8SdFEVARFAUSJSlAETQFUWWEdWUqwU1M0tcMMGJK6MzJsMIWJGicgwKIikkhZqZIqiKVq62r1dX050OA2TJJJyXFNVJDaott/VSpU23AkhVJJAAEgfAHACcgBwAOUWk2/m23xxLfji2tKqSWq0p9OckjnJfM0gSf2+Nt5xsDh0AEX73e99zx8qrPvx19znnOc56Km0EKBaiIIORGQNRGCrIjMzXOfuc4/Knd22xttu7tS9AEQBxAByARqkWAA+yu5oVpJKt2qSVXSVmjDobk8lVJF9k+npkk1JltucPAEkhYaqqQEjjfve5HXrIBxKg1QAZnvfRvTbkABttuJUrDP5VVL3kuqmqqrUn3O5JJ8+7u7O7vq2N3b3d4BB3yBBCQgcCBQyIjufdCSO7tAQcAg+hISFD/pEft/ZKSq5SVSkq0stfazmWkq3kngAAPhtt5v3ve373vNgaikkkknoLtyavl7bbb96TQaqqWABgA24tL2Zm8LSpVLU9IAeIEkkklpVSXV5e973u+g2223bbe6qk23tsnyVUlJ9JJI4370RaV8SSVamvucUkkbbbbbgBYaqqQA3jbbbgAABqlVJNttvrcG2222wwNVVINA24kAHEg1JJJJJJF9ekmtau4puTipSaVQ1JpKB8WWWWWOfItUAbpASSdSkgGPH83twAGwADDfzbbx92kfPwlHTMhYY0161rnOvufaF9zu5IZ2iNc5zrvnOc/cpS9lXuoIVvvN7735vfu+KP0UfX9UHVuB3bv4Mv8azWnmj3G8qs3+88KQb5zYkuZKHf+P8fc7lHOaKlzJLmEpzF3VXVAx9urq6rQcHaqrMgODQk+qST6QfA2ABMSQNTnPucyRVVd1UkkkSSaq6u7uYmKqQ+kkk727q6ruLqrqu85yV3jrve971IDAGw5oQHbG7u7u8Yzdk3d3cu7u+yr0Rzrjrzuy7u/Z3nlCOZXdfd2ZmZmcaI5nDI5zm97VKumKigc3ve9qlXTFQDm973tKupTNNA5ve97VKumKgHN73vaVdMQDnKur5znOJd0wA5vnOc4+VA8yi660UfW5qqqcxFTeAXecwo5lTnulUvsqBcyqPMhA5lQ1hEcxBXMIRbyATmSIOYScxSOYu6YqruqqjNXdXgbD7ABHBoDdB8D4Gw0B9xMT6SROVdLMzO7cAXISBBsa93d7AFqN2EBLQIELWktaRuxz7AFHd1d2c0hAjXrQkktYCBBspGpI3YN7t8xC7vTW72Y3uSAwBu7u7q6YYq6u6uopitVdXnDAO953vc961VUwA53nOc4nbqsMtA5ve97SqtiAc3ve9pV1KZaBze972lXTF1VzAHe3zHOc43V0xAOd5znOOVdMQDm973VbSqtiAc5znOVxBEnR3d3e7MzMvtEabAJICGgAQraqoba2uOkqOsKOc0KU577tCc5zaUc5qTmITmXMIrnOG8CSSSSA5kfBAA+bDmwAJiSSTaJUkm0irq7sByTMmruquqkkOAF1VusSSSbmYbCRgAYA3V3VVVEMbuqvIHOc5zaVdMSSQ5zne94+q6YqSSHOc5zaVdMTEkh3nOc2lXTEkGXOc5zl3dcS7pgBznOc5xKq2AHOc5znEq6YCMOc5zm0q6YuquSSHOc5zaVfcVUpnQd7Pe972dgkIxiBBblgkFzBLVsQHnnG6JN71VH2Env3Nz7muYKuc1dsUxV1dVdsUCh3veySQHBpQKAD4GwADIEqp3ve+93dqQI3d3d3tRuwjWkJLWtZuwhC7o7u7uwXNAg16wQBrSBBvve7c33SpJJAFMAbq6qrohjdZA5znObSroywHHec5zaVdMSSQ5znObS7qVhgHXOc5zaVdMSSQ5znOc4lXTAkm97c5xLqt4YA3vc5ziXVMVdWJJvnOO967V0wA5zne971urphgknN7c5xogD2zKQB5iBbcINYCDBucvOMSJeed7UJ3nvObnOaUjnNHOaSVJJMYkne97JJAcGgAA+BsHwNjIEqdVVXJJ9MEq6u5JyTMwkk1V1VVcnYcArl3V1Vu5q6sNsBQIQaxAg2fe70gLN3e4zu6ALYYphgaAN1dVVVVAxvJqSc5xznEq6YGg73vOc4lXTADnOc5ziVVsAOc5znOJV0wA5znOc4lXTFXVgOc5znOJV0wA53ve9712rpgBznOc5xKq2AHOc5znEq6YAc5znOcSSTvvUR11pIY70ZjrGZvKR9rzrUulE4ylR3kiuc929ypfZQo5lCTmKKDmUqXMoRzIrmSouZSqPsEn32vvtKl4kkkk7MSaB11oAAPgbDXbu6MjgyB3nOd73r5LkkkiVWsQINe7sm73V3cHd3cHdrNYgQe97vdbSFcAAYA3dVTFVdWxVVdXVXMVGbqryBznOc5xKumKAc5znOcSrpgBznOc5xKq2AHOc5znEq6YJJN7c5ziVdcZA3uc5ziXdMEkm9uc5xKumCSTe3Oc71mrrlM0Bvc5znEpHPu3d277MzO1I5oEFjJbiECDqoBkz3dS7o29kQkRuxtJCDd3dW7um7u/SSA4NIwAA+BuSSSSBkDu7qr25zmo4xd3UxMSSddzi7upMySAVkJJOc4713KVJJyAGBgOXdVVIn1VnFZA5znOc4l3TDBQd5znOcSqrjJ9Qc5znOcSrrjN1Vn1BznOc5xKqr4yfUHO973veu1dcZPqDnOc5ziVdcxTB9Qc5znOcSrrjJ9Qc5mZmdojOg5gLqO7u9mZmZ2pIx8zuo7u7MzMzO0RlleknLPTk+SG02uIQkBYlN3Jmrq6qYkmpi6q6q5JIrAkk4mZAY4NIwgAPgbkkkkgZA33HOc5xEupJJI7MSaq6qqqYqSGyZkkuquSVi6q6okknQUNh8BgAnTJQc5znOcS7pgUHO973veu1dMUKDnOc5ziVdMCg5znOc4l3TFCg5znOc4lXTAoOc5znOJd0wKDnOc5ziXMXVMZKDnOc5ziVdMCg5znOc4lXTAoOc5znO9Zq6r7F3V9ZRPMzPN67mZMhOYRI5hz3UlR77qhTmT77QSO8RMZEqSaqquqqvsXV1dXdSSTdVVYkgAA4NMgOgPgbkn0kn1wMgd7jtd73vUFVVUzVVYDozTFVdXVGQ+5VVZmYk73mLururd5Op36QoABTecB9X1XdXV1JjvZusyVEc5znOcSrpgkk3tznOJV1ysMNA5vnOc4lXTBJJvbmOc4lXW6usMAb3Oc5xKumKJJN7c5ziVVMWSSb25znEq6YsBznOc5xKumLAc5znOcSrpiwHOc5zmdqRVxuwIEE7F9AhBjeXnixtjeQoonnnm5R5zm19l9gquMlHM5zN3bFVQdnMZkUAAcGgAA+BsAAyB3lc5znESru6k7MSSFUy0xV1V1TFXV1dWE2SScruPqqr4zztXddTUTUqSSaqquA4Yk3N4EJChgIFvvbSjd3u7MzMzO0Rz7gc5znOcSqthJJNuc5ziVddZoDc5znOJV0xSSSbc5znEq6YooHOc5znEq6YpJJNuc5ziVdMUkkm3Oc5xKumKAc5znOcSrpigHOc5znEq6+xd3dVNZ3iR9iofvml/jbUr+iNZjGdIMzUhsRtrTTUI+Eb13kRXvb9nfckkuEIKmAEEquqECCXKC5ILYOYQNhLIbZTUspt9cCoabcEBjltjPoXmFsKGl0kJS230Q1jVxHWiaDJ7uiKPZTIh6kc7QQ6QQgGzoc8/W2BbQYynLiIGwHUKE+zEnvDI/Ap1h1FGSnR7Z+YzMLMcRIssIScIKPy9WLlID1AgjT1sRrYhmJnt/WrXOt5lP7Wo5rPQUWxfrhE0/308dpnrTAAQNiAXzShjaAFxQfWNs1eNJlzMzoCEMZIykYiZSTIjCswpZ357s+3uECFxULjWRRHVC7vd1pIXcgRWSjMlGEMZrnOb5znPojilMbEADEIHh3dx3dokLm33dx3d3CEGnAAiCwTie7u93ckiC43a6OzunzntUlzOc85znOcquMQylhRlIxZmZgjBGZhVZnOc5znOcSRwxUrGIWMZLDJlQYcoQREd3d3dxyBA0JB9AAC0zMy222ZTKphZUjCWRGJSyAsCIQghKwizQ0xCzJFlSyhZCxEZkRgTMmN/fe++7u4OYIEwQDBsQCVVVVUd3c55znFHyozIlczWRGZooaYpGBVmac5znOc5wqWIKz7mc5znOfUiOYpGWJkkYwkMMCC1MTUlUjIqMoqQJSACUkwIUSMQNSSMUTCwYVWJkRgJM95zXOc5zhygxIyIykYSMzGYmCMzLCGUpZVDIcwCsyqGSLJUNe75zfOc5wJyIypYwYkZisxlVk5EYpWoqoRqaKEpURYAhRC11999+++++EczFRmTJQ2wE1nXOc5zv7nzkkZKmM3znOc55z4FcYkZLFau6VpJVd6bbbffFJUqKVUklqwAD3JeMKaAXVVesTDNB07Q1gDpNMgODQdu7pWtb+kn073t3VRvRt8ttv5tvzx/yAAAI6SSq6qqpGgD3veVGAAoARgDhH2QHBoOXd0cfHwPgbDQHBkB373vY973PVr1OypuSTwUAJUkkm5MmQHBqSfVVXINvgfA2GgODIDvqqqq/e9mvT3s+97qgAUAIwB8dM7A4NB9d3Rwc+B8DYaA4MgPXV1VLu69jAD0UACpJJJDAGjplySTck1Bq7ujIfA+BsNAcGQHfe9O697X3s+97kNACgBGAMnZiTkknBoOau7o42dNqbn0jYaA4mJJJJ3MSqkg1YAeDzTbbbYAgABvzttswdMiDg0GLu65Rzm+bd0Zu7qe9+/thsK/ZSCphAA0xZG9n4v3WzVVSv4AE8dmnqqpNt9GLX211475ZvVVS+vXA9DH7Hr29oS5UWlrWtd5qqpTvZ4s74+++X1GqqkAMbNBaSoWm3naqla03vfvPf1VSuwOvHf2N6qqT5pLwn81xgaqqR3QAHA1VUgO9zxq83q72kkquudvYe1VUueY3aw+NBqqpADVJNXSSv2ktWrsaVCmqXIBvHKCqKWIOjCwsysg8DDA6kxKGgiloKQ8ujMFDIOoUKEyBoBKaTJQswwgx7nrrDMMKmiKzCjEwzEqDCMjITJyVaTo6x6gyKYgHCMzBInIT3rApKQ6on8y5BVHWRLklSRkmEZjgkRFUpLVrV0lWletO981VUu9bA6INVVIAt+rFq/fWnr67+uqpXVUu508Nt7ADtVSA+AEm228b1VUnYFAGBqqpBrmCs3pO+cb1VUm/feW2qSVaSSVWaD4NVVLoGzjXuwkjd2d1cfR2My/oifj64KSRdT96vr6fUzZezCSMndz220a0m0Z7K2OPNJPPM53ziqrSRxkRoVGJGCo+7xUfxfs3ne5U3vfe/VVfqPZaogISRCQEVHRt9AC7r7hHa4+dz9G59FVS5yqpaePnH/AznNdDVVSk1yQXwa4GqqkHPrxpL8H3WHdfcDu6qlfZJzzw+AC9tjZHRrAfOiUwTvYYKN3X1Wcu7pth3GZJJOdmw4p8+Gzlqz9K3nvrn7CTvWmAvYj1IyoYkMEkvoEIIEkq2dufvun6e6+7uj18+9zw2t32bcAINECBgIGJjEgXR3R3c5zgI4IxEZlSM95w+7T1nNK7qkuqq19VUnrvV991+8bqqXmD3owAAOhvFe6qk2+PG3YAIwOGyw+M0gB8b2372zTe9Xbbx4G/i2aqqQWx1Sp/JpvVVS772e8+7ad1VJt8ABhgJc5iqifkCi0kUkjj3Wbcce7pSRvurtrvd3uGgN8H1A5vHpdVV+9n72Oe+97zm+zUkkAAAANh9QBi7uklyVJnsgdGgOSSfSSfBPcx9j6kqLsDWa6aNnzt395/Nt9823jfz25Ye9PUckzJJ7ICu4wyoVVXxO6mJJJdKxd1d1dY+IbFAG6Lu6l3d3iwTkJjJUZmuvedc3znP6q5/an7K/iVORk/vMNw7/YAKdxZh/MP9mdSPOYd9RNFOCAhiqgdwoKwDCofpFBTOYAIcgQHfmFIof2f4yi3xVpT7FUOZEc5qUjmVJL/GRSv2VUn79zdzM5znHOc5c5wKHBoDYfB72/e972/e8AO6O7u7j4Ekjfe8FT6F733fWISPtSASAAAqqSQJHDe1RaSVVSLqi0d0qQ/mg1iSD77u7veQhBjBAg+zLz74n1pKhsFwCkkqAAbfu973yqqVUl72qVEfchV/iqykYkYExhSmIj9qVaiMTEjMqMpKdZSM0VLUSsKliR+yI/ft85zvSohqVVdaxQQ1rnQiG4S3glmKUpSlKUpQlKUKgB+xEp/YVJ1gKTIjKqqdYoZiUTWZEZVUqsiMiCxCIH6EHnOc5zvSKCGpBVHzCieZIS8yl5/aSpOYL9hWYUOQNCUJkqZmNCZmCZA2JmUKq+xAbJH9ooNVWVkqYgsojCKyIwsiEH6RMQQlRzHEREkEOc1znOeefRV7kRvIj33377+8UexGMEEIhRSpuEsxTISlKUoGhKEyVMhLMUBSFRJDkiqHUKLQiJ0IhCiEghHOc5zf956pPcSp7lUe5Uh77/boT9hKUoGhKEpDeWAUA5KWYLWJU/YkluI/taojBU6whChUOc5znN68QXyEAfJEQPJSl77/biT9SLEGAZlg/ZTJSgaEpTJUyEswTIGhKSqL+yUNlSwpCyIxSxiCrCqwKwoMVBlSxCCHWIgIBve973zXj5KiHnmAiHnnOlUUdypuEzMEoGhKEoTMwSzBLMEoUSkEOT11mIAQgPDnOc5zvzWta/a5gCG5DdlkuQmSpkA2YJkDQlCZmCBiuYJvqdJSt4kX79+/fv3Oe/H2EH32oj77e/ylA0JQNCUpQNCUJbxVX7H9mmQhuIwpMiMlJGkFAf1gqswI1EIISiORGVRjIJYkZUVkRppBFOc5znPjXir5KiHnmKKPnnOhRE3vBKUoShMzBMzAMMsUyBsLMSV+Mkom4jEBvJFv9+/fv37x57KemSqHuPffd0TkRlAxiRkRiRcxMwsxNa0pSlKUpSlKUCCbkUDB1Ign2YewqmSGo7kBAJ3GtYLJ0or+x6xUjzJReZUv7AR4SqI8lUQ5CvJBDYADrAFJ+xUTWUocwqXMqULeJVA+hUE3KipuVU3IqJu+vqEk9dVVWB73vHTIDg0Hru0GAGwG2222xKqSDYAeVL15SVYlqsusw74OpJKraSq6VJUaAG2qSVAvJKvi+2Wt2uUqqlRpHyy0Wi1w0g020u7q6nO4uquq93vfd5fpPKCSGJJ6rq+d85vnO3OaVK5nOTAofySYLGIoMSMOMQNZkMzLIjKyIxKusamFRTKRkUzEEFQiEgKn7e985zRrwQF8CBE9CAQiEplJRUqlQffcAaX32qkHaRlFHMpmUzKZklIlKkQgoMJYghCqhIjFKqsiMiVlVhJWZSCsiMqKrEjIVOc5znOe+ZCDohQXVqQQ1B7ACtCFCM7e72pSsMVkRlIZEZBZBC+kATJZgiJRCBEklKmFGU5lI55znOffC9+UrdighNUSIzFCIUtURJUUUUyHkgh5CIecMFUNylKUpSlKUpSlKUpSigG4FCgQXnXp0ChQoAb3re981rz1qKPPMARDz7FKUpSlKUoDvMUpSlKUEQxBCJBCVhEIimIjJkRmVVjEjMojCRiRlMqWBTEjKpWVWK/YRIaiMijeSkV9hJ9+5zn73z2QnmJ5gqXnjS5EIgEKhRQPpSlKUpSlKUpSlKUpFAHJREZBCIUYqg/ZUVaiMoBmJGRGYkYVQyqxFbyTUDBRiCQQkpYqVgRCUKAyIyYZiRkoZJZKVZFQorCIRCIUKifYgP29773vXgip6yABBE0TLMRJUqL5KonkAouuYdqjCG5SlKUpSlKUpSlKUpEAQOSgBG1VZmEsRYkDCRvNWUpZAWRGZRGSMhGJFCCpCgSKrCIVKKSCECoSCEAibkEPs5ve+eeQggnclQ7xKl3/ciNoqzMiMkFDcBWSGSlKUpSlKUpTMwlRf2QotxGZhiRkRDqBQxBCVFAOfc3vfPdd9998+RRdylKUpSlKUpSlKUpQIm7dkCovJBR4giMKoEghDCoFB3GEEQRFLB+jmuc5zWvcgIkqihKAqA1Gta6O0jkCgYIMghCCEblKUpSlKUpcslKUpSlQE5dIoEi2RGCGRGfsVGiWJGWFSCEgKH7FXHnO+c5zvwB77xVO++dAKm5SlKUpSlKUpSlKUoHt7u+8ux7595rzs5a8UUQ5zEEPsv7n7dUH7+0uYRV1ipOZOYCPofoEVPpRDU/fb3+B3KIW97+++22AHQCzrem2/AdAABUqSDG2bPeAA0D13VXUld7VZu7r6+4vvfPbrt3YB6VIq6q6q2LurGrp67qqvNeZr++kBfffffJHy5Ag+aQg46wW7s7u/b9huxqEkLffbu7ugAtg3dnXw2JJB9n0/KH0KKcQQtSUpve985zvxVDvvER7759+UpSlKUpSlKUpSlKUE9lEK5CgHUIANACm55KJzXOc5o1KCvcqo9yCh3ID3clV3L9mKUpSlKUpSlKUpSqg4IISKHJAMRA6Ob5znOa988+99995vSlKUpSlKUpSlKUpSPMNnP3Oc5znmta1rXN/KUpSlKUpQ7jJSlKUrcp0ghc/H7nOc5z7zzPLzzzzn2lKUpSlKUpSlKUpSlN4c5+xBDnOc5z3Wta1rm9qUpSlKUpSlKUpSlKbgEJUCa50c/flTnOc5z3zyPPPPPOb8HbZCmRkpSlKUpSlKUpSCPMOc5znOa3555555z7ilKUpSlKUJfYJkJkGSlCcw5znOc5rWta1rm/uYIGZgmSlA0JQZOZggZmCZKULzDnOc5zmta1rWub+hKEuYiGZgmSlKUpQNCUJKiHnhgKKcgDcIh+mlAP0qod9xZzXPPOc5vYWi0qpIsNKqSSQD202/e82228bYkkqOUkeDRwASSVB0AAb573nttiVVSAAAGGwAfqW2/b8ue8B1ttttukkqG2JF0gPg0X1JUGm33uWkqVJGsrMO9fn3ve4+973q7e2ve9v3ujE22Bmta1rW/ecQDMwTIGhKEsxAMzBMlLMEyDG50c532qc5znPffPPPPPOb8BoShKEoS3gmSlKUpQvMOc5znOa35555v33m/ylKUpSlKUpSlKUpSnMOb3ve961rWta37tSlKUoeRkpSlKUpSlI8w5znOc5rWta1rnu1KUpSlKUpSlKUpSlN4b3ve971rWta1v3alKUpSlKUKUvJTJTmHOd9qnOc5zv33HyPLy8nyTm8UpSlKUpSlKUpSlKR5hve9737rnnnnnnOb2pSlKUpSlKUpSlKUp1zo5ve97777777937tSl5ZKUpSlKUpSlKUjzDnOc5zvvvvvvnPdqUpSlKUpSlKUpSjaRv3016z7l8W8I9vvbmAAgtgJJIPMlLzEXmRSHuJH2APs/ZfsklzCqLnNQDmSpzJKcxKhzIRzEnOapC5hJnOc5VWAAfOmXeGjgD1VVVfvcHvve8ABoO+qqurk7v6+Z97yVdXa0PoQIN3d29+7qFzBJLu7u+BAfe+n7nOeJzwF9vv7KmkR9iiP23M5z8JJKjwA22/klXve808bbbYVSpKkXVKki6pVVJAfIDgB3vczvej3VK7qldqUpSlAVxkHJEpAyMlOYc5zWlTnM5zPb33zz8eXvuHLcpSlKUpSlKf4zFKUpSlO0j+6P7+/v7+/v7W/PPPPPP77ilKUpSlKUpSlKUpSnMOb3ve961rWta37tSlKeSZKUpSlKUpSlI8w5znOc5rWta1rnu1KUpSlKUpSlKUpSlN4b3ve971rWta1v3alKUpSlKUJXCTJSlKR5hzn45alTlyec96H29ny8vPMHkblKUpSlKUpSlKUpSldnOjnOc5zmtfXnnnnnPuKUpSlKUpSlKUpSlCcw5ve973rWta1rfu+QGSlKUpSlKUpSlKUjzDnOc5zmta1rWue7UpSlKUpSlKUuYpGYDQMgKJ9P13IodeiZSonfffQoHIQBWkQVlTmeQkp3gJP77+2qqf2XM5gBzEjnNBzKJDmUUc5pI5+/bCnq97311VW4NbjB7yTkmZyT2jgDp42822wEAADfzbYkkq9aXsNLM+H4SqlS8kNtts6UH3yVFqlVJFqqVUWhveO9gA4ezvf333f0iieXkKo+Q1d3fpJPOhJJnve97vvZJI3dVdmbu2He8N73ve961rWta37sGgaBpbmAZCUJmYJQmGYJzDnOc88VOc517Ht77h55508t7wTJSlKUpSlKUpSlKB5hznOc5zW/PPPN++83+UpSlKUpSlKUpfrJSlOYc5znOc1rWta1z3alKUpSlKUpSlKUpSO8N73ve961rWta37tSlKUpSlKUpSlKUpTeG973ve9a1rWtb92pScslKUpSlKUpSlKU5hznOeeKnOc9/e+575nnnN/lKUpSlKUpSlKUpSlOYb3ve971zzzzzzzn3FKUpSlKUoPoMlKUpSlOYc5znOc1rWta1z3alKUpSlKUpSlKUpSO8N73ve961rWta37tSlKA8nJSlKUpSlKUo5BgqiHsCCakRJveIX9sKR/f2hRPsKJef39u5/c2pFzmiiHMSLmQVzJARz5gkjvvpSQhL5oED+++7u3fa92vn4VUknzrem/Wz4DoAAJJKgxtmw8fA2Gg767mKqr5dVbNVznvuJ26qh2blFZU2Fve9bj6Po3HmyVN76CWAgA+a+Yvvvvq7t3dwQkgPPzBCDzEgQdu7vQd6AFzW7HvfCEGz77d+7O8NtvlVSSSp2napJVT/hJtSSSTMzMzJ7tSlKUoUoUiQDeG973v+9VOc999991rm/lKUpSlKUpSlKUpSlOYb3ve971zzzzzzzn3FKUpSvpclKUpSlKUpTmHOc5znNa1rWtc92pSlKUpSlKUpSlKUjvDe973veta1rWt+7UpSlKUpSlKQrkuSlKcw5znOc5rWta+8859+UpSlKUpSlKUpSlKU3hve9756qc577777555zf5SlKUpSlKUpSlKUpTmG973ve9a555555z7gHuYpSlKUpSlKUpSlKcw5znOc5rWta1rnu1KUpSlKUpSlKUpShd4b3ve971rWta1v3alKUpSlDzMUpWYma0mtaTREayJRzIpbeWILyRUE5HfMQQ5z3oQU5ICD+yipzKqRzEjmEqcyROYu7pirqrqmKGlACMBJOSZnJUaOADckfA+BsNB6Yu6u6/E739+/e9JVfgRzPlPgTwqqsJJKkkhVAkkkkge973ve9ur9i7u6otJVSQHyAAMzMzMPFUorrV0q1a1dUUJZgoZmCZKUpSlKcw5znOc++VOe577717e+c3+UoGhKEoShLe+hOpSk6nJTOdH7nOc5zWvvPPPPOfcUpSlKUpSlKUpSlKU5hzm973vWta1rW/dqUpSlKUpSlKUpSlI7w3ve973rWta1rfu1KUp5OSlKUpSlKUpSnMOc5znOa1rWta57tSlKUpSlKUpSlKUoHdhve/2975+VOXt77nvue+YhzeKUpSlKUpSlG4clKUpHmHOc5znNa355555z7ilKUpSlKUpSlKUpSnMOc3ve961rWta37tSlKUpSlKUpSlKUpTeG973ve9a1rWtb92chyUpSlKUpSlKUpSlIRDneHd+FQ/Z+zBQQOQnOYKAc5z38giX5mqu6qqoapgzVWxVGVD6gbjAHqqqq/envZ933vaODQGw+B8bb4238230XrznAfj3X80bAAG2UlVexfve1VexTF07VVbEk73vUkhQANtvdU7Tbe223yqVUlTbDiAAMzMzNb92pSlKUpSlKUpSlKUDvDe973vfNqnvvvv4PffeuW5SlKUpCtyGSlKUpSlIHMOdc5znOea355555ze1KUpSlKUpSlKUp/T+k6lOYc5ve/e++++/tb92pSlKUpSlKUpS1yQyB7udHOc5znfffff2ue7UpSlKUpSlKUpSlKU3hve97+777/b737tSlKUpShShSlK6pOz5AYBCqpev3tLfdd7pbmi6pXaq7sABm9Ykl3d1V85znL9YAAFYv7F3NySqqqqp2ABgAxiaxJJJPc5yqqe6AAA53n3N9+xvDGYydEmb979998lI880KPMVE/e67ivezV1dUxVXVVVUZu7sDlsKAEYAOmXBo4NAbD4Hwb423822L117OcB+8qSVeKSpoAAfvSSSRwzJJdXJmZu7uoCdne/d73SQbbbbbb4kqqk2w4gADMzFmYb8Xd3cyMwKIORznPOc5vap7777777z7ZEVuAGOX9i7vd3dVOVVX6wAAL1iT1ySsVX79OwDAAGOsT7HvenJKqqxjGd7nYAABiax73vSSqqt1U7AAAJrEknpLmc5x3vec5c6AABMX9iSbklVfN7v1gAAeMYv7EnrqSqr1VU9vAAAGMbxifY970qSqre9zsAAArn0xpjOfYz3Ug6biNGRGBLAszBUbvEAAppEaBQpRDCEQ8xCD6vTDEILaq/eb+swBAxCDGlRPLu/Rd4I5IKPZGKsIhAINCQMbPqq8xZrISBFOCIlilqVCjmEMqYs93OocRRptFvNipobh89GIQeuyUDbeQ4doEGzMoEEEy4B1DqIJoIbkiupulkTdTmxG0KZIVscwDabkaIZDEIUB8OYRbPrpygEqJfu965+6r+z3vu6Z2sw74ocsSQvmCSFPtNLcsbZMFls+BH2V6K+7vffceJQmoY2Mhq1dcJHNu6Ud4kdJGaiOiR1rKm3TMxJW2bLJOut85z77nPpWYyIzM+CcQmTGJM3toBVXdV2rwaA5cuquqwy0BldOPqTVEWJkkYpYSMuVXVVm6zVVd1rONaHTlabNxjfTg10zznPB8yYsGIMYqMnIjDVebqrus3Waqqu84aA5V2NAffcu7qZGZIwwpzXNb555znPFRxVMxAwGRGL5qUa1lhkjMxYQzAq4ijiCYfpzoz/LfX7e97+34eQqhIlM7wXBwnEcz46++++++16ygxjmubc5znOeOOaLCRiGMYzLVGtGLWuc6znOc55xhizEoyuZCmTIa1z7rmuc5znsSuJGSxIwxlVWEjKmJGmrNc965zfOc45hI+nTSo0tpGTWuedc5zr7ng+spKqenzbbfHlJJNve223npSpKjRoADy7qYYAdu6uq7TLQAUBwPsAHTId+73uu96Nh8AAMfAcxis5u7pGggSSSIwoAFACMAHTIDg0BsPgfA2GgOemPe1n3vT1OT1a1pgSCKAEqSSSRGADpmSa+khvmgNh8D4Gw0BzzFa9r3ve96eGACKABQAjAE5JmSSHBoDZNSST6QbDQFe+5mt7333qurqsY9me8HTABFAAoARg6ZHTIDg0BsPgfA2GgOex7nve9973gACgAUAdmJJJI6ZAcAG5I+B8DaTMkknPe97Pve973umACKABQAjANt9b0223wzM++xADxtpJVVF1SSq7qJAR/pfJBB6lCKlBaX6+uilSu1VVdqXOcySQYavoHwAe5o+beNsCqVaqqVr5XZ73vcr3fePqAASXjx8A209ttvgBWAGwEAgAAAr14Gz93+/ZzOKi+90XuCX2KS6wNYhUH2YeOjW2AGAOqTVpJcutWt0rpUoabBNjTQJnxyIJCmgIYnPd7vdg0rbPgANNvzvM7rao972/AAd+A2AJA/O222ArPBoAHvCut7+4221SqqXVar1qqpUlpVXrVCZm+bABYN/NttoLAC7AKA222+c1vPX6zHj8/VVU1SoxVDIjJR+4MZobz9v9znOe0y7ukruldutP5/MACgAADG38223mgzY3omq7u7sPkLl0IBKAAUsr6Lr4Afi1hoDgGklXve972e8HOACMwAQJKhJV0D4DTbbafdVVJsQAXVUn73te97vmg8AAAFJUKlTpKnVLnOcKXFd2kqVXSVJNb78bAPH2NN/N428Xb73ve9l3V1TBQAK1VXvft32qu6rEqrularyvwcx4kx/NttnUkB8Hve4ve99z3j772eRIJA13XPd3b3we70gIW0Q0fF1rjbbrPAABhYHwA+UkJVST973vZ4nnve973sDpklUxd1dVwp340gHTJyxoDl0NPger1VVVeK+zzV5qru7ZxeMVNe1j3PT3u17zQHKqp5oDlUNGZi7upM1dSTUgcsaA4mZJJOQ0ByhokkkkgeulVVVeLuruue17Pvfb9ive9NDs3IYGTN3dA2JJJJNRNsnacAKA5k7V39V1V0SvyIAQJkUCpSaQQsKhholpIBQDxJEz1dPZ7u8hLvHT3d3dghI7unu73ds/G8yEd0LmfD1ovapINzVVc1vF3VXcnvJy7qrqg+qqBuqUAIwUB0yA4NAbD4HxJ9JJqQ7Xd+ve/eTl3V1PXfgJ6RdVdUBw8H1XdyTF1dXPYD3ZO973ohviSoAOAgAAApAgADMzewbBgAAMYmsd72Sdl6znOHe973GM9dv0AAAfmL+xJJySvqvnOcu4AADBm9Yue9clVVVVSeAAAZxNYkkklVVVVSeAAAYmsSdk1JVVW9yeAAAYmsSST9JcznOO9739zl/YgAAC9Y973rkqr5znOXcAAYAvWLuSSVVVVVJ4AABjE1iSSSVVVvcngAKqr7AEPpRD3MIz8ddG4MmVGv2d4/e/v3VI/c0QXOc3UXMiOc5zm6VimDN3dMXdUH1RgA6xJJJOQ0BsPgfEn0kmpDv1d9WaurmazmfVVI27N/PXnrVUkk1opKr0ruwb30QfL5pKjN8tbtItKkqRaPaD3t8Rp/Ug4fWeEkhcyGkCC3zc893s76Fq9gCjd+73tJKjevDbxttNttvtVVUzhtAGBmZnOHi1Felauq1arV1NIAkgVVL3ve72c6zNa1jWs5zjWmgMMWxJJd3VTnKq/ZpeAAL1iSS7uqqt7vsAAAzNY973pJVYxVVVTsAAAmsSSSSqxiqqqnYAABNYkkklzOc473GO973tzwAAF6xJJJKrGKvnOcv1mAAAvWLu5JKrFVVVOwAADHcJ9ifpJJVYqqqp2Ae1oBVAINIIdZggt7mR9fR0dY595j0KCL9GfYkABkTtIQHt+++3Ofd3d3dvcAFAe97ygSTvmQHBoNvj9773ve9vzfe31cqqXON+PXAANADcL74PjoHzBJUAe973r973he933ve956bbbfW2/klTbbeAIAAznOc4eLu7u7u6qqviOFRPPxzvnOc58b9zAXy8gPLHOXPwAAGO+xf7F3d3f72973fbAAAmrXcknu1VVU90AADM15JJJze973OwAACa8kkk57mcYzznOcnugAAdS/1t3d3fJ5nOcMd111+737t6gAAwFYyYMX9a7u7vm/VVVfbgAAC9W/XJJze973OwAADzKfR9J71fv03udgAAG/sZ+w+xPvSTsk97z3ve9vHvexpRoDhQAlSSSSdMgODQG0moDbj7ve63t73h4SST2pJJuSASTdVVzEmZEne973qQAHve896SRJJ6v36b3OwAADOMTWvs3vff0fS+QclXyZU8zz9gcz3p9jkm+8jMCgoKZMeZy5znOc81r7zzzznxwpUjzFSwyiOXLnLnOc819rWtc+54A5llE5jjmAKc63c5znOed9999858comyVMywjZzOXXOc5zzvvvvvnvOKmZYRhEWYzi9Rd3d3z0YxjPHHOa5c6/GAAC7+tq7u75uVVVfrAAAvUXcknN73vc7AAAPYZn0fpJJXKqqqcgAADD2999WMYzjG8Vj3379vnOZ5OyTfjwwARQAKAURgA6ZAcGgNpNSST6Hedx3lVVu9yCpyTMkkTMkknJ2qq2JJLq5MyMB0Zq7pNyT77HJDYAB73vJJJOVVVVTsAAAzNRJJJz2LZznHe973tzuAAAMewxf1ru7u+VU5znL9YAAF6tdyScqqqqnYAABmaiSSTlVVVU7AAAM5zmaiSSTlVVVU7AAAJqJJJPdvWc5x3ve/u9ufgAAMXq0kknKq+c5y/WAABe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73ve94YgAAH73ve97x7rpJKr9AkICQATBAC+j67+++++5G7u7u7vdxkDkgFW4AlUqru7wJJO3RTS02wAa+ttt++7rwm31sA86VKi9AAIB+0tXRo2AAIADYaqqQ0/mwe9Xve973ve97fh8E8AA73ve971ttuqbbbbu2ctUkqFSpIAwAOh9P33330773q96/fbYCBiEDaBKkkPo7njb75JUqSdUlSTvX32/qN7ABg2223irBOdx3ve9cjNVVs0B1M3d0x6rqqq/e5V3UmZJ3vvAMDQK9mrzve/vuV73vAACqzXqVJJyT08AZqqukm22/dtJV7SpV73ve8+t5mikkqAzAPeSSSSQAe973veGKq7qpJJPIABJJJiTN3dQ0NADsxVVckn0k6c19hSh9zQK7inQDN3dAOjXBrRm7uuD4AAGpOSZ3JKuqq6zgBHTIDABHp3Pcd9Xtbmfvu59yTz3TABFAAoD1VVVfveex73veHTIG5JqSSNh8D4d9iSduqvvfe89XvAB4A4e1dVYkknaqr8yek73ve994973ve8DbbYBaSoADuZmcCndq7/NaVq6vVpKtaJ9JJOzGVVLzbbcz12rVq6TvU1JJLuqqpznL9YAADFru7klVVVudgAAGPJ9JJOyqqqqp2AAATUSSfs5ziTnOc5VTsAAAmpJJJVzOc4773vdvfAAAJf1pJOTlVV85y/WAABeru/rknOcqqqdgAAGZrEkkkqqqtzsMGFYvGMYaVWMVXt5973uTzRgAoxQAKyZu7oE4awAdMgbkmpJDGx8xsN/D6u/erUxUxVdxdXeMdxfseD5pv4pKrXjSSo7VUth4NeQUlQ3uqpbbADy1o0df2K/e1y9j+bY+e4kq976qpe4ue80cL8HxYDfG39Tb+TA2ABiWZVVU7AAAGIkkklYxcznOO973vbnQAAL1ckklYxVVfKv1gAAS/ru7nJWKqqqp2AAAY9hPvpJJN73ve52AAPa0NYn2kkkm973vc5AAAJqJJJLmc5xznOVfuAAAev60knJve93VX2wAAL1a7u5N73ve5yAAAZmokkk3ve/05AAAO+/ftMNfsYziQg/pVX9DuDcKA7jd9IhuF3IC7gBHcCO4UM3gi7lUHcqVJUWkkXVKqoukkgfyEaAAAE2wIwAdMh73vd972ve8Nh8D22++97PX37r62HZ8lLqTSqXJublqqUhm6SdpfN/O6dqB5yamqqlIJ27T6/bVLmFNKug5gfuhJs5oO6O2FrRrF8zmknaRiSrSpF0WWWuAAWDpKlVIulnMYzjOcRmSPSSTe973ucgAAG83b++++58qa55975zftVV9kZgUFBQUe7953lznNc0qd+61vzzn3CTvEHMsouXLgBve/jEFVS1q9XatatWr1HqblzJPTmMYzW973fbWAAHqv98l3fL3vG9/r5AAAKn0e/e9JcznOOVW+XJ0AAC9fPV71zf779dfYq+2AABMX9pfbuTf79ve5yAAAZ3ufom5OTf799OQAADMwcxrOsfT9Pek8GQH3TBtGCDIDqmgOIxQB0yA4NAbO9x3u9usdr1EkkkqR973ve37HTIE8NA8d73vezx73ve95gaqqsGxgDt1V83v97sAAAmuu+kn0lXec5x3GMZ7O48xjGfenQAAL1xckk/a3vd1fvWAAB3F/fku7+n79++lQDBgDo9939rXe+9P376cgAAHOJ+iSVP3d7/TkAAAmo93s9+rEuZznHe8ubAAA7i/te1PeuV+/X+vtgAAd9i/13r9d8lfv305AAAMzU7qe9JzGMZ5ve9zsAAAx+1z3t4wqS+uL5UqXL2uZ9SpTmuck7I23pttt+884AIABQAjAB0yNtvG38223xvqi972YDbbkAAKCNtt+94973vUq973nJJJJIe573vm/m4AdPe973nve9OyamvSSV+/fv05AAAM5jU9qSSd4zbGMZpjNVX27n2IAAA/X9+mru7uvVVVV9sAACYv7V6m5JOVve9zvQAAJqTUkkre973vw5VykpaWzMMyjnXOZznOc8QfNa1rJ6XFda0ta1qtaSVa1NSakkne5mZk9Lu5egMM2u9Xd3dSZznHOc5y/Y66AATF/avV3d3Uqqqr7YAAF6u9TcknK3ve53oAAG6997DX379K39KqQEgDQAD63bbbYDAAG22m22vSdmJJA6ZAcGgNnfTMk733vQkngPEgHhEknv3u+979+/fvJJ73vRtttttttsSqlQBoAOpKu5mZh2AAAZmpNSSTnKqqqdgAAE1JqSSVve97nIAAB7F3++vV3d3XpnOcc5znL9wAADuGb+iSSe5VVVTsAAAu/okkneVVVU7AAAMz33ve96t73vfueAAAemJ9JJK3ve9zkDBhhk9773ve9V+znOOc5zk9wAACYv7V6kkl8qsVVX2wAAOfrx9eM/v2sY/b1NyTs973sge9Pex73ve8QDpmqqxQJJ2YkkDpkBwaA2d9OSuStYqqvPfgODfaSrevW7YTUk+qqXfFJUBzjb3X1fpJO9rvX4Pe96sbqqtJqbmJiePgbzj3fPSSS8YzjGJJ99J73u9qqqudAAA9f0mpJJzlVVVyAAAZ9r3te973ucqqrngHNaAHfffva973u85VVU7AAAJr3te9705y5nOcd73tygAAL1Jr3veu+95znOX6wAAL1JqSSc5VVVTsAAAzNSakknOVVVU7F6Y1rGDGDGDGDDNrvV3d3zlVVVfbYYYLAL1d6u7u+cqqqr7AAALa+97775i/r/fbYxjN3u79Xt+173veOmACKABQJJ2YkkDpkBwaEn0nHjTvdfe4N88D5J76TUkk2l1VyT9JJ32Lu6YfPfve973vA2AANtgAGAGgA73MzMPF3d3d3YAjGpNSSTnL9nOcd73vbnAAAO39d6u7u+cqqqr7YAAE1JqSSc5VVVTsAAAzNSakkqt73uTsAAA+n0mpJKre977OwAACMak1JJVX3Oc45znLucAAAvV3qSSX3vOc5y/WAABepNSSVW973J2AAAZmpNSSVW973J2AAAdxrWk+n6Saknve9rnve973PeAEUACgSTsZDY6ZAcGhJ9Jz1d97budeBmvAdM+0BxPSSekk8HhJJJ6x7nsXd173tT3ve973vekkmpJJzlVVVOwAACMak1JJOcv2c5x3ve9v9OAGDAXq71KknL7znOcv1gAAXq5qSSc5VVVTsAAAzNSakknOVVVU7AAAJqTUkk5yqqqnYAABGNSakknOX7Oc473ve3OAAAXq71JJOcvnOc5frAAAvV3qSSc5VVVTsAGLGjN6u9Xd3fOVVVV3eMRjGtOEwZDGRCSIhw22P6IzqPri3NX+u7v9OyABv40AB4LHxtvb802222202ySdmJJA6ZAcGhJ9JzjtdqqvnEYUeSSTknteAPSpJLq/B79z9PpJkkknYHzbbbbYAGJKgDYAaADvczMw8K1d2rpS9S1qTUkk70dVS973e3OAAAXq71JJOcq+c5y/WAABervVySe73nOc5PeAAAzNSakknOVVVU7AAAJqTUkk5yqqqnYAABGNSakknOX7Oc473ve3OAAAXq71JJOcqr5zl+sAAC9XeruSc5VVVTsAAAzNSakknOVVVU7AAAN8zqfZxjEeZQj9gRvKUvs3kRslsQoQJCpoEG1c3777IndrfuQINYAg6bn3b12AgaSSaSBBuQIQZfsVAIGxAILeU9gzl6ve667sjyAXgEEAIGIQYAgqBuziDzr0AJBG1V7eHIEDtrWjwwcxLdy8YdN32xsehq1OcEojb86t6w4dDQ2+gvIWsG1cXIUppgjBHvm+Oe/gXe9eevyTdvF1VVc73m865Pd9vwUBUYOc3zHOcHd3RF13d0fIEJpikCHomCtACDnW/Ovv3Pv3BFeYkbykjWIGMiMyZWRGUGAjWqTVRWkAI4QIMDSFI0AtIIQQkyNBTQxAlMCo0AEg1WKu8YdMkS7q6pjg0EururYA5z5Foua5znOc+5wkcxIyqMlGCMxEZYUZlSmZCMsSsLJRYsJGZznOc5znyRxnOe8ZEqqqqpgdMkYAJS8YvA2OqtQhC593Vfd3cGMBJCaEAxoaFSV0lSV0lVJX+AcADlUqpItt6bbbdMAjF3WMXV1dVitXeaqqq84RQiXV3dMBQSqumKuqq6EYEYu6u7xQIGgSQpGiH3d7uje1AIOfd2d3T2qlSdtvjbe4lVJABsALVJ0qr1qqpXdMtSTs3dVV0xeMDIDpiSSSdlAAoJdVqsXJOzHJAABJJJJAeqqqr973ve970kkkk8DIDsAEUACkmZJJuYAOmQHBoDYffUD5W1cm/td7qSDgyA6YAIABQa1GBxjoDpkBwaA2HwAfA1sPe773s+973jpgAigJJKkkgRgA7MSSSTg0BsPUqqqr9j3vfB7YaA4MgOmACKABQAjAB0yA4NA+kk+8Hve97xgCdkkzJA6YAdlSSSQKAEYAOmQHBoDYfA+BsNAcGQHTBJJOypABQcb3vf1E+5rnOc/XMEsgvs1MyC+xRb3pielSVVov7fAAaSp222237emwDnQZvBJV1FK73733vd7YADbbfOe799rt971+fACSakkmx73ve973vZu7pV1d3XMVdoFfp9N+99993d3d3ac0/Q2iGNpIIcBBlQ5TN7YUETEdAFJY4FAYY0ZhZn2HQQRdGSM5mY5k0/Rh0RVTlS5Y0YlNGYGdffffeee/fAl1V1RnDs3JN/SQ4AFKofXVJtt8bZYAAazvte97PePYJWrVJKqr3vfe973vaSSbkkABm7uu973u+XX2O6ju3N32oEGiEDQhMQJggNcRvG7J9JJ8ACSSSSAAk9VSrxd1VVeKu7vDIPe8AAbDm3n13aNaAAHdVSzMzObxtvjbbbb33vfu971vjmVOcoOJkQznOc5zmVPvZey9l7LnvuhcBfig5SNc5zn7z9+1XdewAd7jGLu673ve9dq6q6pV1dVgHOc+COCMiMEZYxIzOc081rN1eO5uq+++OcM0Ax0BznOc5yB2lSVU235235jSSVXuz4APdDSSptgAAKu6kkkkgAAVXJXe9+1rXe9QAAykmJOSTQY7PIAF9G1aSH999776Ekee7u7ud3fQCQSruvse9r3venuUDck1MSSMmbu6QbDQp9d3RkAAAAAPXd1Vb41VVVX7Pvb573vPpJPpJAAAADpkAPiau7ploJebxVRxiRlUZo1qSySZlEmJMBiBJvu7u7e1IQc+7u7eYC7UhVSTvG39jb+Pe0ve166EZve733nd13oH4slqSam1JPlLUM8FmwG35ptttttpvAojCSB0yA4NAbO+mZOc952Sekkk8eAh4OSSeD0YDbbNAAB4bb224iJS125JNSQO9zKqpPAAAIxqTUkk5y/ZznHe9725wAAC9XepJJzlVV85frAAAvV3q7uTnKqqqdgAAGZqTUkk5yqqqnYAABNSakknOViWZh4u7u7V3Vq0WtBoAO9jqqXvL3vScYMmTJkyZMmSsXq71NyTnK3u6v2LYMGDBgwYMGExf13q93c5yt73O4mGWGc4ZAzNe9r0knOVve52AAu7u7vteVovf2mHwAgO6AAfW7bbbaKADKmbu62H2yMAHTIjBwaA2d72u36Z7i7uu7973vb9dVPVVU222yndJV4VKnbb+YGg0qAbb60vnbb4i3gg9l1VI0d2aOHze2222ve38/2PzHnt+92Tc7qSSc5W97nYd1oABNWppfbNEknejqqXu97DErtK7V0u3d3NSal3d85VZxjNVV9mGCwAL1d6u7u/ucqqq+wAADM172vSSc5W97nYAAB7E+k1NyTnK3vc7AAAEe9r0knOXM5zjvOcuUAABepNeuSc5fOYxjPOcv1gAAXq71JJOfuVVVOwAADM1Pa9JJzlb3udgAAHvax79vf6mf2KDWsMY1zdVOcnu+QGQHTABFAApwaCMAHTIDg0Bs76Sc4bG2+MQAbAsD7ADoHw22/e97y973nAAABtttttttttucANHB5nNnJ2AAAfk+97XpJXbz1rOc44pn6cubAAA3f0mpdyq7VYxjNXy/WAABervUkk5yqqqnYAABmak1JPVW/03OwAAD2J9Jqbnqrf6bnYAABiMa97XpJO37WNM+aZznHXHOXPwAAGeYv6TUu7vnPc5jGM85y/WAABV/XepuSc5W97nYAABma97XpJOcre9zsAAqq+930AhxBDZhuAQ/d3nOte+c5z77iD4APVVKiKOS5JIN+abxt/NttPTA7GADpkkk3JNQGzve93skkj3ve973Pe973ve94ASSd73qSQGwAAAbbbbbOAGjgHe5znDxd3d2ABNe9r0kl97qZznHXOcubAAAvUmvXJOcvnMYxnnOX68GGO6xrTRhdyakkne5mZk8pKqlrV6VrV6u1atTUmpJd85W97vnc2sAC9Xer5d3zlb3u+wAAD2J9Jqbknuu3rOc47znP1zQAAGL1Jr1yTnL5VVfrAAAu/rvU/STnK3vc7AAAMzXva9JJzf79+nIAAB3HtV+9684xnGHWf37W7++m37v4DQHBkB0wAQACgBGCSSckzAOO/pJ3nvEiruqp4BJKAHvBdWEknve95vG38228SVNv5gAAAAGgA7v9+/TkAAAmuzXpJOezfNZznHOYxrPHu6uaAAAvV1qSSc5fOcxzl+sAADeL+u9SVJzlVvc7AAAMexzGp+k1OSV+++leAAA7nHvu/T70k5zlb3OwAADmMz733vvST3e47f7Oc47zn1zQAAHc4v6fT71yc5i+8qr9YAAF6k9965OVv9+nIAABjqfek+nJOczyt7nYAAVWeaPL74E/d49hLvxBE4IhIgLmSUdYTbJJ73oh5rRVlTnOhB5KCByQQ5IIalD4hoSJkIQVOQIpyHqCaYLmICBzvBBF5AAnIRDkgrz3AFUm7q/36fv37P79+/DpgAigAUAIwSSTkmYBx3uO/d7dVfenJ+97NVLu6kkkk8pAOJtvabbYA229pL3veG2xttiVJIADEWAAHg1SVKg1Wc5zmMyST6STWOc5X7OMZqp2AAATUk+kk17vL+znOOe725QAAG7+n0+9cnL5W932wAAPYv6XPpUnK3+/TkAAAzNdnvvSTnMcre52AXMjMIPeZvrfW+c5555rSDrXPeVERXKD1/X9f13d693k+znOOc5f7zIAF69c+9cnL5W932wAAPYv6XPpUnOYxjPK3udgAAGOJ979770k5zlb3OwFVVVVyaR8wRDzppMJaaJIEmC/Z+SBQedG99+c5zexVHnMRaUk+VJVNz1UlW6pJSST0k1G22+t22wtFGzJmqqwoIwIwdqYqQ+t6fG23j1097yuvXnySrXeAAu5eqpJePhAAdTbpKhVFZYHwLVVSsMJSVHpsozJO89O6nu1VWZAMAVVE02JVVUGqpJFnQPgDve5lJVmHi7u7uwATUk+k/Sc5cznOO95y5QAAHL+l39dXd973m936wAAPYv6TE+lScrf79OQAADM12e+9JOc5W9zsAAAmve996Sc5yqzjGaqdgAAE1JPp71XT2c5xV85fqAAAneavd/X9fLvlb/fr5YAAF4v71z6SVv9+/SoAABn2u+996Scrf79PN1VVVVVUpkj1HTzB+joukFK0n3vXS5PdnJALbbfzEAHQNDfk7o6YAIoAFACMEkk572vNtt4+9736tZxvfsE9sFaSoAA8B8353nva94TbG2/e94973httkkkkkkbbfElTbe4AHw3nNlJVzh0u7u7u7u7sE16T6e9VVfs5zi+97coAADnL/Xd/Xzl33veb3frAAAvXve+9JOc5W9zsAAAzNemJP0/Sc5yqznOKqdgAAE1JPpJOc5uqqdgAVUc5nOc63znPN++76VPfPOfjuN0WSpmZrDDGJ8v67v6+cu+97ze795YAAXqSfS7vnOVvd9gAAGZr3vfeknOcre52AAGD15xjOMXK2++Vf13679JPe9r3ve84MgOmACKA2H1ACMEkk5JmAcd73vNknjNPUDofeH1Ae9PeyEknpJPAG222223xtvYAHwB3vc5wHd3d3d3dgTXpJ+n6Tn3GOXM5zjv7Oc467coAAD9jHGM3+u7+vnLvve8qqv1gAAXqSfSSc5yt7nYAABjxPpJ9Kk5zlb3OwAACa9733pJznK3udgAAE16Sfp+k5zlzOc473GMY725QAAG+X+u7+uuXfe95VVfrAAAvUk+kk5zlb3OwAADzCfST6VJznK3udgAAGPzrGM4z9zOMNffb9997fu994GgODIDpgAigOmSg973veex73gdMgbx973ucb973ikkwoABoD6kN/O6VKnbtt/MA4UqDQNt422w6B8228SVe9773nve973vdkkk+kk5zlb3OwAACa9JP0/Sc5fUznOO9xjGPu9ucAAA3V/ru/r5y773vKq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nMNAXvvqnXXXVNJL6wpXRYSD+P597vft/UAAAW2220ADvekhCG9773QfGiaCK10QtvLohbeXRC28uiFt5dCaA0EVrohbeXRC28uiFt5dEE4QkkJPPPPLnn333e973ve96PpM+++++++L7Jl+nYbAAeyZ7JOwCAGBNQJIC77mpN6nwRbXRC28uiFt5dELby6kTUV46IIRWuiFt5dELby6IW3l1BNQ5JISQO+d99c9fAAAC2222gAHJM6SAc5vvdB8E0TQRWupLby6IW3l0QtvLqJqRXjoghFa6IW3l0QtvL1Mmta811udZJ5JMmSQW75XwAAAttttoABuTEkkk887Oph8EVrohbeXRC28ugE0K8dELbywmg7u92PnjIShKEoShKEoShPe931olCUJQlCUJQlCUJQm7vdtEoShKEoSg9GQlCUJQnve760ShKEoShEhhIYSGEhhIYkzMww2MYtadbZze973uAAAAAAGSSZ333fr9olCUJQlCUJQlCUJR8kz2A+97eiUJQlCUJQlCUJQlCbu7uiUJQlCUJQlCUJQlCbu9NtEoSkKPSZCUJQlCUJQnve99oPvCUJQlCUJQlCUJQlCe9726JQlAlAlIX0wDIShPQPvd9dEoShKEoShKEoShKE3d7tolCUJQlCUJQlCUJQm7vdtAvYBkJQlCUJQlCUJQnve760ShKEoShKEoShKEpO+ZLVTItFqlGFlE2qYWRfeOSvfv87/lTzCwuJ/l/3P66C1Q1TtU5Ic1TihhaqrguBcCwRiWFWVTrMyZnWZkk6zMyWZnn7+R999+9AAFttttAALbbbaAAW2220AAAAAAAAAAAAABbbbbQAC2222gAFttttAAAAAAPYdgAAAAAAAAAAAAAAFvvvvvvq0AFttttAALbbbaAAAAAAAMmHUmAFAAAABbbbbQAC2222gAFSTOpJJnUkzqSZuTOpL8XwvxfC+F8L2ldVPtTSHgngSwCIEBAnoTYTgEDfM8XPO96AAAAttttoASSZ5Tn6vq1LEtiW0LapWmobEjYFspVbIbUhsRsRmzVG20JtKbKm2yVNgtkLZSNqLZFspbKg2BRDNCo22VJsbCa2stYjVgZqswNmxIZIJoBaKJkCGoYgiKQWKmI3fnzuksERLRMoi8hKEoShKHLIShKEoShMQpkGAiqYlIgoKKiFWgiCj3sB9vrglCUJQlCUJQlCUJQm7vdtEoShKEoShKEoSk9ZCe97vrRKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlCUJu73bRKEp9BkJQlCUJQlCUJ72A+764JQlCUJQlCUJQlCUJu73bRKEoShKEoSj0GQlCUJ73u+tEoShKEoShKEoShKE3d7tolCUJQlCUZOupk66mTrqZOupk8zMkmQW79v78AAAAW1JgHBbb9JnsmeyZ+qk+Fgvfefvd/X2uZNk2TZNhO5glCUJQnvd4D31glCUKUJQlCUJQlCUJu73bRKEoSkL2LkJQlCUJQnve760ShKEoShKEoShKEoTd3u2iUJQlCUJQlCUvswShPe931olCUJQlCUJQlCUJQm7vAe7YJQlCUJQlCUJQlCUJu73bRKH2YJQlCUJQlCUJQnve760ShKEoShKEoShKEoTd3u6JkCRAPpyGEhhIYSGIBmZsyGHABnti950vjN73AttttoC2222mTC23cmd5M59+ff4mybJsmybJsmybJsJu7wHdwShKEoShKEoShKEp+Tgnve9oIPe97uiUJQlCUJQlCUJQlCbu7uiUJQlehyEoShKEoShPe95HdEoShKEoShKEoShKE3d4Du4JQlCUJQlCUBR6HIShPe97dEoShKEoShKEoShKE3d3dEoShKEoShKEoShKE3d3dAvYhkJQlCUJQzrqZOupk66mT6z9+/fv35+oAW2220BbbbbQttSZ32Ovpk66mTrqZOupkoShKEoShKE3d7ugwOYJQlCUJS3zEMhKEoShPe931qbJspsmymybJsmybJu73bRShKEoShKEoShKT0ZCnve760ShKEoShKFKEoShKE3d7topQlCUJQlCUJQlCUJu870HIShKD0ZCUJQlCUJQlCe97vrRKEoShKEoShKEoShO9526JQlCUJQlCUekyEoShN3x31qbJsmybJsmybJsmydJM9Ld+39+AFttttAW2220xfv3379+/nhcLrffu/ibJsmybJsShKEoSkO953oORHzMXd+c9Cdt5dAW3l0QtvLohbeVCbIK8dELdea6mTWtea6mTuSZfvvfd89/fgAAAC2222hbb7Jnfd8vUya1rzX0mdzIrx0QtvLohbeXRC28uiFt5UJuGgmoK8dELby6IW3l0Q2Ek+9988c8++70AAAC2221JjoW2/SZ6XwvS9L339++Zcx331139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oVhMkqwmiralWEyEWE0LCYlLCYTCaothDCZKWhNCaEwmEyUsJhMJgVhMowmwmilhMpQpqqRiSkGJpEiEpGZGhiWhKpRopFIlCphKUKmqCJiYSmZKaBaBKBKQKpCihqqBaoSlKSimhpCmIFaoiGqBi2VU2FbUTSYKtqGEwDJMlLatqDCaUssJqwhLahRWE1BTWUIwmqiK0iyq2EwmQKsJqksqqZQW1DQoFAhSA0UJVQ1KUKJSjRFVFC00ESwTxCBoRckSgiWkEpAKFKWq1kNaW0G1QbFFNhUtlbWSsBW0SG1JDZUorCaDCaEtilRkmRRWwTZUwmqUVlLSqmoZANtpGZUspbVLUNhWFbCsK2zWUQlJQIUKqUAUtFLFFRQBQJSjStIe97faDgm7vNiFt5dELby6IbCW75dELbyoTZBWU0MREShDEREoTDpjLg1s5tada5ta5e9732AAAW22208kwFkzkmfBOhOBPAmgmZ95dELby+BNkFeOiFt5dELby6ktvLohbeVCbIK8dELdea6mTWtea6mR69994+tttoAAAttttoDkmeSZ54Opk1rXmvpM7mTa8hHREJoFeOhCaAV5COiFt5dELbyoTZBXjohzm+aIW3l0Q13vvnnnj6222gAAAAW223qTNe+90SFLeX4J8E9CUhmbzRDXOckPOc5dELby6IW3l8CbIK8dELby6AtvL1MybkmPVt9r4AAAAAAAddDqZNa15r6TO5k3vfm+pk1rXl0QtvLohbeXUIITSvHRC28qE2Sb3vzfUya1rzXUyW3333nv3wAAAAAAA66HUzJrWvNdTJrWvNdSFt5fgmyCvHRC28uiFt5dELby6J31JrXnmtyZ3Mm97831MncmW333fPfvgAAttttoAACyZZM+kxJngTM+880QtvLohbeXUlt5dELby+BNkFeOiFt5dELby6IW3l0QtvLqQ4GPXuveevgAAttttoAB3ve9QiE5zve6IW3l+CbIK8dELby6IW3l0QtvLohbeVCbIemZlzRC28vUya1rzXUyeT177r3nv3wAAW2220AAB3JnfY6mTWtea+kzuZN735vRC28uiFt5IW22Q5znEJoC28dELrXmupk1rXmusm5M6yW228v3wAAW2oDYAHUmAdZM6L1Mmta818E2QV46IW3l0QtvLohbeXRC28qE2QV46IW3l0QtvLohz0JIBoCei4qpwWqlaLnBdiwuw993ML6C+nvsugq7qcxUapiiYWSWUMLVMgjC1TCyqGFhRffn379+eff379+/fv34AttttoAAAAAB7DsAAAAAAAAAAAAAAAttttoABbbbbQAC2222gAAAHUmAFAAAAAAAALbbbaAAW2220AAt/i2234+AAAAAAAAAAAAAFttttA9kw7BbbbbQAC2222gAAAAAHs1JlkmdSZ5F+F0LCxWF2XRel0I9LouUPCrC1UwtUwsLsu5DovC8LhdVPC+lvotVO5JnUkzrMzJJ1MzJqTOpmZkt893ugAALbbbaAAA/TP46k66666iCoSgooIZioSohoIkiaVCZYkHmAqvPnz50TyCkbYkJbSK1kbCWshlSIMxUzC0jAxBQXBMRM0QzMcQmyCvHRC28uiFt5dELby6AyO95zug4Ju7zbKqqqqqu9znbvrrrrrqTOpmteea6yTuTB77vnv78AAFttttAAAWTLJlkz6TPZMzPvPNFt5cCKr8E2K8bbbbbbbbgZve975Jm973vWta19fvfffffgAAAAAAA66Gta1r6TN73vaTLMzMy2222222+BFV8CKrbbcAn6Zk6kmdZJnz4H78AAAAAAAOula1rX6TNa1pJmta5vkmb2rbbbbahFVttttt/SQ+++99999/fu96AAAAAW2223uTO+xbbfwRVbbbbbbbbbbUIqtttt77754E/qpoK8LRUXIv379+9+fn78FttttAAAFt6ky2239AAHnPvuoRVcCKrbbbbbiqoRVcCcF2ttthLbb+khckkhNwJ1uTOT0892fvwW2220AAAW2222yZ7Jn0mWTPZM7kyZfffr9uTN73twIqtttttuKqhFVwIqtttyb3ve/2Zk5f1tt/fgttttoAAAttQFkzuTN9ecb3Jm973v9Jm973vWrbiqoRVbecwCKrznOc5bf0kHzvfLbf34AAAAAFtttvutd7222/giq2222222222oRVbrWta1rWtyTLbbbfvgAAAAAW22236SZ5Jnnn332ta1rkmb3ve9a1q22222+qrgTAmZmZbbbbbsAnAL7qnBYXlTguCwsLVNU9FyqcCwX8/di6F3UNF2EwsoahNFojCxQyHKhhcLlQ5U5UrCwjCylYTgWCyVhcVToXKnQuspVwWikYWqJlDhLnAuRbgsFpU5U4C4UZFsFosSyVckTgtFqmC4LSLC1Q5U1TgXKScqaLVRwX0md5JnPueTcmbe84KAAW2220AAAAAAAAAAAAABbbbbQAC2222gAFttttAAAAAAPYdgAAAAAAAAAAAAAAFttttAALbbbaAAW/xbbb8fAAAAAAAAAAAAAC2222gAFttttNyYGgFttttAAAAAAPZMSSYzMkzkmeyZ3MyZM6kzuS6C0h7IfKn0XSpwuSXsmbmZMzuTJnWSZknWtbu+VQAAAAAAA9kz2TOSZrRze97X8EwJmZmW23Zbu22222222223Aze973yTOZmZNSZ299177frfgAAAAAALJnsmfSZyTN7+59rWtatttttwIqvwqttttttttwIqu5MfLbb99aAAAAAHe973ve9Qm9972223nOW23nOc+CVVttuta1rWta1rWtaOc5zny34AAAttttoAHsmd9mvpM3ve961rWta1rWta1bbbbbbbahFVttt993mZ6effd6973vQABbbbbQAO5M7yZ2NatvwEVVAiqoRVbbbbbUIq71rWta1rWvj333333634AAAttttoAGpM5Jnng1rWtdzWu9a+kze973q222222222221CKrsJ53MuZ797790AAAAAAFkz2TPgngRfs+8FVtttttttuglt5fAIu971rWteeeea1rWvT333318AAAAAAAINa1rWta1rWta1rWta+kxVS2222222221CXQE/gBJDQE0ZmTqSZ1mZA4P34AAAAAAAeyZ7JnsmfTMkm9/fe61rWtattttttv4IqttttttttQIqqGSczMnUkz9+/A/fgAW2220AAADrofSTPec5zm5M5JnOc5zWtatttQiq223FVQiq223AnDNEF5kLVNVPAtfypoW67F0FypojpQ1T4WlUnYupD0vBcFdqnCxVThWiNFktguC0Rb6Xwvfn0vhfSZ9Jnc3JnN+b3v32gAFttttAAHUmAFAAAAAAAAAAW2220AAttuTLbQAC2222gAAAAAAAAAFkx0AMmAAW2220AAttttoABbbbbQAAAAWTHQD2Hf8AD4AAAAAAAAAAAAHsmHa2222gAFttttAALbbbaAAAAAAckzkmckzkmckzkmei+F+L8XC/F6Xpel0Xpel6XRciL8X4vxfi/F+LwXpVPSxQ8qdl0XtU7L6X0vhfKHReVPpdi9lDUsovwszJJ3+zJkyZ1v3n3vtX4AFttttAAAA5Jn0zJM86nn332pMyZn8TrIGZmZbbbbbbbUIqurby7t3bbbea61rW5M/TUmfv342fgALbbbaAAALfZM5Jn0mbkze3GprWta1rWtQlt5dH2BMzHPAmGZmZbbfFVVVd73ve3vfvvvvr4AFtqA2ADve973ve++7CbCd1zveqqqrbbfgiq4Krbbbbaqqqq4QgAUJ57r322374AFttttAAAFv0CcCfQlv333gTMzMxVVVVVVVVVVVXAmZmZiquQAgH4CahJJkAP34AFttttAAA73ve9QngS296qqqqqqqqqq5yDJA1a1rWtagyQNBWtZVrWoMkDVrWta73ve9++yZmdSTP379999999fwAAAAAAA3JnJM/ZkmZve/vvuSZ+0BPPPPPPFVVVVVVVehMzMzPAmc5znN73ve973ve+5M/fvffd++/vgAAAAAABZM9kzkmfZkk/ZmT3zz97+VVVVVVVVVVVV8CZmY83ve961rWvZMy/e+++2/fgAAAALbbbaD9mZP2Zk6mZk1rX79P2973rkIqttuKqqqqqvngTzzzzzxVXCZznOc41JnT33Xvvv62222/gAAO999999999973ve/SQ5zn33yqqqqquBMzMzFVVVVVVVcCZmZmd+Pvu973vbbbbbQAABbbbbQfZkknOc+++VVVVVVwJmZmZsV4qqqqqquBMzMzPwE8khykJqagTWgLMLMoawsfdwRmSzRd88ynP3Bci5uVNYWsL3UymVMKvdGo1KZTCxK4C8pxU4ArVTQMFgWFhYWC1TmphcVNRgWJZU/hXKqcCwjKmqYWC0lNFhRYWqmFouhaSXAuBchbOeefP6+ff6+/v379+AD2HYAAAAAAAAAAAAAABbbbbQAC2222gAFttttAAAAAAAAAAAAAAW2220AAttttoABbbbbQAAAAAAfwAPgAAAABbbbbQAC2222gAFttttAAAAAAPYdgAAAAAAD3kmJJMSZ5JinlPKd0r2L2LumFwLqnYuKnpfS7qn2pgvS0XBYJnWZk6mZk/jJM1zfu3tW2222/AAAFtqA2HJM+zMm5M6zMm5M3JmKn3Iecw98+fPprSLSotAK1NUVVE0wULSqUCCV9Pp9Pp9Ppu7uuBMzMzFWEXAmZmZiqqqqqq73vfnkmfPfd799+/AAAAAW2220FkyyZZM9kz6TPfffreSZznOc5tVVbVVbbbbUXAmZi22224uGZk16t1bXwAAAAFtt999973ve/SQ/AS2/v35VXwJmZmYqqqqqqqrgTMzMxVVVXne+eXzzz9+70AAAAAAB9MmSc5z775VXAmZmZiquBMzMzFVVVeSZznOc5ve973ve973ySZr4Ni/AAAAAAADcmckzWtDe1X4JmZmZsV4qqqqqquBMzMzN73ve973ve/Pvvfde++vgAAAAAAB9mZPMmeefffb3ve98kznOc5ze1VVVVVVVVVVVbb+8Ca0E8nWZk7kmfckz77767++/AAALbbbaAACyZZMsmfpkzOc+5zWta1uQi+GZngTvnmZiEVW3xVVVVVXe973ve9+e3MyVuHpt8AABbbbbQAAfTMydyZ515999yTOc5znN7VVVVVVVVVVVVVVVee++e6999++AAAttttoAAd+kghNBJD9JBX9+/Kqqqqq+BMzMzFVVVVVVVVVcCXUgT3vt3bf34AAAAAAB3qE+hALb999sV4qqqqqquBMzMzFVVVVVVVeea91JBkh8BPufvRcCnlU/VNU4i4LHIjSLCyXVT8XBdCwsVhdhZStUykcpDgu6mF1UOqFwXBGqm4LKGCwuqnQtVOCOVOVMLgTM6kmddzMkneSSZyTE3zu82UAAC2222gAAAABbbbbQAC2222gAFttttAAAAAAPYdgAAAAAAAAAAAAAAFttttAALbbbaAAW2220AAAAAAH8AD4AAAAAW2220AAttttoABbbbbQAAAAAAAAAAAAAFkzUkzqZmRJJnUmJM8iOCPKHhe1PS6Kn0tU7L93U9F9AaI+qn9C8L99+/fn339/PgAAAAAAB/GZifAGlGqrvcHkXfnz5oGkUtKUqUDSg0oFBMqIUxAU7WarMibI2Q2k1jYxhqgKaZiakApoClIWEKIqKiCiKqqKkqiamiqSmgIJWgKFRYIKWItGta0aNGtGtGjR555554qqqqqrgTFXFVtttRVbbcCbLQne+ernv793oAAAAAACyZZJ6E+CY/Zl8Vf2ZmZiqqqvgTMzMxVVVVVVVXn33nl888+/d73ve+++++++++9AAAADuTPszJ+zMnUzMner+/fsCZmZmKqqqqqqqqq4EzOc5ze973ve973vrmTJJot1fb+/AW2220AAAAGpM1Jn7MybyZvf33yqqqv4JmZmYqqqqqqqrsd783vkmc5znOeSYe+6999/fgLbbbaAAALbbbuTPpMzJ5JmutH2973ve1VVVVVwJmZmYqqqqqqqu+SZ0W23374C21AbAADve99999999+JIfpIW3779bbVVbbaiq+BFVttuKqqqqroJ3vnnnkJnn78BbbbbQAABbbbfZMST0J8EzM+88VXNzMzLmiFt5cCbIK8c2QV4uyCvF2QV4uyCvF2QV5vfcyHvvu/fXwFttttAAAd73ve973uwn0kNc5999gThDMzmZsgrxdkFeLsgrxdkFeLgThDMzmZsgrxdkFeLsgrxdkH33zx88++9973ve973vegAAAAGpM8yZ54O5k2vF2QV4voThDMzmZ8E4QzM5mbIK8XcivF2QV4vgThDMzmZ4E4QzM5mdzJqTK98937798AAAAAd73ve973ve9QlCfSQV+++2QV4uyCvF9CcIZmczPAnCGZnMyE2QV4uyCvF2QV4vgThDMzmZsgrxdkPfJIILC/guVPlU7qfOfzdi3wWFhcCrVTBcqZUwsS/FuCwsLRaqZLqqclDguAuQjCyiYSckOJHWSZ1JJM76yZJk5JmbnnFb4oAAAAAAAAABbbbbQAC2222gAFttttAFttttAAAAAAAAAAAttttoABbbbbQAC2222gAAAAAHsOwAAAAAAAP4AHwAAAAAttttoABbbbbQAC2222gAAGTAAAAAAAAAAAXMmZk3JM8kzyTEmakz5U4C8FzTuFwLunNOEq4D0u6n0vRHtT5UwjIuSknckmdSSZ1mZk937rW3tAAAALbbbaAHk888Hcyb3vze+5k3vfi+hOEMzOZmyCvF2QV4uyCvF2QV5cCbIZmZc0QtvLqBnvvnj7532hPfffWwAAFttttACyZZMsJ6E/BPPPPvfdkFeLuZqTMzmZ4E4QzM5mbIK8XZBXi7IK8XZBXi7IK83vuZN735vfcyeeSZqffe+c378ttAAAFttttADvJnfY7mTe9+b33Mm14vwThDMzmZsgrxdkFeLsgrxdkFeLgThDMzmZsgrxdkPffPLmffe+++gAAC21AbAGpM8yZzne92QV4uyCvF3AV4vwTgGZnMzZBXi7IK8XZBXi7IK8XZBXi5Jnkye227t++AAAAW222+973ve973uwnQmBEJxXvdkFeLsgrxdkFeLsgrxdkFeLsh6ZmXM2QV4vwThDWZlzNkFeLsh/Akhfe++3Pff34AAABb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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
