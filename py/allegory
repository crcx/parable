#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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ue8qgHfvAJcMbbbb9318zczYkBu7u7vt3QAAF23sBbQB2qknDgdAPu+X97qb7uqkmvvPOSc1N665fvfdfd3VSVf17fe8735bdVJNd2cDoAAAXbewAAXetVUk1N+bmtSb014FnYbAABfGwdPfIQMBK8Mvr25fd3M2JAYibN3d3N3JVt7AABe7c2C31tOAdqpJeu737154+9dLaACRNe83wOlz6tSSovetV2SVW98056+G6qSAOnoeA9DwF23sAAF3VSRvYC2gB5oHwucbB079rMp95WWlwBKpXoTfbaQBGAlYCXoca8zrQNnL9nH1903vAEqvoCT705Xdr3feflXrUlx11AlHsASqZhl12cXG+37H7JzJwBLd6ISaBLJIG+u/OvFe4oyMBKMBLjenclTe86eZ5nPV7vLASu8spq+e0v3ZTO0MZb2BbBlyXKqDUqvOgErugEmpx7zzYvOrASvbrNeaHqy+gJcAStkBttyLk9fnwWvjQ33KKbkQJbXdcNBA8vO3ddk172qqd7WAJdHmeeP2UwEpnKt+EgfWF9ld1nrHN7vejrubztnfZk8Al64uV1uXd+5nc8yd4AlMldvmaczvAEr7M523bye7dnq5jggVwj745uddVLH2oCCNPlcKAQAhV33N+fd9LJUla0T2SpN84HS5bewF8bB0uXG9gNgOnZVSGw3dm7u7vr731dbO+nD21V3OWkBVeMq9Jt/VVSb1prfl8mvb3zlrs3VSQB0AAALtvYAAO1UkNgAAAC+Ng6XOXNydvU59p7yuc3czY/VmcSAnXxdv1uX57yZvtzN3dwDwY9CzW9gPQ8B52SpPPN/HHnV21L22AAkSJE++n3vm/O2d4jdW1Ow7uztVfWc9l3pLSAtID3pJSEGVN5Xpg6KHSpqTcvnbIddpANrapV5wqEIyTfJATd1pAXoIOTHzV9+63sAAG+1UkPt74PugAABfGwdLvt1755z2RWvN75vc83PN+fA7OVUkOB0noeAAC7b2AAC7qpJ45wOgAABfGwdPqkHAJuqknd7moeBYB99vfOefc+3XPfKqSXfs+nj336+9uwdqpIbAAAAF8bG77d77AklQEHKg+92r9u+zN9MtIB5s94O2AAALtvYAAO1Kk38jx4LAAAF8bB07e7rf18efc8fDvKqSHA6AAAF2k3JucmgOrqpJpsB02AAC+Ng6Xer9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9nhkz3NZmczMw+g5Q5GbtxZbbb9oAAFyrv5zkkzd3d3voAAG5q5JyRbu7u90AAC75jZu22/aAABy5VlttvvtAAAueLLbbftAAA7L5i7+c5JM3d3d76AABuastu7u+6AAD8xN81ucnJG7u7vuyEhISEIkS5Vxbbb7u8nAkcbGpEgJHG/vvy/quh0uAHGkkW0HrT365WKu7kqn5ru7qV3R3VR+YKfdSfcVc+8qPuCn3EqSVmpJM1JKqQvkRsMzMzIAd7l3d7u8bTy/rt71zNSiRmZ9KqZmZ32pCkthoplKTnSszMxdVSlnMm03qm9Zayklnbby7WU0uYaC2U0UmUikkUkepNK00Uyiil4AIAxptpoppsppNoctqy222+zURDALN8xv5+c5JM3d3d76AABuastu7u+6AABua3JOSN3bb7QAAOXKuLbbb1HHAC5Vlttv2gAAdl8xd/Ockmbu7u99AAA3NWW3d3fdAAA3Nbjd22+0AADlyrLbbftAAAvvmZPa8yvvvvvfczMDYXavOmj217LAHezve97roLaueZMzPLku7uXd78zMzwL72u85znN8QZmgOsADOZmYAAAGV3s75JyTve97+d96dne973v2gAAXKs385ySbu7u9+gAAWb5jZbd3d90AADs3zTd22/aAABzuduZlttvtAAAuW5mW22+0AAC5bmZv5zkk3d3dv0AADc3czLbu7vdAAA3N3Mzd22+0AADly3My2232gAAV+eXr5JOcrZ+fPn5+/fz8/Pzd+7ve97sLv671d+3Z4tADve972fpd5mAzIBIlJI5AAAzvec5ne9Wu9zve973ve5mZgaAAOGZizMzMwALuwAOlVVUptubLY2O7ne85zx7xV3d073vn53h98zJmMMjmZMzMzc3czPm7u7vZ92TkmYwYwDc3c+eebu7u+95NYAbm7mZu7u77QAAOXLczLbbfaAABctzMttt9oAAFy3MzfznJJu7u7foBCOJubuZm7u7u7QAAbm7nzzy223vQAAL+/b8l68XleB76AJAFgGd972u84d73nV3MzMzOXrnOc2e9AADbaSzMzPASAAAzADMzKlZm8M8yZmeegDAAATve973t5zknLbczLZLbfaAABy5bmZbLbfaAAB+y+W5mW237QAALN35u5mfP3nJJu7u9/QAAPscvlufnnltt9oAAFzvczO973v3oAAHO53uZne97370AADud7mZ3eTkltvtAAAuW53zzf3nJJu7u39AAA3Lcvnl3d3e6AAB+7+Zfnnz8+W/bfb3ve53vemZeZrAu+3LwdNyVJ3fe973O9ubyZqJpWAbMzuNNK/MvdYgA22kveA00g99zMz2exd+Xd3PLsAPpKkHHWmg8B7US2gZUkk9w8znMzMzt61rWtaAA73vmZ3ve9+9AAA53vfmZ2ycktt9oAAFzluZ3y22+0biZkhISEhE3b5mfn5zkkttvZ9REPoGzd38/fPN3d33QAALne5md73vfvQAAOdzvczO7JyS232gAAXLczLbbfaAABctzMve9796AABdzd/Oz7fM/M/N/O/f34GwHTS7u7vtywHe973v2eXzMzPM7mZn2ZmHF3d+3ngPV1Kkvy7v8np0ptJFGwgHoAAAAAZmLAPADn7ftuZltt+0AADqZ3uZm/Ockltt/Oo44Afb5bmZdk5Ju7vugAAft8tzMttv2gAAc7ne5md73vfvQAALL5bmZbbftAAA6md7mZvznJJbbe/oAAFy3L55d5ySbu+b3QAANy3My/bbfaAABy5bmZe972+0AGta1rWu5MTznm9++573uZgbAdNLtQWjoHe913vcl33uZnmZmZgwDYZmZmF3d3l3eAwAZWZmfZqqkmZfL3vZ3ve972225mXve9+9AAAsuTy3MzfnOSTd3d2/QAANzdzN83d3faAABcvczO7ycktvl9oAAHLlufvnltt9oCaMJCbluZltt7L1nEiYiZnOSTMYERs21qS7v3baSkknmKqpU1yrqiwu78ADoAABctzM7vJyS2+X2gAAcuW5++eW23doAADrP3Z3w177vfmvfb888k5IAG9FgAdCjve87Xc7kcA73ve970X25NXLu7td3g4MzMxfZ3vesu8AzMzMzMwAMzMmZ9JUltvy225mXve9+9AAAsuTy3MzfnOSTd3d7+gAAXLczO2232gAAXLc+eeXeTklt8vegAAcuW5mW22+0AhHEuW5mW2976AACy5PLczN+c5JN3d3v6AABctzM7bbfaAABctzMu8nJLb5faAABy5bmZbbb7QAAP3uL4ckk5ypJOc8SSc55gk/a1vOYK2R+I1BXN97689/ea39919+5FfYFc8eb5vmxXVUwqvcKnMSvO/M78uxWZCswK8z7rPtPNXr97OXuvwIOgJQB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93znvOkrIn2RW5jJhmpqTUqSq1u7v7DpsB88o8Hx6HgPA8u7vl9nvL5Z78AHKA+PQ8AEu7u7uzQB02coHXXAPQ8F8u7u/bs42DpezygX80AWgLu7uZckqtNmZmZeaAcr777n0v3veX957d+X7ZzMzMzO55xcu/b+9l3jz0PC7u7u7sxqo1Te63qVzUlzUzk99z7MyuZoHoOw2NMldakqTvfu9ztyTGTMzMzHsh77ft3775d2eh02QAAAc736Z93dSVV+d89vMzADsrzU88888kld73zvegAXt9vV3u798vtnoD5qqkl6u7u7sAF1d3d3dgfefXkzefe52F3d3d4fDh8vd3d3fLCd068DtVJcqSq1Kqa1d3d3a6aAF3d3d3YAuT6N3y7u7ypKr3e7jWZnczMkqVcTTdVJACXqG6qSAOi7upUl1KkupUl1U1555zy7sD0PJKkHne953veumwHkqVQXySV2JLQk214dWmmm8TaXPKXnnTOdO4AAYAu7u7u7ElVKgAADgHw3JVUADRuqkgeHHDdVJB165KlVkkqr1UlVme+ZuqkmZeZ7sB03KlUB9d3d3dhyAfDdVKpd3f19vlgAAAA1N1UqgdLeZKqSu1qqlUc0BiwAAABuqlUW1JUg6rVVKrXe973verqmgC40Xd3d3dhdjdVJAesqVKmZmZ9mZie63oBZvdzhPLu78727BoOm1p49D70EehPBKlUkr4UmyaaUcnAXM292qqR036aWBezdSVWq0DlehPKkb72+8D0XvjXnnx573vfeyTeZkSacakm9tTsk1JJM8zMzed873fd9xc5ycS5fAAA71K7u7u8AeA9u7u+96u76u7v9UqT9mZJ57VJJuSSSSTIAZnqiA1tJOqqqoPv3no9+uesvLW02VtVbFspbQ2rO976Idyvea1bNtaotim1LWbMy22Nra1rNtVd7weIThzicScI4gjkSBByHEjkIHJwnJJOHDnAEciG7u5lySSEbkku7kkkE1JJLu5JJImgC7sAmJJqS21JJfNakkkiakC7sAASYBd2AAJoAu7AAE0AXdgExtJSWmq77mHnnic37v21PZxGd1WdvMwR3MzmZmYADwdnfklSfT6+JF37fsEGbgVmZmWCDN3bzMygQZmbr5mZwxzuuru+ru7u7AGVUkzPs8tqeNXd3n3e91d3IAETUkl3YAAkwC7sA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
