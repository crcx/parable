#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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2+0AADLyrxb3vf3QAALfKvFtt/UAADvOu/PN5mSTy3y29+AEIS8rvHe3d3doAAN5reN3ve/ugAAZ3nXeO973v7oA1rWta1rWW57qvPfKz73M5l5eNA+HiNm6kqgfEAc3znOZ9ruZjOZrJmXmbxmAABdSru8ODPczHgu/ru7u+973ve973vfffffb3vXeLbbfaAABXKvN+Zkk8ZLbfl7xPRwkM5OczHOc3ea3jf27u+/dzJJzjgBGVV42bu7vs1oABPW+a3jd3e77QAALyrxb7bfaAABeVeb9zJJ5u7u7fQAAPu+avF3d3fdAAAvKvF73vf3QAAM7zrvGyZJbbfaAAAzMmeMkzPjepmpj2Tk9199N5yswxmaALQDpuSpCAOcnOZO933tZle6qpJns8Xz2c1rXeVUk98975qSpPJnt4nczfLkqRoAmS78g5LvmdDM5mckqR6Z9eZmczO5mW/bbe9ttvtvF985bbfaAABXO98nN5Jknjd3d2/gAAGvdpd3d3ugAAby1vNt/reUAADLy9vOW232gAAMld7znO973v7oHOcACy88tb8zJJ5u78mpveAAAXlSZJ3jttt9oAACVV4ve97+6AABned6d73vf06AAESeszjNT57yeMzP39Mlt1UiQ2gTqMlsISjwHvEnzPkAgvXMy/cvV3d3haAAgDnOc5zfA9v6/N85x2/LfszPs7mZ9zDxJUl3d/pd3y9VUkxswuWBmZeZmZmZmZgHTZi222zrAAS85azfmZJPN3d3b6AABvNrFu7u73Qf3HOYYRmtZMk3kbu7u72I2JxwAlb542bu7u/qAAB2XzllttvsoAAF5b81mSTm7u7t9AAAGtstu7u90AADebs3dtvtAAAnV88ZMksttt/UADWta1rVc796qVPfd1Kmazvv2Zh1oGYtAAQBznOc5k7nMzPOX73vfO5eZd3u7u7One9y9d73MDMzAEu89aqpIO/Pffff379+7feu9lvltvsoAAH9eTzysySeZrMknm83d3bP4AAPOc3m2W3du90AABNbqTJG7tt9oAAE6vnllttvtAA85wLyqzJItt7ffaAABeeX5sZkk585u7u7+/AAAWb5yy27u73QAAE1uzd22+0AADLy1kyRbbb7QAAJ85+73++eee/e5999mdvt3q773Lvty7fOm/RAHOc5+/CX0AN6vy73ve9NDQD1t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O973v7oAAF+/s3y07Xkr7m93nPlsZmZm8C+du8F327u7s5yc5znALvWQXd4u7vAzOm133vx3veG7ugBu7u6AAAd73ve970PQMvFtt/UAADvOu8b9zJJbbe/wAAF5V47smSW7u90AADs3zTd3bf1AAAzvO3nOXve9/dAAAsvlvOcttv6gAAd53vOc37mSS229/gAALy3nOd2TJLd3e6AAB+3zd5zm7tv6iaOGQzDMc5l8t5zltt/S1w5Gc4REQfUZO/KAS+PUrqrz6u7vfr313d3R27u7n3e5v27O9/dXe973d/fv379+F8AAABbbbTKzAP2Dve97UqTvehd3d3d2MzMziTSAPDdm7u7u/HoBJAA+tSaWSLJycEOK8t5znmfWZJKzLb59vJ2TxwAOXy3nOfLuZJN3fN7oAAG83efPPL+tt70AAC8t5zl73vb7QAAMvLec5bbf3QAALL5bznLbb+oAAHed7znN+5kkttvf4AAC8t5zlu5Mk3d83ugAAbzd58/vny2296AAB33n9+577nM35qSpM+128zJO5mbZmZjtgXfbl33q/vnOczuZmZjNYBmYAu2ZMzLu+33vcxxcwC8AAD2SpAfZbbznL3ve/ugAASl8t5zltt/UAADvO95zne97390AADb5bznPn3Mkl3Jkm7vm38AAB7Gb5u8/f3z5u7u90AADed7znO973v7oAAE0vlvOcttv6gAAd53vOc73ve/ugAAd53vOc37mSS7kyTd3zb+AAAW8vnl/W3y9oAAG/ufPPlt99t73ve873ve9t97bbbery0L73t7qpJzjve5dy8makqTefZmfZXy03qqknzz3TMPKqSfcKlSH3zMz6vp3vne884XfV3dpKkHnIb22Hpb2movrju7r+d3TMz27u+1ttttttttviO6Iju9739tc5hhhhGccm8t5zltt/WIUAB3vOc7uTJLb5fegEIR3vOcvzMklttv9QAAbzd5vnm7u32gAAbN8t5zltt/UAADO873nOd73vf3QAAO873nOduTJLb5faAABeW85y2232gAa1rWtftX5q9bv9v9++zvf34NgOmgXfbl33q/vnOcZe8zMzM7mZ5mZmZ4u7v67vC2ak0utNLve3ve9N3phQAwO6AGgBeu97bbb223nOd9999/UAACy8nlvOc35mSTd3d7/AAAfr5bznLbb+oAAHed7znO7kyS2+X2gAAeJfLec5bb2+0AAC8t5zltvf3QAALLyeW85zfmZJN3d3v8AABeW8vnltt9oAAF53vOc7uTJLb5faAABl5bznLbbfaAABfuzzzzl8+75vd3u973uwHTQLvty7XbxzfPec9zudzM8zMAGDYGZmLu7u6qSYMzMLu7u7wyszMzkzMz02A7mZmb3vA61rWtaAAsvJ5bzm/MySbu7u9/AAAXfN85zd3d39P4UkJOccxInETnMySXzt5y7kyTd/t+b7rQiIghN5vvOc3d3d9k1oAbzd5zm7u390AADZeTy3nN+Zkk3d3ff4AAI60Q5JAABbjzMzMzMzqZw5JFu7u/bmAABN9ycvy/Oc5Lbbs9oAMzMzMWe+/bu/cTX2b79931NH0/e0+7oAecJmZmZeZrAFoXd3985zmdzMzMzLu7u7vLu8BmTMzt6u7y7vBeAGZgG7ugAAAJNpgEgNsA+MzMzMzMwBU528755m/cySbu7t/gAAN5bznO2232gAAbN83effNv22++gAAT67535zne973+6AAB3nvec7czLbf1AAAqc7ed88m/cySbu7t/gAAPd8vnOc7bbfaAABvW/N+c5ttv9QAAM7G9Ed3d2c222222223sx3mYQgQC5hXXXBJuuP7CvfCMRwFfermvnezJ3ar5yBLzAEuuM19ICVJJDABHMQllbaoBJtACVvauYdzJ0+9m3Xc/AgwBKAEqyqQJYAk8C3DioPPrhtoEmwEp9md16Al4WtHvRLM2Om5bT3HPMhoG9amoVtdEJ3AhICGAkwErrb+AJeutKloEtc9wNNDHjzfi7XgAHp95zfOc4A59sc8+yqj8abqpL3ue/37+/fv35CV3lHWEc0qbVGy0yjFNBOcJcJTjCXGomLaNi2qW1Q1k1i2NrZZibWRWyTVSVWpVa09A5cqVTQBcqpUaHbu+SQQC2N3d7t7kgS4aBJpJJglYVjIrWKtlI2hWskYJoSQMTSBJvu7u7vIEtHu77Xu9skkpoAtocHi6VofB77dSVVPd77735+/fvx5kpNJZphWitJVVr+AfMzM+qVUrNDYPDppwW1VDYISZKUJJBD7eO7t7QSDn26bu74n7ANv3vv73e++/nulTCsRTqak3oda7faklVeru+WeLlSo0Pg9/JNIAPAAxNam2nxY2mmv2bu83fu766kkaXq7u7u+mgC0PAOEDg8Au7vl3u7AAX7d3fuSSqGZ7mZmfB4C3dmwHTQLvty7u7AgB4tocDpsBw3d3d39dnvsB78AXL+1cu3OZmZ9mZlyVIklVmszMzAAzAF3d3d3YyNQGiv25Nor9qq6643u4Iz3+539z64kqRgHLBmZn2a+mtTtSpN+973zuZhAA9u7v27uwAUAfB6Aec5zJUqV9qqqqr7vfczMzAE7x91vObTmbVHNwxzbLm1rfNxsZrM6Dablw2HHLZzjc3PvTqwjycZMZznOZzjDPycniAzgzOOYTdTWq1qb379790ACu1JVb1O973vOvAOAgIHtVJAfDNazPru/LvndZgHMmpqVKqSZmeg8u7vHADvfe973unu7tRT6ozty/eQJeABMELziPLsfB6Lu7u7uwAXd3d3dskVqqkqtVVVrN5mZmZi7u7u7sB8Y9qpJmwPe9vHwAOXe7u7uwqpKSpolvfffffffffZHsj2R26Ffykn1SVW/vszMy80bqpIA6Lu7vtSVVxCT3e7u7uAS4BCGAk0xoEm+7u4u7u7vd23A6dBd3d3d2A1UkqoAJ2SVWeanlVJHoGAALu7u7uwABd3d3d2AAXd3d3d20AaILvv3cqSVVvN+mZmABqqlVd3d3fbAPTdVJB4AAAAu7u7u78A4tqSpAAe/Xzjvp367v3VuDq/vvr77773q7gAC7u7u7sHPB6Ogut1qSqpNUVqq3DnLENqA1YYFrQFrlSqaDpvtSVVVeruwe5d7nfp8I/d98zzvvnfXG0kbofwX32K2y+K28Vyfs5eZrPczBaF3d/Xx3vcvuZmZmXd3d3eY0AzMZgOXd51qqkjUMtoDdAD8Y2kgOG7u7u1FSuK40k15izEBiQZIYYYmJDJAzDIiWtU2mtWxPPPPOfkhddUr8leeZmbvzJMyfpBjMkZiCRu+UAAB37m+T5q8/v77mSTd3dv8AAB7vlPO9tt9oAAGzfNbzdtv6gAAZ3nvec53ve9/dbxzmGEScVbzl2Zm7u32IhoAanK7zf77mSTd3dv8AABvLec53vbb7QAANm+bvObu2/1AAA9HfO/Oc73ve/3QAAOe57zv3z552+W3tntt7zMzMdNAFoAd1VSTvd973vs8IIY2kvQOh+Gl09xmJNID3Xvz72NNLuptLc0OHQDxMDd3fvubm8D1Gc0XTOS5KkzN53M98BwuO35przTXoZnMvcBNgHxmZizHmMxTSby+tpK22+pr9TbIAAmqjdJIAHwsxNbN2Sbu7uprd3ZJomwATWmBN5y/m0lbbfU1aEkAAE1VbbJAAEnu7sk3d3dTX2Tt55Jue61rXfPJqT3PPuZ9hmw2A6aHY00WgDn3Nc5zO5ntZmZmczMmZMzM8FaHnC2bzMyqkjYXfLu7u37MzO5meZgAFtPpKkD39mZm97zKqszMxtAE3ntXuRtJXLi5bfE15aEk8AATVVtskANbRm7uyTd3eprve9knRN7u6rizHmJtIAm+/vYpiXsjaSMMC/vFmNYrQkngB5rSqAJIAak+972Sd73t1NbiSb5Uk3F4sSTfk8gBbe7u7s3dP1SVMy8zWZmYLQBzv3e773pYLu7/AzmTMzMzMwAXd3d3dgBoAAAbu75u7u+gBJAbYAJoAm3zyfm0lctt8TVoSQAATVVtskAASe7uyTd3d1NaASQABNG7s85nLG0kAeGJqrLbZJbbaJoAkm0AEmASQAAbW7+6VJN/c/fp+/eeX2/rd3d3fAODYDpoDvOc5z93MzMzMu0qpIAxd9Xd3hi7vvc73nddXYA3d3d3dCABAOgHZIAAJoAknjtjaStjuXLiattkltttqattkgAA2v2AEkADU1u7skAAE0ATznC+NpK23y40v2ZbbJPLbbavmrbZJbbbUmASQA3U0fG53k9baSVaTeNNNvNFT3qXVqVfmpPMfvnBXmlJ90o8yjzUu7TaWsyslHmiq806zNmreckqvPziUrzRtu40m7ibbVxNtN9aTVvbbLbd3ftaOm3ec5znABJUn7M3J+1rVfv3P379+/fXMD6B7P2YcHlVIM8kgNDMN7uiTTAD98k0jqMPPQA6ESSaCJpJmMAkgBuprd3ZJt/NpIA8TQBJNAATVttkgACT3d2Sbu6AmgCSAACagBPecL42kraX1NS22SFttqaqtvLzkAASZu7JN0YRNoE1xn7vMmUY1lrNrWV61XnTla+8bTaXnFfLbbraaauGNtpAcbaR4VpNeJpW23ttl3d3d+3c3d3d1d9jTS+z7Hz7347+P3s4zPuJNKAd8ESNpL7d3d01d71ppd1O5iwwDlqjaSy+g00t3737d3Py2qlSMD0ABoLkaosym0giaRgBJADdTW7uyTb+bSQB4mgCbzgBbU1aEkAAEmASQAATQbhAABNdAzktz82krbb6mrTNvLbba0rQkgAFqzHmNpLMatMsqtAEl+pxJ+4m4/YkosiSbxLmXy3tp+wHjJmZmdzM3gHTQHfec3znABkzJmZqSpMzMzOjwGF3L8u8u8d7s3Td+3d3d7pAAAKAAAUNwm73vU0Ld3ZJfzaSAPE1u7sW85u0BNaYbm9l3clXd3ub3d3dyp+Dc3szMyVGAZ7LG0lbbfU1quASAAJqq0MwABJ7u7mAACaqSb5zmS22+W3un4DPMzMxwbAdNAd+5Nc5zgBhuDQZZfgPozMypUmZl5my7u7vLvAAAFtDpvMyZmtZmZmZKmAZhfzaSttvqaFctJLbbamrQkgAAkwCSAACaAJIAAJoAkhfzaSttvqatthzltttTVoSQAASYBJA3d25mLEr7xbiTSNlznnnvf2e+39V/rB4Brg2FnTQHfu9zy7vl5nmYLvKkgDLg8kD1qpUjWazNg+u8u7vGhmZmZmBd3d3d2+aqpI2bgASQN3dTW7uySmfm0kQD1NAE7zgW21NWhJA3d1J7u7JN3d3U1u7sk3QATQBJC/m0lbbfU1bbDnLbbamrQkgAAkwCSAADT9z8DTTeFeYVxFkW+7oVor+/nBXgr983vcVzsV3/CuxHMK97EUAJM6pkHewXnT5rzEJOYrPRlbR07sKGvUXO2QEgJMQlACTPfDWYz40vHixwOGZ3qfz5MW3qlNFfOlNchAEoS28/e/vnv33+5XurZtYn0FtUYjKNpRhHFkSuSVkhorjixG/dfv379++wF+k+yh85STijdd9+u/fXfffu7UYMQyjdu+j0upKqSdkqV7VSR489BcqSVOVWpVVUqNHdfHq6u7u7u31VUiSVB6d999yPcowKsKzuhV7Fy6UaR1Ky3ffrv5+9877hF7UZQ7bijc779d+++++u6H3IJdZEl+xX4/ujvKLn935/ee/ffO9Yy2KZUmJL5DkLSNDa03FG5vt3X2fXz58oQYfBJKBAm0JQgMByAjriKxze+9+9fPffH6is2ZjIsTAS1Ak3m1sbu9iSSKaBLgEQxQIre+/u/d89999RXkMqenKBypznMJaE1RnM2JsxlzVOLTd9+u7vvvv57TXamwJsUslFyKxzWxR8a4dCuc0ta22TZmRWKtBM3vvfvx777+9CwrZslX2KxVze+9+/n79+IPI0/MEIhbO1vu6OsSQlqBJoEdHdXZ3PPzJrMzPszMSSpJ79sPeBJJU+Xe7u7u+DYdN9NXd3d324HakqjYC6qpGgAAQLv67vy7sfB6D0HweAcGwu+Xeru7C0BvzZd3Odv67t6toA6bAcHmwPnQHt3LtpzQFgIVUkW0AW0C/r7JKq9eXd2zM3V6qVKo3VTmq81Nazf32Z0u7u7wAesmVUkt5XvnuoHnOYvOAGu973veXbY2HTc6AAAuSpHe9++yVKq79v7MzPnd3d3G74LYJDQwDmQ0MYCOaSK3vda0enQAe973zve9ABxe7u7u8ZmZmZmZmYBd3gGNSSq+7N1Kqs9zM7mZdzWrvAWrQ973vlVJVd73odqXNDfd3du+ASWvd3d7u1JCwaSDmei+1Jdau7u7ODwHavV3d3dvsqkkqtVJVam7zzPPczMy2gC2gA5JQpQpQuQtvd3d2t7tqN3u7u9eefbsJEl3fl6F23sAvzsqTsqu1Kk35zmncmd3UkknZUk7znOGXkA9B8Xd3faqVKl6uwLlVKqcmpqpqtaVo9AqpKoDQ4PFh5VSqF39d3d2D71zQ59xweeZVSqzMzM7mZ4BweSpVF3f13d2AAAAHklVQHHc0hLt3d3fawSUtISlIS3u7u32nNKSPQfLZJVVySpWZme5mdzNyVIAPJVSqu7u/ru/JQHACIeG6qSB6D6B6Ht3d+3d2AAeDweZJUqZmZmfZmZ6C7aAWAA4c5z6SpLv776/rs9AABNdkkqbqSpuSua3uqkh89HigcPZdVJKNFfjVGXJUNMg3793+99996/Tk0h6M7/Hbk5rY9nx+/fB4D9nczN53Mzw6aA79zXOc4AXeVKAZbRug9hvNZgEkl0MzMxmgBu7u+e9xtJd7PO973d3d0AJIAANMAkh/H82krbb6mrbYc5bbbU1aEkAAEmASQAATQBJAABNAEkAAE1bbZJbbbU0YwJyrzy88bSVtvvtxtW2yfuW221JNv7FmIVXFkvCABrp4BwbfB66acHmZeXqqkl3d99YbNxtJbu/aHJ8HgAe9S7m7mbjaS3TMv1uW+8qpIdOMzAyZmZmJKkzWYIA3i3N39vfeZ0+3Yt0NCYABa8xZmY2kswy3lmW22iuJUtmW2/rRNB6SQv5tJW2+XE1+Vts85y222pq0JgAA2tSwOEkAAE11IISKAACa60EJFC/m0lbbfU1bbMttttTW4/bcnJ55afAAAcACnwEADd+3c37dm79vn7u+9++7mZjMy7vV3d3u8+773zfe96thUqQ+XfmXd3eW0OmzMzMB7d3ec4PcAPOcSaXAANTQBJAABJgEkAAE0ASQAASYCJhfzaStvFbE1S2Etv621NW/jzkAA6mtQQmAACTNCYAAJoNMAAE12ffTp6c/fvUnJmY9DwDXNDYdOmgO+85vnnOBwZQG5KkGDo9B8qVJmZmZ8B03gABd3d4W1mZmYu2aXG0lbbfU1aWS2221P9mY1bbJL7u7u/dZkkIZkkNt3555u7u77rMkhGNpLMoWS220uNpLMeYk0sWK22SW22iuJNLFizEmlnuW2yS3621XEmkiEmSJu7vOc37/Zkk3d3fs/kmSBCJpYrbZ5zlttte4k0sWLLbZJf1ttv7JiIZMRNXb8mxhPjOT79+ffvnn35u7u3MzM8zMzHBsB00DJl/dnd97fczyB1q8AZmXd3d3drwLu8Xd3gN3d3d3d3d93QPQADdA5IABRp4sWYk8WK22SW222pPFizEnixK22SW222tPFizEnixW2yS2221p4sWJZbbJLbbRNW22SW221NAEkL+bSVtt9TVtskttttTVtvnOcoAamgCSZmZmZVTW9e/b81mZmdvAD0HweAcGwd7znOcALu7u7uxd3d3d28l5d39Kq7vGeAcAA+D0A3RAEkAAE0ASQAATQBPOciC8bSVt5cbVts3nLbbamrQ85zgAGpr0AkgACT3d2SaAAmgCSAADTAJ40uYlzGF42krbxXGnbbN5y222pr3979czF5zlPf34+Dd3d3zd3Q/AHAA4Ng71JUne973K5zGazz7VVJPsx99d3d3hLu9SVJd3d27d4HtVJDMzKlSZnMZnuZmZmAAAAb3sDJGASQAATQBJAABNAEkAAE1bbZJbbbU0ASQL8k0rbfG1bbJLbbbV6sbzHmNrMtt85zltttMxO23znOW221DdtsktttG15+zoQ9+M+DgGZme5mY+DwP2Z3MzeZmO95znOafB6WbkqQ8BbnfL8u7v91pmwcu95d3dgzMzMzmZmAu7vHJKku95A3vZmAJoAkgAAmgCSBfm0lbb4mvcWW2yS222poAkgAAkwCSAACaAJIAAJoAkgX5tJW2+Jr222SW221NAEkAAG1+98nn5ZnraTCNlaTd78dvblxLzWk3Ll40m7Y0m/Gmnf3Gk3bGk3b8k0740m/rbeX5tJXPbeb1xsHe81zXOb5qB7KHl3+Po1uSpDj0Cfd/d738boNNIGmkBWk2MAAM/AAF3d3d9vVxrmper/VJVfvt1JVRAEkNttE0ASQAATQBJAvzaStt8TXttsktttqaAJIAAJMAkgAAmgCSAACaAJIF+bSVtviattkltttqatt85zloBqaMqSb9ikqs/XnZU+9+9++999z37uZ7d/j0HwedNjg2Dvec5z3gj4DKzMzMzMwHtVJAfAe1d3ft3dgBd3ffpKk7n2b72GibR+hu97u7sk3QAbqxrMVtskttttWYk0sWLMSaWW2yS220qzEmliIpiTSyBJA9/NpIA99WYk0sWZiTSxW2yS39bbV6sTSxYgOc5wAAMzESGTETd3ec5u7u7dZMkRCTJCxoCSAAAk0sWLMWYk0sAkgAGiWYmkszMVtskt++bSVtvq9aSnev0ZxnfXBX8SyqbNtnfv9zpQdfyM+gEslCSG/RECQnjhniLHAEsiIZzOOc259550K5Udao+d7ij75yWuAEuztpYz0CtktA2FT4BLIoKuGtts22LObm1rYqeitFHf7+nvdOys0Y9bJmUT8Nqqy6+dPyZnvfBCT2SScJcw5ASYhFCEg6a2vdp3zQEFa3VSTVSqqpU5qpKpq/DouVKlNdALagPi5KqpJGvQFyVKqp7Pd1JVSam63JKqk0fea4X6dLu7skAUXTTwLa45VSpU0PTpvKqVU155ndZ8+V8v3tuhAmJIK+cgQFJANCAU5lfe+15/DmMvDPM0D0u/bu78u1yVVSpXaqpNVKad9Ni5Ukpo6aH1ySq1qta1KNBZGe733v96999/Ko9pWKtoLl33cvd3dutNS5KqRoFm/effpKqprMz7O85mYkqpVTfuwfLeVJVNLu/Lu7v4PAOGru7u77bQgLAAAA6bu75d78u7HOC6qSX888H3o+cdOeg+DwXf13e7uw6aAvty7u7sEAFtODwdN5JKp5qqkm83mZmcxnaqSdj57617fz1pznlVJHXh14uSVXHtVJPD729yxuqkno8cXu7mhxtJHwGAjY2ku9793u/av3RJ7kN8yEhnzEgId5WfM+X8983vVpCQERQIJn3X3d7r71JAXBs9E5PX8E2EsO0kEHte+i7ube/MvfkJAd0b093X3QkBj7oDxp3dVJLePRs3VSRd37d6vE8qpJoBD8I2NpLf2tYsmz735DTSXPVEk3+QJNAltpAT7c+fO+d2pAQCDo7undzWhIlghY2IBoRrBBm1ve7OfNIBoHec8vVVJNtVUk0+8He2E6e+DrXNXd3d8tHh6NH3lVJNeKu/b5c7jntUks0DwPhDbTMefuNpLA3m7ve/NpKfsSAez87u73M6oSA8+6evb3YSAexu73dfajpSAyenuvZ3yEAiRgIaaSDaSAjdnd7Z6w1NLqSAnuuu6iN8jHtJSTd8+v62jdVJAOJeqqSXd3d31PslSfTPaqSZmdzueTJe6qSXdzy/Lu7HdGz4KfaXd3fNXuqklueD0B3z1NTyX9d/dv6x8HoFX7zvfe9ypVSpMkqSVON8z0zM++qpIH3wGy7u+dlSVV6uwLlSSqaAN1Uqjptqqkjr03VSQJ7d6uxd+9u7u78jYPKqVXQTg97kkqSZnkzOZmXntVJNyVIDhdt7kqS93d3Z3dVJGgL43uqkht8HoAbAdceVUqvXsu9X9y7suABAMqSV3MzzMzMzdVJAHdF1Kku/rvd3fgHIAAENB8eDg7u9VUku/bu+X9oeA+PKqVR8Hb/bDuJps6Hc759yZ44sWHIefjG0lu73u97d3d3q3B5sseOjOAGAA7767u++/kJcWgX6K0D8xHe/Xzi1xJUrQDsklVPpUl7u/bsb73v4Efx+njSb8kTSb5+v1v5pN3E02luxtp7TiaTZjSbS9DhjSbD8AcA3d/bu75oeu95znOE99BwrMAzMu7u7u7Xd3dyqkvGmZmZmZgFSpF3d973q73ed3fw0m90402u40/QJ/H1eeRpJ27xpNK4m0lbG29xtZjeLEmrbZJbbaJMAkgAAmgCSAACaAJIF+bSVtviattm85bbbU1aHnOcAA1NAF5zltttTVAkgAAkwCSAACa9+nJ5mZM9zMd6u/bu7fAAGwd86kqTq/rvn0HklSHXrxWSe5mZmZeZk8zWZiTSADgfd8+/b98d762khppbogAN3e9737777e973d73pu7ske6ACaAJIwABNW22SO222poAkjC/JNK23xtW2ybxW221NfW3kgfgDxNag4ecgAGpo3SQAASZukgAAmtA5IABkqPsebzzPM+5mYcX7d3ZzQADYfsv299773mfZlvS7r8PQzOXgBl33vvHfMu8MwFtLsA6Bd3gbm7fm0lbb4mhW3km2221NULJA/AHiaCByQADU0ASQAAauK22SW222tK22SW22iaAJIF+bSVtviattm85bbbU1aEkAAEmmksWJNJSTWpUlTVZmAv9d/j1d57d3d4HobfDvec5wi7u7XV3d3di7u7u7sqVIXfe9/VJVXd4ZmYBzy78u75di2j43RegSQAATQBJAABNAEkAAE1bbZJbbbU0ASQAATVtuZbbbamvgMzgAAmrbcy2221NAEkAAE1bbmW222pNppq42kk3uJNNrkVlSX3999+ij8tUbKNqfPOJUzXuqqpUqW6X999fvHcu+fj5d99u7uwBsHne885y2l3d2uXd4eyVIZnc5sAy7u773uXd3YAXd3d3duL3d973poZgF+SaVtviattkltttqatt85zloBqaAJIAAJMAkgAAmgCSAACaAJIF+SaVtviattkltttqatt85zloBqaALznLbbaYk2xYjEk3iWcd855bbdTa+tPEg/cCL8btvv78v67u7vGwd7y+969S7u7XLu7u7fswBd5dyqk73tSpO96u2VUqszGfb1KlUAeJNsIaYeJtNmJgABm953vfyTS7d4dtvnOcttDU0ASQAASYBJAABNAEkAAE+4kHCSAACattsktttqaAJ5zgX1tJW2+JO22bzlttE1bQkgACT3d2Sbu7utr63d53ca/e/vv3vvfane/v2fmazD67t++zDgPjMzz7Md6kqTnOc9XdvZKkL872d73q14NyVIOQzpoXd4v27yqlUbqpJ8GczMzMaAOpNLcLmJJu0AP3wcC2yS2gCaAJIU+bSQRNUAm84ACa3e9kne9NokwCSHQATQBJDd3dTR7iQBmHoAmu38kcDMPbbamgDMNvzaSPg8bR4EneFadttTXt7V0zMS88/T2+efsV72+u28Tb7jTtvH5bfgOB99xJpXve+fbd+Xd3z3zv73fvPuZjt4F3dg/Zx8Hq7P3e979++zfhJt93dA+uYkm7E7bbfzabtoetpsAAzd73ve/boGyAANrU8JuyTQAE1rRgSQAATQHS8lvnW0lbeN+W23ibSmTLbaVpXoSQttokwCSGgAmgCSBu7qaEAeybfG0kEOxNXPx4GYB6amt75mTcc5p4mrbbnKzMzM+5B6XfjB9fL+v279vvZ+5znMwYGAFsAXeKlSF33ve97mVKk3eGJpsA8QAQAN37d3fu53vat3aW2SU3d1NXPzWAGZ6Aamurc3cw3d3U1u7ueQSaQX1NpW3jattzOgFtTVt9swABJhuyTd3d1NCAJIAAmt3dnnOTdvEmkEMSYBJAABNeZ5yeXTz7vF5793t/fr9d73aqrbfLb36/rfeYsTv60DMvvf135fe85z6+C7uXdv0ALYQF3l3d3uqmau7w52qlUZmZgqpVOm31bibaa0AD8BzN3RgcCack3d3eprd3ZIAAJMAkgBupoAJIAAmt3dkm7t62kgiTAJIAFtTVts85y2m/Jrd3ZJu7u6k93dkm7ugXErTLLbbRNd95+8+sn18SaXiSbKkLFc754uJJvnO+cP7hx3I2iuNue7oLrNzmtKBgJMufmfVevPIEoqJmAEmblEt0AmRn16raYAk+cYDASiIinCBKYggnZIn02zYir9RvoMbQJZvq1uLJadg0IdTE20Cl4RFuAZab6YASYO/WG3kRTGAk69pGugQNgJOGOAErZvznj904YRyYOIlx9V05dfVer56p+p+tqAEn6L8SIQ02kkHRf1fze+cIS4c8AASmItE1QybbNFrO8FxVTIEm93d97fLQEmAkDYJvu7u7uEJXNSSVG0N1UkBU8kOwcF1JValSVUnjno9dXd329XdqgBRcr3dSE7a5aqVdINIm1sBpdb58+e/ny+S/UjVsibRGoa0F+3vvvvvv73fwV5wq9ZVtUNmg1RmUNI+qNBxayjAyDYmxsBtRWA5v7+/vn9/fG6sWZiTSxJJv1JtRptr33+IB37oRuNqRpsRrYkso+8777777/O+4r9FZK95377777376n7GivDhVdaqXVkTIppNlUcwDhae89+e+/vevfUr9NURmbSBiNSaZRs2WzbayjLvm3ffvv33nvsT2RvcQ02sbZgTYNrWptA+tOZssxKdc998+++4uVJVe7SVKrWvA7LupVTsvV3diACwB21VJU2A4TWqqR4B8HoPQfF7u7u75ZsB0Hpuqkg8AAC7u+3r98Mz7M7mbBf13fl3dnweg9B8HgHBsF8u9Xd3YtAAQAW0AdAGp5oeeDrg8888A73AGdzBoLvV9u7u1sXuVVVrVSt1UlOZ559mZ3M90DgZnMzM9zs7znOczMvAC2pd3d3dmh6FuALsA4bvy7u7yXom5JVPM++zMzAKlSXdy9SSSa1VVJWtVVeareqk+3d37awAt7d3ft323DdVJGgeLu7+u7sHgHLsF+Nunrpkkqvu88klU5nPMy7y804HpYG13cu+XdhogJ27qpUu7u7CgF9vV3d3YAPOXe7v67tklVWZmZmZmc+u/L9u7sACJKkSVJd7ebqpJ49BfAAd753ve+9DZuqkgPj1PJKk8vJJVXvclSPeZ97y8zHgHAF3d3vl3ux0VJVXVSTTYPGnslVXtVKr0LXdt1UqgHSC7u7u7sAgaHhlSVXmqqVKmZnuZmZltAHlVKou7+u78lDY4HwevR054AAC7u773XV3d2tqVKryqlU4PHvFuZJKoeSpUrJn33OZmYAF3d3d3YAeVUqge/Xd+3d2AAXd3d3dgAALa7eXnnue5me7zBwXd3d3YABw3d3d3dgA6bqpIG7lajYOlVVzVVJVaqSq1qZRsrvnfffffffcpfKjBbAahJibEkk2NNHR3d3d3HszPny/kyr9H2vLvjSa+36lvnzttt/H1tvlod73v33bu+b3vOeq++u1D0ZmVKkzMzMzMzMwF3eX379+/b99ve7u7UbeZiSbAACiMxJN222227u7trTWYlaZy8948xNrMbVsSaV5vRV5wc1Dzzouisq2hbVEllplnltttTVy2yQADU0G4QAASYbhAABNAEkAAE0ASQD5XGmlbeJry22SW221NAEkAAEmASQAATXfdNhPPMSzPfJy/vff3jTv1t+zTNbw+D0AXd3fl97znElSc/ZLufDwA9SaRugRfgDiTSADfxuiTSDMzOXd3dSpFtRmZmZgXlVJCpUgbob3cSaW7s3d3d34AJIAAJoAkgF62krlsTVtsk7bbbU1bbJAABJgEkA3dTQASQABNbu7JN3b1tJBE0AST4C21NW2yQDd1/9mNIAkgAampi7jaTeb6sWPFdnvp4fwu6WhmHwegC7u78vvb7O6zn7q5+8/V+Z71+8Xd3dh4fXd+Xd3xdSpLvvex3KqVVmgB3pu6AHQA3d3ebtbadzbjaSueXtsktoAmgCSAXraStvE1bbO85bbbU7QkcAAtbVtsjlttomgCRQAATXQhMAvW0lbeJoVss7LbbamqUmAACTNCYAAJr9xfn0amSr9mO3v1pe627bbfnf1tPADfNxJpbuvQa93d8jv32VzMmzGmZ3JQAwu8AVKkzLu7u7u8jVVJGTMzPZWLextN7jTe7u6AG7vdzd37dh0ITAABNGhIoBetpK28TXltsy222prUEJgAAkzQkgbu6mgAkgACa3d2Sbt+bSQHE14ASQLbamgCSBu7qF3d0RHd3dwjGhBp7Yfy7Pk3bvLmqr5nzMAfB9v4OelnweLvk5z77clSX3nnNcdtfLvd6u7F9u7u7X3vOcd7kwz3MzAXd3gONnoLzMzN73mZmZkqZmEkAvW0lctjattkltttqatt85zltA1NAEkC221NW2yS0+A4mgDznOAAamgDznOAAbcSttklttokwzN73mZmZkqPOdd15v3OfZ33uXefAfB6AAcenuZcu+85zNVUk8Xd251gBhd3d3du3d971fbuwBlVKrMzMADd3d3N3d3QNJIAAJoAkgF62krZcbVtskttttTVtvnOctoGpoA85zgAGpoAkgAAkwCSAACaAJIAAJoAkgAAmrbbJLbbamvtn7Gk3ycZiPD9VvLuq+3fOzLeAegHgAA8Bz9eX9JUne7Z125KkxmZv7M9qpJrMz6SpMzLj67tJUgPr737mub8Npvot0ADQxtNgHjaSAAPyMMTM3d3d3d3dkm7traStvE1bbJLtttqattklD4DiaNpeS222praF85y222pq5ukgAGpoC3nJbbbU1d23nLbbamrukgAAkwCSAACauTSTeeKT3iSb+9/K+/vL3y3eqk/AAfj4DgBgAPR9zuXy+5vnb6u7/fszMzLzNl3d3d2vupKk7znI7lVKruqqVWGZmZmLu773ve7u7u7u7WAASQDd2poAkgFutpK2J+W2yS220rStvLzkttt1NAEkAAEmASQAATQBJAABNcAJIAAmqASQC21NAEkALraStiT9+8WYfd9vlvf3775dJQAP1vbby22gA9Du+e+8u+65fbzADC+973vfmmlve9++++++0Sbe5EmloeGJpsDjabNDxtNgB62mzLmJJu228u2y7+W7u7uyTQAKmrby85KAGpoAkgAAkwCSAACaAJIAAJoAkgBdbSVsbVts+5y222pq0JIAAJMAkgAAmgCSAACa1b3i3Gk31eezJ57+bSR7Uv379e3qpAqtt8VvbbwA0adZypUmZme5mfY+Pt8+37qOXy+9ndWv27u/bsHb1d3fe972pUne9u7MqpVZoeVUqjd1ppaBrAD1tNgm0j4OHnQm06gCSABW0lbEmrbZJe222pq28vOSgBqaAJIAAJMAkgAAmgCSAACaAJIAAXEsttkltttTQBJAABNW22SW221Nc91e++6/x32TuRoJ9CBLZaBKJPcAlJsxDPnrmY9duPZWzNXcTuddYPjpvc9Pn1iQbwke+Gc8Xkxm7HtdXPvm+v0e3HwCOA1oUAATZ3RYD95388/v73+v3oJzzOCroR0yV1aGLrWyRwVto4qc1sE5SsbXDTLm4tzhzW2a3OUjkTYlaoW/fv3z9+/fgX4SaQhNpIxJxz7r6kgO7ptAk0HIfH3gHAH11Sqqpqa1rVSpWqqVNeSaifJ0104i4zlSunIKb3357999VJVANAFjUJVSV9qtyVqpKrQNCAO3b32m6r0EAiSY7uzu7kIXsPkg9P3oHT1pN7Gk3+5420kvG22n42jl6sSXKRivfHqR1IWg38OZgxmVUqt81Km9D4c9qSqu/Lv67v5Q9B6+lVUpUqVK3KlVrU1E1p45wee8oyjuUW1DvKObnfffvvvvnfdIAGABRJKQSzu7u3nsoEvAte7trRcjQB+klV9rVVJWZmZ9mZefVJValSSt1NTVTU1qaqBwdNgODwD4PS78u7u/rHi40ONVUkPGgOHjQPgF3d3cu7AtoF3y9Xq7uxweAfB6D0HweOfB342u7HTQB5aBwCYklVrN5mZmZeA1uy3Hy/Xo8zMzMzNZly7u+/TB78Hq7u7u7sY1I1Te6k81UvU3mvfs5n2zd+3d/Xgu29jJVyVJznOczLkl5mZmZmH0nr67+vn1+3Y+DoAuwAnOc5z6ZbdSVWZ9v37MzMA73sr3U9PfZJQ973oAJ5O9733ve+g+A+u91UkvV3d2ADld13ve96Ac95eTN5zO5mXd3gODxvi93d8u7BOaHpd9qpLlSVWpVTWru7sXTQO9ne973oAHZPpe7v27u2VJVfb2mazM7mZklSriabqpIAS9Q3VSQBJUnKlScqVJypUnKlSX77773vbAHweyVJ3vne9770OmwI9lSq5VSTeskqS7+nlSpVZn3OczMzMzMzMzMC7u7u7sBJVSoAAA8A4NyVVPTdVJLvfL5fl68vdVJA9PD03VSQ69eSpVZJKq9VJVZnmZnczNgOm5Uqi7u+Xd2AeQC+tt1UqgHQAF3d3d3YA1N1UqnttD7tslVJXa1VSVTNZ7mZmYAF3d3d3YjVVJAN1UqizUvl3qbqpVXd9s7a6poAuNAABd33ve9XMqVUkeaZme4zV59Afb2T46jVVJPgFgbEXfJf13flgPDejZDp3VSVWpUqRUqUtqZZFcXKqc1t8YRz577779+/Dw6bFvqkqtVrYfB7UlV3vfOvl6+Pf4eft1fbSm7tSadatvnjV7beW23d3d0I9HPv332866u7Zd3d3dgu7u/b73bzve9/bu7u973taaVAD39mJJu22223aWy239Nm3XnzMkIEN3d58zPvznxknhrZbS2qti2KrZszzzz1IeafmtmzbWiWwW1LWbMy22rZszNbYNhP8P8OB1rZbLJmQYgjIyBBkMiRkIGZDJJJhhJARIjd3effPN3d3dmTdpJAABJgEkAAE0ASQAATQBJAC62krYmrbZJ9bbbU1bbJAABJgEkAAE0ASQAATXh3FDDUnnu9+++5uZzMzrS9jJnczPMzMwAXzru7L4EF3HCQe73bYIN3p973tBBu2fF7kqS7tbXLv2Xq9Xrq7F3d3d3Y3d0bSQB5sIgwAN+3d5JN3dtbSVsTVtskttttTVtsktt6ETQBJAABJgEkAAE0ASQAATQBJAC62krYmrbZ9zltttTVoSQA6EfcbDhIAANrdXfv088S88L9ibxLGk0vb93l26WHwAfkfAcADd3tIAB4G/vufucy+dX3vH6V+Axq8zMA73L3JUl9++M6Npv7d3y5iSbCnrabtlxNN23oAG7u7u7u7vdwAJAABM3SQA/Ba0rb9JLbd1tJWxNW2z7nLbbamrQkAOhE1qQHJIAANr5LAPJIgABNfJLdkkW7u7upoAkALraSti3HmNZpP3OJNIAATXfDj8xtNNfc989ta99t87e87ScbMAPGjD44Evttttt3d3f2vnrveffZmSVIu8GX3ndd73qwD2qkgqofH0qVd35d3kprclSG4bHi/s3d8LmJJu2227bN3QIAEkALSJob3sBJQm9gJUwze95mZmZKmGmSAF1tJWxNULPuW39bamrT5SAHQiaN0kA9AEmB9IAAJrUByQAATVWqSdwPFueLmZ57fUvfffn5izMx/r27bLbWwOI+A9aV9ttttu7u7u+bu/d599qO85fedtfsu7v27HQDvbu+96u7u8qSVUAGGVUqszMzMqVJnMx308rZpgBIBpW0lbE1Qs+5bbbU1TbIAAJM3SSAACaAJIAAJoAkgBdbSVs4sSWLEk7bZ7zlltt7W7dsktttEmASQAATQBJAABNe7FPDwD8H3Qvlttt/W7zd3d33d3fN3dT0d7dVJO85xd2u7uwAC7u7vvV3clSXdgIA/VUqs1Uqq/a1JKrf7TaStttt7u7s3c3d3ft3uyTd3StpK2Jq22SXtttqatvLzkoAamgCSBbbamrbZJaACTAJIAAJoAkgAAmgCSAACattsktttqaCByQAvUmlbE1npv0nLy+W/vvjfuZWHACrv7c/fte5mZmZYB6Zl3d9ySpL7v3WTBxySpB5V3d2kqQPWVMPZKkW0933Uy7u/rwAAAPWh4yqkm80AfqlbaWz7nLaBU1aHnOcAA1NAHnOcAA1NAEkAAEmASQAATQBJAABNAEkALraStiattkn1tttTVtskAAEmBmAAA6s6ennc91NSeee/u9+5+/X+t+2MmZmdzM83mA6Aejvdd7zO9xYXd4A4R5+zAO9y78kqTve5e/rux0GZqVKrMzMzMzAADVaAZKmZmprMzM/KqSfv25Uz9luZ9bbbU0K5eZQAOpoBAAAkwDMAAE1pgZgAAmgDMAAE1qtluZbbbU0AecxczmAF9bSVy4muBzOd3U989/c9+/fv3VtAHTYAAPjve97zi77eru7sgB8AL71d+d71f13e5KkB8bP0zMzM/T9+/Ngvl/tACSAAVNAEkAAEmASQAATQBJAABNAE8XMXAC35tJXE1y22SW221NAEkAAEmASQAATUAJIAAmt3d85fPAC/a2krjaz790Pp577N1Ne7+5+++++/d/fraAOmwAAfHe/a73zjulSpHweggAF3d3fervveu973b8GZeZgZVSqzMzJmbbSQG7u/b+W7vJecAAqatCSCANbXpACSAHWkLd3ZJu7u3GqASQDQTW7uyTd3u6mqASQA1td73sk73ve3E0IAkgBpia3d2SABpia/bxfvvOHnXfypASq4ip97tifliEr72xvAJMEHofgEuQpu46Hft7e73RGWIS2ygYefrjZnLl+d789vfI+UAl8QJR8yZrPkFohjiLGR6Fb+P4WbrAScz8tY4aSBnZdiHmb9qfd9zrHbAD4PfOb5z3nPgPH2g5Lz2VPlZVSQfc3mdy6kuVKpKlVqVK4qJsStJXOTbG2EwrRWalYzJtmszZrc1zG02gyjWxYVt+9fOfPnz5+/NiMUxTEaisK02Nm0dG5+9999WAu75JUq5qqkk1KqSSXu7sElSSXNKqVW5VVNaklVU1re9tAeFjgSSUAFVUqrmpKqV5H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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
