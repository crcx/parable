#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
# BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack
    if type:
        return stack.pop()
    else:
        return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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7TWSAoxMSDved73uus3bADne973vXaumAN73veyXdZwwBve973Eq6YA3ve97JV0xd3TAHe13Hcd73rdXTAG+c5znDtXTAG973vZKq2AHOc5znEq6Yd3d3ZmZmZ2oQIJYkJAqaQJIDYnnCRtiE5hR3upJTvn7aE73uxR3upO4Cdy7hFd73vfM73vQB0ycGgASTUBzYABkBxSSSRIu6u7JJJyY6XdVdUBwAdmO973tSD4TsxJJIMA+q7qqqpOyY3d3WZIOc5znOJV0wA5zne971urpigHOc5znEq6YYA7znOc4lXTADnOc5ziXdMAOc5znOJVWwA5znOc4lXTADnOc5ziVdMXd0A5znOc4lXTADne973vXau6uu4qI9zbKRrGmXMQ+863KJveqo7hJ+7ruT7uu4iu91XcdygruAbwAABwaaA4AfA2Gqu6A4MgFJJJIF3VXQsBVGbpi6q7ti2KM3dVZmSSbS3YQIN6AADmIEHAu6O7c3c3d7bkmpIMA+uqqrqTsmN1mSDnOc5ziVdMMAd5znOcSrpgBznOc5xKq2AHOc5znEq6YAc5znOcSrpgBznOc5xKumAHOc5znEuqYqqsBzve973rtXTADnOd73vW6umGAO85znOJVVVHthAB5gC3IMbaEgsby8yzhggQszJBAIx92yjugEIO6A7o5oEHcN4AAA4NJJJJID4GwADICfc5nnOTCKursEE3eEkkd3d3Zu7u2hALdhAg2xI6UCDmIEG1G76BIn3u3c7eEjnzOfPu6QH13dXd3JNSYzmTUHe95znEq6YGg73vOc4lXTADnOc5ziVVsAOc5znOJMXVMZA5znOc4lXTFVVgOc5znOJV0wCb5znOOu1daZA3ve9ziVVsAm973txKumAHOc5znEuqu6q84qqsDOsCvY6u6shUOjroeiIkhQTrEqOZIrve7fskvsVSO5FE7lIg7ilLuKodypdyVF3BUO4B3BJ3uu90qWd73vQjADg0xJJJOwHwNh26ujIDICd72SSfCySSSXMVdVdVMDVB9JJJLqIqrq6qSTud96k4k3d3d7ufd3d1oDmIFzQAgWs3oSRATe9724lXTFAm973txKumAHOc5znEqrYAc5znOcqkq6YAc5znOcqkq6YAc5znOcqku6YAc5znOcqkq6YAc5znOd7TNXWaZoCc5znOJV1KR3d3duZmZnaI1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pbaqmlKUpSlKUpSlKUjzDZz9znOc55rWta1zfylKUpSlKUpSlCVuAyByFAgEI50b3ve9+88zy888859pSlKUpSlKUpSlKUpT7fRwBD9IIc5znOb1rWta5valKUpSlKUpSlKUpSm4BCVAmudHXSJve973zXh5eeeec3pSlKUp3BkpSlKUpSlIA8w4c5znOa3555555z7ilKUpSlKUJfYJkJkGSlCcw3ve975rWta1zf3MADMwTJSgaEoSzAAzMEyTJyF5hve973zWta1rm/oShLmAhmYJkpSlKUDQlCSqq8hf3mCIdSgH0KodX7nfy/ft293ZJJSlJNpSocaaSSAn0UkkkkkkkkE0kwwOAgBNJMPAfve942HwADzQBdezyfZ73rsIZmZg2knJDiUpqSfpG22uSvJtQP3ve8kVVXV1QzVWTknJJDg0BjaSfvpJgeQABd3d3Zm623znE1yknVJlCWYq5mCZKWYJkpzDnO+0TnOc577rzzzzzm9A0JQlLbcBLLBMlKUpSheYc5znOc1vzzzzfvvN/lKUpSlKUpSlKUpSlOYc3ve971rWta1v3alKUpSlKUpSlKUJXITnRze9733zWta1z3alKUpSlKUpSlKUpSnu+je973vv3Wta1v3alKUpSlKUpSlKUpSm8N8/Im973vzXJ8vI8vJ8k5vFKUpSjbOSqqbVU2qpNqqae8WgBlzczMzY2im1SlKUpSlKUpSlKenOjm973vv3Wta1v3alKUpSlKUpSlLyyUpHmHN73vffNa1rXPdqUpSlKUobSG+YiGkNpDaR3VNersddGedRee1eeVUP7BKh7glzAvchIfsqF+z+y/shL7CUX32gD7CR9klP7KKHcqh3Ene6QqrYqrq6wAAbD7plxRpuSamZgmknCwD4CSSSSTOZmZmYJppl575/vemYNptw40mlhJOyck4nKTTbkkgk0kePwIDyaDE0kyymmrTSaRSTSaU/SYmknl5hJIAfJtAAWAAB1JNJopNNIppNtID8gOgHveu/e839+UpSlKUpSlKUpSlKWjiBG201u7v2Usz3vl6szi2im1VNKqf6HJSlKU/xmKUpSlKdbgw/vx/dn9/f39/a3555555/fcUpSlKUpSlKUpSlKU950c3ve99+61rWt+7UpSlKUpSlKDkGSlKUp8Vc6Ofuc5zmta1rWue7UpSlKUpSlKUp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/qTTb5Taaf6muUuU0cADITFkkkkGYgPwAT6SZ8OSfofgAD0mfKszM3JAyHTNb3ve99AART71XdVdequNtJpoD4sgSSSSSKJJflTaqkml+pNLjpSSSeyCAkkniL1L8ue97x5eA6CDjTR0AEhtoJMzMwkkEAASSSSSAZ4bSTrOJptJfk0k6SbST9n29+973qpVAADIN97JJJVuAJVKuru8Ekk7detVZPe973lawDPVgpJJADI2kyuAACCSfv1Um21TOffAACAA+DjTRfYvs+zuZhEAAe972/ePgk8AGkkm5JHwN3ZJEru7u7kkO0k0mJppAFgB7KzMzN++7u7uvu6wEDAQNpIVIQ+jAWArSf75JNNLqaTSlJPn79JJIAAAEkHZyqvudTFXr6SQjAHDNXdM1iu4umv1CbSTDoABJJJJJKmczMzOn5OQAPApJJJIlmZmZmZBAAAEkkkkpNppe973ve9SbU4knJJJPSXfBtJMC7EhtoCT8v379JJJJJJJJIAAAFXdXVAEACSSSTEZuroaGgE5JmrupJPodOa+B9vQK7h0AzdXQDo0GjN1dcHwcGgCak5Jnci6qqus4AR0ySSYkkgj07nuO+r2tzP33c+5J57pgAihJJJKkknquqqxGHq97w6ZAcGgNk1JJPpA97nvNHigk8B4Bw9qruvYAK9V3XvZ9713dAJIAAAEkkkkgBSbQAHru7uwUAAATckkkr+qea81zve973K4AABm8kkkqqrLu87gAADWMzMklVVVVTkAAA8m5JJJVVVVU5AAAJuJJP3mvNSXd3dVOQAACbkkklZPNea53ve97lcAAAzeJJJLqqy7vO4AABm8zPckl39999LgAAGup7qT6SStar7776cgAAG/tXrmtetalb/T3feDABRixJuSalZkzdXUkn07MSSSTkmQHBoIxs1MfSSb+kfUkF8UiksnG2uVKcpokUnY21T9WW01rwSseu7pJqRhD01rCo0wZ3iTPiYfJtZnsX2AjpQH4oCTsk/OSflAPgkkrVfffVU5AAAHdI3Lkkyea81d3d3k4AABNZ7uSST777Kqs7gAAGbzMySffv379OQDR4085Tvre/2973333333v3cU1QUBQTXgb6ifpJPvtffffS4AABetak/E/SSZPNeau9Xd3neAAAZvEkkn379n32cwAACaz3aZmSffa8819999LgquZGYFBREczlznOc55rWta1z05EXCMsqrfhs6OjXugTkIPcqr3DqDkqA8j69kQ5C7kBdygjuBHcKGbwRdwAjuREHcAbkVdzSSCfkI4EgB+QKSSSZ7KzMzMy8zkHve933va97w2TUgbODCMSak7dWpA9v5Lae0mUJG79tJtboe60ikvg/FMpbu5N3hu7qKKRc/JqUl+psOIpJZS/ZinfvvXvuPsm4fo+gNwb0KYJud0UUugABEm02im2yk02imBQAS6qqqpyAAATcSSSfryea81znOcyWAABm47kkl1VVl3ncAAAzeTebzva+/Z99OQAADXye9dkkr792qqcgAAE3L3Nzva+/T76cgAAE312SSXk815rl3znMnAAAM3ickkuvvsqs7gAAE1nuM/Zkl1r7776cgAAHk312SSXX33305AAAPI5p5u9P3fve573gyA+6YEYTskkkUFAknZigDpkBxMySSbgBNyK16h93tV6fSpJ973ve9zprQHXveyCSekknve973ve97zA1V3QNjAHa++1993kAAA+1PeuyVJdZPNeauqyfAAAd1nsTJUl1VZVZ3AAB3e3dZ7+SZJX3379LgAAHnd8m+9kl3VffTkAAAm+933sku6r76cgAAE33u+yJLvJ5rzXOc8881zmSwAAM3mbkkm7uqy7zuAAAZuTcmSXdV9OQAA0a73e5+k3JU7d1X0nQNYNnmjX7dc/a1rzWvM5qq399vn7e9793v78GQHVMEkmOdrve952SSpJJJOzAB0yA4mZJJO5PScEASSJtABu7u6lu7r3QAAkkkzMzM96ZmbTT2kkGgBkn6aAHiSSSSQAOAB7130E5W0qpcqlxc5yuKnzi5zie1+k5NKN9mUymmsrKbxNrKz9e8e3rFSysoqKw5nOZzm+czzz7zzzznNkStrzzW9tmmmbk3PpmZzl199nO+axsAms9zN5lZl3VffZyAAAeTfe772SXdV99OQAACb73fZEl3VV555qqnIAABNybkkl3k815rnLvmSwAAM3mbk5Jd5d1XIAAB3GfszcuXJzl199zgAAHPt+vvf3eyS79ASAOAAT0lSSSBkUmZnjMxSSTEk7MeIHTIDg0BsHvASQmZmZkiQAACUgCAACQOgc2fj8ST9J+AAKH66u6v3vez6SS7qvvr6AAB53fOb53rvbuqrzzzVVOQAACbk3JJLuq++qcgAAGZ7mbzO5l32ea81zl3koAAC9TfjP2ZvMrMnOXdVncAAAzfe773JLuq++nIAAB5N97vsiS7qq8881VTkAAA+1PZNz7var6ffVOQAACt97vt97VZ3zXmr7dyUAABM7v9mbz9Jd3Waqs7gAAqqz7f379X77kk0wkk5JJIGBQAE9izMkGau6FMySSc7MAHTIDg1JJJ2SSAeEUm1z9IfTL9jbXc++rFDeb3d+aa/ZuttalugRyqUkkkkkbaknT8+m6u6kmnGPYY+HwN3SMde9r3v115rWpJ77J3vecqvvu86AABm+932RJd1VeeeaqpyAAAeTcm+972tVK++qcgAAFz2Tc5JVcr76TrDW9bBoKKLZzOczfe96198ic9885sPPFTMsonMROdb3m985zfvvnmtc+9uURkRFZzcm5mMy7qq155qlZyAAAeTcm5OyXdV99U5AAAJJ+k5Jd1X305AAAO7ST9JUl3VffTkAA222/zmfiNn4QiqIQj9UfpxiR+9+/dfd2QHTADsqSSSBQAjAB0yA4NAbBPanvvaPtve99sFe994NqfA2jFXdST8PMXV0wDZPszMzZIAAEkgABZIAB7133s5AAAI1vvd97JLvO+a81zl3koAACcz9mbzLzLuq++zmAAATfe772SXdVXmvKVOQAADybk3J2Td3VVU5AAAJvvd97JLuq++nIAAB3U3r2TclyXed815rnLvJQAAGbk33uSZzl3VZ3AAAM3xzmd7Lqq815SpyAAAa6nsSdk326qqnIAAB+39p76nvTvp7wZAdMAOypJJIFACMAHTIDg0BsT1H2ya+Bmg8dMtHhxJPSTwk8d77ve9771ntsXV0NJJ4D3vMA93nN79yAAAd1N69k3Jcl3nfNea5y7z2U7vYAAzfs32skvOXdVncAAAzc7vvcku6qvNeUqcgAAHk3JuTsm7uqqpyAAATfe772SXdV99OQAADupvXsm5Lku875rzXOXeTVizzR54eeN73re2eybkzMu+3dVnacJzCzLMFMzmbvvub3rmtaB1a57yrmYQaeOs9xmTM3XaqqzMmttgAGnfAFKv3fdT9V+rv573n3cz26AH344ABh7Hmw+7KkkkgUAIwAdMgODQGxJJO97KknjZ590aPATzAzdXT3veO/veyo/A/SfpJJhJAtNoA+AKkkll33phVVVVVVVVVB3U3r2TclyXed815rnLvJQAAGbk33uSXdZdVncAAAzcm53JO8qq1rylTnAAANdT2ftydk3f3330uAAATfJvvZJf336/pyAAAd1N69l7kuT67zvmvNd7zmdoAADNyb73JLuqyqzuAAAZuTcmSX999rXnz6XAAANdNans93J2bzzzWta37uqqqqqr6630gh6QCGsQj+wI5lKX2byI2i2i0gSFTQIMq5vPvsid2t+5Ag1gCDr9vO/d4I8lWCTzKVZiRv7Na5aAQNoAQU9p7BnL1e9t13bGpJHgENCMSN56qG97bz71ptjfupIjdruvFyBB2RKlgm6p36ah1eXXdqV0cwzZ2SqqPNCk90l+heYNrIuRCQrYI3gjBHm/nf38hc3r+/c91y3lFXO93vOvdd9vwBoDvOc5znQM85zGTHcdXdXyQhNMTjTw3DABA3PvVve/v7tQr3IjeUkawBjIjMmVkRkDCoa1SaIrTFQcJQGBpCkaQWhEIISZGgpoYgSmUUaACQQlXTJEq6uqY4NBKqrq2ACVVVei7rve9737vaI7iRlUYUYoKEEJgUKFFKVQJgFga6u6q8VeLuquqxgAl1V1SgBV3d2wOmSMBJO1Lxi8STcH30uqq6tne9553ve9PcJSygxkyIyIy6q7qsD4G7u6uqYGQHTAIxTMJGN1oFrO/dd737vxI7ne967u7QRzQAhvd9r3d9rQJJgIGCFdXqsXWcDpmJd3dVTA4ZnaurqYkm5knwk2kAHwAUmo0kkndZnMzPZ1pK67i5hpkB0wARQAKATsxJJIAAJJOzEkPVdVV+973ve97wSSSSRkB0wARQAKDpmdmJJ2Yh0yA4NAbD76gfbDYaA4MgOmEkknZAAoNalyu/dxvvUh0yA4Zkkk3IfAB8kjYe933vZ973vHTABFAAoARgA6ZAcGgNh96lXVVfse9773vPpJNSTxwZAGJJJIigAVJJJIYAOmQHBoDYfe973ve973gABkB0wARQBJUkkkIwAdAHJGgNh8kmpJJsNAcGQHTABFAAoODSMAOc5vexJmetirq1lC+zUzKF9glvemO6JWv7uudv2BJ6X2KSfZnpUgB0CH1kn76IaqgDvQAIUe973ve9wqSSS5JibXe97dXPSXJAAAwqJNtq6TSafZJ2dkCSST774PD2bWUmRSoZYEGVDlM3lhQRBEdAFJY4FAYY0ZhZnuHQQRdGSM5mY5k0+xh0RVTlSUOE2QhtNkRV1e7vd3d3d3PyBBuw9knY0BwBVYq7pKkk+urqdkbHqAAyZ7KzMwySxKlSTabYHwACX7JJNyQAGkkm5O3X2JrJOSdl1V1WiEDSBMATEAa4jd3d3u7uru7u7uO973ve9AAVPVUq8Xd1VXiru7wyB7wA73uu973m3n11dezn3ve97xQB8cHPgO973ve9BTF1dF1VVSrGhAD7u40SPe9727vbXQJGiAXwAkkJppcACw400ZmZmZMnJTTUkkk8iOpGdwI0IwRgjLGXVXVZAABmgfOSfSSQAkkkppJN32m2vv3ukTSTrtH7viGeDid0ADve973vQAAVJJJJAABJJznGe971g6NBjs9dXVVZzPutNUCR4ppq6zMzMz3iHG00vzTX1e9r3venuUDYfMAyZurpBsNSTV1dSZkgAB1iSSSQD13dVW+NVdVV+z72+e96T6ST6TwAAAA6ZAD6YurqSakkl5vFXd1SsJGVRmjWqLCTMiJlYMqqrvGAIlXV1TAnZirup26q7uqmBP1yT9CTik5Kdo/fv1fve98/eA1XtLd3m/L9+/ar9iv3uT3se+97wigAUcD7BGCSSckzAODQGxPBJPXd17wEkng8ED3ve9Pe8Dncd9JJA4BJJ6ZmH0k1GpbS9WJ7u/ubuh7133snQAAHdc15Pdfp+3Jcl3nfNea5y7yUAABm5N97kl/fZ99nMAAAzfc3Jkl35VV5rylTkAAA8m5Nydk3d1VVOQAACb73fd9kl19+/TkAAA51Pdfp9uS5LzvmvNXdVnaAAAzfc33uSX99+z7OYAABm+5uTMl3qqrWvPa3U5AAAPJuc3J2Td3VVU5AZtre9aNaNaEqpV9jlLa+/cDf25ogPcAAnpKkkklKigQMqZurrfwb47GCSSckzAODQGxJKlysdxdXWu98bY+uq63i2Ku6ebo7rFSZu7pVVfsHdOmevau9SSSeTan6UB1CbVSxBl000cPfdPwVydySTJFmffp8vqlTsmFln7gAe737489rTTRgd1m9ezN5l5lzvmvNXdVnaAA0avPe5uTMy78881Vb++zms8AAPp733feySrqq815SpyAAAfmp72bkuTd3VaqpyAAAfanve779JL++1+/TnIAAA7qb/RuSpLyea81f32d+AAA7rPe5rffskvK/fs5gAAGd97m+59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J7JJervJ5rzXOc5koAADN5meySVWVmZ+38z0DZDYyGhEREDHMKomyZr9f79+/fve973ve9r3ve84MgOmACKKAFB73ve89j3vA6ZAcJ58H0cTMknpPpJ2pvKSdmPC7unve970ne+v1emeycc5AADAN8eQfHwBoB8fAGJtZ67uzFo01znOKlTXN5u7+3d33vXd3nMAAA8m5J7JJd3VVU5AAAJuSeySXd1VVOQAADybkT2SS6yea81d37q876AABm8zPZJMu6qqzmAAATWe7k+/SSXf3330vgAAE3JPZJKr7776XAAAPJuSeySVX3330uAAATck9k799+/T6XAAAP3yXr9v3932p7JzvvA0BwZAdMAEUjABQAjAB0yA4pJJJ3uYOSSTibRJmZeYSST6QAsSLAkkd730kk8qgB73ve973gGj3Ocn7F681d5zJQAAGbzM9k7VVlVl53AAAM3mZ7JJd327u52gAAJuSeyp27uvpU70AACbknsnaqvvpU5AAAPJuSeySXd61VVU5AANGvp7JPZUl3etVVVOQAACbknskl3esnmvNc5zmSgAAOaz3M/eySZzlVVZzDQAATWeyfvZJLvtVVTlAAAa5uu98441yvX97pV1fbPSeAA/ABLknJJJJ6SpJHq97z1e973mw+oARgA6ZAcJJJU72TxkPBJJ6SSSePer3gmeXve94zJJIlJJPJtSLkAAPJtBvXe933vf3e9l39999L6AABN97PZJLv7776XAGba3vRp41m5M9zMy7++++y8aaaMAM3JnuZmXf3332XAAAOz2T97JJd/fffS4AABmZ+zPfczMu/vvvsvAAAJvvZ7JJd5PNeau7vO0AABNZ7mfvZJLvKqqzmAAAZuTPv0knOcqqqc6AABNyT2SS7uqqpyAAAa919Wmte373ucr08B8DYaA4MgOmACAAUAIwEk5O96knV3dAEkkkkSSaknp4Tvu9r0zJPAlVJJIACeoGh7ve85znp4AACbknskl3dVVTkAAAm5J7JJ3nN65ee+a81znPdZNgAAarPczPczM7znLu7zuAAAZuSffpJOc5VVU50AACtT2SeySqr776XAAAPO773s/SS7u6qpyAAATckn6SXd3VVOQAABI4AfHiimllPKSzN/NNZmfltMqqqqqgAZvMzP0kznOcu7zuAAaNVzsrc+7Evs90u/YSSSfSSB9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yST3hJJIVJJJrTSW1um7u7u9k8l73vXczaoAAJuSSfSXrV3d5PNea45k9BVVR3jmcznOc53zngefe+++ec5t9MzMxzB802b0xmZmfZl6u7uqzk01jemmmtJpnvuZmfZlVVffZeMAACaz3eZmfZlVVffZcAAAm5JJ9JVVWTzXmrvO/gAAM3mZmfSVl3dVnMAAAzeZJPpKqq++lwAANGpuSSfSVVV99JrgAA77+0+03p5KzVnl7u7u7kaS3d3d89vSfpJM+zZJ92Sen1z6HBkB0wARQAABMHJJJAFIJgASTMzMkAAAmZmZVXJmR6hqr6G6u6uqYqqv3TIJ473v3e97+73ve9+72qqvvu3AAAJuSSfSVV3eTzXmucyfgAAOZ7vMzPpM55rzXOc5d53AAAM3JJPpKqq++lwAADybkkn0l6881d3dVOQAADs93JJ9JVVX30uAAATckk+kqqrJ5rzV33J8AABm/2ZmfSZd3dVnMAAAms93JJ9Pvvvv0lwAADXqeyST6fffffuy4AABjzzWvN1yT7i7++q+eZVVWXWZ33ve962k1JJIANAcI1mSSckxAEUAAASbkmpIA+BsfA2oBhi6upUk7v9Unnw973ve8AAAANuXd1znObJ7GMYxjGAAm5JJ9Pvqqs75rzV5k/AAAfZ73MzPs++++/ZecwAACb/SSfT77779JcAAA13Se+ySfT7776S4AAByeyST6/vvvpLgAAE3O9736Vqqqs75rzV5k/AAASmft5mZ9n33337MvAAAJuSSfT7776TzdVXHMCiC+o51znOc780Ka1rXfOe84iIhwMYyGMcqvthhP67/fs/fu7u7u7r7ZnUkk4ANJ+HBkkk5JieAigAUAJPAPekAPe8AkkkklXdBJJJJA9d1dUKA8u7oGgJq+tBvu971vB39j9jGMYxgAZvMzM+z79+73Xnms7nfwAAEZ79PpPs+/fs/eZl4AAGk1m9z9mZUr7X336TmuPAAueyfpPp9+z79l5zAAAM3mVk+leeear6q5J30AADs93J92S7u/vqk50AAD9Pe9++72pX79JXAAAO8J+97JPr+/fpKgAAHk3OTvfp99rzzX30lwACqry9/Zd4AhvO9Z1hv9vXEB5zm+e88yOftfve373vfAB8DW5JU3JMyfg6Ye8CaUDgKdM1d0CSSpiSRabUgHF0600AdTa+7Is6X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iVPSWVGMsSyoyo0lWk8887888pPKTCutjJtsKuKTIhosS0Xvvvz332oHVaW2ZQeqjAPfffnvvgqPVRksl3OS2xqlHJRgTvCJxLEkxLJYpZUaqMCj333zz3yiLraMS9S0oe+++e+/SPoj0qRqCRqzEQTYS9578998VHSaRPqWFZLEBoDUslio0WVGiyK999+e+8l5SVqYRHqWEvfffnvviSvUsqMliXaZReeLNzNz363M3NzdzPu5v75197P37gALzzzz5ub554nYAAqmA+7m/dzfM2R+EX8SlqoWk1RimhKtJpNJpKv4/jr+PPPkQeSaJdpog+OkuCWS0kpksqNoUWiwUZLIHvvz334krpsNFR4liWS1LJYlksVGSyXnnvz33ykrpMQXnnnfnnhF0mhL1UZA0lMS0liWSyo2kC0WhLJYUHvvvz33xUr2iylO0yguUWio0WCWJZVGyJktoDEslkJksqMkNK999+e++UpPaXY5UoOEsqyrRLIGQMgagZiWSyWSxLRZB7778998kI9SyoyWUl3bVgkuEskMloqP0+/fvn376qOk0QfSoxSyoyWS999+e++peqsqxLtOCXJRimk0mJpNJqk3nnnnnySeGffn359+7m5ubvPWbu7mZ+r535cvwAKqqgAAFVVXzc3vdzc3ebm4/iDz7+/Prugj9iQoKbu7vgIrrS4Q9JalkvfffnvvE+fPnXz5xPUvU08zDMpNRJpyTslJrE08TT408zDMwNhhRLd3m7gnnnnPPNR5e2JI1OZl5lKNPnON11JpJP9mWZP379u7u7u7u+9TAdAAAVVVe9ze8zczaz58+faPKCRqCR3d7u4G35iMWJe5ncyk0BYUmgLCk0BYUmo05J2Sks4nmZncyk1QHelJoCwpv1dabbaaz95587878/fgAVVVAAAAA7zczc97m+szd3Mbm+tzNzdPY95q+ack7JTnG+STslJoCwpNAWFJqkvnnne+RglqO7vnm5tUJR+QuDe++9zKTQFhSaAsKTXtE0m21GnxpNNbmee8++/fzrzz9fgAVVVAAAAA73c3c3Lc31u5vq91e83Obm9999kpflxJZmZ3MpNBXe0mgLCk13td7SajTCdkqLjS5JOyUmgLCk0BYUmg6zN3NzMzP3z58+99/v34ADm5vOc5znOc4tzXoAAAB93N+7m97m5mbmfNGAUT58z5u4h9lI7u93cE3d3u7hyEguwpJAWFJoCwpuLj405J2Sk1JJ2Sk0BYUmgLCk1Ku+5xNJNpr73vnXfnOAAAAAAAH19fX19fX1oqHz5nz58x+0aomRqkd3e7tJqSTslJoCwpNAWFJoCwpKLifGnJOyUmpJOyUmgLCk0BYUmrbSeZuc77+fe++c4AAAAAAAAfdzfm5vebm5mV7ur3nM9Zmetze+52Sk1JJ2Sk0BYUmgLCk1FJOyUmaju73dwTd8555ifmgZAlAkQnvvvffdBOQlCUJQlCUJQlCeec88zwShKEoShKEoSkKPZPfrNz7d7m5ubv6fPO3n78AAACqqoAAHebm5te6vfM3PXrNz16EoShKEoShKEoTZHd7u54JQlCUJQlCUJQlCUpu73dzRKEo/JMhKEoShKEoShPffe++5olCUJQlCUJQlCUJQm7vd3NEoShKEoShKPc5k2TZPffe/ff1Lr1Nk2TZKEoShKEoShM9xH33z33PBKEoShKEoShKEoSlN3e7uavucybJsmybJsmybJsnvvvffc0ShKEoShKEoShKEoTd3u7miUJQlCUt7iGQlCucTXOJr6Z2plcve7P37u13cmLfbnPe7Ee3nyz3bL6y3zm2nzvm79PEWBGFGUZSTJYVNoslkviWK66cDzj3z2TvSdcE0v+r+h7zSaFaTolyUbnIuKjJYocS4S4S0qMKxBiWQNKNm5vv1m5vm5rfznP3aAACqqoAAqqqAAKqqgAAAAAAAAAAAAABVVUAAVVVAAFVVQAAAAAAAAAAAAAAAAAAACqqoKqqgACqqoAA8y9VVQAAAAAAAAAAAAAAqqqAAKqqgACqqoAAAAD333333333pPkeSapNJpO01J7J3JoV2nvqd0nkK+SfU4W/N3dzOvPXz534QAAAHnnnnnnngAAPe5veZubbmtzfX8X8XrM3PW7m56xLaFtUrNIW1JbJE2qtkq2AzbA2bEbbCNomyTZtEmxTZKbJDaVNtgtmxFsQNhKUM1CbNpLNms0VjUrUBMotNKQ0RBNCjRRJIEkxBMERSoxUxH55+fn55pLBEQ0TCovYShKEoShKEoShKEoTEpplGQgpiAiSgoqIBaCqIgo99xH3z336R54JQlCUJQlCUJQlAXzBOfPnzfnzPRKEoShKEoShKEoShN3e7uaJQlCUJQlCUJQlCUJu73dzRKEoCj5DkJQlCUJQlCe++999zRKEoShKEoShKEoShN3Ed7u50ShKEoShKEoSvYchKU999777miUJQlCUJQlCUJQlCbu93c0ShKEoShKEoShKEoTd3u7miU+zkJQlCUJQiQwkMJDFbWtYYa6BmBiMYwwwpS9a1rhawAAeeeW5tVOwABzc3qXyXoF3LEvz85+eec9TZNk2RQlCUJQlANCbu8R7u5wShKEoShKD8nIShKBK999777oJyEoShKEoTuYJQlCbve7uaJQlCUJQlCUJQlCUPvvvvnvueiUJQlCUJQlCUJQlCbu93c0ShKEoShKEoShKEoTd3iPd3OCUJQlL7mCUJQlCUJSnvvvffc0ShKEoShKEoShKEoTd3u7miUJQlCUJQlCUhe4uQnvvvffc0ShKEoShKEoShKEpTM+d8ATM+PWbnvczc33+Pvd+8VQAABVVUAAFm7XnlzNz16zc9es3PXrEoShKEoShKE88xHzzzglCX5i5CUJQlCUJQlKe4J7777oIPe9754JQlCUJQlCUewZCUJQnvvvvu6JQlCUJQlCUJQlCUJu7u7olCUJQlCUJQlCUJQnz333qPvuo+9fkGQlCUJQlCUJQlCUJy+fPnz57olCUJQlCUJQlCUJQm7u7uiUJQlCUnyyEoShKEoT33333dEoShKEoShKEoShz16zc7fvdV+8/VXAAAFVVQAAetzaqvfM3PXrNz16zc9es3PXrNKEoShKH8shPffe++I+8wShKEoShKEoShKEpTd3u7miUJQlCUJQlCUJQlCbu93c8TZNhveDmTZNk2TZNk999777miUJQlCUJQlCUJQlCbu93c0ShKEoShKEpC9wcxN777178l7idMq2TZNk2JSm7vd3NEoShKEoShKEoShKE3d7u5qFHsmQlCUJQlCUJQlCe++999zRKEoShKGEhhIYSGEhhIYqSBhr1rCda3re1rWsAAAqqqAAD5ub80fnz58+bn2JQlCUJQlH5JkJQlCUJ777333UeQlCUJQlCUJQlCUJSm7vd3NEoShKEoShKEoShKD2PfffPfc0ShKEoShKEoShKEoTd3u7miUJQlCUJQlCUJQlCbu93c0ShKEpPYyEoShKEoShPffe++6jyEoShKEoShKEoShKU3d7u5olCUJQlCUJQlxviklyVmU0szLzKTXPfCTTz9z1573vft0AAAKqqlVV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wpNAWEadprkk7JSaAsKTQFhSavv5pPE2m3xtPltP35398P34qqqAAAVVVDd3d3Rp9afzTGnGmNO2k3u76epJXxdzO91Hgnc3ed3c5VVVVVV2zvc5VULD4ec555gne53uCd7ne6jwS3d7u0mgLCk0BYUmuZ70PZ+TTz937Mz779u+qYDoAACqqoAPup+Tfve76k0BYfmnaa5JOyUmgLCk0BYUmgLCk1E3JOyRp2muSTslNh186666666669/tzN9373V5fvxVVUAAAAAAKqvedddfOuv2bvfffcgAAAAAAAETckkgAAAEW5vWecvlVzhVVUAAAAAAM3fW5vM3N5ubznOc4zd777777s1ySSAAAAAAAARNySSeUkkgAE9veH27VmLUezb6k0+Jp5xNOk0+JOlOJOJNJpMppPZOEnFJinfHz73J3J1CsTuJaTIrJFiYK0moVqVwgyXJclHEuQGSyoyWINScJYloGS4JdJcS6S6xQcSwRMlqlMqOCucJcktxLEsJci4JcRMpbEtSwrEHFKcSYmU1JxJkTSaFcSaTik8k5kLmTE0S5JzLfebu+vmbvzc35nt14eeQAAAAAAAAAAqqqAAKqqgACqqoAAAAAAAAAAAAAAVVVAAFVVQABVVUAAAAAAAAAAAA/gAOAAAAAAAACqqoAAqqqAAPMvVVUAAAAAAAAAAAAAAKqqgACqqoe++++++++++5PlJ8qjxOpPU5JHRLpLkvsuEvxUfEvpXRLkdNJsbTiaSSpJN8aTTVmWZubu7u7oAAAAAAA9bm3ve94AD8m5JJAAAAAAAAAAAAIm5JJMMSacafvtO7u/fbu7u7u7oAAAABVVdbm/dzebjjT60/fbhgAFoKAAAxNySSAAAAAAAARNySSRN87fYZnPu3kz33AAAAAAAFVXqaeb73vU0/k3ySXIAAAAABE3JJIAAAAAAABnvve973vfbu7u7u7oqqqAAAVVX3c3xX25jckkmKSSQAAAAAO973ve970xNyd9999dddddevnnPPPvnfnOAAFVVQAAAAbms3QdddddddddddddddAAAAAAAfJuSSQAAADJ6qzPPPOcAAKqqgAAA3d3U373ve8AAAB8m5JJAAAAAAAAAAIm5JJMg06+vO5mffbu7u7oAAAAAADrc37uP5pxpjT1N7uGWgoAAAADE3JJIABE3izMzMAAAOgAZkvuT303s784AAAAAAADd3d973s73vfAAAAAAHybkkkAAAAAAAAiSa/hJJp8TT4k0+Jp8Tzb8B+/AAAAAAG7u7u7u7u9adtP5NtLd3ZoAAAAAAAH5NySSAARJuSSSJNySSRN99999995u+63M35m5vOfv379+5+/AAAACqqoAAZu1VddddddddAGySSAAfJuSSQAAAAAAAO/kfee/3P7n3ny+9+/AjSaTmk1dKaJx+3yTlJ3JgruFaTxMQLqTmFfk7k4odUnCaqk4hgrE1G1JxJkJ4njT40/mnz6406afzb1p3d2fbvt3d3d3QAAPW5oBAAAACqqoAAqqqAAKqqgM3QAAAAAAAAAAAAAALc16AGboAAAAVVVAAFVVQAB5l6qqgAFua9AB/AAcAAAAAAAAFVVQABd7m17qoAAqqqAAAAAAAAAAAO9zR8AAFVVQABVVUAB77wnCcJ6nqep4nqepwnqfJPifE5T4nxPicpwRPU9T1PU9T1O5PlUnxNSep9TpOk6inknCfaTJk5T1PiZPifBXCdyep1J8oVoaE+ybN3cz3+3dzc3fOud9y5wAAAAqqqAAGbrc3m7u5v3Oe85znOCbab/hLjaWZmZgg70ADve97E2BJAAAAEABaCgIm9+9jTq7933vv3ve96uAAAVVVAADrc360xp/NPWmNPm7kzE3JJJ04AAAAARNySSAAAAAAAAKyYE5f0rvznKqoAABVMB0Bu7u7u+Tfve95AAKwoBAAfJvkkkEAAgAEAAgAEAAiNttpKJ75z78q5yqq4AABVVUDd3d3d3fk0/NP5p/V9999ib5JJBUBYLgB0ib4m5JIRJuSSSJNyACTckkkSSAAQSSfNPFye5aaTTS/Jp8Tb3M3n3nXOcfq/YDoAACqqrd3d3d3d3d3rT973u++UkkkkkkAA4mwDoAAAAAAAAABxtxJp/k1t+C/fqqr8AAAAAbu7u7u7tNPWn+TSSX333330TckkgAAAAAAAAAEafVyS5IAB9JJJ5vW5vPlfa8VVQAAAAAAB1ub93N+bm8zc3vc31ub+zc3nOU8AAAAAAAAABkkkkTckkh1111111111169fPl5Zu6/c5XOfvwAAAAAAAA/Zub+zc31mbm83d34AImwA7AAAAAAAAAA666667zd777777+7m37z55555+/AAAAAAFVVQ5m5oHXXXXXXXXXQAARNySSAAAAAAAARNySd9/Xq5fKq4AAAAAAVVVDmbmtzfWbmtzfWbu5nv2HXXXQfsTfOJvMzMzMTfOJvMzMyNPOJvnG3mZmZFJJJM4m8zMzMxJvMzMwACJuSSTpiaeJpzMrlZ79999xe/e9U7zvTvs2c9mne3Kw+889frPrvz7+X3vd+Xvd5pQjMo0JZks0o1kssqMyXbnGZHf7kTnfJOpOLkmsprSeSYmSaFew0NRMTSZUcJeS4lxA6wpcJZIYlhLJaLRaiyXEslxLKsJYViX1VwS4Syo1JpNJqTUqYmAmkxLJal0lklfw+iXRLpS86XPHPLy4AAAAAAAAAAAAAAAAAAVVVAAFVVQAB5l6qqgAAAAAAAAAAAAABVVUAAVVVAAFVVQAAADgA4AAAAAAAAKqqgACqqoAAqqqAAAAAAAAAAAAAAAAAAAAAAHvc35SdJpOZPZOU0nEnsmpPE+J6k9k0K+JknEmqTW5vrM3N/hubvzz468XOACqqoAABVVUG5vM3N97m+s3N97m83N9qn6Q5H5+fn5+e60i0qLQKtTVFVRNMFK0qlCgle++++++eeeeeW0woC+873safVyS5J3ve9AAATYF9de+uuup655ub8+fb7V+ACqqoAAAAA63N63N63N+7m83NHnmRNySSAAAAAAAAAARNySSAAAAczt4cSafvt3Jvvvt3d3d3fe973qgAAAADmbm/s3N5znOfAAYm5JJMxN5mZmAAAAAARNySSAAAAe/ZmZmfv27u7u7u7u7u7u7ugAAAA5m5m4B1111113jckklJsCwAApNgWAAETckknXXXXXXXXXXXXrvNzfOVXlzgAAAAAAAB63N88888895u3fff3vvibzMzMySSSSSSSSSSSSSTE3mZmZk777777777777797m+Zu+rmB2XAAAAAAAAC3N5m5vrN0buySSTE3mZmZkkkktSS5JJJJKTcknZJJJJJJJJJJI24sTT/Jpxp/u7vR+/AAACqqoAAbu71p40xpjT/NJJb3dzMpNySdkxN5mZmZJJJJJJJJJJJJJJJJJJJJJJ3333369deddefM3N576u+65wAAAVVVAAAOZm5tua9A8zd888zMySSSSSSSSSSSSSAAAARSSTvrrrrrr7ze++++/OcoAABVVUAAAtzeZub73N9Zmbm/s3N+c5znPMbkkkAAAAibkkkAAAAAAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
