#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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EMaQEyCOGkhK72iUgP36fr98vK9ikgK/Z28epU3vd193Wz736N/OgTSXstYq/Y97ft59wLohO8ge37yPV73Pc97SeZUknJMNqe9n2Pe016mvewvexyte8zS8/hB+GPo/ev8/1/v3v2H6UIIbyGOuiWhNDR3lzbKOP8oqFe6icd7/K9Xee9pr1NySakk9sps3jIGsowdHlbp5pvue573HOmZRA0GAMhhOVd3d7uvUnKXj2fe972/Uve97QAbBmQ9n3ve9v1e973tpQhPujnVZnNkJCYIOEJCEJIUXWfvent+8se972ve8/NvRFKpJUq5hLFU6qsU4yYqoPWwYxk1FG26GGAioCIoCjCCyCyRGKAqjWiZaySIKDGLE+CUiMFwtq0rJEYRRkQUUWDBkjFYgjERVU9KsUqwWcs9v3l73vc973vbbFSKSkkknp6SSSTwOSTkk9oPe373ve34MvDTmHd3erpJtPtk0AGznt2ZfGmkvJJJptrPt66WaK9zCANb4Ac2AG98kmpJISQ8fLW23+oj9+/Z+++1CDwk220AjkgGQ2kqaTptJU6rF3cngiZVUASF3VUvViSST3jaADYB6JooAAL7z3qTSWqbSVNL1e57vva962mkV32TpsAvle8Hr773te970KSpp0t03v2G/e971+9e6leA5tJhhgAX2r8pJuSe9skkkkk8Mkkkm/4mn3rPKvJNpJezvvPe97MkA5JMyS7wcw0wBNJCTSxZwALE0lU0l7TSaes/hjACKaYe9JJckmp4k3JJLJJJDIAHJLueQB73ve8c3hQTSbdBnhhp9k9qSSTwSSSSSeWVJJJySk36l4yABD3he8ABhppS79JOzEmGnJJJJLu7uTwezlppe973fe96X3yQkm0ko084aSaa0YyYaYBNyTOZMNOSTvq55LG941Xve973JDIQpNgBhNpXd3avl5ad+ADoAB979TQW2a4TPeqkgpoRDCKi2QCCD9JR5aZxz7OVW687FV5U75QXOQIYDFREPkWCLasjBh8bKnGesx9GJZCERhAEZ5mDMaUO4BUPgmBAyzTgsWQREUB0fDhPI54FOqH6Xc7ubWNNNbYzbVDEnSTMACQrAJAOMgHy78OeeX5eQCpdO8bdt8P2qpc9+S6jNkW1s6751++ffn70AkTmlVSXuIkjtFXfO++++vKd863rGeuc23NGRWSqi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u7bb9wofv3KHdDNQ1WoZUaQ01DaLNQ2UMoahqarAahhTBpAMhpR+yKl+/clR+yl+1Un79xfkNKSbIDIZqGoQyGiq2oZDNQylGDSX7UcpaGxkNNqzbKyhqNhqGmNqGlBqNVTUNqGahtE0v37lJP2l3aSxmbNZazMbYXue5CvfePKsISyG2tqlDKHu5aJaimobKGkaQxG0iaMUNQ20lqGlGQ0qe73VK9yRe4E71UnffRV4A20qyhFim2NQyKPco5QwqHvPffffffwqr6BaKtQxqrY93NsCIIiyJPX33WICMFUUgoC4e577708miWsLKGqkwGlWoYpqGE1WL3gcvfeJI973vWCQft+MfT9lIQgPzECEKGI/MEECAvO/e/fq1I+2PfQRPd3YCDtSVhHJLu74abaacpJPc3NNQaaWEUukkkjklNpKAAHSGQAyCbyAFhFD7RWKX+IYTmL9+4v2ofv375ealLrQu8neu9B3ku8Sd6g02mk6m0liSbxtsNBwA+SZVoAAjaraSwwNGAHyaprG0kAAVpN+2g0295yXu9z33333x+abSzQ9NgACmJvMeYkkAAFMeY08xoAJJI3E2kvUkmkkve9tNJe5hNJe9729tQMySSSQkjkg2kgAykUkATibkx3ve9vaburyk2kpNSQTSRYAASSSBrXpJO9nqmr+00w0AHGmUAIGk0FtttSdttttTVttttTVNJsNMxGINMxpIygAFTQW221J22221Nfs3q9u56nYRm2buCAxAkJCMaEjM7uJpKSb00mvQuGACRNNuXhtJdkwpOBoNJmJtIAA962iaCJpI+MbSRSTaSAAE0kWAAAmkgAAvqTaSeZkkk5PaTX4zTbMAPkGml/FiQ1i97fve97wmgtttqTttttqattskTVxXGY0kYmGmYGmmorbu22rmZiSttoAkJIALYmo0ml/DE0m37G02v4Ymm2k0tUmmimmZTSR0vRRSaS3SRCXbZE001PX1t8CQaSZiTaRibXsaXjDBNJYRTCSbkvO7w0mndNJtk3JJ0AAAttvG0l7PSTvok5+0m7iuW6A22y0AgaTQFttqTttttqattttqapppmBoA+TRaAAJoC221J293d3craXIEj5oBfmhC5iOYgR9EK60BrzefCOyVF/YlSfPvKJZvvE0lwJpspNwbeJJJL62kpgptpummUHJSlKUpSnaVNOT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JOCpUk2mgNSSTN3b46AAEkkkhsArX2H2ul7yRtJRNpY03M1qFoHAD4C2222gAABbd3d3cEm0gAACXd3d3dySSTchNNP2hNibE2Jv33333vfWgcAAAOFu7bbQBpsTWNNvAAAvzatvLy36ppITSaG0l2sgbAsqTDTkkknZJJJJ+oekb333333331D1RZDWahmAAAAAaA0gCBAAAAAACSU22nJJJJJVppI1Sy0zQAQkkkAAAAAAAAAAAAAAAAAAAAAApgAAYCAAvfNJMTSQVjGgAJJJJJKaaUm1nWtSSXNSYaYGwALbbbaAAAADlibznQ5z7j6so41Q0TcOcsqbSRqxKm208U0kmoBhQwRXzt8W6dNPyw+U37nTeg96e6AAXd3d3YSpJJIBAkkCAevsafsXiXLbbfAX6407b+X5tppRRVWIKwFBYoJEFIKoWy1q1mxNprLWR1wI+juOF2IE2SrZsW9+/ewXZtppIYDG2D9CRjJGCbXdVUhd4S973E0cC0ATRLbJG0ZllttpmYks7bbbEqkpL9806JsDiaOBbQE0WSd6mg1matttiar7Pb+W/t6uNOBvZ+98tiDBTT2BYcGlZumUmwNxzru8Nu4klKgZLANJgABd5KM2bRWYKw4rTYYAzLu70s6SwUa304k+c9lp9ibu72muXtttqanSSSJq4sttttTUkkkiaikPmnRtgcTRwAAE0WySRNGLLb3d3CMZm9IQU23kyMK/TcLPex97PfvvqYAHAECAMyR1JM8kuGALq7u7u+kkkngDoGQkiUknU37ve94HW13uPK6007nk2aXwbTWzofAAmi2SSJoxZbbbampJJJEYsx5iSVzV0tYldaadE3rDQd2sxrEdD4A+GkW22xNGLLbe7uER+gQE/CAjX+GIC4vPtSX3fO/36LgS5JJd3fpJIcEAAB2TF3d3d3ckAAAAD3vAEnfSd96Jov4NcaZgG01bbbbU0IC22pOSS22pq2222pq5cpppgBxJgAACaAtttSdtt3d22rvffCaSxveN4zXDZwPd8AAEkwm0kAAeLYW2+ATfvAAAFMAAAAC23vu+kk96pq27f400w0zDG0AAAJoC221tcy222xNSS221NXLafNMA+TXMwDYAC60AAAk7bb+/fvyfP8fOdVH9QyCs0omZbJmtGKVs1tY2lD+wiYbZr3u+97fPemZJJE3J5L1V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eLFmNPFiAAASGgAAqaAAAE1bacaYB8mgAABtAFttTVttttbX7Wfc1vADsLfwAAW2220C2222l9bbbfHtgAdALbZJN+XDfe996pq2222pq5bpW/ttMDaTOAAA2i2221NfW222pOSS22pq2222tO40riVx2m2mBttnAAATX25PbzX2/vVqb0m5yeg+cIUZ3TT2E3u7u7skV3dJu220l9bb807fB5t+933jYBbbJILh3ve9PJO2222pq2222pq2222pr8AAAmrbadTYG2/lgAdAG/seLEnmZjAACpCxgABU1bbbbW1tdya8tTRsLA9RskmpLkwm5MySS5zubzd3f6GHgt+7Jv1vgAD3veDgW2+qbqnrbb6pq2222pq22/utMDaa+xYAAAmrbbbak7bbbamrbbbamrbadaYG018AAAmrbbba2s+ekmkNpL9pPlDMoaq/uKHFWof3av7+8+/2KPYul4DSckzdkm1Kwm5MuAY7fLu+EPIG3b+bSVMQH73v3794AAuUDQkBcVx/m0l+xtJYi29p+qattttqattp1pgbTXwAACattttqTttttqattttqattp1pgbTQAAA2gAttTXfYE0lvCaS0dnU1vW9b3rVnDs37Ukim5JJBgAAEkk005JJuNuSSSSSQAAALbbbYm7l8rbbfF/LGseNgABWm7bbbQaMeAHetMDaaAAAG0AFtqattttqTttttqattttoju7u9iF73pER40dMQHhJMAVRDbTXPMJCV+JAGATHdLQAdN3W7GgYltQqUtW8u8IBZjJOJJiEcogJ2/272/vRTGLWQ0DYZQgNugq4cVUVVkErUQSAdIAyBDSPfkb6N5cubIhEfG+qq+9GvL8CB+sknSd06QxOxTrpF5vZYFXeoe9BmQK83rgitccorvxze/DhK9OoEK+SSHl3bbBJk7qEkUhMRR1587877vH7+5FB+tLZI/shzGVgtZ91QfpGUft+mUvf3z4EG2hIFjBB9nvvU/dKFm1M7tfev2/DSWqNtOIvutFa5s1KOcy052Zk7My00lyaaeZN6vCuSYaepJmZW5KgZaZ0CgRMNO7vt3OxcsScrFVKWG1SONPG+cDIAFWmnrXyb3uHAIcIvmnzSuzXl9PvYVaTfJnbrnOb5k93l9pphqmwOBpp9wNAGzCaadNnwGg00y2/W5fC20z3ve17vx96EL2eQxx6NvT4QE2QIDEgGkBeNPcvfePBWnpNmgN29uNNreJNPuYmksaauJvt+pDphjTMACd7u409GNPDmwJKAKB9sCGdy223tEbD4DA3lp1mO71fLXSc006gGg6IaSVmHXdNPPcNgWxp67jTy78AQxH2mnMDZy8t008uraBwrRtp92bDl3Y2k2trEseO/NPVu7S7OJV42fNPYc+D5asa7l+aer3l5TA00wAOiuNO222wXPJ8Xvmn73p6e2vK6adtW7u20CYGg4AM5xp8afGnxp/XoAHcNNMO7A+AA53f2safKtLa4XvJeUDgB8AGYBrAADzTSaEkkmUAAG9tOSTUkl3i7kknbTaSMAC2JppK5bbQNNNIIGjGmQ+Madtq+kgABwAC7WW23bTS7aAugTyTSXvbXveCHmnpNgB0LTWk2GwAncady2229NaaYaOAHwW223VoAQ6baaXwcQZztttioAACAL5N9A2Ae9ppgAEwKY0zvalqT6SFOoAAAAAQYAcDYHQJoNNMOXVXGIQPvraEGfW+mHKbHDlCj6IvvgSHlag9sF4wr2jQnid99ePfXxfHwrptNJpPNJNLNyp4v3PEWpJJu7ZJJJALu7u7u5d973pdWSAFgAAmwku+6cz5JAb/CD9kJAve9IAL8xAj80lw2mgAAqTttttqattttqattp1pgbTRwAtqaMLbbYmi2221NSSQtqTttskTXfrv9pLfyAvPk33py/u8QG03J2axbEsySSFgLJQUmwAyHbvd3ckA20xtgIACSSS7uzZx84HU13scltqa/AMABNW12nU2BttB0QACcgB0A+SQsAAImpJJJEnJJ3vepq7u7u7tNWu7SwiayFmLNeDYXNSXb9JNSSByySSSQ5d3d8uTJIAEkkpgBbbfd93v7jTk/bTQggACatLeW3battttqattttqTttttqattttqattp1pgbTRwAAE0W222trWJNpL8sbSTaxe98AfFnlbbb+rtttoFttttLZJJPzaS8Hve973gAOgbSACeVttt9U1bbbbU1bbbbU1+AAATVttttTQAAAmrbbbamgAABu2220ElgAACTSaZjaTSVxpKuBpRe/PP3dQ8ZDahsX9o0ZvG0mnL22897vpufi5bbaVW3wfJsPenu6AAD3k2AGm0AAQAAAADgB8vd73vf3U3P37aaAAAG0AFtqattttqTttttqattttqattp1NgbTQAAA2gAttTQAAAk2rvSuJpLEtD3mYlmP7YBeH685Vb9b+qtttp+94AAt9aklJJIWnmml73j7MSaQB8m0g0e9nvkkmgDfYm/0V/dA/fqmrbbbak7bbbamrbbbanMSurbbamgAABNXLafNO27SYdAAE1ZJJLtJ3d3y7u212HsXq6WU+Y9hT3r2m9e97Utv75NhdyKSQpfAaTYHUHoGAW30vV2NNKU09Xd2ckgCQBabPVSaSK0AX8RvzVtvwRph9tJcSNgcAE0W2SRJySVJ26uVNXVtttTW+97JImqW2gCa+kkvWnQ22jZ0ABNfumZ25n3y5vFjeYklnBN/ePTet+/eAl/AFtoSTxybkk1Ls5d3d326libSgBOeqk0kYTAA400j3ppppSTujnOcDraidVd3LbU1U7bZImqv1tv3WnbptbEkrly22prkkkkTRitttsTUklttbUnenGn3uJSalbkkklpq7ppLNLHCArDnvEDwB4AAKeAALfWySSFvvNv3t+xJpSBpABgsCTvl7ve8733rbWmq73Pe9kTVVskkTXe1NyHUkrdJK3kkl5Ulq222JMkkkiaqttttTUyTUhtN26Qu7u7u7hEuXPu9WbJV7ump5ENjQ3vtw+t/Hi2q2/vIAAKeBABb4TYW2SSSHWmkBJJJGmlAMG2Uk2mAc413Xec96JqSW22pO2222pq2222pq2239GmGkmAAAJowALYmrbbbak7bbbamrbbbamu/rPr7X7Sb0mkp8Z8HmeGEAy6tBlcmMgFFSEVaIlAxAMme9+r9eaCBxAgGXKgdfsxCAuwgQDcNICGyfSROTbNiKv1bs7mpAPa225tTaKmJ2Y0iLgILTfpgQDB3th61kRTGICob3jpEA6cCAtnfeePfThhCG4cfvvTl1+r9E5++zdv9LEA/0d/XQa2pT+b50SdWK01QybbNFrPuLik0jIakbJ3QzJX1WPTnVDohfP5w46XnUF8s4wqdQmKrZtRMn3kciMbQNkjKMwTeofeKOmVbQtmoZDWlGI+UMJyZqGatpGxNjZJtUNVS5y5Yh8Ryofco6wjLaRm0S1D9kOUMR/aOY1Dw4HuJdWVZKNJsI5pJwtP7UOTRUzWwlaVaGmKtmy2bbWKsuud+BzQstmrbWgtqrZmptSdtOZssyK+cUPevgjaxNLamvsSbe83jYUE3O++Prby+94AJJWa7IJpLWgLOAZznMkknekkkkOgBgBbllttKeLpJNZjT002d9PvpPdDsknK7zUnJJA4AaOb3vewLkkkklylbbbaGAfAFOgAFoAAdDV3bbYrqRYTSUyb2AEkkjbu7V00klVJtJ5jb3j1iS5q2/UoAABT62362U6GmmYAGy23ltoAbAA7aAF2aIHxA8mkuTu00kd93fvW+vsOgHwUADRbVb22gGAgAUtaatttAGAAWXLbbQAAA323VvLaeTaXfe9773ve93lu79baAAAAhNibmINNPZ8AF6AAASTcknwAaDTTADgfG7jTt5byzyaSmtK/Hufd973jYBeW220ADUDQAFbSUaeXVtpsPk2l800tgFLaaaaVttvbUAAAAW221WhgBBtJcppNMDQSTt1d3ZJMtNKSSTkmk+26tvbQ4AfAHQ1bbbaAAAAWTJJIUpiTS200joGzofeTSUk2m2xHOd6HvAAABUqlznOHegAbaaQAHQAAAAAAAAt5v73PeyJv3U8/Vcaoahs1DaSyGi2SBDEAxNiBDY0xdt73tyZV7+AJ1hKuE6ecnR3d+kgDbAAAAJJJd2du7u7uS5JLvykntVSaSAPeCKVSaR99dUAmwxn6qlNgJtI3YSEjWUhfrAKwAPjZCkFGKoqqMWILG8xttZibbSwDYADaAtttTVttttSdttttTVttttTVttvUY2w03sAAKJIAAKk7bbbamovr6rf29JZWK2JsWu1jp3abLF7y2OgDabJAMLgBlNgBOEgmwAOX3vZ26VkggJJJBpg2wCSX1Nzh3vel2mru7u/dacqYmgOgAJoC221J22221NW2221NW22kaYaTQHQAE0Bbba/4+NIAAKmu600mlf3Vix4udzn7uxGfd7/AEfn49IftlttoBsOW3dtpW3J9JNovmmlAAAJJIBJIb8mkribrOru79601bbb6NMNJo+AABNFdtttSdrtttqatVtttTUttpGmGk0I4AAJrt3d3dBbu7u4ls+yTCR/kO/jWwaSa+424CJr1v0ixJ6VA6JySSSQkuySSQne973pdilNOCANJgQ2mmkUwJA7PSST36pKVW2yNO4mtWSSRNfhW221J9tttvXU1bu221NWySEadxNG8AABNSSSSJOSSSVVpOrtXbxft95nO63vaOH7Sbne77nfQL23Vy2gWW221NyXd3d3diANAA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73ve8QPIQBwAAA0my3ltn13QOK4jUDgIK0mmYAAFaSSZgAH2mnJPpCXR8AHAD5tgBwA8m2ue973ue9733bdX622BoAADnU3ib6m+trcWfffSQAAAAC2222gAAAHwfO3lvLr3cqMz3tNPnvX3ugFttttAAAALW2krbbaAAAAW2226aaVAAgY00gCq2VW2gAfZzfk2373vdvqW223wAAAGNNK222ygAAAFttttAANNNIADturby3TTpdgAAHm2AAB4AAAxaeBz77mkm0+cACAm0gAAC2222gEDSbDRpppHvcUkr+EBOfbxiFlCXu+EtXDTEgbawrFXyKsVcrJXIcFHCjUnlxKvPN3f0fdR75yv7X7R/YzGktYkvYk3Ma+3zcm/T1u7bby2+ttttoFttqkLbbQAAAADE3bbb13d2r35AfhoO7u47tl82w7u7uzhhzWZidttvbiVay223rmOSSTra73vbJmZmZkZmZWZxwq7u6u7phtBvT7in1dv2Jv9dCAA/Jv3vbGAHE2BTmgBfJsk3I0+TE3MyAbAAJADIQoACG6Tfdd73vtSSTkmpJJyTUkk5JqSSck1JN292N3d3d1ZmZmXuZk5mr9SFDGIYd3Xbc/Ka17d5Z7L9f3p72qAFvgAAEABeW220LaBsADoAAAATve94fl3ve2Tve973sUxfrbbZMadt+ttttkk7zl3cbr3dvdu7u9zdcvWbu7XNC38OP30T9997nj9Pe0BbbfW2220ALbZJDabttJyTUkk3JJIAAF+73ve98d5znOda5XOc52dTyakknE+53ve97O973t605XbbbJJJKuySSd73ve9i5Nyfa+0t597nPuWz9+C2222ltvgA973vW2ySG7bQ6BoxpgAdBAABPTve99yrve772JTH9NSSfuNuXu7u7MzMzjOSW7G7s48zMzTd3d3cu7u81ZJJyS7TeJpLansAF0/fgA0AAS2222gBbbJIW/g973ve17xbe220ALeySfr79LbZOd73vexSSSTnOc5yRZJJJd3d3hmgGzr3d6kLt7u7u3N3d3sNcIR6LZzIBL9TTK3d3m7kppyYkkmpUppyTMkmbpp3d209Xi7mZJ42AAFkkkge8Bb6ySeF3veyTve95zsWSSSc5znOc5znOfom5JJJ2ySSqSSSd73ve9m+bm/k62NUtgo1opqGAH+apXENKg1gSah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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
