#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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PMQfyqqvFXi/rLJbHjy2SWwY8nlsveCq5kzO5mY/pY8VVfszMzMclpkB3ve971KrDIDve973qVimQHe973vUrFM4xWAHe973vUrFMhJznO9e85WK21QHOc5O9SsUyyJO85x3qCXLu7u73ve973fRAQxBFEcwFQewR5FFFKcZLMgAJmCoXuhUFL5zACJd3gVQu6RLgIJcbijWMSSbzJIHjSgOj4DgbDbgd4HySTkk1APeNJUkkkrFYtQAFer5bZZAA/AKrZXF6GZEkm5AADIHKrGKqqIZ5oDve973qVWGQHe973vUqqZAd73ve9SsUzjFYAd73ve9SsUyA773ve956sUzQDve973qVimWQPd73vepWKZAd73ve9SqwyA73ve96lYpkB3u973u+qib5QiLmKB3F4RUTGKQE1BRLu8J26uAgF3S3C4IotwuxzIB40oDo+A4GwbBw0bBOjQDxklSSekrFVigAAWL2x5bJJDkDttlDoCfpTlssmczkkskzkktk+fnP2YgqqqqvAOVjFViiGeaA73ve96mMUyA73ve96lYpmqxgB33ve97z1YpkB3vfe97zlYplkD3e973qVimR8Hve73vUrFMj4Pe93vepWKZAd73ve9SqwyKr8ZmZmLLDiqr9999998klkmHbJIdgdgI1AuNRRDMmsamtKgjrWcCoJrNXd4S7oRQ3dBd1cUQu7u9S7A8aUB0fFBwNg2DgfAdGgHgkkkkrFYw973ve8jACD3ve913vb7pAR7VAocsRrsBSHJbLJnv0xPJZfgV+V7LK8eR48V8AOVVViqqgZ5VYxoDve973qVimQHfe973vPVimQHe973vUqsMgO973vepWKZAd73ve9SsUzjFYAd73ve9SsUzQDve973qYwyA73ve96lVhkB3ve971KxTIDve973qVisVisZ1oVAxAkNxzEUJqI0IiWRRiDBQQuqURb3eDkQXsQUQuAKiXEBEA7FUVOxRewBQewCSWQ5JZIcktlgdHttsvFVR5i9aA6PgOE+kkm5BwPgOjqqriq/uSyqv5WmZmZmSPey2WQ4nYBnoCBIAdn3JbLJj8HfvgV+VVVVeKq/rJHvZbK8lltkpyD3qQ73ve96mMUyA73ve96lTNVTOgO973vfearFM0A73ve96lYpkB3ve971MYwzQDve973qVWGWQPd73vepWKZAd73ve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VVIAAAbbbfUqqF3QqIX5RE/EWCoQFCLCKipBRD6lVpRCCRFGICpmIoSgQWkBWKAsBQ+iiH333333N8BEOQBU5ylRDnPsIoeikikgkikgnoI1EZVCVAZBJFRRD6CopiIACkUQiAgOIAhIiiJUiiERQFWKIREFhBUD6Aj999999zfAEEOQQUHkFETkFUR5FXn1IIKXEH1USCVVCVAZBJBKiDUElUpUEkUkFQBCgFD6gBApFixUSCikVEIIiwFCAwFCBiIlKIRBappRRICh9999999znOoK9iiGYoh3ve/aFDaiEIIhAUJD0BkGpUEqINQSVSlQSRSQGQSRRFKBFIh9EQExBACQQUwChBFCKIQ+++++++3viInIgA8iAnIACHOfYFBPQT1UJUEaikqhKikikikgMgkiiKFKIfVSohAVTEAUJABPvvvvvvt74gvIAg8iKgcggLzn2EUTyAjAQIIBIxCRB9BJVCVAZBJBKiDUEqqCoVAZBJFBEfoqgYEBYqqAxRCICAEAAIILERAiCDEFhBRDFCADIqig/QVH777777m+PIooc5QChzn2FABbgnqoSVQkqhJACQSpUUkEqINRUlUICfRrFUoBEGoKh9999999vfOc5zPPqRAuAyCSCeqgQoWqEkUkBkEkBkEqIoJ9FFDBABH77777773OdDsRXvaBQ7372VJPQCoJIJKoSVQkikgkglVSAI0ohABSKIQRQfogItQEUHEoQAjBRkhBRCAoxRCICQgglRBRKBQiAJFEIKin0++++++5viryKKHOUIC859gERL9QlFUDIDIDIJIDIJVUpIpIoAKfRUBwohAEAwQUH7777777e+IpyIoIchznPsoieUQgCBCAoRRCIoPopIpIpIpIpIJKoCopIpIgqEAFOQXsRE4QDUNQAECJqDpICCYRRfoiKH0UEfoguoiCb+oUVT6Cv0UQsFU3SqolxERKiAIXBAW4IIqYiCCFxERLggA/RAH0VBT0vNWXd3u/CqXfbll2WeNAOj4LxVYu+3d3u7s2DjYqVJB8ABgKkYFUqO0XXfweA8qpTNcEYoD6vHve97wAPvdEcenJ6GYaUBfUewHoehn1Hrq7v3rREvl3SjI2yqafUANVVfHirsku/Td3d/TfUgie8KqB8AKRUhED6AqgFAoQRAkiBJGKIRYohBVcwpIiAqRFCKKSECBJAUIoqn333333298VUeQUToQRCEEkYpAFZJEEe9oUBe9+wiCBsFCAqh6KSKSKSKSKSKSKSKSKSAqgxSUohFAT6CAlKIQQUAIohABWIsEBWQFERiiEBVVgKEUVT7777777fORQHkBReTkUQ5DkO/UIiVABZAFAPRUEaCCwFCKoEUQiAsUQn0RBKixgQhEUIKJEiIoQVCKfRFD777777vedF7AEcsQUIySRUYwkBQkGSQhEkhISEjEOwFDsBQ737AIJ6LyVFJFJFJFJFJFJFJFJAAUfqwYFQkUQD7777777e986yQkO9oAUO9+9lSRSRSRSRSRSRSRSRSQFBeKIQiiEVgKEFRSKiESKISIAQgKEiohAFCAoRSILAEYChEESIsF+ggKgUohEVDEVBRfoiJ999999zfEQHkFAOQTkEVTnPsD5RCEEQkigCHopIpIpIpIpIlQqKSKSKSIAg1ARRiiEIChBQQPooKtKIRAQCQFCKISAoQEBCIsAVxESlAICkgRRCJIsJILAFCKEgEUQiQJAUIgIRUYKiMUWICkBQhAUJEFT6kR++++++5viiJyI9YiAQIRkIxYwhEkgAB2CI9ggK979g2gsEPRSRSRSRSRSRSRSRSRSRABQPoAoIYEAJIKMBGIoAQBQxKYgCxRAYohIqIREIiIQFCQFEIIBERSAoSRFSKIRVQiiEARPooh999999znIoryKggcgiCHIKAvOfWohkBVkiiEURA9FJFJFJFJFJFJFJFJFJEARH6AKqYBQkgQFCIihiCoUohFAAD7777777fec5znPrUFfQuDUUkUkUkUkUkUkUkUkAAQ+iqjhEUYKCEUQiRUCQMQogQgQhIsD6H333333Oc53EAhEkkJBJAJIB2He9waSH0FQKBGKIQUQh6KSKSKSKSKSKSKSKSKSKoJ9MICERWKIQFAiiEQEgowFCMZIohBUXFItP333333298VOc5hAec+wKqeikikikikgknmANSoBUUkUkB3rBczeNayb0lfcVBQ+7SiGo/e9hRAPYoexVFfoIKXEuAglwbigoXEUNxu/eyD6IqVgAe9rfBCAOhrfG22BoH4AElSQYAfAN/Ntvrbf5ttvGUkqQI/U8qq/ottd2bu7qsXy2WyV5LKnbDbJJex5VV2a0ktkePJLZGKru6wAAKqlSoAAAFVVSOFgfiy8SoE9Xo+UPRUU+UQm4kin333333298HkUQ5ylR5z68qSKSKSKSCkgpIpIoCfQRAqKIDICqej9AB++++++7w5BAOQAU5EQXkBUORQeT6IAeikikikikikikikikiki+gCgwUQiqH0VaVAwfffffffb7zl973v3tqSKSKSKSKSKSKSKSKSI/UePs/fffffc3ve97+9akikikikikikikikikgPlEJ9g++973u73X05znPr2pIpIpIHzKikikikikikinfsGftUoh99999zXt73v73lJFJFJFJFJFJFJFJFJBFSLukqSuldz8p99SVQA3MtTd3YbVK7UkUkUkUkUkUkfRKgkqgRfvykkkmG7u7scVJ2ly6pXapXziVJc5xUuXVK7Sq7VK7VK+cSpKflJJJMzMzMg5QlRSQGQSQSVSoVVCVFJFJFVTikkkmZmZmTwlV2paXLVK+cqklznElQGQSQSQSQSICAfQEBJtV8kkmyNu07VVSTtvlUqSSbb+fbbb6/e317u6xVVUmwOAAKqqkGgfgBvobBsHA+A6uqu7+AFyQNttsVd8k3lmvXhzfpZVfH8gHZJMYqve69z3kgABngbEu7q7u7v2973ve/d++EqKSKSKSKSKSKSKSKSKfUffa0g/ffffd7znOc597ikikikikiknotRSRSRSQX6j7777777fuc5z3e/eypIpIpIpIpIpIpIpIpIp9R973ve9ve973v3fKSKSKSKSKSKSKSKSCSfMRPsH3333332971rX3fIMip9VKSKSKSKSKSKSKSKe+wfffa+++3veta+75SRSRSRSRSRSRSRSRSRT1F39pB99999rvaeR5yuQ5E+9Skikikikikj6JUUkUkUkR4fYPvvtfffXz3e973v3vKSKSKSKSKSKSKSKSKSKfUfe973vb3vWte75SRSRSRSRSRSRSRSQD6qqIfYPe99999ve9m97+z3ykikikikikikikikikinO6vOu7dczNFb5s5rQKj6ACIBuAi7gI7igqByAoeiIB2ej6IKNwQRG7oUALiqlxBUuKoIXERC4Il3Sqg3ERrIG5PTMkiQadHx0fBdYxjFXfbu73d2bBwPgOrrGKrF7u5fcZxUu+bm7uyy269tlkaq/l6vZXkkkkb73wIF7vF3d+4J7gql41cQaUQuNVSpL37Tyqqpez3hsAD5UqAAwAADqpKlSLpVSRdUklSA/IDoBu7m5heVJFJFJFJFJFJFJFJFJFL37J73vuoPO199XZ3tGp3dH09FJFJBzCopIpIp+qpSRSRSRTCQ/MHve/Pz8/N+5zW9/l/KSKSKSKSKSKSKSKSKSKfUeu/r9rWtCOte93ykikikikikikh9AqKSKSA5n2D777777Wtazf3fKSKSKSKSKSKSKSKSKSKWnsHve9v2tazn3u+FJBSEQCTsEqKSIXJwK9k17J6fRB7Ox++7gezsTe94H6enohUUkUkUkUkUkUkUkUkVo+we97777Xd7z99fykikikikikikikikikin1F97997WtZRz73fKT6lIVQMg1KgMgMgkgkgkgm4fYPX9v3tY+3rX31/CSCUVQkqhKikikikikikinKQFRkAQ+igCpBGVARU7AURPvewCAPo+nYiq/QFC7oAuAggFxVFu6BQsP1UqqkIA7SpUAHWW22/eG+PG3+b6PgOBsXd8u7u+XZ8B26xjGKvkm7uL1UJZZYaqru7Ju9ku8ltsnoqr6Ie9T7wqlHoaQZ73ve3v2vYAsrx5JZLXktttVQ+BVVfFVflbbb7VKqb5VU7oOIbbfTMzMPFUruqVxSRSRSRSRSQ+g1FJFPqPve3tB972OQ+ne0c5zD9PRSRSRSRSRSRSRSRSRSQH6j3u+9Xvb+5znuc+9lSRSRSRSRSRSRSRSRSRT6j773vZ97e971r3fASfQCopIpIpIpIpIpIpIj9R73vfffb3ve97+75SRSRSRSRSRSRSRSRSRT1Hve973t73ve9+75SRSRSRSRPo1FJFJFJFJFPqPvvvucQfvvu572uze/vZUkUkUkUkUkUkUkUkUkUs+we972/e39znN7+v5SRSRSRSRSRSRSQSQ7EqKfUe973332973rX3fKSKSKSKSKSKSKSKSKSI+ou7v3vb3vete75SRSQDcaikikikikikikikEFQ3HEAUYSSSEhDsKIMgIIZzEAfYFAULiAImoqojr3sPvdwCoProBFAuAAFxAFuKqty4Ko7vkttlu8llk+53d3ft1R4AGy2SLocD1h+A0D8ACqqpPrbfzbH822+tr4qn4215LKtsvZA1Uy22x7vLZViD6Xe7hcLhcL9CIPvayGYAoB6PoN3vHe973130RBC5cAULgqINsqgz855LK8efl8XZJZN83d3d3NVePjeJJUqpdtO0lSqnf8kn5QkkmZmd7PeUkA/KpSRSRSRSRSRSRSRT6j3ve+71B++73ve73961JFJFJFJFJFJFJFJFJFPqPe973vb+5znOc+v5SRSRSRSRSQLhUUkUkUkU+o+++++++3ve97393ykikikikikikikikikiPqPe973vb3ve9793ykikikikikikikikikn0X7B9999999ve97vnPrypIpIpIpIpIpIpIpIpIp6j3ve991B++73ve85z72VJFJFJFJFJFJFJFJFJFPqPe973vb39znOc+v5SRSRZOxCopIpIpIpIJKoT7B9999999ve973v7v3wlRSiNRGoVFJBJVAJVUJUUkUkF+o+++++++3ve97393ykikgMgkgkgkj9AqqEqKSKQREKiAAn3KBUcnLrCi6iIiyCKPs0oh7nMII+iogegAA9ggqH0BQuAohcERLipcFEGaHygBGZ6ZkkGnVHx0fBNySbkhsHA+Lu3XMVWMV+u6s/Xd2PwReru6vl2bkk3JYFSe973vJ5ttttttgAB1UXSSpFpVVJAfkB73vb3ve9795S4KSKSKSKSKSKSKSKeo973ve+tB+7Xe9x2d597KkikikikikikikikikiHvsH333333293znOc+v47BqKSKSKSKSKSKSKSKSKfUfffffffb3ve97+75SRSRSRSRSRSRSRSRSRH1Hve973t73ve9+75SRSRSRfpUUkUkUkUkUkU+o+++++++3ve97393ykikikikikikikikikiPqPe9r3vfZQfp2d7Xe13lIfepSRSRSRSRSRSRSR9GopIj9R9999999vfuc5zn1/KSKSKSKSKSKSKSKSKSKfUffe973t73ve9+75SRSRSRSRSRSRSRSRSRH1Hve973t73ve9+74ST6AVFJFJFJFJFJFJFJFIohe94MgoZvWvtgigfQTe6EQPvu9yiKP10Kgt3eC5d0DcC7Ksu26ByMySS6xjGKLu9X67v46Pgm5JNyQ2DgfBOS8CSx40sCq75ZLN5deyPIcsPpZQ6aqqGZme8kAG8YZoNg5isVWKwLq+Vd373vb3ve9793ykikikikikikikikikinqPe973vfeQe9Dvch3vcfT0UkUkUkUkH1UpIpIpIpIgfUfY++++++5sPc5znPveUkUkUkUkUkUkUkUkcxzExFPqPvve9d72G973v3fKSKSKSKSKSKSKSKSP0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qqq5nve97XumsVWGTwFUBkD4g6OZmfczufJ6q7LbZ+z7y22x+37zc3hiT9JJuWAHfZ973veMoyCGMVjEZAMADr0+1JJIANkm5JLxVVWOxm73d3dhJJNySOADk73nc9axVY62CdDPve973fAcDeSV3FY2jpHaO93y7u7vnhVOVQCHcnvazv3vWDvuYrHdfe+3XveAAFVMVjFVPbghQvDqD3XbwqhgVDaDd3jt85V3isYxVeNEp45Xva973vdHwAHyU4u222PLLbJO6e7u7uqqqvktsiqckn1YkkOgAHA2AAKqocAAEeWWyeS2yKrH5ffvvtlYrFVW1O930uwAEkkkkAfVjGKoDoAAAAAAABJ31tfBfPXemwBJJJIZrFYAdHwnmnzxqsVgaAeLuujC6u7u+XaB0gChAUJCKISCXWbukG7vF2oL0RCIASAgkUQgyAgkhAiXWLu773c3ve797fsXn+Put/VVKm4Em1JJJhskn0kmRv8222/gOjQnZPfTMkBFACVJJJIgAiwBd3V3d3d3YBJPe973m23EBPruqVJSVSqSSSCLuqVJSCpVLkkn6N6qVN5G22N7u7qWYN1L2AAzMzMrM/Xd3VZ2AAAa8kklXJd3fOS4AABN+9705Jd3fOS4AABN+9705Jd3d/ZPta+73J/AAAfZvMzM5Jd3d5d57AAAKz9mZlck93ve1U70AACb973pyS7u+clwAAD6b973pyS7u7++19VTsAAA5P0klck/Xd3VTsAAAmv03U+1vL/Zn9rX2d7kuPRqzgbAAHwHRoSTs5NSbBFOBto1iqxKk/OBa7GQ5VKvNgcWAH5UqAfuvrb4qVP5n4M97usKarHlkugANkou7u7uqqqHwXd+73l3d1WZ9rX13PfwAAGZ+7mf2f3JLvL5zLwAADTvZ2c967q7qvd8AABX2s/XJyf3JLu75yXAAAPpv3venJP13XOS4AABN97PTkl3evtfXdVOwAACbqST+5Jd17WPvtfVXs9wAACs/SomczLuv7+ysAAA7qfvekrkl3X9/SoH+jewANTTP0nJnMy7r+/sqAAaFhv5ctHOVVKku872+ffP7P42SSADfW2/mJJYF/Xdjo0KknZMyTgbiiqqkAABH+3d+3d310A6AD8AACpwAsodMXZbZN3SKqBDd3d0AB22/elJUlLBgEk63u5992Vd3d3YC5P73pL5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JQlCd3e64ShKEoShKEoShKEoTu73KXfIchbJsmybJsmybJsnvvvfu8RQlCUJQlCUJQlCUJepTVGSaTUBiZIbUYmiZhfPPtHWo5wnaf6f97voTUrUdqORXNRxKxPqcpLonQnFGqVimIsoyo6mTM6kmT+X8ZX7zz23+QAC2222gAAAAAPJb3bbaAAW2220AAAAAAAAABbbbbQAAAAAFttttAAAAAAAAAAW2220AAttttoAAC2222gFttttAAAAAAAAAAW2220Afv379+8TvwmVGJifkyjtPlH2jRXxPqeKPhV4T8nRV8/ea8949oABbbbbbbbbaZk7kmT8nqfHz+0n9pNqJsKZYVo0g2RW1VUbCbUJskoRIokUqkVKUGgRqhBNom0JtUlso2qNqGwVbEiGyRUrMqpNtiqbVsDZbQbWrTZDWJkQKKEhkgmhVqiKlYahiCIpVYmI+z6fZ9nuJYIpaJlQXYShKEoCzAMhKEoShKEwCmVICKpiAKSnZsg2Mxs994nvnu6TZNk2JQlCUJQlCUJ3d7rhKEomybJsmybHuuZNk999793iaEoShKEoShKEoShO7vdcJQlCUJQlCUJQlCUJ3d7rkKPkmQlCUJQlCUJQtk994nvfu6TZNk2TZNk2ShKEoTu73XCUJQlCUvzME2TZNk2T333v3eJsmybJslCUJQlCUCd3e64ShKEoWybJsmybHucyd0g99537+/n8+/AALbbbbbUyAePpk6mT6Y7oj6mE+fOfPd8TZNk2TZNCUJQlCUJ3donusEoShKEoShKEoShKE7u91wlCX24uQlCUJQlCUJQnz5898uEoShKEoShKEoShKE7u91ybJsmybJtW95HMmybJ77898uEoShKEoShKEoShKE7u0T3WCUJQlCUCUCUJa9x77757vE2TZNk2TZNk2RQlCd3e64ShKEoShKEoShKEoTu314ShKAo+Q5CUTZNk2TZPYlxME995179/n8/r+AAAAttttpvMm+9fTJ11MlCUJQlCUJQlCUJ72Ce9glCUJQlCUJQ/bZCUJQkJ3fPnAg+973cJQlCUJQlCUJQlCUJ3d3c/JyEoShKEomybJsmye++++eJsmybJsihKEoShKE7u0TuwShKEtG94OZNk2TZNk999988TZNCUJQlCUJQlCUJ3d3cJSbJsmybJsmy95xNk999988TZNk2TZNk2TYmybE7mTnXN8/fv378AAAC2222iY+p77777v6TZNk2TZNibJsihKE7u93CZCUfbJkJQlAlJsmybJsnvvvfu8JsmybJoSgShKEoShO7vdcJQlCZhDMgZO+ujvvu94QVrhBWukOiG7t3CCtcIK1wh0EF6r7+5+/c5znOc5znAALbbbaWZOc5znWZve9b+mTuZOc27hBWuQ6yC2uEFa4QVrpDohu7dwgrXCCtcIdBBeq/efffc5znOc4AALbbbaZk5MnOc5zqZN73rf0w6Ibu3cIK1wDSGHp33294QVrhBWvZDohu7dwgrXCCtcIdECL1X76/fAAAAttttTI6fTJ1MPiHpD0h77775hBWvpDohu7dwgrXICtcgK1wgrXSHRDd27hBWuGTe9631MneSST2c5rd++9+ttAAC++eeeeec995xkFXCCtfiHRDd27hDog51cIdC9Vwhb1cIVa6Q6Ibu3cIO9631Mncyb33rfUydbm97+++++ttAAOc99888888577ziq4QVr8Q6Ibu3cIK1wgrXCHRBeq4QVrpDohu7dyRd639Mncyc5zXOpk3veuffffW2gABffPPPPPOe+84quEFa/EOi4Bu27hDogvVcIK1wgrXCCtdIdEwhgbu1ToDhI7u3oT3vap6E+uqECSjQXZNRxK0VqNRqP6JyUdVGSco6o6o69wn2jsnCcUc4TwnKj56kviYpdUaUNSu5PE/J9TOb71778+/f6/fvwAW2220AAAAABbbbbQAAAAAAAAAFttttAALbbbaAAAAAAttttoAAAAAAAAAC2222gAAAAAAP54A+AW2220AAAAAB5Le7bbQAC2222gAWzJ3Mm8zMzcybmTlH2jCdp2UcUfE+J9UcU6kmdZknkydTJqZEyczMk76893VAAAC21AcCzJ5MlmT33333+P4zKjYNjYi2qmyjYFsjakbRG2xLaRsK2pLYqbUi2BWzbapbQbKVLQilAUUq0CUNNI0CbFTZGyNotqmyLZZmwCkWhSgoFKaApQiVptFsVslbJspmA2o2RNgGwmwtkRtRm2C2q2g2VbSG1sbGwWwaRoWKgWkClKBClpApTatqzVNpRjGyTaU2hChWhCqUWkWkKApKVLYjaWy2jZtEbKbZijYRtKzRbIbJNrYqbUNYU2lNhbCtlW1bQ2BoApKUKRRqIRpShKRpoKaBAoClFoaA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5MnOc5rWtfTJve961rWta1q2pBVSCrbbhb1e/t3d377z77nvvvvvvvtAAC2227zJve9a1r6ZN73vWta1rVttttSHxDd3bbbbemBCTAh6EOoqOEyhaTE+E64TsnnXjtR/VHTildE7lX5MSHCaUrE1SZKxNRpVHWQnCajEypWJiJ/WkTOuceeUAALbbbaAAAAAAttttoAAAAAAAAAC2222gAAAAAAAAALbbbaAAAAAA8lvdttoABbbbbQAAAAAAH8AD4BbbbbQAAAAAFttttAAABZkdAANSY+p4ThMTCxPE6T6Toq+p9Tkr1VqMoxNRiYnUVxOqZOUdJ8T8nWTqo7JpMnWZkzOpMmZ53MnnWqvqlttttAVrWta1rWlKUpSkBBcJgQCSSQQCSEBIBIoIZioSohoIkiaUCYZovnKVXz5xO4pm2U2a0gK2ULNSGYiY2a0tilIgoKAb6Z3don2ie97Mzjd367u7yu9kNId9999qqqr0QXpf37z9+5znOc5wAAAAdTJ1MiZPpksye+++ec3d3whpDvvvvtVVVVVIbu7vZDTJznOa1rWta1d73v3n3r4AAABznOc5znOcIe9999pBV+IKttvhBVtttt0gq22pBVQh+kDAhkIbu73fz9+AAAAAB3Mm9971q38QVbbbbS2221IdC9Ntttv6QN73vz9+/fvwAAAAAOTJzd2238Q93d1IKttttttukN3d1IPfffXXXXhD+UaVTtNJJ/0aINZMnm/PH8fx9/H8AAAAAA0h+CQnfffdtqQVbbctttvpC26Qt0beuuuv0gaBJDIQzQm71vv79z9+5znOcLbbbaAAGZLMn0yJksydzMPPPPLbUgq229XLbbbbUgq22228+/Zkj3333zj8/AFttttAAHOEOENkN3bbfwQVbbbbaW221Ib3veta1rWtfsyTc3vfvv79+/AFttttBznOc5znOctttt/EFW23C3q6q226Q3ve9a1rWta3Jk3ve/vvvvvgAAAc5znOc5znPghpDd3bbdIKttttvarbbpBVttttvxSQECGBDAhZA6JwmJiajUfScqOCZR+6JyjqlaT+iGJkrVBkshqXJcpHIcI1LkuCuUcoWJirEyFkOCYTIsTio6JyjonWlFxLAjUsSrSOUXOUuJbhMo0o5Rwq4qsk2E0mFlFyIcJpNRqjhNAxNUco1HBOUq5RpNMzM7kyeyZO5mT36ZPu573p7577QAAAAAAAAAFttttAAAAAAeS3u220AAttttoAAAAAAAAZkAFttttAAAAAAW2220AAAAAAAAABbbf5W34HwC2222gAAAAALbbbaAADUyAeAAHupksyJk9kmT2Sp0nafE+J6niqPRPaOk+JxR+iuUek6UcTkp7J6hneZMnWTJmOtHFoAAAA5znOc5xIdkN3dtt/EFW222222223Wtd97mTe973mZJ3Mmt97+++v3wAAAAAZksyfTJ7MnnOd+TWtd99998mSqpBVttttttSCrbb9599z7nOc5znAAAAD2ZN73vWta1rWta1rWta+mTe971rWta1rWta1rWta1r773774AAAAAEyb3vf0ydze+961rWta1rWta1akFVCCrIJJFW237BW979999zgAC2222gDcybzJve9a1rWtatttttttt+IKttttvFX7fvvvuc5znOAFttttAG5MlmTnOc1rWta1r6YKttttttttttqQVcIW9X7v7777nOAAW2220AZksyfTJZk88884QVeuurbeuuqW1IW3rrpttttkPMV+vz4AALbUBwA1mta1rWtW222234gq2222224W9VJJ/BICSdZJmdyZOpmSdSZOsyTzzfnn79+/fgAAttttoATJZk+mTM88881rWta1r9IKqEFVJIqoQVUgq2222syczJOpMnL1555fz9+AAC2222uc5znOc4QVbbbbbbbbfiCrbbbbbu7u74TETASFQNUJULATH7imlX75yP1GJ7RpV4laj6mUI7J1FfU8JwLtRxMVRyTRNJlNico1RPqc79mTcyfTImSzJqd9/fWlAAHUyAFAAAAAAW2220AAAAABbbbmS2gAAAAAAAAALbbbaAAX2ZL1bbaMyAAAAABbbbbQAAAAAAAAFmR0Ftt/i2/A+AAAAAAAAAttttoAD2ZDsAAAeTqZEyJk/J2n5PyfE/J+Tifk9T1PU6T1PU9TpOCT8n5Pyfk/J+TwnpUepiV0n5OJ7R2nyo6T8n5Pqeyuk8o/J17JXkmZJJZMnUyZnf7JmSZOfc5Xv33wAAAAANzJ9MyZOdTnOazJMsydYQkP4DJA7777ttttttSCrbbbbbbda1uZO5k95zXP35+/AAAAA5znOckPSHxDwh3333bbbbbbbbpBVuta1rWta1r2b3vf05znOcpbbbfgADnOc5znOc5zlkLbbbbbbb8QVbbcLerbbbbbahIEPcAIJDvvrvv777733333334AAAAfZknJk5znOTJve961bbbbbbbbbbakFW2shAk/BDJJmZJ975557+8++tttv4AAAA5wIK/EP2EFe90hmEN3d3SG7u227pDMIbu6kFW222221AhoQ877778/ffW/oDgAAttttpqZPZk/ZkkOt3Ugq2222222222pBVttt1rrMnm9639999bbbfgABbbbbTIekPCH0JP0geeeeW222222222226ZN73vWta1rWuSTLznOfj6222/gADnvvvvvvvvvOfpA/SBhIG7u7pDd3Ugq4eC1tttttttttt0gq+Kv79+/fc5znAAAAANTJ9mSdb3vWta1rVttSCrbZC222222pBVu4r99998AAAAABMn2ZmZOc5tttvVtqQtvXTbbUgq/tIbu6kNxPPPPOy8JqOdKbvOSbEzEzKjGKs0maT+OJOco/UdOpM1GYT4JqV4LC1E0mo1VcUYmEGJklhWCsVisVhWK4ViuUsLBWqWiurU4FcpYjKNRiYmkjSYkmJqjUaTomhTgnBOJP58ynk689/ee338AAAAAAW2220AAttttoAAAAAC2222gAAAAAAAAALbbbaAAAAAAAAAAttttoAAAAADyW9222gAFtt/i2/A+AAAAAAAAAttttozIAAAAAGT1PyeE6TUcT7R3R2mo/OqP1GUfE9T9UfqMT4mk4mTqTMzrMk6mZJ/GTJ739v36/ffAAAAAA+zJPJk6zJPJk8mTvMyfx1HI+n0+neaEaAVoAWpqiqommChaVSlAS7u7d3d3d3d3hPeW22231VSCrhDxa/v3739znOc5znOc5wAAAMyJkTJZk+mT3333cybVtttttttt7IKukFW2221JA95znL78+AAAAAB9mSfghu7uFvV0gq22222222pD03d23Wta1rMm57znOfv36/gttttoAAe+++/EkirbakFW22222221IKuta1rWtbkydZ9Oc5v77774LbbbaADnOc577776Q8Ie999922/EFW2222229dMyb3vffffeta/b/dc5xX78FttttABznOc99999SH6QPiHXffdtukFW22222222222221kD8EKQ777vfn79+/c5znOc5wAAAW2p1MiZEyfpJM79998tt0gq22222222224W9W21kDzd5zz3774AAAAC23UyfTMhkgqkFW222222222222222353vf3333wAAAAFtv2ZJ5MMCQP0gd999+irbbbb2QVbbbbbbrWta1rWt5MmdTJ+5zm/36/fgAAAAAJksyfZJmeTzzzWta1rWta1rWta2QVbbbbbbVV6CHUgfBCl98CHQkeVHtGo4k4THJVpJiZTqjE4TEwsToTIWo6TkquqK6J1RidUrpE4TlK1RuEyViYnVHRNUcKuUcoxOVExNyjjJ1mZJ1JJk7zv77e+e/LaAAAAAFttttAAAAAAAAAAW2220AAAAAB5Le7bbQAC2222gAAAAAAAAALbbbaAAAAAAttttoAAB/AA+AAAAAttttoABbbbbQAAAA/fv379+/fv3afU8Uep0Tiep2q5SvkrxOJ9lep2UfE1HidUeWSeyZkzrJmZ7MyT9Jk5zfF+v3wAAAAAP4zMk/SZOupkzrrrrrrM66l73vD4ilpSkSgaQGgAoK1EbWZbWzMrME2JbSImmCSqWmmYmpBoKWhIGQKIqKiCiKqqKkpgiqppoEpDoEFyCliorMwwzAww3d6662222pBVttttttt1rcyb9m5k915rz9+/fgALbbbaA5znOc5IcIcIaQ+IZ333bbbbbbbakO5vfe9a1rWta1rWta1rXvW9799+++ABbbbbQAD7Mk/ZknUzJOc5zcyb3veta1q222228IKukFW2221gSebu7+/e/vwALbbbaAAeTJ5Mn7Mk9kPPPPPSCrbb+IKttvwq9kFW223WvJk3ve9TJ71ve/1v78AC21AcHOc5znOc54Q+CQOd9999kFW222223sgq6QVbbbbdVUhhDzd1+99++5znOc4HcyW22+WgAH0zJP2ZJznOJkVbbbbbbeyCr+IdkN3d9VVVVd73veZN+fvf34AFttttAAMw4Q4Q+IeeeeefEN3d3BWqq9kN3d1VVVVVVVVVX33377nOc5znOc5znOc4AAB9mSc5znOTJznOc3ve973ve972226QVdFW2221VX77777nOc5znOc5wAAAGZPJk5mTnOc3ve973ve97V+Ibu7qq5Fa4QVrhBWukOiH0888351Mm833rn3z60AAAAc56Q5nOeEOyH0gd+Z555hBWuEFa4QVrpDohu7dwgrXCCtcIK1whu7ruEFa4Q+vsgYEMCHwQ6CHcCfqOedco3pNRicEWqMJyjK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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
