#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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8BQwKi4jIgSEgBIpAUISd7r7f1/dBUCxkioMQEgKERFMRDOETkDCiBAJJJIyQIiCyIKFiEqpeaEbvnbvcVGIoSM0AoSru73d30QFS5y79j3ve9fIoIX6qv0Ufefe9buIoZQW1BakIwYzBSiFAoSKtiIyiEpqoAo0wKq84u+WXyWih6CgTvte9r09PetVEWAA3rzttt9bHSpVxKqSN/AY33suSAoSeJQpwhxQYCVQqgeMe9r7f331/QFDwqGungBDCgmCKq6ip/lXs97vew9RAICBY+TXd193aSCB2vnd3d39SiHkQXnvex4MHvd90DIChFECyDJCLIdKUGhRCdrt6zu7u1RSwkIQkREuCIhsEYgUwAoBQ9SBgkIoKOc1j3va973REVwWCC1kKhAUMYu7u99vqIGyAgpcfPm8fX1mLlUkkjYceN9/AhBJJJO4Zv5nk9fn8BJmSacAFXV6qrf7+LdAB7kbe229fO223zrbgGgA8WfeANknuxe92RTuZjbGoAADabbbbfnYB4yB++9999r77775wNhr2mg2+vcfGB0wHptt+z0em22B4iuKSSSSCoEAAAMsAAfW222w62fAffOBsFbBwabB7oyA8++ttttv9+5ZbbbaECqr1Hirqur0D997777X3333zgbBsHA0E5J7Xve82+sNAAB6J2pF9JJJI2m222R4yD0ZA++9999r4fnA3++++bG3xtv5ttvG2/m2m4X2y5ck+kkkki/v6222rFVA04AKur1VX+u23y3775wNh9d19z775sTUk+OjIDwNAAB64IAAZKQIAABUMsAtrq9QCv5Xy222/rbfbbq/eKvy2mwAMB6bFpKqSitXrn25uTUyGyXVVSVJqoTPazmBUgFAqRaSSo1KhKVVUta1pLtpS92pctdnYcVTWkAbAHwsH3oyfe9Hq96fIYidXfMwhIJLfc+7o5doarWw0B8DDiptvbmlRaA+kknJckk5IpJySp9JPpJJyXJJOSaS+v18O8+VKk9WubpUqWlSqlq6f3OcbjnJFqSTckk4y5AkkYTcohJKjcXEkkCclJGMXLISqrJEwSEJIBCEgEhESRSRWEZAJJCVKIYqoqwJAjGRZPFFDCJJgqqjKKILCIyEagUEhCEiRILGSMCEkhCQhHJKkr3TPBySSTJJJyXFNUiapAAYkqVPzgABSSSAG4AbAOSSTkAOF0ve16/e97fgDhN+OK0qSV7u1Ppzkka2Xvmk23vmNwzgAcOnW9Jtt+GQrt3d3qbX0n3Pvvvugj5RCQBkhCCAFqIRRJaqlSV1VKtNsAGqLuwBttu7tS4AAPiZA4ARqkWNtt9indRWlVUt2lVUrpK5qZOybk8qqki+yfT0ySSZYBMkkkkkLHpUqbh4NdCSRuUWAHEqDSQ2223HNAAAF0lUTSqrTSqrVgsLUiPta1r3va/kR5wLGxGHvsa5v6SfNtjbbbfmHQHVKkmVSpLVKqSvSEahVVdy7oRu8K+6ohaiFUCC6v8fIVVdpVe4sWs4yXVKskYAAB8NtvG22222wNRSSSSSGXLJcmSSSAGg0qVAD42223F8gADoWqpVLQAAeKgSSSSTSqqSGgAPANttt223tUqbb22T5VVJSfSSST2ZF60r2lVUtGvucTbg22223ACw0qVADeNttuAAAUaqqpJttt9bgAAAAYGlSoNA24kAHEg1JJJIAL69JeWtXYjYcVINKoak0lJJuXLly5cD5FqgDaQEknUpJJFOnT4NgJMsGwADA973ve97AKFloKoZJFBgQorhVXee32lHt6bVAmgFCru9Xu7v1qAulV5QKEnp72fe973yj2Eh2fkkDEC4tz8n4BH8olUboOQxEWYO+2oJmIAo5zeAQRuCCF/n5d6VQu6BBbiC3FFS4AKF3d3nQKFXd3u7L5d0A6NNA68bBsHA0B0vVVXVX8HQAyZMkQAAV8mSZkOSAHoCr3JMA5JmSHJMyT3ebqfgAABgDlUxd3VUmZJJIvuK0bG7u7d3d3fYprQBKHIPuq+67u7u+xVtXTFbODve973qpV0wA73ve96qXdMAO973veqlXTF1dsAe733vZ95qrpgB33ve97yvVdMAOz3ve94qrmAd13d3d9oI5d3d3dd3d3faCQQkSCSRSkFHEFQ6EBQGyAqpUREblxVDcEbgCjyKqA9iAmooKAdiCFRFEOwVBewUEBxFFFDsRVAOwES4ooXES4igBmqq7wBtTxngHRoSbkk3INg4GgN9GXAeJd1bFSSSS1GwEEJ3ve973aj1LukDEFAB7FO9rs7ajV3ebu+CiJ2diIAdiLdXVSqu5JDzFVVUNA4AMBhelAUuXEQU7ZcMAtTt3d3zhzlc5zzlXTADvve973nqumAHe973vUqrYAd73ve9SrpgB3ve971KumKq7Ad73ve9SrpgB3vfe97zlXTFAO973vepV0wwB7ve971KumAHe973vUEUDEVURzFFB7EFEMaoRQw5zZkABMxVC7pRUS+UAidvuBVDvaROwEE7HsURbu7vUu7u7svxkB0aEm5JNyG3A7wNAdGQHvGUqSSSVdXdpJJBk1dVd1Ukk5JAXVvGdySbBsAAMAcu7uqqiGOZA73ve96lXTADve973qVdMAO973vepV0xVXYDve973qVdMAO+973veeq6YoB3ve971KumGAPd73vepV0wA73ve96lVbADve973qVdMAO973vepd3V17FWIuIoHcXhVRMYpAS4KJd0nO13FXV1VSZu5ipiqu7q7mKBzACnjIDo0JNySbkGwcMmwTo6qq6vFADQmSZEAAMi9yPJmQDsO9pUe9rve33Q9iiHJyAIHIA3Vde8nZAAAYA5d3VXRDHMgd73ve9S7pgB3ve971KumLq7Ad973ve89V0wA73vve95yrphgD3e973qVdMDQe97ve9SrpgaD3vd73qVdMAO973vepVWwA73ve96lXTC773utave930TUEXnaQA7AzERqBcFQzJrOprSoI61nCqCazV3eEu6Eu6rrNUZYu6uqBzACnjIDo0Uk3IOHDYOBoSckmZIHlUAAJkzHd3d3UfMkyTAA+AT7ICPYChy1GuwFDsAUOZ5y+4Ud9g6M3dWwxTDA0Acqqq6qqBjl1d5JJznHe9SrpgSTne9e956rpgB3ve971Kq2AHe973vUq6YAd73ve9SrpiquwHe973vUu2KAd73ve9SrpgB3ve971Kq2AHe973vUmLqmM3d3d73ve97vqiIyqFQMQJDZMxFCaiNKIlkUYIwBELqlEW93g5EF7FQELgColxERAOxQBbiiIXFFuAiDcFVAuAgXiru6ujJm6u6vCST0rHZMgOjQk3JJuQbBwNCTkkzJA8DmLyYq/K4bu7u7I97JMyQ4nYBvoCBVSSZrWKqruq8knddkHQAGAXpAuqFG4iqD2Hbqru+3e973ve76owA73ve96lXTADve9733maumKAd73ve9SrpgB3ve971Lu2KAd73ve9SqthgD3e973qVdMAO973vepV0xVXYDve973qVd0wA773ve956rqRRDcK5SiGQLq87vLd13fcKqVLvFuVd3VA5hJIU8Z4B0aEm5JNyDYOBoSckmZIH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AcQBCRFESpFEIoIKsBQigLCCoH0BH777777m+AIIcioIPIKInIICjyIBz6kEFLgj6qJBKqhKgMgkglQRqCSqUqCSKSAIAhQCh9SAgUoxYgJBESKiEURYChAYChAxESlEIgtU0ookBQ+++++++5znUFewFDMBQ73vftChsFCEUQiKEh6LUKgkglQRqCSqUqCSKSAyCSKIpSIpEPoKAmIAgSCCmAUICoRRCH333333298RE5AQHkQE5AAQ5z7CoJ6CeqhKijUUlUJUUkUkUkBkEkBRQpRD6qAUICqYgChIAJ9999999vfEF5EEHkRUDkBBec+wiieQEYCBBAJGISCPoJKoSoDIJIJUEaiVJVCSAyCSKCI/RVAwCCxFEBiiEUEAIAAQQWIiBEEGILCAKGKQAGRRFB+gKP333333N8eRFQ5yhFDnPsCgC3BPVQkqhJVCSAEglSopIJUEagpKoQE+jWKpQCCNQVD7777777e+c5zmefUiBcBkEkE9VIhSNUJIpIDIJIDIJURQT6KKGCACP3333333uc6HYive0Ch3v3svolQGQSQSVQkqhJFJBJBKqkQRoFCICkUQgIg/REBaiKoOJQgBGCjJCCiEERiiEQEhBBKgKiUChEASKIQFFPp999999zfFXkUUOcoQF5z7AgiX6hKKoGQGQGQSQGQSqpSRSQUAU+ioDgFCAIBggoP333333298RTkRQQ5DnOfZRE8ohAECERQgKERQfRSRSRSRSRCQqLUUkUkUkQVCKonIL2IicgGoaiAIETUHSQAEwKi/QUUPooI/RBdREE39Sio3EVQ+gr9FEPAKnKFAU9AREqKqB6CAvoooqYgoCHoKInoKAPogD6IIp6XLLsPqq7uiMA+PGQHRoPqur+MANgN7bbfGxJUkGwAMBUgEqo3RdHweA8lVUt67VKrqklRoQACqqo97qjj05PQzDQIL6j2A9D0M+o9dXd225kmSlvZMySyZlttdxVVVV8eXd34U9s973vaLiCJdgAIfKCkVIRA9EAECgUIIgSRAkjFEIsBQgABmFJAUFSIoRRSQgQJIChFFU973vffb3xVR5BROhBEIQSRikEVkkQR72kEF737CIIG0UIKqHopIpIpIpIpIpIpIpIpICqDFJQKEUBPoICUChEFQAgKEAFYowQFZERRGKIQVVWAoRFVPvvvvvvt85FAeRFF5OQFDkOQ79QiJUURkJFRAPQUEaCCwFCKoEUQiqMBQn0RBKixgQhAUIKJEiIoQVCKfRFD77777nN8F5BQcsQUIySRUYwkBQkGSQhEkhISEjEOQFDkBQ599gQE9FJFJFJFJFJFJFJFJFJFRUMRBF+x0wKhIogH333332ta3xkhIc5QAoc997KkikikikikikikikikiKC8BQhFEIrAUIIKkVEIkUQkQAhAUJFRCKiEBQikQWAIwFCIIkUYL9FQVApRCKqGIoKi/RET77777etigO4KAbgm4oqm/vsD5RCEUQkigCHopIpIpIpINMqINQqKSKSKSAAg1EBRiiEIChEQQPoCKtKIRAQCQFCKISAoRQBCKMEVxESlAIIkgRRCJIsJILAFCKEgEBQiQJAUIgIRUYqiMUWACkBQhAUJEFT6lR++++++5viiJyI9YKAQIQkIwYxhAkgAB2Ao9gAK979g2gsEPRSRSRSRSRSRSRSRSRSRVUQPogoIYEAJIKMBGIoAQBQxKYgCwFAYChIAoREIqIRFCQREIKsRFIChJBVIChFVCKIREE+iiH3333297iiu4giBuIoIbgIC7++tRDICrJFEIoiB6KSKSKSKSKSKSKSKSKSNREER+giqlAoSQIChFRQxFUKUQggAB999999rm973v761BX0UkUkUkUkUkUkUkUkUkUAQ+gAL5EUYKCEUQiRUCQMQogQgQhIsD6H333333Oc53EAhEkkJBJAJIB2He9waSH0FQKBGKIQBQh6KSKSKSKSKSKSKSKSKSACJ9MICERWKIRFAiiEQEgoxFCMZIohBUXFKNP333333298VOc5hQec+wKqeikikgknmJUUkFJBSQHetZIBuBeN3jnMndJX3BQUPu0ohqP3vfZEQD7NDcFRXMEFLiXFAS4NxQaSd0qpLLpsNpUXSqkrAA97rem22B1vTbbA6AACqkkGNs2A3ttt8begAfi5mZI2XzHmKr9FzMbZbbVS7wgoNwRvtJ3yqlFxu7u/Hreg0k7dpVSTTbbAYAAFJKlQAAB4FT1envex6emxASXG1C4iKfKITUSRT3ve999vfB5FEOcpUec+vKkikikikikikikikikgIJ9BECoCgMgKp6P0UH777777vDkEA5ABTkRBeQVQ5FB5PogB6KSKSKSKSKSKSCSegFRSQVQaAUIqh9EWlQMH3333332+85fe9797akikikikikikikikikiP1Hj7P333333N73ve/vWpIpIpIpIpIpIpIpIpID5RCfYPvvvvvvr5yuTnOc+vaEn0AqKSKSKSKSKSKSKSKfUY+zSiH333333d73ve/veUkUkUkUkUkUkUkUkUkEE9IghEk+wfZyI/fffffd5yHOc5z73FJFJFJFJF9KikikikgkqhFfsH3333332/c5znOfX8JcCopIJKpEKqhKikgMgkgl61SpKfKSSSZmZmZBzSpauqV2lV2qV2JKoBKqhKikg0yoIH1H3333332973ve/u+VJFfoFQSVQIVVCVAZBJBJBJBIgIB9FFOwRFriSvvvt/vfvwxTFXd1TBm7q6qqDagJPTEgDZMzJaW9tttkzMlu2221fgH1VfVV+V6AB+LI2+Kqq0ALkzMirfJLzJXrw5f2ZMV8fkA7JJmSbu6zsgAAMcDae+KB993ve9737v3wlRSRSRSRSRSRSRSRSRR5j3qoEH3ve9u5mZme+wkJEhIkJEhIhXZdJauqV3VK7qldqqmlJJJMO97096G1JFJFJFJFJFJFJFJFJFPqPve973t73ve9+75SRSRSRSRSRSRSRSQPiVEfqPvvvvvvt73rWvu+UkUkUkUkUkUkUkUkUkUv2D3va972971rXu+UkUkUkUkUkUkUkUkUkU9Rd/aEfffffa72nkecrkORPvUpIpIeg1FJFJFJFJFJFJEeH2D777X331893ve9797ykikikikikikikikikin1H3ve972971rXu+UkUkUkUkUkAk+gFRSRSRH6j3vffffb3vZve/s98pIpIpIpIpIpIpIpIpIpzurzru9czNFb5s5rSKj6CCIBuCi7iI7gIqByAoeiIB2ej6IKNxQRG7pUALiqlwRUuAiIXBRC4Il3SII3ERJd3d33vOzvZIPGXRo6A+qru6++6Pt/ffGwvyvQAPxZMkxtL9nJky+W22zJmZXNVd1Sw4ZM1bFVVVVEn1VdVTrQe4J7gKl41cEaBQuKoh3He+sFU+tgAAbqlQAGAAAcqkqVIulVJF1SSVID5AcAO97ncwe6pXdUruqV2pIpIpIpIpIpIn0fc+0fffd6I87X31dne0and0fT0UkUkUkUkUkU/VUpIpIpIppIfmD3vfn5+fm/c5re/y/lJFJFJFJFJFJLglRSRSRT6jF39fvb3vajve/d8pIpIJIfRKikikikikikiP1H3333332973rX3fKSCkiAQgpIpCKS09R73vb97e961r3TykikCKQGQgkYK/VSkikinpOAfpHvSPLUCDq1H3tgHVqNoXbB8vkSElJFJFJFJFJFJFJFJFfH2D1/e97Xfua19fykikikikikikikikikim/sF9++97Xd6R1r3fB9CqpSFUDIDIDIDIJIJIJIJuH2D1/b97WPt6199fwkglFUJKoSopIpIpIpIpIpABUeQBD6IAKk9BHGARUuIIifffYBAH6P07EVW4Chd0AXEQQC4qi3dAoX72FFTyAOVVKgA4ywAG+t6eNv5vG382235V9Vtv1tt+tegCu2TMyXkl/XV7d33oiJ313d3fveD3qB9EVD0VV9EPep94FSj0NCM973vb371CI3LgJV2xVXd3ckknZADQHQDl3V03qqp3QaQABmZmZh4qld1Su6pXdUrn0WopIpIpIpIp9R9999zgj999jsOzvaOc5h+nopIpIpIpIpIpIpIpIpID9R73fer3t/c5z3OfeypIpIpIpIpIpIpIsnYhUU+o+++++z99ve96193ykikikikikikikikikiPqLu7972973ve/d8pIpIpIpIpIpIpIpIpIp6j3ve972973ve/d8pIH0CopIpIpIpIpIpIpIp9R9999zgj9993Pe12b397Kkikikikikikikikikiln2D3ve372/uc5vf1/KSKSKSKSISHYNRSRSRSRT6j3ve+++3ve9a+75SRSRSRSRSRSRSRSRSRH1F3d+97e971r3fKSKSAbjUUkUkUkUkUkX6VFPUCKh2AoAYqKqfYUAUPvqUBE7BVEd8+w/fXgFQbuhUUC4KrcRUbiqrdu6qqpMPkqqlVF1SpKwABvztttsVUkg8Gg9YfAdA+ABKqpBgBsBv1VflegAfi5jzMmWyZnZFVTcmZhdeiisEfS73cLhcLhfoQR97WQzBFAPR9Bu9473ve+u+ooIXLgChcBRCwW7u7o1fMKNy5q7xd+FA9j3gA6N+57XvcSSpVS5a9dJUqr35IbUJJJve96193ykikikikikikikikikinqLu79+dEfvu973u9/etSRSRSRSRSRSRSRSRSRT6j3ve972/uc5znPr+UkUkbjUUkUkUkUkUkUkU+o+++++++3ve97393ykikikikikikikikikiPqPe973vb3ve9793ykikikikikgkn0AqKSKSKfUfffffffb3ve75z68qSKSKSKSKSKSKSKSKSKeo973vfdEfc5znN/c+9lSRSRSRSRSRSRSRSRSQfa+yffffffa1e97vn1/KSKSKSKSKSKSKSKSCTtCfYPe96/ta1r7f3fvhKilEaiNQqKSCE2QCG2CGiQkSEgD8h6B73ve913d3fu+FJBfolQSQSQSVQlRSRSKIhUFAE9FVHBu6wov0FEWQRR1D7VKIffdwgj9FRA+ggA3FBULgKFwRELgiJcVLiogxQ0oARgjAeMuqNHRoDgbBsHBmT4PO3d1dfvv1fvvvrbVf5VG9tsv1q+gHoVVWAABAAA+++DdWxdVV0xVXd1Q1S7vvta1r2/d8pIpIpIpIpIpIpIpIpIp6j3ve990R9yuc5jk+597KkikikikikikiEnotRSRSvsH333333293znOc+v5SRSRSRSRSRSRSRSRSRT6j773ve9ve973v3fKSKSKSKSKSKSKSKSKSI+o973ve9ve973v3fD9CopIpIpIpIpIpIpIpIp9R9999999ve973v7vlJFJFJFJFJFJFJFJFJEfUe97Xve+yI/Ts72u9rvKQ+9Skikikikh6BUUkUkUkUkR+o+++++++3v3Oc5z6/lJFJFJFJFJFJFJFJFJFPqPvve972973ve/d8pIpIpIpIpIpIpIhJ9EKiP1H3333332973ve/u+UkUkUkUkUkUkUkUkUkUiiHc0YEQx3PtAKgegmtUIge97uURR9dCoLd3guXdA3AuyrivsVX4eKq2TMyWlvbtt8X8r4qOBsGwcDQHX1/ffAeMqqqq3zJMl5leyPIcyH7MmB0qqoAACqqqvuY8ir6Ae5mSZMAsvR73ve97e973vfu+UkUkUkUkUkUkUkUkUkU9R73ve977wj3od7kO97j6eikielRSRSRSRSRSRSRSRA+o+x999999zYe5znOfe8pIpIpIpIpIpIpIpI5jmJiKfUffe9673sN73vfu+UkUkUkUkUkPoNRSRSRSQX6j7777777ew3ve9/d8pIpIpIpIpIpIpIpIpIj6j3ve9729m973v3fKSKSKSKSKSKSKSKSASfQCz7J9j777773hHs6drs1O97gz9XopIpIpIpIpIpIpIpIpID9R9999999v7e9739fykikikikiki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ZJDefvvvm2KureOcHm+tjoyA8YCqjFVVViqqotzy2220BmKqtQAVbaqbu7QBstt9mW236TMyS8kklttVQAqqqqvy7u7v797sAAAm5JJyS7u7ya+19eT8AABM/ZmZnLmd73vaz2AAAZv3ve9zJd3d8nYAAB9N+973uSXd3dVOwAACbkknJLu7uqnYAABNySTkl3d3k19r7vcn8AABm8zMzkmd73vbvPYAABm5JJyS7u7qp2AAAfTckk5Jd3d1U7AAANa1985fvc25v9/cnOc593774BwNg2DgaA6RrITsmJJIIoAFACACIAACAAAq5kxXjyZMAD6wK+qttu29VAAAVVVVfl3d3f35IBo0BNySTkl61d3k19r67z38AABKz+zMy+Zl61d3zmXgAAE373vTkl6u75yXAAANd0n7973pySqquclwAAD2p+3JJySqquclwAACbkknJKqqya+19d57+AAA5n7Myf0nOZXOZeAAAvD4A2HOeznDpd3d1aupeqJ9qQ2HOTOcy4AAB+/av3ftfv7+36dv9y5U97973vL8q+eqr+VVV8Vtt229tqn4OAAqMVVVWKqqi2222tBVVagABVAN3dd3UAFWzMyS220Squ/qBjgCBw9Xve93qfYxjGMYABNyT3973OSsmvtfWvPfgAAJpn79mT+97nMrKrO4AABm8z+zMqTvbu6qd8AABNySTkl3d527z2AAAZvMzJyS7u79dz38AABNyf0kqTvbu6qd8AABNyf0kqTvbu6qd8AABNySTkl3d3VTsAAA+m5JJyS7u7qp2AAAa+++1pGpJzPtfa+zMzO5e2sz9+++59999sANg1wKdGR+++eMCT4mjAdEU8Zu6sECmAn7MmNXvqxX3MmNYe+gHmZM9KvwG7uvbMzJAKurW3kzMktt9mTLar9Hi8193s973ve973ve5713d3Ve7AAAJuSScku7u8mvtfd7vEAAAZvMzM5Jd3d5d57AAAM3mf2ZlSd7d3VTvgAA0iT+klSd7d3VT2vPgAm5JJyS7u7qp2AAAfTckk5Jd3d1U7AAAJuSScku7u6qdgAAE3JJOSXd3dVOwAADM/ZmZnMy7u7qs7gAALXn697lwve91SpIWe93O85N4/SGAAYdtvlttVVVX1bbf1reeWvU+BfNfy834ACSSSSHcSak5Uk0Zu6v99b9ba/AABVDoGTA6fln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TZNk2TZNk2TZNk775HfbibJsmybJsmybJsmyd999u02Xm5k2TZNk2TZNk2Tzzzt2mybJsmybJsmybJtR33327TZNk2TZNrzXMmybJsnSpXnnO/t++++AAABbWSDmSfsk/ZJ9oHkYj+fzn58TZNk2TZNk2TZNk2TvvvqO2TZNk2TZNk2TZNo39cHnnnjtNk2TZNk2TZNk2TZO+++3abJsmxNibJsmyd999u02TZec4mybJsmybJsnnnnbtNk2TZNk2TZNk2TZO+++o7ZNk2TZNk2TZ5pzJsmyeeedu02TZNk2TZNk2TZNk7777dpsmybJsmybJsmybR333288rmTZNk2TZNk2U66mTrqZNTMzJ3MnUzJJ553q377nwAAALbbbMlrkyddTJ11MnXUyddTJ1k2TZNk2TvvvqO8mybJtP6zmTZNk2TZNkyeeedkX133354mybJsmybJsmz3HMmyeeed9psmybJsmybJsmybJ33332mybJsmybJsmybJsnfffUd4bzkcybJsmybJsmybJ55532mybJsmybJsmybJsnffffabJsmybTXnfc8881JN5J1Osk1knc33vX33z74AAW2238tt3kmsktrM5knUm971vJOsnWQyFtSwMhkDAtrIKsgqyCrZJ6mS2kkAMyAGZPUyT5aXvO73qqqAW2238tt1kltZJ11Na1rmSdTJvXchVZDd2Q1WQVbAwhbWQVZB1rWZOpkmtd65z9znAABbbbfy23yBkD58+dkFXyBhC2sgqwLAwtrIKsgq2BhC2sgqyCrIZCQ5vet+85zgAAW2oLu21knMk/YHuByByB5558gKvyBhC2sgqyCrIKsgq2BhC2sgqyCrIZISeb3rdvOcAAC222/lttmS1mTSvkDCFtZDIC6yGC6yCrIKtgYQ+HOcsgqyGQF1kPVtvnnvzzve970ALbbb+W221mTWta5knUyb3vWZNKyCqTIC6qtgW2xV7A23b6tu+e85wAAAC2222usk1rvXMDSFu3IC6qqru7SBbaQsBWvXSfOQ0NDUXWoaGhwlqLQ0ND9DhDqhlHIdQ6hx0R8h2jiOIZHUOqHaqeRkLkNKrSXVHcXJEyey5Jz3fvr0AALbbbaAAAAAAttttoAAAAAAAAAC2222gAAAAAAAAALbbbaAAAAAA9lvdttoABbbbbQAAAAAAA/5wBwLbbbaAAAAAAuSd5JuZkzeSMk7ySMknUmSbw7IcQ8fY+x+Q5GU0PkbJNZIyT2ZJNa7/XwoAAAHe973vesDIDA++eeeU/AZJJAzADMDMEW1U2UbAtktiVspW2xLaRsK2pLahbEptBWzbapbQbKW1bJTYbNqrYmy2tpbE2KmyNkbRbVNkWyzNg2lbKbLai2bVbFaw2bKbUbSNk2UzAbUbImwDYTYWyI2ozbBbDZVbQ2kNrY2Ngtg2TaNbajZVsW1K2NlWxWxsawtpRjGyTaU2iNlWyNtiNkbK2q2Wwm1K2TabRs2iNlNsxRsI2lZqm0q2ktm1C2BrCm0q2qbVG0NjZVsWwbTajaUtsyW1Nk2ltbG1sQ2G1K2WwtpWypbI2WwVsk2qLZS1ithtGybNYjZFtLY2toNqFs2S2pNkNtiNqbDa2ltVTZLYtibI2m1TZVtsSNltU2q2tkNhNhsqNqtrYJtNktqtijYJs2obSTYttibS2mZSm2ZTaItswtpNiFtVtGyqtkbE2Q2ibJtIra2rYltEyWRaWqjamzYzKqYDFWqmGZNm0tltbUYGoq2qqYlhsrYW1tLYo2KptUyjUGxWxtS1ptFgY2BhWqYGlZS0hgZJW1LaqNlmpsqYGraFTA0BbNjYNotltVGqrUg2kMBomqrE1RlVGoZKratms1m0lVgZSYGRRgbaqo2LWmyVrRtDCYhaJiVbVRsNVWplJomA0JtEsxbKmqrAayStlI2TYWxFmbLa2Gw22q2RmbLbbagxLUKYGLQMrVVqq1RhiYDakjEslsibRskmA0i1VYSm0lsbDZbTWLNttmMzZGtW2xbCMqZUpaLLYqsDAwMKwMKWBqhVhWlSsJgbC2VWqrQLZLZmDZZmxsZo2BqybQRqjFRappFYGSFgYFYWBrAZqq0aW0hqRYMwK2VrLaWBopawpslNaIYGSi2LbaVtbNrba1rZtmrbYZomLUbEqrA1KMLFSsowqwsDC0SwNLWBqpaRWBhVpLUtaqrAyjA1KWUmKYGowMktiRgam0C2qsDFJbEptYlo2FNrZW2y2bba1tLNG2aNm2zZrbWspA1DJYGlVVsE2BTKMSWBsDIGgYGBilgaQsDFNUsRGBiiwNVVqqsKWBiUYGqYGVS22lbS2msVts2jaZmzbaGabU2bUWmNYGwJtQTAZJWoZqlsDETAyEyppKWy2kGqrQNojaJMLEFqliEwMKrTFkwMDSlZVWFMDSjJLCmK2JZRWBiqa0DE0obVVaDSLKyZVqqsDJDA1VWBkkYGiNtrZWtVsVstjWsza2zTa2TazbCzbVsbNrbY2bNhWaJmCS2oLbaJTZZpIbVmiWBhZNSWtmBsSs1qyqKwMVVqygwNQNglbVUmsqVgaSwNRpNEmzalMDUq2UVtrErWIm2wGAapGwm0qjAaiTVVlKsBhbKobZmw2bTa22U2qrYmy2jbMTLVGsVsra22bBTaBsBWqrIGwmiZSWyijCsiqwMQLA0Bqq0qVMBhLJNJTVViC2KjAYDQNLYSYDaqrMBgGA1BrEWtYGFZJrA0KYDJAzVVaqtVWAaBaqrKahgZqhsqYGC1VWW1LY2mwtms1ja21jZG1bW02Nhs2bbE2TatlMxbC2SZtthstWZjNbabTNm1o0xomYo2wMAwNFW0ijCslhMRCwNRVVgaKWBpIqwNUJbbKk21VaRNVWA1VYDZBqqsA0lgNVWAwGAqwGBsBkmqqsDJGgaqrQMkrZSsDVDQMgrA0SrVVag2pRlVkG022myZtpmjatqM1s2LNtTZLNtbNpmktmYttk2bW021s2y2rbNtJtsRmG1sjbZtjM20xjZbLW1mm01tts2bbLbTNMzatjbNiJNVWokYDTaiqtoK0VokDAYqqaqtUE2oVYDBG0DUmIjJNAWAxKYDATVVio1VZSkwNEwMQWBgaqNBbKVYDSqZVWAYDAwNAsDVVaqrUo1VagwGSYDAWA0KbW220s02FmtpMybS1pbLNWybbC2bCbTYNtZNqNtbbGazWG1rTZTaK1pbNk22VtbTbbYm2ybU2mza2W0bWaZmZbbDW2VRsFqGCq2pVgaqqWBollgatSKmyApqqyiVmhIYDUkjZSotJGAwGqBMDIjKE1Im202SralbStobS2202xbFWw2UbUtmbbMra2ttqRtRsbVsJtBsptWxmWaNlDYEbVQbQVW0bNKakLZQVbQlDA0VaqrRFsFA0q0BTaqraKwGEKYDSRakylS22RbAaDaqrEtgZUbQNA2zW2ZNptQ2KLZbbVm22bBtKbVbDzzzzuLbVVVVSCrYFtqqquwPp8eXzz59bbbfgAAAe5J7knMk/YHIHnnntV9QLbVVVIKqrYFtrrWta1rcyTm8ke9++nOW220AACqrMirMgB3JLbQAAAJkALkltoAActt71d3d3d6qqqqqqqrMiuy23uSW2gAAAAFyS201rXU1rvW8knvnnnnPxbyA8AAFu7u7uqAdyS225JbaAAAAAXJLve9a1rrze9b5wtttvAABbbbZk3VAAAA7kltoAAAABcktt3JO8k98815znOW220AALbbb7knsDyB7gcgd757VVVVVfUDyBznOKgAAAXJK85yr971VVVVVVVVVVJkhkivv377kgHYB79+/mSAUA5kltoAAcyT7znOd79eqqqqqqqqqqsyKoB3JLbQAA7LbeZJ7lvu3JLbQAA+W2/O971VVVVVVVVVVZkVAO5JbaAAAAAXJPcDnOcVVXbJIEwgeyBpCAaQMIc0oco0P5DQ7R330h/Id9dRLI9Uv0airiMSWRijUWRoaklkaGRrJmZck6zMmTuZJ1kyTJOpf3Py39QAAAAAAAAAFttttAAAAAAey3u220AAttttoAAAAAAAAAC2222gAAAAALbbbaAAAAAAAAAAtttt/jgBwLbbbaAAAAAA7mTP2SbySdzJOphlMjuOo+I6UvkfI4l6loZDQ0NDI8jui6juNHIdx+j8jiHaMjUlhLrJN+d6r9+oAAAABMn0v7MbbbMbZNjZsZazbJtmWxmma2oY0zRf1ylV/X9f10rnUWttFtrZiSDahNZKMyiY2a0tqZM1sbJZnOc5YHyBznOKqqqqvIHIHOc4K61rWusk/b3rf331+AAAAAeoHqB6geQOQPPPPfbbfUDkDnOcVVVAttvMk5knOc4AAH3kfnz58fvd6q7u7ttoAAayTu23eSb3vfMk3ve9a7YFtu7u6jyBa7usBbbAPsA36wBzJO/ffffz7nwW2220AAPckt7+Kv2Bbaq4LqqqtgW2qqr9hJ9555599998FttttAABkgaV+wPfOc5YFtqqq4uvIHOc5ywLbeuuuvFV/UNEncYqDlHz3v33+v6/rnwAAAADJPpmZk5znNa02BbbhBdcF11xfcC23kDnOc5YFtoA/fMknrZmSZPeZJ65kh9+n3zfO+KqoAAAPMk3knMk8yTeSdyZDvtVsC21VVfkC21FeQLbVVXX2SR97777979z4AAAADeQsD4Q+fPnu237A5AyBznOKqqq+W2+ZJ75vesk83vffff2STX7rzzw+fAABVVVVXdm76h69+ZIB7oAABy23mSW2gABZknec5zve96qqqqqqqqqr2ZJ3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zvzveqq7u7u7uqqr3ve975ANgYEA+wDzzzxVVVXkC20AAAAAALJJnrJPOc5fPPO+Kq7u7u7uqqqqrckMk7mSYqgAAAKtgW2qqqq223SBsA6QPiefCOEHiHyGhxRyGOSWlGhidQyOIyMpkdIaSaHUchXVRdI6hkdSXSRxHJLIbiMSyMjqHSNQ5RchyGhypGRuJkzuZkk77n5dcfv1tttAey3u220AAttttoAAAAAAAAAC2222gAAAAALbbbaAAAAAAAAAAttttoABbbbbQAAAAAFttttAAAB/AA4AAAALbbbaD9+/fv379+/dx9jxD2Okcj2O0uSXxLyPsPY6IfI0O46h5D5JJM6zMmfpkk+mSeeb8Xl5wC21AeAAP4zJI+mSd9TJnXXXXXXfUzvqdc5za7ZtW1NpNi2qmwNjWojazLa2ZpbBNiW0ma2atNtjZszWbaptWxtLSwbM2zbMbM2222babWM2trZsjZtErY2rbbbbMsznOcVVXpbbyBbaqqqqq2BsD7zzXn37774C2222gAHmSeZJ5kPIHe99KuC6qqrYFtqqqqquub3vf79znALbbbaAAcySfZJMIB5555YFtqqqqqr8gfec5z1A5znOW22228zJM5znOeeb54qqqqqqqqqr6yT1knmSTsyd73u5JznOcttvmSc5znLbbbbfUDnOc5bbbbb6gc5znGBctv36/fAAAAAd5JyTJJznOc9QOc5zlttttVfUC231A9HOc4q+rbXWtbyTzJOT3333zzl5wAHeSAPwKqvZkk8ySc8888ckttAAAA+5Jbb3JPmSc5zgByW24AEAmTzm/fPFVVAAADzJPMk8yTmSc5znMk3vewAA5kltoAAAAAAAG7u96qgAAAHMknOc5vJN73vm973vdtAADmSW2gAAABst+d7zvVVVVXd3d3d1VV5knvJGZFQAAyAPkDCFtZBVkPVtsgqyCryBhDe96kzWta85zjgAC2222gP2SMDYHkA8855IKsgqyCrYGELayCrIKsgq3IFtSCqE9QDSBofUch3Q+Q7967RvYaGRwKahiOQyGhomRkZGoyGJyhwS5DlQ5Smhkq1JcouSWRiHNmTMzzMzLOcN+PwAAttttoAAAAAAAAAC2222gAP379+/fv34AAAAAAttttoAAAAAAAAAC2222gAAAAAAAAALbbbaAAAD+ABwey3u220A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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
