#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        tos = stack_value_for(i)
        type = stack_type_for(i)
        if type == TYPE_NUMBER:
            r.append(format_item('#', tos))
        elif type == TYPE_BYTECODE:
            r.append(format_item('`', tos))
        elif type == TYPE_CHARACTER:
            r.append(format_item('$', chr(tos)))
        elif type == TYPE_STRING:
            r.append(format_item('\'', slice_to_string(tos) + '\''))
        elif type == TYPE_POINTER:
            r.append(format_item('&', tos))
        elif type == TYPE_FUNCALL:
            r.append(format_item('CALL &', tos))
        elif type == TYPE_REMARK:
            r.append(format_item('"', slice_to_string(tos) + '"'))
        elif type == TYPE_FLAG:
            if tos == -1:
                r.append(format_item("", "true"))
            elif tos == 0:
                r.append(format_item("", "false"))
            else:
                r.append(format_item("", "malformed flag"))
        else:
            r.append(format_item("", "unmatched type on the stack"))
        sys.stdout.write("\n")
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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3333+/u74pSlKUpSlKUpSlKUjzRmZnOc9999/v7m+KUpSlKUpSlKUpSlKQAI7+0Kq/Ruf19II771JOvOtwP7IUrMqius9yiE/QognvOeAqpk8slEQyVAzmg5lRBzJEc5pQ5/f20J/Pe9766q6Dnw297zDpkIAB8bfzbAAABv8xKkku2l394D8N6UqoTf33333N7DmaB5CCHIFHkhzmnnAQDRyec5znPeQAJu3CCO4FV++++9j7vUkiAOAH11VWZu7Yv3s173uc5z3333333m+PYNSlKUpSlKUpSlKWtKR3w73vffke97v9vet/fefd1yBoGgaBoGhKEoShOa0J3R3ve9733n3333N77zD+E1A0Ja0JqUpda0pSlKUp3R3ve9733333333u+KUpSlKUpSlKUpSlI80c5znOc99999995vilKUpSlKUpSlKUpSnNHOc5znPffffffeb4pXYDUpSlKUpSlKUpSndHe9798j3vd73v333vMUpSlKUpSlKUpSlKU7o5znOc573777777udUpSlKUpSlKTGDUhqdSlKd0d73ve999999997vilKUpSlKUpSlKUpSPNHOc5znPfffffffsUpSgPZ1KUpSlKUrMpmU/tRK/taQq1ilH8777x100Qd7VAbmEGGf2ShPMCiDznPHnM8FFHM0CoAZKoOSorkiqGWSCmc54AovIUC5zg3u7erRN8bElSo7+ehwwNAAAApUkkGAHwDe0q6qp8bfW2/z+Voqu2qdK/1rmtPOecuc58iAc5yRV4aR3aPOc+ORyORy+3EjzkeB5AIryeQ8uc/vevrmt86nOc8Kg+zvJQ+ylDU9ezu9BJzTIbQsmPOvek96/gSF9XffZ9994bTbb6klVVSdp3VUqVP+UnykkkmZmZ779ilIV/kBqUpSlKUpSlKU5o5znOb2jzm973v777PFKUpSlKUpSlKUpSlOaMzMzM95999999vilKUpSlKUpQbk1KUpSnNHOc5znPfffffff83xSlKUpSlKUpSlKUpHmjnOc5znvvvvvvvN8UpSlKUpSlKUpSlKU5o5znOc577777n33M/ZD081qA1KUpSlKUpSlKUp3R+73vd7R73fm9783ffd5+UpSlKUpSlKUpSlKU53w73ve9777n33333c6pSlKUpSlBudSlKUpSndHe973vfffffffe74pSlKUpSlKUpSlKULzRznOc5z3333333m+KUpSlKUpSlKUpQJ3QoIUqVbZ9iJ9lfsr9iVPXO9bhd4qqO8fvdKHn77apP2KB/ZBTmKEcxQ5ilTmAnMqcwrqqYoaUEkkkkDDvDTZABvft3d+3dbbbbbb/M6rpVVVMxdkkikgAgOAywSEaADbbbb3d1alW7zdbbfm23r83xttjAA6qLqlSRdJKkuc54c5znOc99999995xTJSlKUpSlKUpSlKB5o5z9znOd/ke27dve/N/aQ7zSlCXNCahNRqUoS1pU1rQmoGke6O973ve++8+++++7nRLelTWtCagadTqEoShLWhNSndHe973vfffffffe74pSlKUpSlKUpSlKUjzRznOc5z3333333m+KUpSlKUpSlKUpSFdgNHOc5znPffffffebxSlKUpSlKUpSlKUpTujnOc5zuI93ve/4N7+87clKUpSlKUpSlKUpSkDujnOc5znvvfvvvvu51SlKUoNyalKUpSlKUpTujve973vvvvvvvvd8UpSlKUpSlKUpSlKR5o5znOc57777777zfFKUpSlKUpSlKQrrC6kSRA/XbwAXzzwUDP2K0n7X7ZVfv379zsIte6KruqGqYM1VsVRlQ3SSVvHZiSD1VdVVM+nvZ973oAE3JJuSAAaYvnzvx8AzWcAAABID9SVIug8fKvYrWLoBJJ3vepJmBOSSTd3MVB822+qqSSpth1AAGZmZmGlJS+XVK5SlKUpSlKUpSlO6O973ve84ju3vW7+3re9H7uuSlKUpSlKUpSlKUpQPdHfO973vfve/ffffd5xSl0eeaPPNHmtAHvv79m9Zkk727u7u59AAAPJvUkkku7u7ufQAACb1JJJLu7u7n0AA+3sJvU9kkmTzXn3333332ToAAGs3qSSSXec5znM7gH29gBrN6zMzMy7u7u8+gAAGtTckkk7znOc5yd6ABttttezPX26X6ZSLEhLovO91Z9oAIe+6qh7gE7991t/f2qhzIlXOaXV07kN2woAADHUayEACbkk3JAANPVW8Z973vdnlXdVVa9dVfvAkqpPAOVdyZknesVdXU73vU7IDTCSbkkgH11dVdD1++96SSXd3d3PoAABNySSTJ5rz7777777J0AE21vejRm/MzMzM+5yfffffZPONNNGBm8zMzMu7u7vPoAAB5NySSS7u7u59AANAam9SSAZ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JI4d6ADpPd3d3d1tttt67U73ve1feoCVSqurvAKk7detVZAA1+v8223vfqVCe/b3d1mtJKi+AAANv9+u0kkldfvzYHKVA1+AA6HKVAj9u7u7q3QAAOgAAbu7rb+bbfW/e93vepgLsAkkA+99iruqqvXd1VeAwAPAfrbbe77Rt9bfaVJK6VJK7SpV9Sq3xt592qVUksSqklnzbM9ugANgLvve973vWAOGbq84aoFLu+rXaukd8RAMAQkQDMznOc85zmZmYGBoUxW/aqwHfeoAB3ve9Fu6AANtttu0kqS3d3My1VPlUve9543r+zOCVJJNKkrOGYAD8szMzG9bbPe973ve972KqrqgCAAUAwZurGhoAdM1dpNSTknNbBv4bYYwAGbqwHQB8ZurmJJJIHwbABd1d1WawAgOvu7Ot93d3dvvtXzQjzRLPMj0CF8xsr2Kq7rf3GucndVd9np76eploCKABQHqq6qq97z2Pe97w6ZAcGjbb623822/vjvzbe7q1sAAAAAAAAPqVAAYaqp2293dGk3o93d3R6NtttgAAd73vegJ3dq6X8Xy7u7UuTMzK73zXnOc5zMnwAAGbySSVVVl3mdwAADN4888zMnsu7u6k+gAAHjxNySSVVVVSfagAAE3JJJVVVVJ9qAAATcSSS875rznOc5mT4AADN6ySSVVVl3mdwAADN5mZJVVVVJ9AAANNJuSSSqqqqT6AAAbzpmb17efe95JJiAIoAFZM3VpJudmJAOmQHBoD4Ngqvi+sAee9PvePb745oU/VGIV/dXdGx3yqhts0ou0AGgHwN9bdv7dxVQ0/3cTsT582/mwfaT1222wAAO973vQ0uwAHd7Tf5rzySSXnfNec5znMyfBoAAzeSSSqu7znMzmAAAZvMzJKqqqpPoAABppNySSVVVVSfQAAD6fp+kkqqqqk+gAAE3EknvmvJed8159999zMnwAAGbySSVV3ec5mcwAADN4zMkuqqqk+gAaAPJuTckl3Vf39zm+VVVVVVX71+80/kTkIPkqryHzmkUH+jlv9pEOQvJAX6BEcgRyFDXuhF5ICPIRQeSBypVVUXSSQP8hHAAABNvd3237b3W2OmQ973u+97XveHwA3t9uck5J56fki6lqiwk+lqqUge7SX44kHC6LUkjVVLABO3angSr5Ui0v33KotFpIfF5rRyQ3zWZpyTIc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159rzTfj7PueffZ95wpuQ+kMkM2IasqXHndwTUEoSAr1Xbx3ip8JAPcuRG5Cb2XUZ6K2avcfkHoYRPm6rGIhkkRTzelUwbWxm0kJCJaEA0IDx1fAgDpg+LyVbQgDdqte79vZ77uru7u7u7uzMzMzu7uOy696vQfISAaYuuxuHCAQOX957v3fObRFHIUDyVUDUIrjFDMmVihiqwIa1SapI6IQB0QAMDSFC0gtKIQSkyNBTQxAlMIIxKJCgSK1mZ5mZvP5UDLMzMzM2IDlmZmZmbRTQOazMzM3mIoGSoECmRGUGYUMsiMwKZkQJkRgYQRhkUCszMzMzYoCsATtVV3cxJmVJDjA4NJS8YvDu7u7q8JALn3dV93dwYAJiAQmABEkKBCgSghf5znP7nOc/AqGW971ve98zPsyzMzN5KUKgR4ukVNWbUIlXd1VMBQSrumLuruqxvFZEX2ZtFMhQJECABHwk1ZmfZmt5LqrqqYHBpKurpgfSTX6rqruwb973vYq6Xd3dXXMDQj6qqqqmBkB0wARQAKAEYD6pJ3czJAdMgA9VXVVXve973ve9oDgJJJJIMAEUACgBGAJyTMkkODQHwb3UYG/g1pzA070cGQHTABASSSVJH3wfOYAOmQHBoD4NySAfAD3ve97Pve946YAIoAFACMAHUmMSSTnTQHwb9SquqqvY972/e973waA4MgOmACKABQAjAB2YkkknBoD4N+973vb973vfAAJJJJIwARQAKAEYAOmQHBoD4K3Xqq6qqD3ve974NAcGc5ASYkknrmKqhkg9zRmfYkN71Y/tVI1/ZvrsAG0+bv5403+1+NAuwDob+3dxFK7b/M6AAALeLd3d3Nbb62388XszMxv2tgAAB+Eqqq9apVSVY38/sbY2223mzJvtUmopUNRoINVDqmbdooIgiPACktOgoDRpo1otazR4EEXhqRnWtadamnI0eEVU6qXThNkIbTZAVc33d3u7u667u7hICMxZn2fu5jbxttttpe973ve822WAAGF+973veeCV2kqpKkB8AB+b3d9m83dbbbfd3erd2cRT173X73vCQHkkAwBNCRi7u7mM5hJNySbgAHe973vegMzMzgYMCAQkqAQol+1mZme5nA0FHFXckknow97Hve94RQNg+ABJJJJFMXVlXd2q6xd3d3jMzMzIX33333PvtC7BAOCipxUDXOAYHKVFt+973fe566VNttvyVUknVUkr5znOPfEh7IZIZIZYxQ3zn33wBmgGOkknZJAAxVVd0u7u4Pb7xYwRIl94EAO3wl2999uffRV34AA+5jnOc4AADve973vQAAznLAPg3jk9dVdVVez7fyE/vvt++hC1hHJLxu7l5v0AIJQqf3T973p7lA+DbAMmbq0HwaDd1ZkAAACSSSSeuqur+41VXVVXs+99z3veAAAAYAqdkkkgKAAJebxd1dUrF3dVWKqjNGtBZCZiVGVgwKzOcCJd3VUwAS6u6uqY7MSSTlV7FV5hA15pecs80Qmg+GfMErd5CzHm1V9r3gP4WbaknJ8pJ+UtSzQsABvWm2wkqYkk6pNaaYAOmQT6Sakmv747uYAJAnu693d0baAAG2222ADbb9t7pu7pxtNsDRtttxESlqXmZm8zJd1Va88p3vwAADrW+933v3bvPvNec5efZOAAAZvM3J9Luq9zM7gAAE1n7M3mXl3VeyfQAADyb73feyXdV7J9AAAJvvd97Jd1Va88pJ9AAAI1uTcnYu8+815znMyWAABzP0m5My7qvcz7AAAO6n6Tcly7qvZPoAAB5N97vvZLuq9k+gAAD7Xml6krR+5+bABAHA6fgO+bvzbbT69ab3QPqmJUzdXJJPiMBGDp9oPvX73p972e67ulQw6MaFN+8fdXZSDem39zfXi5ulVTEkizpvzRf4wAPaHEDbfX7ba+fi6VO93Mwv3jdOXVN78qp9Tb6Fybkku6r2T6AAAdn6Tcly7zvmvOcvMlgAOba3vWjWs3JuTMu+3d+a8tmdzWjWjTWvmmmMzeZMXdVWc6gAAaxn6TcmZfvv7L6AABz533vu+9vt++/uzkAAAJv6b72S/s1p5ry1vP1fZksAAC8/Tm5My7+u7815bM7gAAGbzNydi7qqk+gAAHk33u+9kv339JyAABt+6ZNgiMlaUpkhtTRX1/b9ne993d0d3cOmAIxFAElSSSQjAB0yCfSTUkxG9er76vvebkk3Jd36eFe9n3s7Hwb8AklVcmZJj8970Hd85w943W2223PvJAfuBhmd78Gl3d3d3d3VVHw80eZ+1mc5923atzqR++0e97z9VAAHnNfa8z2ftyZl39d35ry2Z3AAAM3mbk7F+++ycgAGjWpv6b72S78qvZPtTwAA7qfpNyXLuq9k+gAAE33ut97JnHfNeWusztAAATfd7++nblVWteUk+gAAGbmbk7F+++ycgAAHjnd/fd7fp/f2v2ZvKqqqqqs+3z8iBvooFoy6VJL7Mf7ZO5r2NxB+ADUkqIo5Lk/fv3iKAKFODQRg5Y0dMgn0k1Iozve5981O973vfY9PHA973t3V+8PgEne971MSJO+ne99J5PAOz2akm5Ll3VeyfQAADm/t7++73nGPNeXdT2d2AABp9N/fTtyqrWvKSfQAADNzNydi7888qt1J9AGsGzWjy2fp7uTMq6r3MmsjfjWmttNb35rze2w00ms/TN5l5d1XuZO6GnmsbM3JuTMv7zrzXl3vymMk/AAAZv9G+9yXlVWteUzPsAAAzeY3J2L999k5AAAPJv6b72S7qvZPoKqqqqsv7P2+igaE0eatfu/v3f7uX3eg1AcGQHTABDIDpQAjAJOSZkkb3++++95J3sq7qqk9PBJAB6vAk73ve1XUiTvec5FVPd/aMAAPB0+Dhwwzv34NLu7u7u7AJudb72T7mX+815dZ+zuwAAM33N97kvKqvNeUzPsAAAms/Z+3J2L999k5AAANXpP3032Sv2tyX0AADl6d+7OXcq3nnl1r2T6AAAJ3vfeyfc5zPfNeVmT0AACaySXWS7zla15TM7gAAGSdrOxdfpPvoAABrafvvfv0kutyciopqq+9/RvzXn4VOQKh1UCUAT6VRTkCeEgJ2VX6VHM0inYEAOwoHYUDsoYQ0JEyEgCnZBU7AeTNMF3SgAfoQReSH6QEOQoHJVHn7QCKSt170979n9+/fh0wARQAKAEYBJyTMkje9z7fzc339Jmq/Yxix+9lVUk1SBplAHyABAADf5Jd3d/atGzd1aVVVT3dOp222AaHEqqkHKqlVR57JJP0uXW5OQAADupPe+9/eyfcvP3mvPczvoAAGb+zv7Ml5fvmvPXmZ9gAAHvdZ7Mn6ri6/ScgAAHk3yffpJde/pOQAAD7U/dk/S5d3Xsn0AAAm+97+7Jd3nfNV7JDt5y1ziV2ldq07r8pP30n6eye97PpG2mmjADNyT9My7uvcz6AAAdE/ST9OS7uvZPoAAB5jf29eSkqB9o3D4Q00x6d8Q8f7SmqYLn2/wAD7r9+39393uHIQR73Sgnb7uqVUvx6qVL9SSoANCcjbbfm7bbbb10HTNXYUAIwAdMg3v2+nFhf7nFVPd1bvKpJZv5GjbzS6VoulT5VSrRaA/F0qCFVX528abbb32P3piqvX5773nrTt+b+/PjtsqkqoOUkqLPAfiS7uqqT6AAATfe773svOO+a85zmZLAAA5M9zN5eZ9zl1WZ3AAAM3JP0k7znLu5z6AAAeTck/SS7uqqT6AAATck/SS7uqqT6AAATck/SS7vO+a85zmZLAAA5n7Mz9l5nOcuqzO4AABm5J+kl3dVUn0AAA8m5J+kl3dVUn0AAA81rz88z7ftfv3muPxdpUkrSN1fo+w+lqqjc+AOP5NtvzZzwHTABFEkkklQAjAB0yGta0Hzknq+2U4e9v73ve2/e97g3+jW7ux7sSptvxu7u6EPAfgJG23XXmvO97+ySSfpJd3VVJ9AAAJuSfpJd/czfmvOc5mSwAAOZ+zM/ZeZznLqszuAAAZuSfpJd3VVJ9AAAPJuSfpJd3VVJ9AANBNzu+97UuqqT6AAAfT9JuSVy875rznOZksAADmfsm5Ul5y6rM7gAAMSan6SXd1VSfZmt7bNPOcpVzl8V2pyHAOzO97JsuXauly+XfFVJLpf4md/STZAA422997eHG2235u222IpSSSSSoARgA6ZDWtd2aJPGaLu5PHTDXg+pDx0aSSScd76SekkkkAV8G/e95kfe599Un0AAAm5J+kl3ed815znMyWAABzP2Zn7LzOOcuvczuAAAZuSfpJd3VVJ9AAAPJuSfpJd3VVJ9AAAJuSfpJd3VVJ9AAAJuSfpJd3mu+a85z9zMnAAAKz9mZ+y8u7r3MzuAAAe5+kn6Sqr33kn0AAA8m5J+kqq99kn0AAA16688881++75+H372t3Pfefe733gaArgyA6YAIoAFB73ve89j3vA6ZDWtaKEknrqqJPCUZuvDbFVVWwwe0KbJPpJrc6m/B5mrsN1djRgAnvSSfpKqvfZJ9AAAJuSfpJd3nfNec5zMlgAAcz9mZ+y8znOXVZncAAAzcm+97VSqqT6AAAa4n6TckqvqqpPoAABNyb73tVKqpPoAABNyb73tVM75rznOZksAADN5mfpmZznLqszuAAAZuSfpJd3VVJ9AAAPJuSfpJd3VVJ9AAA0eW5+88881rU15rzRkqyVf2vGYoYobSf3ed76kMUO2hHNyGvtf0hsVPNgDZEgNki2TMRckSQotyfEN0+rdrNsMNIEgJ2BrIgdDH1VJU6i5u4W2Vd5VwTTxYhAMBBCEA94+76pDt1yENHU3zvM2PvveuvdLTTSjkvJjabJ7YTDxUQ+FSA/AAV97+z3OcxclopZKe1SyyUyqsolgRoyFTQVlSjKhppZnOdc5399qqK+qeRI71VVaUM39919vznOePuKGqrFIxQzXvOuc5zn1EnlVc1mfsyzM2iA+rQAwAi5Zn7eZrMwlCfd3X3epCR5IF73r7O7qvkkBgJAwSGIsuQk8abUMqG6JJZn7PbMzFFUMb4UC1mft5mZiCfzClLbBVL1Q+P7Z1lVTXP39z+5zfPf6JigoFIBAIERwHQqSoEqOhQNaIbQoFq/znP7nvOf390I8f01KswhpJ4Zui20SBBqzP2ee5memIoE1VBIrIyhyoZnvOua5znPJVOVTvShpU1lc59zzznOcKHaTFTOGKU0qta0wBlSttVS03jMJmMMWpU0ENmfsMzM36rGKNKoJEhVhVVpQyayzEV4y0bUPN7kZgqhKIgUCdyoGkVWLm++evec4VckMxmSR6oZEazM/ZvLMxFQ9Qm2iBIg6c8z9n2ZrO0lSqlqqkldVVJ8b+7u7+i1q22dAHSqquvsBsFXdXfwaA4Mh0z0wARQdq7qqMhQl1V0CMEANAcoOR3LbYbmmRwgAAMgOmEkknZUACgBGADpkBwziSST6dI5jI2D4NAcGQHTAkk7KkjQHKAEYAOmQHBoD4NgAGZJJOSMgOmACAAUAJJJJJ0yA4NAfBsGwfBoDgyA6YCSdlSSAKAOzEkkkdMgODXqu7u3se9733ve9sABJJJJDIDpgAigAUAIwAdMgOJWa73veyDYNg+ZmtazOc5zAQDlmZm8zNDyQQMzSqCy6/K6uznegaHf6Df23u7vgev7rbc7gkAA6DlAAANUge5u80vd/aNtvzfHKxj77775wAD7fqqrqqTc+knp4DMzYewqSSB+jUkQCZKjrWmA2dIbB8TN1eZJJO9AHBoStVTqq3RtvWwBAAAe973ve8DtKkku+XKpUkj4OngG1d7u7u77attttt1V3VUTve95d9xdYx1ASrqrqmAknbu7v68XV3UxJuBLql4A33vdd73pLYZmZmZ/cEQMBAJEAjVhnmZmZvlmA0qMaruO971JmrsAKKAYEkiB93vepM3VyZoSM5Aquc5KrvveYt3iqlVJCSVVdpJV18MwDRNv3ve++++zM8zMzYgjl7mZsXau/kRX+ipxisVjErVXeLutOc++uruqrhAcGgZqquq73ve/d6AAFbtrnMbeqquqqck5z3mt+Dg1d3VUAJJJAAAd73vdVdXVd70cGKqrqgCVdXRDAQQAgrMibd93e9533d1fAkBqSVAHwANJ3q9+973vySVJe69bxt/lTbbcAAAB9QbB8GwwG7qw2SSSST13VXV+973vfe972wAAAGQRjoHwb58Nt/M3VjQFY7VXd1jN3d1i7vBsGlVVW5znPOc52cFJihwyUxaKkyGAIpxCF3X3dneMHx3fX99P9t94SWbC/Yu/vsvuO/vwNAcGWgJ1gDDKKBAUAIwAdMhrWta+ZHy6v4fqu/eAjDF+G6MsHgSqCMXdne976SekkkkAA973g/AZmd70Ck1/Ry1a4ly5ck/STMzveyDTTNNbbAN5+zM/ZmXd1VZn2AAAR5uSfpLzWfffe15rznOZ7TJsAADN5mfszLnOXd5ncAAAzeSfp2qr2VJ9AAANUn6SfpKqvfqk+gAAE3JP07VV7Kk+gAAE3JP0mpd3nfNec5zPcmwAAOeZ+zM/a7dVWZeZ3AAAGr3rWta1xV3VVMVWc/vva3z2fe8HdBPpJmSQxl0wOz3q956ve97wZKzdWD4RgA6ZDWtaRjLF1e0nn2eJPBHsYYurODUe9q6saoEYFfSTXtJV2x4/Y230bbb42ABoH5b998HQ0u7u7u7sA8m5J+1JLu6qpPoAABNyT9qSXd1VSfQAACbkn7Uku7zvmvOc5mSwAAM3mZJKqsu7zO4AAA1jP2ZJLqqqpO9AAAm5JJKqqqpPoAAB5NySSVVVVSfQAACbkkkqqqqk+gAAHk3qSSSqrO+a85zn7WZPwAXd3d3aX792+n3Z76QGwAD8Ab3d3m7uh0wBsinwAoPe973nsEkk8ZDWvb7973t+9V37vmSSSQ6xrEknJM+8u7ATxmqs7MSc5Jl5yxpPPz7Xe977kkySSftSTOc5d3mdwAADNyeySXdVVSd6AAA1EkklVXe9DVIrtcu1a5dKuc5xWrVqckn6SZmd73M+zPNeb3vemnmtt5vMz9mZd3VVmfQAACbkn6SVX2NeeXd5nbANHhM/bzP0kqsqqzPsAAAzeZn6SVX1VXJO8AAAm6kr2Sc5yqqT7oAAE3JP0ku7qqk+gA7vYDX49j1TLuPufd1H0eANBPpJmSQdMAaIo4AUAIxJJJBkfN7rfdtt9HPX73vMVdhJPJJJI8Nvrbbbbqq3d0be7u7u7rYAAACCSfpJd3VVrUn0AAAm5J+klV777qTkAAA7Wnk93J+k5d3nfNec5mSgAAOzTWe7zP0nM5rnLvM7gAAH2tZ+33v7vcvV39dydoAAD7zU/fv3e+97L1d1Un3QAAPZ+73v7tyq99k5AAAPJud7+72Xrzy7qq155J9AAAJuSfpJd3VVJ9DQAATck/SS7vO+a85zmZLAAXd3aOYz99++n33emAAAfgDe7u83RN8bpgHq97z1er3veAoARiSSSDIa1rTShPvGSSq8E9JJJIe8AAG7q33veN3Xu7u61VN8YAGhwCZmZnfcz9d3VZn2AAATfdd7+72VXvsnIAABr4n6SfpOVXvsnIAAB3U/b7393sqvfZOQAACd/ST9JdV77JyAM21vejTzebyT9JlV77mcjTTRgB3WfszP2Zyq73zXl3mdoAADN5J+73Lu8u7zO4AABm8zK9knOcqqk+6AABNyT9JLu6qpPoAABrnNJ7J77TXnkkmve9GxNySakiqR3JkB0wBOySSQFSSSSGA1rWgduYkkklUBJJJJrVQ8d6HpJjve99J1JJJId73ve3rzzve/pqSSfpJd3VVJ9AAA0iSfpJd3VVJOgAAm5J+kn3Ob1y8/ea85zP2smwAANXn7Mz9mZ9znLu8zuAAAZuSV7JOc5VVJ90AAC9T9JP0lVXvsnIAAB53fe9nsl3d1Un0AAAm5JPZLu7qpPoAAB5qbkk9nI15rjzjWucz95rznM/Y8gAADN5mZ7JnOc5d5ncAAA/XVda3+3nKk3c+73ved733p58Gh5lwZOmjphwJ2VJOSZq7BQAjAa1r1++xXve5urvxufb3m7qRjb1btqq3d3d1PWwA+pUA2kkdkk8PvSakkngHB3fve373t+9znOfVJ9AAAPJuST2S7vWrqpPoAABNySeyXd61dVJ9AAAJuST2S7vV1Un0AAA5rM9zKz3Mu699zOYAAB3U/Sez2S7rO688u8ztAAAeZuTM9k9u7y7zO4NXvXLtc4uc5xSw+k7J73fvpPQpVzl8V0uXy7nJMrKzOcr33M58AABmta1rP0mZ7mfc5vV1umsz7AAAJrscy/fazN5mfve96e373vPg0BwZBo6YcCdlSSfSGygBGA1rWgSdmJJJVAAe957Hve97wJK7Md73rwe+8AAA7bbbb0ADp0Pe798Htu7u7u7sAk/Sfp7Jd177JyAAAeTfeyeyXde+ycgAAHdT9J7PZLuvfZOQAACb72T2S7u875rznMyUAABbxn7MzPcy7u6rM+wAACbkk9ku7uqk+mjxpoaPBqbkk9ku7uqkndaaa08AJuST2S7u6qT6AAATcknsl3d53zXnOZkoACqruytCra88XuCgd793v3bsHcFBr9n7ah+/aUOgP3m1D9+0ofv3tVVU+VUkvSSfpJB8xt8bfn835u+ttvfSpJJAUHwbmGQ1rm8VsbqqLum24WNFiD8AfU3xtsAAqqAiqkq9+xX79+/e97y7uST8AAALYYfteea1rM3rzzWtbZmZnfcy7u6rM+wAACbkk9ku7uqk+gAAHk3JJ7Jd3dVJ9AAAJuST2S7u6qT6AAATcknsl3d53zXnOZkoAAC8/ZmZ7mXq7uqzPsAAAm5JPZLu7qpPoAAB5NySeyXd3VSfQAACbkk9ku7uqk+gAnLXOJXatS5JPpMzMbVV70hXculXOXxXUQhRDi3IkB9nUhAZHhzNzufrv9n7ve/cDYPg0BwZBs6Y+ARQAKAEYDXN720cT6T1hmrtXve950AODT4NySd73qSQbbbbbG2229YAfBPe97MkhRylXOXxXXOUqvi5OSSfSZmZ3sg6nKVc5fLtWuWr1vWfszM9zLu7qsz7WMAGgZvMzPcy7u6rM+gAAE3JJ7Jf3Ocz3zXnOZkoAADzV5+zMz3Mu7uqzPsAAAm5JPZLu7qpPoAAB5NySeyXd3VSfQAACbkk9ku7uqk+gAAE3JJ7Jd3ed155zmZKBttttttuIXl0ygSRzPfQhIyeut3OqiXfmpTvP0hihyQ5zrnfdA7HBMMoiAG2NthMbJAkA1PQkkZ2ZTYdEyhAOHWZ6on2wzNItigUMhlLS1v5EDw/ftSxUEVURIamNcMyFDaEheQgGkJIsa4H8bmSS7h+j0Zk7P31fHVXvjzBAHviCXpIRlDfNVFNefr8CAQIvqqp+8/a9/c5nOYiJ+tIyoou7MzPv5/RvegQDduf7cj4aDYbqruqq6YYDA7d3d1VV8VAhJMhQkkBAJDXHQ+7t3umZnqfcOJLzX2ZJuTuyWw+Acurq6vA2ad0fIBBVVXx999992d3ZSEkxAir4QXV7urxV1VXeq5ev6/eng9rnsmzYPg8zM2KgAfIpC5Z9me5mbVQcsz7MszNogexUgl7CIbhAY8QHRjnq7Du6PAhJcAgaBA33d3ad3oOjm2/O3a2kqpO23vt3j32RJKqo+OnvYAu7q6u94B8NVd1VMA2D4NAcGQHTAoEUMpJJypIBtvzfG223+EkqqgEB7ANpV9fM/P5voFg2D4NAcGfqkmpOSYAIoAFACMODQ6x6quqS0uqpKuHAAwZ6lTazm85++fX1tv5ttsHwaA4MkknJMSNgcoAFACMPg2dMzTIOdOXV9+NbACakkn0hoDgyA6YAIoASpJJJEYbB86Zl1dVVMA4Prq9h8+DYNg+DQHBkSTkmJJ0yQACgBGGgOdMgODd1cr5l0+ur7tpKw1V3oAA0BwZAdMAEUACgBGGQEVivSSSPe9m6uVtkPujYznIUZurUOo7t4+80YwOcN9EDAbQ5+89Qsq3s/fe+7rOQn1CXT1zE3pE33XPbcdSFTH3ucTc9J7col9fehC1m+6qru6z4Rbhh99mr3dXuZ97Ve9773s3VuFZk1Fpu6vGo3sZRq6vmmKrvPd1dXz7nvOerzN1YBXruk120QfSDJB7/eS6515znP7nPodC5rMzMz7CRTyRGvaECUcIbNqdcYYurYG63W7D75i6vLUVoO9iAAqtpicn27q8Tcm/jDtOburw/m/njR9ylV7u79u+E6pJJF1efqVWAfHvEurzV3zMmbknJipIze6u8ZZ2OGbq+9HOTx71+sPXSFOx7uzq7yEgFIxJEwoQkdKFHdPe3Z9a8mgqkKfeq77uue5axuqQo7qvs7rj0+qkKp9Xve31vohC7uptvetYJJViDtKuGHMD2UqNe/Ntttfrq3ZvM3OTU7locHdkkkDV1eGWDl4xX12NvplFG+Ebx9Bw+Pj6lc+/cz9mdzGJUqqqTSqqSSLzoB0PqVN47qI3Y3dzu3vdtdAJAc+7p5iSQHd3QFXVbYKNukcTeWqu5CZurxJ2Y+kMd3d0d3dICDr7sgklwvT8AgBy6+v32T27q/bNH1cObYzirsN9x93ubq9Y7nvRwzdXGfg3szdWScka1ST7Bl0zVVdVpHO6Ozjf3ZWJJJt3upoHqq7q+VV0qLDh+ADlKmlvmrpVu5u7vtbbb83xXYABwaYDQdjtawYMhHA2D4GqqrqvpJqfST0xd3VVWte9972pr3s92bzdXvOOtBAOm9A4D5tt9TbbbbYgsDwH61dm9W7vVVJLVJbmSK1KYJOZKGea+4754nyUu7u8NiMJd3V1fLqqtk2puhrc3fu/r8enrEgKmASArvSJAdnNC/frFA5ACh+5oQDnOeAoHJBU/uc85Vd1d+9z3ve173hwZA+dMbARQAKAEYDWtajAkk8Hgkk8AAe9j3ve97xJJJPAA3dzdFVJL9aVUknaSqnbAD4P5e972ZJI0AABm5JPZLu7qpPoABo1qbkk9ku7uqknQO72AJv9JPZLu7qpPoAABNySeyXd3nfNec5mSgAANXn7MzPcy7u6rM+wAACbkk9ku7uqk+gAAHk3JJ7Jd3dVJ9AAAJuST2S7u6qT6AAATcknsl3d53zXnOZkoAADn69fv368vMz3nveTt9vve+973va6mZJJOQyA6YAIpJJJmTN1coPgjAa1rQaq7SSequFPHR+TbStVQAA9e7ujbb7SoPD5u7nrVV43RJ2222/bu+290YAfBPe97Mkcu7sAAzcknsl3d1Un0AAA8m5JPZLu7qpPoAABNySeyXeZ3oaXd3d3dqVfOcV8pVP0kn0mZmN0q97MlrN71s01rGZme5nec5y7zO9YAAGbzPcysznLuqzPugAATcmZlZnOXdVmfYAABm5JPZLu7qpPoAAB5NySeyXd3VSfQAF3d3d73N5b/b939o+evunteQAD4AfW95JJJyGQHTABFJNyd13tJJAjAa1rQJJK/B4JBVe973verxJJ4Hve95JOzEkgAkknKu5M+7JJPZLu7qpPoAABNySeyXd3VSfQAADM/ZmZ7mXd3VZn2AAATcknsl3d53XnnOZnsAAAZvMzPZLznOXeZ3AAAM3kk9ku7v67k7QAAEbkk9ku7uqk+6aAAJuST2S7u6qT6AAAeTcknsl3d1Un0AAAm5JPec9999/v7nN8qqqqqqVVU5CKjy6VVSri/fgACAAfAD623+babeNvgNHTDgEUkk73vaSSBGA1ru9mySSSRJJJJQAAP1XdVXve973qqq971UAAS7tgAHvSST2S7u875rznMyUAABm8zM9kvOc5d5ncAAAzeST2S7u/ruTtAAARuST2S7u6qT7oAAE3JJ7Jd3dVJ9AAAPJuST2S7u6qT6AAATcknsl3d1Un0Xd3d3K5xWlLkk+kzMxulXvSGYqrnL4rrnFVc5fFalySfSP3vezJG4qrnL4rrnFVc5fFalySfSZmZ3smyKqtLl3xXXOKq5y+K1gBaxClkLKqL7+1Shx0XKCHsQkimQ0IEKrzj9Vfr9n7793d3dQPg0DDgyI0dMOARSSSSSUAIwGtab3kHGQe90fDTwCeAKAJJJJIAG2222IAD4MzM70NkVVzl8V1ziqucvitS5JPpMzM72TZauJVfLviuucSq+XfJyST6TMzO9kHU4lV8u+K65yqV8u+cn6ST6TMzO9kjqcqlfLviuucqlfLvk5JJ9JmZneyDqcSq+XfFdc5VK+XfOT9JJ9JmZneyR1Oa88N7b01tppjMzPcy7u6rM+jAAA3n7MzPcy7u6rM+wAACbkk9ku7uqk+gAAGZ+zMz3Mu7uqzPsqqqqqqFA/emz78fjzSIGs10O7/fZG2/SSdSk9+k4skknZA/Ntt42+NsOncmgRSSSSSUAIwGta0CSSSSXdj973veCSSeu7mJJJ3jgCGZ9v9qVA5vfgiG963zM/ACHIeAAANvNj/QAD6TmZmR0q29kPru7uzRpprN5mZ7Jd3eXcnQAAZn7MrMqTnLuqnPgAAO773vfe9u7uqk+gAd3sDyb/ST2S71q7qpPoAABNySeyXetXdVJ9AAAJuST2S71q7y+6885mT0AADN5mZ7Jd61d5d5ncAAAzeZ7mVJzmruqk+6AAB9qfp+zMrM5zV3VZn2AAAWqct3X6891V/q+z7PfNd/e9+yVMm/Q8YHzOgB8ABgB+AbeN+f5/m23TEkkk7DpmrsCg1rWvsBX26u5JNySaq7A93zFXY5QT3se945ik35VW6JKktulWm7vd0bABsl3SpJSTMzOZmTMzM9zKk5Ve+yc+AAA7qfp+k9kuv36S4AABr5P3ZL9kuv36S4AABN/Ts9kuq99k5AAAL1P3ZK9kuq99k5AAAMz9MzPcy7888v33LgAAF5epXa7PZ27u9ZXmvLz370AADzu+97crs5d3U++gAAF5rPZcuVLr39KgAAHw7++9+72u3Lr2XBrBvzRrbWzW91SvuXz6/ifH77tr007RJ+SrbVVJP1fST0n6fvv373vb97x8Gg4dbZAdMD4NxQAKDWtfbD5V2FBJPwPCSVJ4BPVdXVBJz9jF1dVSs1UAMPJKkiXOnUlSQAAA222222+vO9VV355Ll85y7V3d2rRbAOmYqrMxvzXnJk8pQAGbzMzKzvOcusz7AAAJrP0mpUqXXv6S4AAB5N/TslS69/SXAAAO6n7v7slS69/SXDTm/NgJv9OyVLr39JcAAAzM9m5mVl1Ve5nMAAAm+ySVLqqzvmvLzO+gAATTP2e5mVLy7usz7AAAN/vtVf73K1rkzmsrXms/ckn7KAA7iAOgB822+tt/m228bT422OmFH73ve89XveAKDWtaBJJ4PHQeEkk9JJJ3vvGl3eLu6qunt173ve8e8AB+oAe+c5znPifsAAA8m5JJUu7u6k+gAAE3JJKl3d3Un0AAAd73va7ec5znv3mvOST0AADWXr9mZmVl3d3WZ9gAADve97Xbu7uu9+6AAB473ve127u7rvfugAAZuSSVLu7upPoAABNySSpf3Oc5lea85m8mwAANVn7MzMrLu7usz7AAAMV+3f59JXOTWta0rl83+yt1V45IpUkn0k30yTv61aqZJJPpN37d3f27BwZAdMKARQAKNm960OpMyfqD3s+6HHve8ESTwk9xJUk2+tj+bSVJP82/zyi6VKlQdAAne87PN973ve97K7d3d13v0AAA8m5JJUu7v2TkAAA7P0kl1Lu79k5AAAJvve9lS/uc5nuta1f2ZKAAA1m8zM7Uu85zl5ncAPvN71q7V1LkknZmZn0nlLUXLVVzl8V1ziquc4XaU+kkzszMzOyaK6nFVc5fFdc4qrnMSn6STOzMzM7JsV1OKq5znFd85SrnL5OSSTszf199ngvvddsf6rS6hGtatEarSB3nPvv3v2ZmYC7I/fut/hkOIYlEOBjhpKMgmt/SkkUhAftN/SSJAfoKdTAoZCpBTW97kMZmVVmaxQ1vW9N7kMe/vzX7XXdQzwyzPt7xIZNmpDzXeOaGJAOYgTY2yhlSnKiJX649Hel0WxICxkvJmCCSmEBdzlGoKqdum5ohhdU7yaLhCAaIcOr9JrkcIQDyNg2hJCcDhCA6yD3zrjKNZGV+3P1/vr+9ERHQ39zBAD/dM9YeTEOIVb9YCDQBmlRd++b39979zmlQMLzBFDxgVlUlQISqJBgj9CjpUFhQKzMzN4jlvEQJRUpSszMzMxUDZCqZrMzMzMTwMze9/297+FAkau7rU0jFXZ0EYBdBzMYbJV70KrljTCE2KMCrMZkUIXy3mZ9mYJtVAgpEAoQQiZRXM599996+z+kHeEGqR8xVQtFCgSCEKhKgYqBKIaShQIVIpFCkSgpRCkUCRQ1Zzn3OfcxygUhED+EfrxRH09/1zn3N/b5zQCFCoENKoEUJLFD+1znOc53zih8oZUOa65znOdc4nzDCh2aVDeRDdlVIBRhSlQXUooaBkzWe7+3mYsPlglMYzCqMkMqrFigKaSmqIUCHNVme5mazFUxVKzQgklBBUSgrQBTMpQqHxJqKGLcIo/vM/f32ZZm1EBj7Wqu7qqxjQJRd1VymAFACMaA46XV1V5AcKqrvMkkn0hsGwfBoDgyA6YEknZUkAAAMGbqwOUAAB8GwbB8MySSckZAdMAEUACgBGMgO9N7+cwPu94ZYSSbkk2DYPg0BwZNcGkdwBOypJJAUAIwAdMgAEm5JNyDYPg0BwZAdMAEWACgBGN73veEkknOzIDg0B8GwbB8GiSfSTMgOmACKABQAj973ve973XsgAAADYPg1JJPpJkB0wAQACgDsrF973vehkBwaMYB0zQB5M1dXVVjFXebq7u8+rPte973vZSSdKmmzOLAEkknre97PvY973h2TEknIY1ABV3vXau8uZ3znzpACermJ2s1V1VV3j53vHfeAL7jmkANoSE2kqahgX2d3X7vd3d3UfGnJcn3e96AYAqt873Xe97oKPG3xv26tzdvdeiVJJPfe+pUkkxZzMPe94qpJJJ2YAA3NST7G5MwIXdXdgkm5ck3A4NBJJJJDfwb+D13dVVZAdb8HwHe96k3J8OAJINB06ABgAgbbb2qrVVe973vPfFKkkvc4lVKtZ9+6Afcd27u7u73d3d3ufd3WJATYKwUArBd3dIhBICDMQvemfdux3SAg7u7vHdd5jue973oAA5V366uqqs4qqq6q+ffb9709PADVVV1QHe1M5q5JJOAAHwbAAAExj7nLq8/fdnNJASAg72+68u46untz2/AgBV99mb573vKoWoAAADNVV1UkknJAAAAAAASSSSTs97Ove9733fey7v42cAAjFXYDg0AIxV2ACSZ7V4o0zM9+zBDZIoEKBRCgUqIZrMzMzMEAdogQi0KoyIEtAJA2MGjo47u7u7d3fvr+mUfya3aSEb+ew/S/vVJJJh6ST6SSfN7v27u/t1tvG3jIDsYkkknZQAKDWtaBJ4DwNDxySSe4M3V6oLuzpNi3dn13SpJN1VOBJBF3SpJSCqpckkjzbpVt7N3dA5mZnQbl8V1ziquc5xWr1iSTKy7u7rM+zNtHmvG2mmjZ5m8zMysu7u6zPoAABNzkk/VLu79k5AAAJP0klVLu7zvmvLzO+gAAeZuSTKl3dXl5ncAAAzeZkyp9znOcuTvQAAJuSSVLu79k5AAANd0n6STlS7u/ZOQAACb73vZUu7v2TkAAA91+tK/xUXAPkqP044dA/Gvrbfzbb+b3lzckn2+w+cGQHTEk7MSdlAMmbqyj97m9t7v2ve9uruQZr4NVd+99u6oBMe7tqqf58be+H5sAbad0qeevxvLq4urh73fY97xymGGKsHTIB99VZnmvLzJ6AAAxJJkqsu6zO4AABrNyd7kqqqquTcAAAm+973sqqqpPoAAAdb1Ekkr67u7k+gAAE33ve9lVVVJ9AAAJuakkrXnku7u/tY8884zJ+AAArP0kky7u7vM5gAAE33ve9lVVVJ9A/s3sADTTN5mZmVVVVZn0AAA7x+1+88881rX2/Z7+qc/h39+/fv3ve8fBsGzx8Gjw4MgOmJNySb7KABQa/bfenc7975JJiSTwgkkkkxEkk731VV1U8Yk9vvYvDbAAB2223FSSUuQkkkj73varvfsAAAm5JJUea8u7u875rz5mT8AABm8zMyVd5znOZn2AAAZvMkkqqqqk+gAAATckklVVVUk6008AJuSSSqqqqT6AAATckklVVVnfNeczJ6NVvze98ri5znOS5JJO9eZmSNeiqr5d8Vq1a5fFeMzMysu7u6zPpp5rGwPM3mZmVl3d3WZ9AAAK9+5rnnv72czXx5l5O/R5ryRlJL6SSeqZJD4Ab7bbt9bb/N6+t+b7IDpiSSSdlAAoNa9e9+97wVVA2KgBtt7ug2222bu7u+8bonVU2/lQAdSSpIuqQAAA22222233ve127u7rvfoAABNzve+9qXd53zXnMyegAAdz9mZnuVy7vMzuAAAe5+ne999lVXJPoAAB5Nzve+97c5zl3PoAABNySSpd3d1J9AAAJuSSVLu7vO+a85mT0AADN5mZlTOc5zl5ncAAAzckkqXrV3d1J9AAAPJuSSVL1q7u6k+gAAGPPPPNY/Z9K88xfMVWO979zvfvvvv3P378Bp8G+BsHwaDRwZ4B0xJJJOygAUGta0B0yCSSSSBQFTF1ckk7z9Xhs8BJ4AAAD5zWru7rvfoAABNySSperu7zvmvOZk9AAAmrz39mZlZVVXuZzAAAO6n7cklSqqvZOQAADybkklSqqvZOQAACbkklSqqvZOQAACbkklSqqs75ry8zvoAAFZ+zJPZ7lV7mcwAADnZ7uSez3lV7JyDu9gNGtTf6SSpVXd1JOgAAq/NPZ9JdyffTve9+7e+97sGwfJMyTw773s+94OmJJJJ2UACkmXt7973vEgPBJJ4ASSSSruQSSSSeqquq+e9733ve8u7O973ve97zvd973tdvzXl3d13v0AAAm5JJUqqrO+a8tmd/AAAazeZme9rXnlVWZeZ3AAALme7ysyp9dV+9D2yucSu1dLnKVc5fJyST4+++2dmyCtWvNNNGzN1mZ7Pffc+rM+9AAA7qftz2SXLqq9k58AABNyeyS5dVXsnPgAAJuSSVL888u7upPoAAB5NySSpVXd1J9AAAXz7hfz7+pUkvu/uMzIqqlPpicOm1PfQPugH3W23222+vd5u7u7jb424AaFgNiKCMAp2Yq7ym9qrQ3V3J4zXw9qrsJ99J5qrvYONVPqmJiY+76qq6Wje6b7VtpKkt0f1KmAAGlptttt973ve12qqve879AAANTfsnfe++ys75ry83ndgAAT5nu8zPZ77ysrM+wAADN5nuSu17leyc+AAAm5PZ2u3q6l1J90AAC+k93JPZ77yvZOQAADybknfe++yvZOQAACbkklS9eeXd3Un0AAA7P25JqVKqq9k5AAAM5nuZlaysqqr3OZ9gAAHN723m9+fd9981SS+ayd+c37GtkMQAGHgPwAPrbfzkmpPPjvvPd3rwcOtNfBvpgAhJlpvASfSfm9HhySTwBkB2eqquqYqquqCrs8Tve99JIAO55JJJJ33732V7M815md/AAAc1G957v3Mys99y7rM+wAADN5md9777KfVJ96AABXk/ZmZlZXnnlV9dZn2GgADNyZkqXdZdZn2AAAY3JO+999leyc6AAB3U/Z+zMy8qqr3M5gAAHus/SZmZde++5l4AABNzve9y7155dVUnIAABrqfpKkl3dVUnIA1g34a0a+1n4/SSek5AAMk2SfpJI+vaVO0/nu7+3ZFOZGgODIDpgAikmWtAGbqz3ve90JJPSVJJJAJJ5BDLQub83Kgb5ngCGbzPwCHOc5z+SVJFy7pUkpJJJJG3qqnbbbbed6u9rveamNm2971ve/G06yt57mZde++5ecxjY22222bz9mczMuvaqszkYNtjbY3m8yZmXd1V393zXmZPz1ttsbbbb8vP2Z7kmdfe9k9ly+c5VrnL5yr5aqifc/Eknu/ffSXnd6aeGttmbyZmZdVrzyqrM5AAANd0n79JJL9qqqTkAAAm52SS7u7u5PoAABPv0n6SXd1VZ3zXmZ38AABq85dZ7zTzV83+3M98/a8pJPiWb3Nx+wS970b1zgRSSfKdmyT909567r3Pe97fiakkn3hoDgyA6YAIpJlrRQoASSSSRJJJJGauwTknqqrqmJM1VXVekknhfsAHySpIAAAcZYAAYd973vA5d3YABm+9kkv27u7k+gAAHk33skl3dVUnIAAB3U/SeyS7uqkuAAAfT93sk5d3VZ3zXmZ9+AAA815m+9yTLu8u7zPsAAAzc/TJJzl1VSc6AABN97JJd3d3JyAGjxprpqfpJJy7u7u5J00aNGjRo0ae+T9JJOXd3dWk+1GqKKKKKKKLVxFMlQOfyIGvPPhICBX9U3kEu2RET30123FPb72U8u8mptvHtT80khb7PGZ9543D+vdB9h45hznwbLZrQV/CAk/hVkULfN7/ZzOX3Co13jSI2SbYI3ZDC3lmVJqQzMjQWssxStCMKdBJLq0NrQamoktaVRNKpWZKGURvKhrnOc85znBTkhiAzBXlZpzJc5rvnOc77UMjkzmZ/ZmZvLfpb354jve/l2IsVQAEKWaMqnk2y21KtMahG2iJY6dF3dVQAaDJwLq6uvsXm7vFDDMZVR7znPOcc5yd8CLbeufX73vIAPt2NDuv7L+++99YkB0CQGTSRJ1SDoRp0xEtKhhTzV0qB4ICyKgX+uc5mZzOcFA17CasPhx9V3VUbPh8qqqxuSQ+q7qqoCq6VAojCsz33MzzIUCFAxRGYEcyoazXOc85zmucBGQnVarVVd1rFA7GG6u6qpVWwPkUlUwbbbanbpUklaqqoAOgadVUkrpUqriGNDBsa3YkEgH3Xed3b3R3d3d2d3aA+XV1VDYNg+DSUwODJJJyTEgEGrqwOFD4fPjD4DkfaYHw4NAfBsTUkk+kNAcGQHTABFAAr1NKkkrOAAGnfP63+fW35vj6t3f293d/MHwbBsHwaffB93hkE5JiSSCKABQAiZZAAkn0k1IHwbBsHwaA4MgO0YAIoAFe3jwcOseAdMgODQHwbBtJNySagODIDpgAigAACMCMAGqB11oD4NhqSSfSRpgHwyA6YAIoAlS5JJIRgA6ZMYASSSSe+aOa6ICGKWAJea+ku39k/X9f329kz7I5u7g2aAA3u7u5oqqn+YAqAYlQH1eex733tg+DplVS7vve973qAAKZurle7M1d1VV97733PeeMAEdrFX3Fd73e7u6O773psH1AczjnOc+71m6tgAFd73ve96ABF7kk3J2c3miRwzp4BtLd3d3c337X35tvXrvyXve98bt7z9mZmbUMBQIUrMzN738woG8ySAoD6SakkglVymTYPfZzV3VVSvsDrhd3dyvVhm6sAqYkkkkgAEkkkkAfBuruSbkk3O7u3uju7uhJAXdzd93wAkve94oQIAMzMAADd3d97wNttttvqpKlTbfzYDQHDF1V1Xe973vOssGbqw2a5vnNS59V5VrKh/EHeKDXn3Xepfu88+z4Dpm7uqoDfJJuSQNUBwZqquqA6jQAAB37777+jQCGZ9mfZm8/cBBPiBRpAQ5zm8e973vKKkkkkAABiqq6qTsxV3JOxis1VXVAOxLtgAlMAbbbbbevd5Srd3d7oqSpUAGAD7fLYEAAAADJk4Ob0eZmZ9mfb3tUDaom1EWkYSBQIFCEJQ03wxCSjt7ozu7r7s7oQr6O75VSSurbbfW218qpJe978HT73e/x3N3ZJBtyqqqlKSffUpsk/SSR9bb+e7v7d3d6xoDgyA6YAIp+Ne3vfve94kkkngADYPgLuwSd/JJVG233LulSSgSSSRw4ABqqqUTkn6SSR5mZmNzVdq1dWruru7k/ABMzLu78zPsAAAm5JJLu7u7k+gAAGZ+zMzMu7u7vM+wAACbkkku7u7zuvNazO/gAANTH7MzMu85znOZn2AAAZvve97l3d3cnIAABruk/SST67u7uTkAAAm+973su7u7k5AAAJvve97Lu7u78zvmvMyfgAAKnN6byt5+/Z533tjQ9Xu+97Xve958MNg2g+DQHBkB0wARQXd61rVLDn1XcmpupJG6uwfDNXcnZiTmpiG317u/bvvz973vPdbbKVdLEHd6WfuABz7N55mZnvvvfvvvucztVVbdaCgoKClOSSSZnMzMk0tKcVVzl8u7tXanIATMzMzJNLtWrV1OKq5y+K5ckkmZmZmSapcd1NNNNNNPdd73ve++++++5iPe541rR4eeaa162TP2ZmZy7u7u+5ncAAAzeZmZl3d3d/Sd/AAATckkl3d3dyfQAADybkkku7u7k5A+3sADs/eyScu7u7uT6ABd3d3d5933fietVVpWqVJfSe9NZPwABiPAfgAfW9hzoAfA2+tt/m4AeA5737nve9ue9j3gIoo1rWgZkk9VndnnHJoPAk1PByeqquqRhv9jF1dVRqqq6r8yxd3VUPx+97wAAHe97d3d3eZ5rzMn4AADN5mZmXnOc5zM+x9vYAAmfvZJOXd3d39J38AABNySSXd3d3J9AAAPJuSSS7u7uTkAA0a7P0kk5d3eZgCpAABmZmZkdKpOKlJJJJk973vSRUiQAPZmZmZocTurukcAAzMzMw5xSn6fJVB88udTvf7v7vNczPFyzMz8Ms8fg5OySSdkj+bfm+/m2+tt/m228bZAdMAEUUa17e/c96V72fZPeHfe97wJUkkkgEk9VsZq7ak9J3i9dKjdGS7pUkpIRJKSSNs8H4nZJJJmZmZAVJgAHszMzMAVIAAMzMzMjpVJxUpJJJMnve970kVKQADMzMzQ4qTAAPZmZmYAlQAAZmZmYAqQAAZ3LzMAVJgAHszMzMjpVJxUpJJJMnve96SJIq37uaGL66vt3993fTUszHX1q7u6ybrnACqbn5HgO0lOySSdkj+BsHwaA4daaB0wARRRrWtAkkk3JG6mJJJHZAPssUqbb3u7okqpU1VJsbbctu2JKkpJJBg225VAAADzMzMyBPySkkkkzMzMkKpOwADczMzMAVL8AAezMzMAVIbbbMzMzI6VScVKAATJ73vZ61JFSkAAzMzP2YBVL9YeANzMzMAVIbbbMzMzAFSG22zMzM7l1VR0qk4qV0lavJJJ0T1iAAkyR/m2223+bbbz5yTckmoDgyA6YAIoo1rWh8SSfSZ6gBJJJJCqUF3Y293d3diSpJ2qVJS7pUkiSSSSNttv5tt1VdbbbeHPe97wRUpGAH2ZmZgCVDbbZmZmYAqTQAB7MzMwBUhttszMzMjpVJxUoABMzMnvSRUiSfSBvvXmZgNUjW22ZmZk96SKlJJIGZmZmAJUAAGZmZmAKlz78t5+D4Dh5/tlNs979Xf2a/ft+973veAG3h8Gng4MgOmACKKNYq71r1a973vPqut9z3veN6qobfzKQfg4qoDtKgxvrTbBtt/bvh9b/NgAA28ZSoPgMiUJckkkeZmZmNxUgAAzMzMwBUpJJJJmZmZkkVID8AHvZmZk1VUnKpSSSSZPe973pIqUgfAHvezMwGpaqST6ST3vZmZI1SAADMzMzAEqAADMzMzAFSAADMzMzAFS/Gffvr9PL7lqbu7+zshsn73h6ve97vve17wABsHwaA4Mn3ve976e9j3gnZUlSa1re5Ane973fYm5Pw84NSTfpJvve9d71JJ5i7ukvCD8AA3bbbbetttt5mZmZJSqTipSSSSZmT3vekipSSAGZmZmAJUAAGZmZmAJO1RwADMzMzAFSAADMzMzI6VScVKSSSTMye970kVKST4A972ZmA1SAADMzMzAEqAADMzMzAFdd13FtZqva9v73vTwA6ZAGAD6DYNg+DQHBkE5JiVJvWtSOUNNAcLAAASSd97z4qr3vPdzdEABFJIqoPgB9bbbbbeZmZmNxUgAAzMzMwBUpJJJJmd73skVJgffAHsXrWZmTtKpctUv1QJJJmd73uSRUgMAMzMxLMASoAAMzMxZgCpdQAdDM798AqWp/WkB+MDGvX6/Zk+pVLVLP11dob/MDMxZ3skql7fd2JzfNY19zNfXjGMV++199+7+n5JJ2YgyAAD4Ng2D46b0DgyRhOSYlSb1nWJAABQBJJJJGaqt3d933ntVUbYAeOKqPzbElSQDAAbbbyqbf5tvMxZ3rYlKtQAkmZ376QVI3RgZmVmVVZgCpAB0D36bu+9MdKpapSASTD2d9kmRUjLk78dDM798AlRujAzO/fAKkbowMzFmKqzAFS8B+AMz7MzJJFS9JPxJMzv3xJFSfE85wnP32YAA9+mvV+3ZEgLq933WRkiQFe95904hAVrQgOSSIqkIDyQhuY9mVWe49fvdZWc9EgOfm2N5EQWSvD81bewT6vXZ9HE0+xCAgSApyyvWWHTH23O7kzVaylifxe3EQbNr30NoBLJSSUm177OqqqqZ9nvPc56emwAcrnOVznAEpv3ve9URX1MQhQJjNfLj4kkhpsiZNF5u33vrnP7+59L6ociMqGqEFCoEqga0lQVKAyIEKBEghBEJUQRFE2p1BSUkKkKBCgRSkilazMzMzAEMoVZUYFJFAkQJSqA8CyBAAdu7u1Yqqq6xdVd3VMySTewAT4tgIaFSlUArWtZmZmZmYAXVVVUMAKqrur7WLq6uq1hoN69VO2222+LolSSXE6t1VJIr9wwPHN40qBMKCuAqLrQygjCoEQKVK6BtX+c5znOB8Ihma1ve973ydZaAXd3dVXMXUq6uvtabbOi6qrCWs2Y7rvu7vcgESMQgJYkkjsi544FZ0u9VVVV5yDkZyAkUAbcVUl+VLaEcAPB80kkk7tt9bb872SSTkNAfBsGwfBoDgxd01gDsYAIASSSSQABwaA4NAfBsTUkk+kNAcGQHTABFAAoAa7UYyODplJJPpJoD4Ng2D4ObGzgyA6YAIoAAAlMAAAcGgPg2DaSbkk1AcGQElM4AIoANqSbkk7MAHTIDg0B8GwbSTckmoDgyA6YAIoAFAAo2D4AODQHwbDUkk+kjQHBkB0wARQBKl5kkk4RgA6ZMYDjAFD3cYxnGcVfsYxWcIPl8AA373ve97ybbu+tNv4Phtvvqb5TYAA6SAAAHjb/Ntt8bbS59mZ9nAAB6quqqpisXV1VViNZ4NHju7u7r3yRbOalk7KoaKY2wmIIahrxRJBLRJEA2xyKG0pkantrN7vd3d3Ak73ve9SAPg3d33ve973oAN9f6/fl73s97nQA6Gh8mm0t+3d3d1ttnwbkkVMWyPowSqu6qmASduqq6q5iSSAAz3ve9+703VVVg+D13dVVfeGw3yeafAJi6uSSSdAy2dM1d9EkkABSSSSSA03ylTbf3Pzy6VZ++/ZnOGWk0XYcpV2w5p7SjN1aSSckgO1dXRkM3V55VXdVQ0JAAD7VVV1STcnJMVVXVR3Hd3e7u7u2xEN9qSfwIAiekQCC1VVyTk99E8AAOyqq6qSSSIAAAAAzVVdUA6Qa3a/b7b3N9z28pU3828ElSoPAAD/dpU7xdX2t6793uKzePugkZurq6vICRdVdVJJJJDhm6tgAAxVVdUAQAAAeqrqqrmKr1e9773ve9qMY4NDskkD3ve973ve8AAN9M5n9mZmZvfzsmQQpiQEIUDYoMUNGCrVVNUqWkRgJS8Z0HSXVVVXmmQIVQA730n02xWu17N1vUknvSMSSSQZAAB8GwbB8GgODIJyTEqTetb3jkjT5JJJJKAJJJJIkkl3ckgAAAABsHxzn2/mF1VG6MDMxVWd6MtUsG/zAzMzFVZgy1SAADMzMzNdqkAABnczvQVLbu1X8K6QMPBmZmpZnC6pF3aQ20wMzv32xTiqpSu7VRuEkzMzFVZmlqqKV9ADoZmZ3ulpUXQ22Bmd++jlqlr+usvvdb1fve75meNpmSSDIDlXY0B8GwbB8GgODIDphRvFXetb0DjlXY0DdXckm5I1V3JJPt17u6bvj3vHt0bAAbbeNs+D9SoA9mKkB0wMzv3wCpG6MDM798BVI3RgZneqq70iKUtUoEkkzO972SRUoE+kk972d7PDVIA+PB73s70GqTQB0wPL3s70IKmpYfEk8vezvZGqTAOmBmd++DVSaLb+YGZ374NVLVy/ud3wez1199h7274kkkizIDg0B8GwbB8Gnwb4Mv3ve97097HqN6zrA+oN0A+LNgkmZJJH3au3T4k5zne9SAAAC7v973ve9733329+96rr3jYHszMzBqkMAAeZmfZhPqVVdssADvXmZgKkANt973vetqlt3b42233ve964KkAAGZmZmAKu3SADAzam7u7mzm3SqWqUkkkmZh73vSRUpJPgD3vZmYDVL967/V+A6Awe7u7utvjAAABtj4NySDQ4O6A4Mve973vT3seo3qZ3trYfA30yfAJJJJIlSTveJV33ua7hJruHgJ71eNXVjIdtvzbbzMzMxsSoAAMzMzMAVIAAMzMzMAVIAAMzMzMIUqlqlJJJJmZmZkkipSSSSZmZmZGWqQAdA973szAapNv82373szMbapAABmZmZgCVAABmZmZgFUt9r57T7Mz77774zwPd3d3WZAAB8G5JAPjpvQODIDphRvWs6A7qSSfSe8ODXpJJJPZq7kk137vVfVdyQIYurAdAAAOcd73vfnquvez73ve93vcdx6/e8fS6VS0uWlJJJI/e973vSRUoB8Ae97MzAapAABmZmYlgCVAABmZmYsAVL5AAYZmZnQK26po/AGGZvvewmUqlqlAAkzMzOySKlAAkzMzOxliKr8JAV6QMmLbb67Lr9d/fX+zu6e7u/Hve9Pez73gAD4NySAfBoDgyA6YUb1rQaA43dWG5JJIkAck8LuyeUkknoAI22222222AHvezOg1SN5u6M9mZ0GqWsAOnszM6AlRu7ozizMz6qrAFSBAAZzMzMAqkWtvd1syve9+XsJ9SqWqRauAHSZmZ2SRUoAEmZmZ2MtUhv82w97MzKqsBqkAAGczMzAKpb+i4uC4lO0q/SSc9G1O8b/NtvzfG24AH4D3nHwbkkA+DQHBkUHTCjeNYur1igHGLqz9r3ve9ti6smpJ7UxdXJJuRJJ3veu96ng973veBwaNtsAADMzM6AqTQAGGZmZ0ClQ2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nNttttuEHQqaFS0GgaD379+/f79+/fvPPPPPwQQVWqqqqqqqphBVUACHYSSFSDAyC9+/fv3+/fv37zzzzz+pBfkFgYHXW223XObbcS5znObcKC6oLCqVgagpoGBoAAVCSQogBKkCSSF3d973vec5zuqiOc22224lznOc2224DYH5JJQQhd3fe973nOc7oQgqtVVVVVVVVVVMAAh7777u7u85zm7CSQWqqmEFXm223Euc5znEqn4GpVYGSqlpCtVVgaQWgyEKJJKCQAu7uzve97mZmaBJAFqqqtttttttyoRfgage/fv3+/fv3779+/f38Iq/AyCwNA662222222225IPvpUKp0l0lv3797/fv3nAAASSf11dSSR9AAAASSSSQAAACSSSKPgEkkkkJJPl1dSSQ9AEuXBFX9QT9KpqVRgYqrINIUsDAwMlS93+u93d5znO7JCQgdkklQAA88qqqqqq22223KBXd2DlAwMqqjAyC2lAaDKkWBUhJAu7vve97znOZJCQBaqqqqqqqqqq25EF/A0DA1VWBoGBpBYGB69fvfv9+/fv3nnnnn9UAFqqqqqqlFDJIQk999/e7u7uZmZoEhzm222222223EB+QWIVqhNAxVWgYGQW1VUMDKBgYqkvnz58+fP379+888888/qCr2l+QcUJ33ttttttttt30qI7QZILQaoGgagW0qmBtIVoGBkqmBkFkqWpV8+fPnz9+/fv3nnnnn9Ap+pV11ttttttttt0oVLqBqValWoKxCsQrEK1BWtAwMDA0DQakr379+/f79+/fvPPPPP6IS/AyCwMVVXXW21s2224gDqBkqWBkgvfv379/v379+88888/kFzm222222223KqpfpBZVVZBYGB79+/fv9+/fv3nnnnn4H6lWpVoHXW222222223VA6QWgYGBlVYGlVqBru7vve97mZmdhAAWq8Wqqqrxaqqqtp/Z/fLu7v78+XV1V3dX5vd3e9OAAAAAAAAAAAAAABJJJJAEkkkkB559+/fv379+/fPPPPPPMQXSWB0loH8B+g7779fv379+/eeeeefoHObbbbbbaqqqYQhCe++++7u7uZmZpAAgtVVVVVtttttxVU/QNVVge/fv37/fv3795VAAAGZmZX55rzVVX0AAAP7zzzzz+88888+++39/f39/f1c4AAAXdeeeeeb3+b33ve9rnAAAVVdkknZJJUIXd9++73vczOc/QgtVVVVUAHvda15rXm99++73ve1aoO++gAG97zO973tc4AAAfn5ZlVZnOVWwgr2vPKqqqqphBVarfb6BJCd5d3V3d7v7P372QAAAAAAAAAAAAAACSSSSAJJJJIAkkkkmZmZmfQggSSfvz+zLzMzMzKqqqthBV9AD3zXmt73vfe972qjvmvNe++++ge+a8177776Hu973vve97VQAABmZmVVVQAABmZmVVVQAAd99N73+d73vec5QAAA75rzW9733ve95znYAAA7ve9773ve1U1oABmZmVVVQAABmZmVVVX75rzXvoAAPPkyququ6u7r+f2BAAAAAAAAAAAAAAAAAASSSSQAZmZmZmZmZmUQAlwhUkgE9hCiQkNa3v3dXKqoADQHfNea3ve9973vaqAAAO73ve+973tVAB330A+155r777e+972qoAAA35ve97qqqgAADMzMqqqgAADvmvNb3ve+973tVAAAHd73vfe972qgAADMzMqqqgAADMzMqqq8222222222256+ciKurKpVVjH0gAAAAAAAAAAAAAAAAAAAAAAA815rWta88/Pz38qqqo776AAHvmvNb3ve+973tVAAAHd73vfe972qgAADMzMqqqgAADMzMqq5zgAABYzMqq5zgAAB3zXms7ve+973tVAAAHd73vfe972qgADvvv9+ea800/Pw+++zP7+/v7+qoAAAzMzKqqoAAA9815rzzzzzzWvvfNea8urrwYIAAB11dd3d3d3cl1dPAAAAAAAAAAAAAAAAZmfQhmOZmZmZnIQSQkhC4Qokkgeb37u+rlVQAAB3zXmt73vfe972qgGgAd3ve9973vaqAAAMz8/Kq5yoAAA9zMyqucqAANGsz8/Kq5ypp/NegAP7zXmvvsz+/v7+/uc/qAAAO73ve+973tVAAAGZmZVVVAAAGZmZVVVAAPPPPPPPO7+mVvzy7qru7qr+Z3b3dAAAAAAAAAAAAAAAAAAAAAAAB5dXd3X9/fP4AAAAB3zXmt73vfe972qgAqthBVaqqfffffd3d3MzMqthBVaqqX0A3veZ3ve9qoAAAzMzKqqoAAAzMzKqqoAAA75rzW973vve97VQAAB3e9733ve9qoAAAzMzKqqoAAAzMzKqqoAKqqqtVAVIb+hJJJ7CFQJIAfvN3e6TgAA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3Uuv6/v3979/fvz8Drq68q683d3e7u4F3WZmYAF3WZmYAF3WZmYAH26uvKuvN3cHqSHXV15V1583d3u7ukhd1mZmABVVmZmABd19+XV0MCAAAAAAAAAf11dAfQAAAAAJJJJIAkkkkgCSSSSS6uuurr26uvt1ddPkk2dwF3WZmYAHXV15V15u7u93dwLuvu7u6IBd1mZmABd1mZmABd1mZmAB11deVdebu7vd3cC7r7u7uiAXdZmZgAXdTvfu71fe73pwAAAAAAAAAAAAAAABJJJJAEkkkkASSSSRdXW7u7oAu6zMzAA66uvKuvN3d3u7uBd193d3RALuszMwAPPKuszMwCSXdM8zMAknXV15V15nbu93dwLuvu7u6IBd1mZ335555555554X3z+B+gwMVXpL1u9/fv379+gAAAAAAAAAAAAAAAAAAEkkkkAAAurr+3fm7oAu6zMzAA/XV15V15u7u93dwKuvu7u6IAurryrrzdzMCQXXVd15V/27ud3d0gu6zP7+BIOurryrrzdzO7u6Ti7r7u7uiAXdZmZgAXdPl/qu7vv7zu7u5wAAAAAAAAkkkkgAAAAAAAAAAAADKu6zMwALuszMwAP11deVdebu7vd3cC7r7u7uiAXdTd3dCSSXdZmZkAC6uvKuvN3d3QB11deVdebu7vd3cC7r7u7uiAXdZmZgAXdZ1XdVVV+q7u/Kuqu6urryquqr9+/fv3v79+/AAAAAAAAAAAAAAAAAAAAAAAEurr9V1dVdffv37973u4F3WZmYAHXV15V15u7u93dwLuvu7u6Ikku6VmZgJJLumZmAkku6ZmYCSTrq68u/O3d3u7uBd1mZmABd1nffffnnnnnnnnnhff0H6KlalW7S/d/v379+/T8AAAAAAAAAEurp4AAAAAAAAAAAABmchDYQyEOQghADn33285uc3MyQ8/fswEDrq68q683Mzu7unC7rMrMwALus/v7+BAu6z+/v4EC7rMzMADrq68q683d3e7u4F3WZmYAF3WZmYAF3U+/07f13d37dXX6ffz9+9/cAAACSSSSAAAAAAAAAAAAAAAAAA/rq6zzMwALuszMwAP11deVdebu7vd3cC7rMzMAC7rMzMAC7rMzMAC7rMzMADrq68q683d3e7u4F3Td3d0AVVdV3Xl7u7nd3SSS7rpu/qu7udvf3vSdwEkkkkASS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JJJIAAAAAAAAAEknvvvqSQAAAAAAAAAASSSSQAAB7dXR8AAAAAABJJJJAAAAAAAAAAB8qSST7IAAAAAAAAAAJJJJIAASSSSQAAAAAAAAAASSSSQAAAAPPPPPPPPPPPPaWgcgZL3SWQXqkvSXSXukvSXdA+JYHpLoHsHiVLQLtL5A/A97zs773OAAAAASSSSQBJJJJAEkkkkASSSSQAAAAAAAAuX+IH4G1TbbbfPnR18+fPn79+/fv37+/v7pfrW02ltVbFsi2DasylWzWrattZNgrYpsVqy2WZbbK2trWs2xXOttttosuV1tjWq0ybWa21lq22tstba1a2trbZNhU2rY2bbbzyvKvy/Pv379+/v379+Bd1mZmABd1mZmABd1mZmAB11deVdebu7vd3cC7rMzMAC7rMzMAC7rMzMSSSSXdN3d0JJJ11deVdePf753fbq6773doAAAACSSSSAJJJJIAkkkkgCSSSSH9dXQH0AAAAAAF1dLq666uvfffffe7pJJd1mZmSSSSS6/edV3Xll3d/t73vczMyTtdJCpd3f7ve97mZmSH79+/fszMzMzM2EKlQh1ZRKu7v3ve97mZmSH79mYAF3WZmYAF3WZmYAF3WZmYAF3Tv7srPnd3dwAAAAAAACSSSSAAAASSSRR8AkkkkgAAAEkkk67u7/Xd3flXd3f379+/e79+/A66uvLqvN3d3u7uBdVmZmABd1mZmABd1mZmABd1mZmAqrQAAGZmZVVVd815r30AAD3e9733ve9qtQAAGszMyqqrUAABmZmVVVagAAPz3975rzzzzWd7ne9u9qqqoAAAAAAAAAAAEkkkkASSSSQBJJJJAEkkk+3V19urr9d3d+1d1777+13varUAABmZmVVVQAABmZmVVVX95rzXvoAAHu973vve97VQAABmZmc5znOc5wAAAt73vdVznOcAAAMzMznOc5znOAAAGZmZaqqqAAAMzMznOc5znOd815r30AAD3e973Vc5znAAA8888z79+/2ce+/fQAAAAAAAAAAAAAJJJJIAkkkkgCSSSSAJznOc5ea813WvPPPPPvvvvu953tVAAAGZmZVVVAAAGZmZVVVAAAGZmZVVVAAAGZmZVVVd815r30AAD3e9733ve9qoAa0DMzMqqqgAADMzMqqqgAADMzMqqqgAADe973uqqq35rzXfNea9/AA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rrfd73uqqoAAAzMzKqqoAAAzMzKqqoAAA+3ve91cqq+815r30AAD33e9/m6uVVAAAGZmZVVVf3mvNe+gAAe63ve9973vaqAAAMzMyqqqAAAPt73vdXKqvvNea99AAA93ve91cqqAAALPHfNea/Pe973vO9qqqqu6AAAAAAAAJJJJIAkkkkgCSSSSAl1dPJJJJIAAALq6XV19+/fv331VVAAAGZmZVVVAAAGZmZVVVd815r30AAD39+++++73vO1V95rzXvoAAHu973urlVQAABmZmVVVQAABmZmVVVQAA617re95ne97znOceAADv333331XOc5zm/Nea99AAA93ve985zlVQBtttttt5vP7vz50D8DVVcSyhOVKtAwNQU0GEJqVZVQsDQJoGKp7l177+9/fn78AAAAAAAAABJJJJAEkkkkASSSSQBJJJJAAADLl+QX5QMDA579+/f79+/fvPPPPP5ea99ANHh7ve9773ve1UAAAZmZlVVUAAAfb3ve6uVVfea8176AAB7ve97q5VUAAAZmZlVVUAAAfn5+flVVUAAAZ9ve91ftVX3mvNe+gAAe5mZV+1Vd815r30AAD37e9773vedqgAANu93fwP1AwMDSC0qmuru7r+/fv378fvwAAAAAAAAAAAAJJJJIAAABJJJFHwCSSc5zmZmkkk+hCpJJd3d7u5uZmZVVVVVVQAZmZlVVUAAAZmZlVVUAAAb3ve91VVQAABve973VVVAAAH3333331VVV3zXmvfQAAPfvvvvvu972qoAAA3ve97qqqgAADe973uqqqAAAN73ve6qqoAAA++d88888+QPe5fgckFgaBgYhWBoGxVWQWBkFpV3d3XlXd3fl3d38+/v36P3vfgEkkkkAAAAAAAAAAAAAAAknvvvvqSAJJJJIPbq66ru7vbq68u7u/1Xd3fleea8881r9/P39/f7+v7+qoAAA3ve97qqqga0AN73ve6qqrvmvNe+gAAe/fffffd73tVQAABve973VVVAABo+++++++q5znOc155oAAA1u+++++quc5zgAABvvmvNfffffVXOc5wAAAvvvvvvquc5znAAADea79999V+3Oc5vzXmvfQAAPd/Wu+eeeeZzO917869dff6664gwOvvvv13u4HSD1/2X/lzxphIXLuOsR0jt6STSkOVeUQUgqu2OnlVcHj8kfF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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        sys.exit('')
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
