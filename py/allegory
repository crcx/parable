#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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JOznJd223dtz75MOmb2d0l9ieYW/rdNXGu3VurNTJJPpJbulaSTbSV1d22/NTElJJ9JJd3E7vVt/W8r++zFia5zX7mucv65bb9bq2/rdNTJkkk3Man2lbf1t7d3Fbf0kk3JqS/rbbu5bfymPvddzrTaTTbT72/Ftu7ltv1tf4ENgMeQI2m3GHmlTbbB64hpppW8bnOdtOjNsNmw2aTam1Wa2G2zc3GdbgMbGtbNsas0245zm3HNVmls1Y2bNppm3jzMeJYseLFmYsf5ZrFmjpztu7bbu22bSUxoACyWSSSSRyST1t9773ve97lskqMeYAfJNpmBbd22/NNJVttNNpZltr3JJ9eaVy275u237d1bb9JAAlmpbkf2ZmZcv1vLIJNKJvMzMaSajaSxaTSeNJ42ksWZrIpJKrRO5mWSH6DWtZoD8AH6zI0A/WZHuw9FmZJ7f2jwP35DcmAO5MTHnia8TXqm8TXia8LJ1179+/OrzeWy5tJYk8Stt+dttvPSSS26Sd9qSSfSaSck/T1vykkm5/sk40p6222/p623kOO3Vv74JkkSZJrWtAXsySWZJP2mk09ZmSSSWySSSSW22222SSS22222ySW22222NqSSSSW22222SSSSTSkkknZLpN5ivbb+tpFby2/pIaaaQHCz92SSSSAAB/Jafr75ppe373v5++v5MmcAAAG/29M1Gckzc+3z697bZbbbbbdJtKABwCSSSSSSed5T5nOmyXib1vOfZV9JJeWWvlx3dJnoNz9e6g6Firnec+q+9bay/Lha24OK++HGvrPM9avOCTWSAaH8xwpU4oudANh/MoQVFbobW2Zmw39802f6797lJPdSD3US3u85/ATbbTSXEncSWsxNYprQARJklT3CSHtUPee++++++URSb1JmtNZMHOZMkxpqRQt73u8zurdZkkusySD4b8ya1NdD51rep7u8nLvU155MnvN37dSZJC22rJeHgAXb27OvfuvTvfb77bTJhyB4ArVVVAAGKqqAAOTAAC2gBn0kyZvnSZPJ95OPfGxRtS2Iu8DZRca41DWBZxwBetLjBV3oqudUbFROsT9iByySbCdJggG1aQ0LNpwRd0XCJIPkBXt+40TaSTbzEu85NThJ+acxcAAjTjSSTSmgABoNNJTG02mpjbmNqTUySBb2XWZmZl1dSTMl1JMySAOtYbDeq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8/gH9O3d31ADvVArWTADve973vQAAakAC85znOcTXFirTx+xJhoD80rh3veqsybkxVDWTBVUzOcxiABMjObOSY8VXsybMwAVZkAUCTALadbU0ZrP379+0X1tv25JJIoAABJySfoA73ve970APWpMHAttv77777752ZP0v9yTAPpkve97bbk5NSgLMUxZix4sxGZJJJJMxN4saAAASzHM1rKyZzkmAfTupKDomS2296sF73ve97hHtr++BBzEAwQH8ICEbJz57/d0PEPe/7e/lF4osh1xD+6Q8biHSHWUXv5Dzorm45nMxtNX+qm2J65XlLfZ3rz3bQgL1qhAWUIBuzMEE17g7M6JLhAWCWKCAkSLYhwUY3tiAoWfniqCAamCAYgINICy1S0gSSHeszq3PN7Mw5u/pMaFskuq+q5E6yp1pw+bn3sEq+hNaTS2bruTrCCQNfMn0Kh8P1yhz3yI6aI67/OPtXvzp97967x329973vvT3fHo614QafaUKAJMAAAttttoNnh9fre++W0HoeEmduvdTved71aAHe973veg2AnQAAFyY73ve9+6ABLbJImsya1kyZrNdmjg6C22+R3u+d73oCG5MFt+ttoAO9973eTO96HxuTGgvlu5Mt3ktp4bkwcHk53Umd753xlu9m5MEw9NNSZb2S5mSat+srcmFkSaHUaky2c1bbfrrJh6HjpvJlkktto3JjQHpuTDYPA8kzrbgB93Xe973oaAKW7ky28tvAzAAxbbbbJklAPhza22/W0DE0vsbSxNJZJJOQ6k2khNpLuaPwBAEBu222fXUyitF42H02edabhfvaV6GC2222j4cA3MAdAGgCgAAAbmTJAKu8mbcwC9APTcmGwAL77776+BrJkgGjcmUHwAADy7tvJM5ZMmTm5M1931+4Cvwl9ybk+t53CySSHe973vZAAAkgyZZmW222gAAW219/f2ZkxsGzY2qrZNimxZpsMW0s0tRpYNLC0sWlqyYpkyZMlkyltTJqrJk0mwzFimTIZMTJiZMkyYjaqts0qyYmTKZMmjSmTFkyqzNhZMEwmU1kwYTS1RpYGato0tQ0tFNGqsmKjJpMmQ2WYI0aoyaqyZVo1GyYmlNJpNqLJqls2zLGCMTSGjJkyaMmGJkyajFZVqZMmTSZkZMZNJZMqmTE2WbYUyYJtUZMkthMmqmTEyaqyZMmTJkyaWTIzSjJixNJk1QxMq2FtJMmhMWTJpWTCZNKMmVGGhZqhkyrJpMmZMTJimTQzW0syTJpMmEyZMmqGTE2tmybU2ilsobUrajJibUbJjUlk0msJkwmaFYmismisTVDJqLJhMmotkbRS0tBpZErS0WliiyYqyZDJhTJkyYsJkyaqxMTJkyaRZMmJlWJhMmTJpNpRkwlZNCrJkRkymTSoyYpZMDExMmJiZMmTJkyaExMqyYmTExMmJqrJiYmRZMJkyLJqNqW1KsmCsmTYlMmokyaFZMUmTJMmTJlDJiZMiyamTFDJkyYqyZMmosmVYmJiZMmVZMmTEyZMmTJiZNA2TWJaWlNLVA0sCWTBRkwUsqyZMIsmqWirAtu++++/vqQr6loS81RJxMBZNQMmkDJlFZMVZMgYmJiaUje5MA+mS/pmW2hMgFtky970tmReKqsyXfJMADsyDkwAd3Zk++++++7gXbu7uiO9+6f3YEFkyv1H6IV/uwxXETTMbmJuZMUwzO9/dTfj8eSc8euu3JA9JDs1rAA3ZqXVtts7JqZJJ9JJNyaaud73ve0TXfaSYAHE0QAkkTWqoEmaq4qzIAQAkm85zNl376TJJJtp8xN4Ikk5JH+xJ5jAABISR73ve9wibzY/4VWhIBc0kAljBCQPecLzIbnrZJJyGiyaTkl+SSkkm2lMSk1cdxenvakkkRhiPe/Nq4lcauK4krjdulcaVVv63TuNXE7iuJObaek1McyZMaaab7TvU33oJo2e+Sckk2moAKsybN3d1WTAAAmQAcmKsyLd+kzd3d7Mm6AqzJs3d3VZMAACZPfNe6/TMt54+P4BWh2NS2973qzMAkk7AALC/rbareK5bqSSSAB1p3tAaYUTQHvknJJNpqSHewE1O5N3dWTLUAJkAHJirMnyu9kzd3fo0B3vQE1FJJIRRNLHiAAAWZmZmTNav15Mkm7rbz3XPfPPO+fenv7+B6E8f379+/fv3H9+/Hw/vw73ve970AH2TBxMkAAvaA0wovYnmKck+e8ScxuSfu8nOSTmr6qsybN83VWzIAAEmAA0wBNGwABNHez5JgHyaikkkkkyXVve979mTnNyd73rvb+/gAB+/fiSSBLbbWnbbJJJJJFJJIAAMJIUAGmFEmAd70E0AAdTQgPbUzd3fpk7OR8VVZkQNyYqyYqgKmgADqaEBNpOST5NHAJJImva5xftfv3bNe/NPmt2n06o5jTkkgdFrEmH77Cz3r8k+dtt3u+t3vFnTGmfAHxJJJJJIfE1Nak0GtmkqsvOcafLRJezMckgVcyM1AFuSIAsyd715JltvkxHAI05JE19AAOiTAAOpoQAANrvez5JgHza1o19r3336Qpzp6SEySdMAAgAASQmAAekltttkkmAA01/d/r+DJh+/bMm7vqA9mR4qrZkYqqsmAABMgA5MVZkV36TNV3syAFmRBbbZM7377776ZOz+7+l855yead+395e96Tikn5SSfJBoNICB6SJuSW2wDQAEDEnMUk3JJ8EkkPmmcf6/3e5M/izIAVGMk/RarSScnJyTmc5JnOM5Fe/SY7u/STqlvbJHIAFmS83zJ4HpqkydyB4OTFWTHrv0mKv0aOdiAOITUydcmv3799c+z77fLb639JJJ8AOW5bfbaC2222um+mwdyY8V9Q1/pMyZ53+tp/MmBaATJ6A5MVZMOn76TFX6ZENVWZNvN31Vcyd4ABZktrkwAkw6OTN7Jm7u/TJdZ73ve8I+puX+wgJCPzBAfmICmIC2JAqYIIJaJQBAf1XV/f37S/er33yQfcQ++ddd/vvvaHyLId6le6R388ukNoh3vvbevf318Q4hqHZAMwr1XmdVgIO3vQQHYkZ6LSvSk77fTA+aCPvRfVPN1AjG0JCGxAMySb7OZzPNa3rnMmt7u5x9592hABWt+93fa7351Pe++YkW0kI+aQEaBIjSjahsstQ0rKDnKTiK4wrjSrU2jYthWyhrJrFsbWyzKbGUNoahqDhcqHGI0TSMhjKGso2pLYhrGLBWWqH3bvlDrSOnfLp3xA5jYRaqs01DUMqHz3nWLYRnlcivukv2J3iT3nFTIagvGPdIcyT3vpOqK2VPffffv3v579673wAavw4Ko3vZrQd73ve96AC2222gAAA8c+g58u/ffeer0AHe973ve9NgFtttsoAWe++z318ABbe5L9vWsm9Tao5uGObZc2tb7uNjNZnQZocUBsCETZBueopNDHRGhNSSKRgMjG22oNtKODZENpskq79998AO3cmXMkjQO9vAPgttst3JloOiABWlaB8L5q23lt5TgB3ve973oLk8002vve+5kk7MyTWTM7re+rR6HgttttoALbbbaQAW2220ADO973ne+8kzvTz0AVbbbe0MmYmTWTMzQAgASZIAAW2220FzJIkyTQFsySWZkmamSTWamsySa1bbaeh5kw0bkxyPrd/X62gBg3bbdZmZMv17Wyq0D66ky6ttt++NyY83oHhuTDdtvLdyZR4AAAAAAAAB4IegAHxrJkm5Mac8888AAAAACG5MBfd/e53NVH1qhom4a4qbSRqw020kt95O2iL8lPLT+xK/O2mX3PWfnJIfAFufgH79+GTAAAE5DQAMJOtPy82ml8fm2g00tpLFiWZJMyTk5mTi/vs/ckzEQAmQobJirJn1+r2TA8yT3Wr1fLbZJ5IgCpkUAsyMA2TFWTDpv0mKv0yJQO4R7+rv4/l+yr/t2bJbBfe/VXe77D4/Psn5ie7eWbjS7EpjTkktVh63zb93Xve9u+t/J2SW2mrlttqvbbbbZAAW1tdzWW+/yv8SZagBMgAyYqyY9X92TN3d+mTVBVmTZu7uqzIcnAACZAByMASZsJtJySfJqB3vQE1DRNGPXs3rWtc3Neb57+77+f34A1bLZbe1+g4EltMAAO2QmHpJJJLZADnv3L3vbSTAAAmQAZMVZMer+7Jm7u/TJ3VABNRAAEmY8xJ5jAAOmPMAI05IJo2E2k5JPk1AAATUNJpLvppNJc/fLmJpLfL1t6/e9rvve56yTJJI05JPvW23kkE2B+CybNgfgJJIgAAJu6PO5MX+8v8F/lkwAAJkVVVzIGvIzSTMMX4Pyan2ST6SSJoDsAEmAAAmgAAGmZJpaxKa0k5NTJNJPkHAMyF91Mkn9/fvvu95z+98/v7f9+/OcBOyVppKSSSfWASSFksTYABYNOYoAABJIAXd5znLRJgAAJoAttsyX+HPcmDjUyfACZLattsmW2223Ma1qADIjTR7yTA8kz3339777776n+fm4o/UMgrMUTWmxazK1EbWbNWyKvNCTa027ulurfekkkkk8l7Mx+973ve9QCKST71tadqttkkqSsuWS22STpK03q123iuJJPnOc5y0SYAACaAALZktvMv9uTDeNNZkFAmQW22xMAABNAAAJowCfJOST5tSQk9999lvOfNTZqGrNM1s2RrE/ffm2mv10m2nrbbt/Ls0m6s1jt9324sf7J+aepJPjPNpLskkl7MwCJ+zFly36+2k6/ctt7uSKett2B+ACSQA+MT7U1qgBRJgAAJoAABNAHtpOQ8mQUCZBbbbJlttttmS22W23MamtT5s95Jge+yZrWaQeAmS6S4mksb+xt/n+017H+WNfeX78tW+vsPdtkkkgIDGmAQOgASQD8AG5JIIAAJLbJJPRNwXoB7ra7mLve973qa7AACZP5i/3ZM3d36ZNqqrMmwAAmTec4ABZktAAmRXd52TN3d+mTqoAJqLcbSUm/Na39+5r2/Xxmvck7JqST639D3Qfl6TMB+/fraA/fv35WhJJJJA2Ykz9bz9zd71JgAAJoAAtmS23+9kwPJkfAEyLbbbZMtoACaAAATQaCfknJJ80t5kySSSRCWJE0kkVfvvtavua973uWQkkkkrSVtttuxQ0l+A+MbZll3JJ8SFkkgWSdmJOZJIACvL3ve9okwAAE0AW22ZLbf72TA8mR8ATIttttkwAABNAAAJoAm0nJJ8mpySSSey51/dfv7rSGQ2QxWKz/EMkA2kBBAfdn2+v7PCQeEBdXWCAxCA9QJKCAeuMHrz9D70PmcwQPub9UPYFddB39MYYXlWMIIBggiQD+6vrOIhuOb9Mv96/s9vXldflyBI5JLbLYbTUd0NrKtQ2UMUcmAuUWRTUOOIDKcoXXCOFDIrSNQ1Vqo1DyXZRcVc/dAuq0Ku3XVyHxqHFDVFaGu6C+OOqGI6hj7iU6oaUdW5Q/cEq70SXVD08g6O8pd7MZbSmVVol0cSrEZQbMtyhuSccE4VsHA+G6dcUMe8dVDNmaxWLIdEfOiPNQ7OZcqGUMGVO5wlcTnOYqxVzNibMZc1Thp7zqWdRbFRsVaVVyhjmtpLtrh1Q5zSzW2ybMyhlGEbrnEshs2VHVDKPehTqNb7kuP3E8oar3t0kuveSTM+a79vMkjuTNSZe8873vQAa5rpsdUAd73ve96AC2222jpsB4D0HoeJ55554AALbbbTQ8B7bbbbQAt5bbfaAATMtvZPdSZk1k1kk81vUmpqSZLqTJm97zWrfK6AF73ve96oAfLu222gAW2220AFtttmtWgMDve9zMkne96NlzGsmtJOwOpNpGGAEyTqTXFjmSfQh1pDy220+HAdy6tttr2xo8BfdW3y22tAem5MJvJjJjJjJjJjJnnnmvPALbaB73ve973pC8kxsHUaky2229oAQAAD0uSYnM+kkm0mdbSb4sWNY8wefHxgSRtqQUC2223mTJKD4BbbbbYAA3by23t+HJMkA+FttttAAW228mZJbR8NZMkAK1MyTmsmScyZIBe3wHoPcmYHgAA5MmSBjGBMA+AAAB7A8B6Hu935kzvZrq5VxO86ZItQ6NY4FNNJNd0vyz8u9+72e6v5N71J6+8Yb+skhJA805JJNSkw3pmgC9lrTtTdttAAAkk7JqSSOSTO3ve9520bYAACaALbbMlt/xr2TA8mR8ATIttttkxVVJkVVVmQt36TAPZkWqruwOYAG91C8Vf38hX/FZn7PMF/V/X77V999OYk5J0y8k+kkpe6mJW6tttsMXr9fknbbb67gfgskkkkgH5GTermuc5e9XszMxJ5iR+AAEwADwmjvZ8kwD5NRKdkkkiaiUwAAbXWsNAACaO973vepro0wABNSSSSSJounjcx/r+tKrq+tkkk7MDAAJAAACekk3JP1/AOgBbbX7O6/py3nkmW3+99kw93d3d2ZHVVWTAAVZkVUCZGK72TN3d+zJ2PFVWZEAAkwAAJk6tttsyd/uav29+ecc8Orf54D1bbbvEwJIPuGNMACUkkkKaD8YgKTiAW278e8/v6TO9/v7yZAAk91rUwArUma1NakzWoAEma1NakzWpAAkzWprUma1ALbJmtTWpM1qcbhJ3aThpT7STzFmNPMRoADgk8xZiTzGABJIk8x4sbWLJJJDpjaxYsxtYsfdkjuZ+3znPvuXd5fWbkUn0gAAE3IfgACFkkkLATYcC/pJJJIAF5e97299iaxYsxNYsAAkJiaxYsxtYsgCtTJqamtZk1NaACTUge+yYHkyABmQLbbMlttttky2222zJbbbbZk5PO/0d4fd9X+09DwpvJgDpeW2326pkx+FB+AABgdyZ+7rvdzv9eSZf7+5Jj4AzFAAATQAACTAAATXwAANPusk7qTus7XJMHMzHoBMi2222TAAAE1vn7i1+16TTT3ve2nNTD2jK87e27a+zekneXc5w+RgaZZEfjgG5JoE2WT1u0nb73ve9bJJJJJAD9pcx7n3PuSWZLbbbbMn8AJkttr7Jg5mQAMyAttmS2221EzWpqamTWtAkkTixSSSSCaAAATXv32k1hqa5bf1ff3n79+PQDYDoPJMP79+/fA2B+skkkklttttgcaZnZ2ge4k56/k19iySSSSJoAABJgAAJoAAtmS22vpMHJk8AEyW2222TLaAAmgAAE1rizSTSjaSxPG0lixNpLG25pNpLTTeNpKbttl+370W5ySbB+kk005JbeBjTAAnTvfNpL0knrfe9JJJJE3JIBhznm0l7G0lh6E5xJz3vya+kkkkiaAAASYAACaAAtsyW219Jg5MgAZkBbbMloAAkwAAG1E0lvSaSJ39799v79bNn7j+v5A61c/YA/fv3TYDwPLbbbUzFaAAYH6fffffffv1k/prJqA9+kweeZkgPgmZ5qNSaAWYgAAEmAAAmgAAE0AE4k5J+TU3JJJImoAADa79xC9iaS+TbxIE23chbrSAg5r+/SCAYgPNJfvXhfb2b73HwAPblZHNHFjRbGNjZXqKpkuQQDR7drWhLdi1oJUEB9xLYy2HmU0Da9YgPUFyqo+kbY222IZbjGmIDhANIEUzrzXa5MZ7zn2Tfnr69Am+ct+h5zXmZkybsyTGkmayQq71D7qRsoVzJU7eckoMigJB3lZS+rUCF78ClNglvuEkjotFHOvt09/uRQfbFskf2Q5jK1U+6QfpGUft+mUv7vkzMmYV9qTGved3Jndd79vsOG5M7HzzxrfjjRvJj1fHhx65Jg98u5rdG5M+HLz00bkz508I65Jm7ba6nnrkmD35z3lt5PJM1OZM3fr7Tp15kzTjk433Jlm/dSZ99ruvfPOe66+9rcmG6Hh9yTNXe58699fe8ajUmUeDZuTFt8t1buTKD5HXJMc7qbtv1n13JneKBZM3kc1JO77jTaMSae8xNJYm0Y0w+J2cmNSY0B75rJmt97533veghwOtfattt+pzQND7NeSZb5fPbTxrgenzxoPD6TL5dcD03Gmhbb2+9uq89eag1M3J2B1JptaWJY8ZhsD9CbSHjc2eHJ37J7ruu++d6AB5bb5ba5PAe/D2TA8B7Nh7oe0yZbPdTM3bfrduAfcDyTDfZzyOX237t9o9DwrTy+5ktvvltskkmNAHvsmB76EACzMkjQBZMySNAG8mSAOi23vbLdyYD300bkzvofHJmSbXcmWnXwBbuTLbbfgAG7bbXThx6Hnwttt3bQ86byZJ49aQ68Xdu7Rv55037ovfhwA3JgCdD1rJ9r77z77eTHxsAB26sttsoANl1r7PO5Mk6X/ftd3+7MuJsckwF+/ITnRtjuSwSHK0hyxL6yV174sjrfPUJ1PPmj3Vz+Z35pNP7E000v2NpL91d9Z7963ckn0gOySSS2gAEk1GnIAWZJJbbbJITJqSAcKk2+Xve94326aYAACcttv+fSYOTI9AMyLbbbZkASRNAAAJMAABNAMABNAMABNTy7mZL27vzTvOU38wPzTA/eH5L9JJJbbLf1tttkAAkl973En73ve971sk5JJJP05ezbAKJoBh7jTDTaknIt3d2ZOqHQ8mQnADVJkALdhMAAsyaAarMgBvZMV9mTZum7u7syH3svdfb3u7ssn49ZkACi9JPpJLeFkkkkod73fYfrJbbZJJJJIAXd5zm+W/m0AAAmgAAEmAAAmgAAE0AHuJOSfk1NySSSJqAAAkwAAE0AAA2mmmYn3E2ls02ksWlmZn6b7+k59PdgAHhAAEkAwxJgBODb73ve982krJbbbZJJCZADfGne0AtFk/gBMlttttmQAJkttttsyABMlttttmQAJkttr7Jg5PNYD4MmSZM81mSZJLrJJmbkk0hzUk9wjp/cQ5kNifsGsTSaYlvi/aLT9b7sAsh3vaHzTCzp+7zgD9bO973vf1oAAW29yZ38u0AsE0AAAkwAAE0AAAmi23++yYOTIAGZAW2zIAI2gAAE0AAA2vYmkot6WTSaS+r08SzHv5p2S61fUBB6SQAACAcDQEjTkAAAnmmlbb9cSaVtvybSt1bb8kk1JJ33F3wB7wmgAAE0AFtsyABM7qS63bXsmDkmPQGzJqqqyYqqrMiqATIqu2TNk/Jrvdd6u60n+2Ze8q207ee+APfNOST4AAIFkkm1JZJJptQCyfdacnvNNL3tJPvve97l1ITElJOy5iaS3mu6793nj0mTVaq5vJN3dVJk3IqqsyMgABMjqqrMntt2TGyY7vuZPOtXd3ZkLUAzJsziqqTJ5ffNnfvfvu8zOckk5vT4A8fWQ+QHgCSSTYIAAgd73fc7kPJtKW2299mJpL2k/e94vGmlf1PmmkBPuNffuc56ia74A+4kw02v0bZhhJN2ZKqqsmKoBMjFVVzJb3fpMt8eTI86qqTJvgaq5k+yctQLMjv5L7eP77fyT+x8xb5yRnfPnc74CxN+tttttkCNOSSTgAASS239cSaVtvytu7uoH6bf4t/fiZLdyYG3MxfMyL0AWZOKAEmaAASbzZu7u7rMhwPA33Ji+ZMVVVzIqoEyAaquZN4875Ns1n2+b/JZnOZrerxft61mLGv3bavelYHpJJ5W23807baTskkkOQAAgStNK22222tNKtO3Vu2205JI09tcve97AmS2222zJbbb/dkw3JgATI0JA6mgAAEmAAAmgAAE0ABOpOTSaknJJJE1mcy6Tek0lVvCX9mJAVLkBoQR0FMQEG2IX6Rt/q3DELPoICR/slpJJ5EgH1KDoEBPUFCAv09c1pARsvqj5l150MdVVuxANg76/Ttth7RbUqD9F/MouaQlS6UZmYHrXnbGIC4P252CAeOCAzfcieJzWrhfrzmSrqSWPMbaS3jaSFl+SabqxWtUMm2zRazzFxSah5xDko2TyhmVXxyhwhfOfejp0u+lU8uOCp1CYqtm1EyfeRyIxsg2SMozBMJmqtoWI1DGlGI7oYTkzUM1bSNibGyTaoaqlzlyxDtHKh5lHWEY2kM2iWoe5DlDEe6OY1Dw4H3UXVlWijSbVDmJOFp7qHJoqZm1SMhlWWobG02ttmKsu+Pm9QstmrbWgto2Zk2pO2nM2WZFfOKHvXwRuYQUdLYINaSLYH31/U34Syu7O7O+f3zgNDblt7fetgFoB0ADQBVfbHnLLZb7bQeA9uTO67vXe97vqjjofKyZbbbe0OB4BBeUPWj4S22972gAd6u4228xppPMbZj1iS3oD4hJJJJJM53ve+d+6fG5MaBxbb7bq0Ci973ve76odOm1tt1baFA3Ji2y362npo8CPqZMnABgHm5M793Xne/dABDzps9AAe23lttAA3mTeZN5kZkAAAA+77mT7fPe+e986AAeb2RDofa8OSY9OneAfAANgOiTJAByZknMmScAtreTJAHSAAdAhFoAC3t1bbRzJkgHw5M7dW323lB8Hw2B9aAAW6o3JgeVqTJOZMkA+Xy23y20AA88888AcyZIB8LbbbafG5MaaAv0zPnzrv598LqXvv77LerPVcaoahs1DaOuuJOkNFtRMhlsgQ2NNEBbft/v3tsoaZ38Aawe5++Pus7X3veB79AA/AEnDgaABpyJsAACSSSeVt99mJpL1tsgjMTSUnBp7WqHRJHtL0bWseY3JJJIJMAABNAAAJoADimJuTSa/SSSSRNAAAJMAABqSSSSRNAATqTmTE1xaXH5rP3E3LNJuXih1p79fwsCGbaZJP6ehwPz78Afr3vfp3Xf1qZgD+/XyT9bbUrIfuzvfqB70TUkAASYAW2zJbbbbZktttdkw3Mg+AmRIAAkwAAE0AAA/6xuSSS9Sduk1Jz80ml+/n7X7ut2rLvt/mmmc7+7nPd9TgaJqSfSHQAJ0AAUnmmlLbbbbJJJADnk0l5d14A96JqDAAEmDAC2ZLZbbbZk7bbXZMNzIj0BMlAAJMAACZNVVWZBirpJm75MWb705j/fft9Xcx+zTbx3xVPXc7iT73ve07E/SSSSWQLbiTttu53ve97Qqkqsn5OSSbTTSmOWySU93ve994TiAAJG5QFmS2222zJbba7JhuZOAN2ZFVUzI8VVSZAAAmQADSTHmZN5JIbp9/c++736/xC3+7v4DtBV/t8ickkk7IAAEO973vYFVtskkALAC7vOc57w2j0kkOITQfgJJE1IB3neTJs4qqmZAAAmQAAWTFVVZk4qqsyAAaSY8kzf21nnnv6fv337+tvDnewC22222yAAANOQxpgAHZJAACtNKS222yd73ve+9G0AB3raAANZkfFVXJEAB3ZJ5u7u7rMgAACakAAE1EABBJzE0AcABGHxI4xAVl/BfH4ZXzN/Z60L+e/f3no0/E99JJPmnJLM2d73vOzve973oVppS3GnbJbZZjTSt96bSfve9720vsa0s3+3v37+/tzJ/ACZAC5k73ve972ZLbbVZkVVVmQAC5kOAAWZLbbbMm7u7vuBeYiPj0MKq7EBmUfhmaJV9+nD97Ec9296u5Pem5J9N23U5ICAO973ve9QVppTGmlbbJJAaYWAHU3nmNPh/Kn7MltttmS2238SYAAEyAABMgAATIqqrJOAALJnOZIAdBcyKoBMl99+D+ud8++67N66G7/Hf6gd9bIpJJLJIaaYAc539PgDkklTaVy3UxJpST800pJPmmlLZ800pnsxNJf39+919UP2yYAAEyAABMgABrMyPiqrMiAASYAAEyAABMgAAskkVeqsyV/t5PryTJOe8k++9791yckvMOu+/vx/SYU/lfyAAa7uqqhq7A/SSStNK227aaVttttjkk+aaXb+9fVX8TIAAEmAABMgAATIAAEyKqqzIAAEyKqqzIAAPgS9Pe973vAXX91dlH9r5o/NCg0gOoQGdb3dEBZGfXT3v69nbs96b58T3r40zNevHlNsc8XfsypM7c2b6kJNAjyE1G6zhR8RdMR1aGLrWxLiG2jhOZtFckY2uGmXNxbnDmts1ucqHKthGqVznKhkNSNgd1zUNHDy5XBZttVaTdmnh0104VxnKRgjmnfffsq66u89UxVq1ReZ69Auwdd867O9Q51Q867UO6ldyO3US4IyP3Lsjoo+dc6yVomob5k/coe+PekHyiOiNmfHRHVDoK2UdYjnvChxJ66dI63XlDwvcedSvNQ5mSZvJqayamtTUnng75N23zvfuxYAb3695b7fe/WgDve973vQA+14w9PgDZ4fPu972fe+c70G/vh54zu9/fffe+qA2F973ve9UALbbbaGgDNyZrve9793tABm0zLbM+1PvXnkkwed70APC3y22+UO/HBntu5MurbaAGpMve9737u13JgPTRuTFtvtlu5MoH3Uakzj228tMaYSSSLmdk00/oB1tITaSxNrOaNSZdULj7bcmG3ezfe7kzve8DhuTA8LI5tuTAerG9tyYB9kzLGm5MAJdADnO97333vQAHy8t8v1vfT4ADyTJLbfLbQAAAaNyYB8AJkyYrWTAAHB4Onw3MyQDTpsKdOAfDkmSfHjzcmHb4AdNyZIA6W2223kA+G8mSC2/W20NG5MA+3bbb9aGpvJkhwF+kz7VPNyYB8b2bkwOtfN81OcD4c3kyR03kwdNTeTJLe3Vu5M392jcyQJJBTJ+OH7MbSXEmnxtpv7Wm1iyh1XKLmtvzSO/KHliPvv7oOvu/ve/pmZ7k5zJ7r+P3e/r/Af34AA13dQAG0EmmnNqSSdkgBK2/e973t8zE0l73rbRCO+NoD8/Y0pieY8WNMAAJkAACZAABZmRX5VZkVACTAAAmQAAJkAAFmZFVVZkPaH3v3k/rN/kXuTP182SQD89yYv96AAbQC+yY3b55dXUt3bbdZMtvJdUeN7u77+3f0mf1vOc/eW9/GZAAAkwAAJkAACZAABZmR8VVZkQADMgbu7qRz7u7u1Y0tm7u9wjhXU72NJMGkmlMf25Jv3sXe97452VP02pJPpbklstttp0AARGmlJJ97MTSVtu2ml72vYk0ve9bbbYNPDve97ye8m0aAAE0dttsyEgAAzk5zGTi+qqznJzk5yWSL4qrOcnOTnOcigASZzk5OZych4OJgHEJYsSxYgADvTS1jWAAdbX7HvGk081Y377TeY3cXLN2fJO33vAQAJJJPmnJJNyGmmAG+wAAJKncly2ltqbkkkvsxNJe97ny3zv3e991Nc53ve9Jk6AAszIeACsyeIAGZLbaBJgAWzIQAAmS221JmQ8AAmSz3zXe6etffG0tPMWZmOaaXMaX67twvuW/HQ+APIAACSAAd7AAAArbacklttskrTSttvm+83vfhJ84d73vU13ve95ZkAAFmZDwACZC21CTADwtmS/W22ZLbaCzMir1VmT8/P05J779/db496evKAAAeAAAkgAHewPzTADYABJJ5ppXG2l7MTSXve973vevOc5b+Mz8qvV8cxVVJMAACZAAAmQAAJkVVVzIAALmZHxVVzIgAEyXztknvPPd3LN5Ld1/GTP395P03Xck405J+mSSSSHJK1bbaqa7ip+A4V0byYD02APGv7e/6TNa5Jrfe973+JkAACTAAAmQAAJkAAFmZFflVmRUAJMAACZDAACZCB3vegm0XW8WDX7dxc+k9hf3ZJ5N3ltv0AAh/fvwDMlu/xwPGxoOyQluJNK2222NPe/c5z3k1Fgd73vE1bbbZMtttskAAB5zk5OQACk5OcjPFVax5Hi+Kv2TORVVtttr/WO9d7+7fcD78AbAogCNOST6QPzTAF92AASSSSSSSSVaadttvl7173vecvLbbaQ5AAbJnFVW222sAALbbaCqrWTHxVUtstr95595mB4znvv3rxfdL/f31u+22238gAAge23lttAAOmw/ZMk/fv3vs9+5z3392fW23ve97+ttt7QABtttpAAC2gAAAGZGcyRVV5+7yHv7950d8mST3u8Xev1lmSQu6+DZkk3jt8mST3tz6N8JEHzr1F6RU5fCW/dce+dX+3sggOSAzv37d/BH+dOxAZ1L5kMzs2wxMVfKDqt7muTN6z7vDt89o54Dz4PU+epU9/a517/da+x0RwjEcpU2EaI5ybY2yMhqG0jTMm2bazWtzXMbTaahpG1NtpGlZTaoZDRsNrw97VdNKZQM3cjipspW3CLZK4fPnLuh3zGxGtCHIc4sktEbWVwt8tUc392kfcdh866Xhcz+3Sp9agn9nztJyVceN5Jc81rJM92Ln333330+XYDfhb9599d332mtGtA73ve970AEAAgBbbbbR8ODEmXve97O9UALbbbaAAgDzQPgLe973vVoAMX7uZOal1nNTnvM8msmvIMKkI1GGllEKaKJAbY6RG0qo1m+W+/dACy9ne971aADLbbbafG5MaC97222nw2IGHLUHz00D4vLbbaOnsanmx69t3kmTLq22i5JJMaAttttp4D0J5mYD0PAeh3ve973vAPge/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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
