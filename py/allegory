#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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FTDfLr00oE37aqrv2prWta1rXfu+exI3d1VAOgAABI3sBGgDt3VVw4HQAB9Ent739W93dVU13flVrVe91tu7qrne7r73k9m7uqrXdnA6AAAEjewAASa1d1Varfm61qq3prwIdo2AACcbB097dXVe7qqu/ZU968558kjvLuqqXXG/AhKuN7AABI3sBoAj6S7qq1qb39trnvp0ACNAFznivffa7erqrqa1qvqqrvf3HPXwnLuqpsHQAPQ8BPo5t4AAO3dVRsBGgCeNh8I81sHTv2pOa+95PEsASqVyHuX60gCmAlQCXIY1xmtA2ZfO49e+9swBJ3oCT3TK31c3nHxVy1JcdagSj9AEqnenbrZixvb5187M7MAS97RCTQJdkge5d8dcK5ijIwEmwEsb8b2VPczTjOMzlc3LASu+2U1ec8XzZTNoYyx+itgy5LlVBqVXHQCV3QCTUx+zjYuOrASv113z74OV29ASwBK2QG23IsnL48F54wbN7VNyIEvVvnDwIH2+7d1snn7aqpu10BLR97x9fO0wEp3Kt8Ege+gZyXzGcsfPc9zR1vuZtm872cAS5cDK1uXd8zu945uAJTsrbzvjO7gCV7O5tu32c27OVnXBAr4S/E53IxnMiSDJSQAgFMJzm8r3u+6kI7puvbuqrW+bDpU42DpKjewEqeOcDpI3sB26uq4cDp02B6e9717uVje3JuRnfZW3NaQHO5uFoxpVVfa8b+57qtXX2va979u7qqe96OgAABI3sAAHbuqo2AAAAJxsHSVyVuq7NVz7WnvPfSRvXZyaqrqua1fnO+1779p5v51IGAeDHoSN7APtDwHnaq6rz7am3nzp7Xoe+hGgCcbLWtXNeb1Wq5N2zcR7y883Ce9sl6zOdu/DpIDyQHe1jog8B1W3vj2HHiQHGru1UcJCXUKlJAenn11eA6BBmtpAS40gIR1z7v33QAb7d1VH298H3QAAAnGwdJOy/XvvnoiScql835yt+b35rX13VVz3no6bUB0ACRvYAAJLuqrxzgdAAACcbB0+qmrrRwCt3dVXd7rVHgQAAH33vut+eeee691XNaqrqpOc088799d1VO7gAAABONg77286EkqAgyoM3fVfPe53vpvYkA79PYJAAABI3sAAHaq6rfz7T16+QAAATjYOnZuXv6cefc8fDvLuqo4HQAAAkb2AWtXlc3d1Vc0COmwAATjYOkmp7rnPW+eCR31v2quqc1w+dAAACRvYAAEu6qvNuB0AAAJxsHSdqb3VN84Bu7qqAdAAACRvYAH33l3VV6knvuvva5Wm6v3CuRIDJUvZd+jSAqvbtkHXrM4khWPXmd33POHWbcQJTSuPvkLEInNEkc1oEoAkzJyjxgCUXQEptTXbpBTTfmAk72cumaAlyF3Dbh7Yn2+XNdivQr710K+CuCuCvVU5FbJ/boVz0K9CulT6K+ivfXsCUgCTTdDjiKZMqcEhdworAEvAJUR2Akxuthi3sECAEgVeusv3dRKq6q6q6vl3VU2DoAAASN7AAB27qqNgAAACcbB0lSe3dVW983W3OcHTd3VUA6AAAEjewAAdu6qjYAAAAnG7Wvy8ePGv18Sty/XducdKjjrLKqUV26qZMphGzLMribHsJGjCMjlJ1HnnA9w7VuhjcIpObTd+m6VVNU5T6XAQXOOyrpxlwGmIG0BrKGFQ9R7Fel9qnUUJx+lg6qMdyXtEMarClqmZLcqpaLKSpoXe9nXatt8M4jTawjgcrZRYjZRZ5YTl5i3e+q71lNaqV+tHaMYBTZmG7RLWYKLajNzVy0QYt4LhnLuwjOSG087ZyuUz3eKz2yyPKj8EhasiwbqGU+VTTdWyBVQ2RV2mVGxqnmwfjhzJrZrduMkhXGbwtHC02Nkxyhy4ObcbesqZV82vNeDsx6kcYhRkNjE3lI9ZrJu15rlwB8jqi7IxtM5o6jR5ojYOHOPbTJdSn2Vo1Ad2SimSIbNi9vanHwr3YKiZQx7pxlLN9JRTo5DMZxhkumn1lWQpXKaduBKVZLq61iD2xLr40xDZynOFxmxN6nR3boAbc9OV3LYbcDGXVepVTHba9fKrKqTZK6zY5pujZVOGwbgyUptbUrd0wC2uncW8rLNfVkBsHub2yViYNvCrlqVLIwqVQzHB1dVJJDhZRt06zkWp2KmUzheW247OSQ26vNwao1kM17ZGjTHJV1ORUY3VY0Z0cMbq4dswuXAiSbcg16xJWNouFHltXThCXRBj6ch6XSJQTAzgawdr3e1EMVvOEVFoC7LKHHkI3LQSmPIeKPenKzznOVo2LrhgN5iws5hOstmo45zxt11twpmFs6YaNdzFpsqtdM2ilxHCHdL4Slyq3MNMtRqo0TGGNermE3Bvlmb3mo5pUhQh65y030NUcqZzmjGdqPuplervnd3TrrwwvI8Lu8xrEx1BsvjyVisFBta1WM45l5EoxSODcBttspzjMdck1wvlVy4U25EceXFBkkOVHEia2Slj3FE23BkB68ds5VZY2UyM3TlMGWzOBdcZnGrrlVSdFMbHMt0222Ntttx7JWU6CDVm5XcPVvPVRkSbT76uVRIetYX6Fu1xkzi0sRbS87RiThwmHLyrrGpXXRmAghywQW4CC3UnvyAACRvYAAO3dVRsAAAATjYOn31aruq9jXnnp03d1VAOgABgJG9sAAHbuqo2AAAAJxsHSe3VXf29VWutueeh260+57aAdvwOnlT183lZzid+urbLdZi7ykgM8+888r1x7Kd30AAO3dVRsAAFAB99qq19vupVVf2ruqumvPPviO7OAgANXdVQBG69Dw6ABv0PDoAHt3VUHgAA9737d3VVLuuaq6u+t+efO9AA3oBAAKq6oC1rWre9gBPWx6AAABK8k++fe+kkfc9u6qh69dAAACRvYAANb7d1VGw7AAABONg6d993W/ud3o+5598PuVV1Q8HQAAAkb2AA+7PrsDthvS+uOIQbyy6c92VvPbzvu14nve97pPuTsrfd+O++d6kfcqrqh4OgAKAEjewAAa327qqNh2AAACcbB08nKqrv3tVV3vtUce7QIVDadEBB0BJ6CCQ0BJw7Veqad0BKuNSwErKOPWHa9RfAE5qHrszznooM0ciAGXwBdMuILsK9CvcK6d+uxXffBXXHQroVioZIAtAWbvu/BfYbPsXBRXfM35PpIl98qrqnHg6AAAEjewAAa327qqNh2AAWtWvdh6fVO6bvnZrwu6quc7be/eydka3VXVAOwAAASN7AAB27qqNgAAADvDgdN87W9TValb99rj33h9DvLq6rVGw6AAAHaNgAArta1zVcbu6qprbfBI7GtgAA7wnfPecurq6pXNfTvl87VXVc571PoAAAO0bAAAlVdV9tw9DpsAAHeHA6S/Kl+/V37zm/K91qvPhCVHIOoaPHV7JvubTqu57CaS04bb5vznvfkefc8u6qpUrbnPXXYAAAO0bMAGB927qq4c8CAAADvDgdN3VXcu7qtXd1Xt1V3qK/uorB1Ff3XWzmK2Vk5VzZxzm3NuK5Ucivns3O+mN0xxs09xXCXqvdR9iuRXuo0Vor5Fetjl84bXMdbanNzpFciu4r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shdtpu2222Szva2cSTdTTSSeszltD1tJe673RzG0lJJKfBmBjaSCe9153ved6SnqAA9DaTbnJ9JiTSn0lACGgxtJAAB2Tve973pKkattviVttvtW9YlFiuABCDNJq3G7curbeGjRo0aDFNJygeJAFvqV0AAATve973pIAegINtJvp1EFdkSGGcMzvd368vjURngguW3y+23tRRPEU+xBZO+Z3vnfu/X8gnQGEhYWfySD2L2dnykf2EhnIn01ARmufz1fkyoAmkF/im025IxjCaxrMzbOY605xRR79++oqP2RR8++/l8BW3FESwbFECxEFoee1dXew+AAfEne+Vd3d3V3WzrCzeCEkd0QjH7vN9PczRIABCRIogAPICCCNBEKiGW28vucnkWPmZJMgaZIOEJMg6hCOsDGEmubwZxxwcOGYc5mGGZpjmBlcg2VcG0wGuuOi5FFGONjg1IMjapymSOA222xuNUwjj9u5ASSPPWHOe7ffd73veIAKABsQNoBtiQHIA8ggt5z3nIak5hkAhJBhIMTBzmYzDOYBnDnMZjMcwBgIyAkWRIEkI/IRcDOW3y/XMNZmNTo4BYy5QmoxphVdd5mKm7psVNtSopUGqllVUipoqSnRVCkklVQMdVd0EB1RTHUdWURNDbabbbBNAxsprsixomMi2SSEYDbNINtt3CNsGrGxxLLKUTbynLMitoxyRsugdVG1INiG40pcRIMQ6Ch1RQ3UgUNu3bpwcQNjbasicZdXY43VRlSDqQsY6mZBjbLuNiVJ+ljQqYFwdQacJE22MZGYSU1YOoRqrQKmnesNZm5JGAhmvt33n1tttvgWJdWcuqvkkk+qov7VScm97kkd157KumvSSZ7Pe48sR49DPekm+944I6zveyTve9OCchznMzOUAtynBLC25mX628EsLfST3e94I9H6j3vST3vaI4+c5JOc5qRx859mZ9wA5zLwT4Ek3GSOArIIoHM43Lq2axzZm445znDjTZzFzdMYwd7UJThRLlDbYxqmMaIDTaI3GcY5g1vDOAYZzDMOGY4OAczNc1zMcHM1nxm7ueMzgYYT1od6jmlzVRtKtqLYlOmnOcdYqnWOuuSkubrW0KvWRxqR2ymythHNYbMpTloW0S5iabmuVGlbQuaWyKOMG0tMy5zkNkmK2JbVK2JTO+I4bFznLczlTJtK0euVKdc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Wl3aCxmbNZazMbYF5nmqKeeedPcTI/am1NqbU2ptTZTaqSXmRUuhW2iao1SlkV1uWpJgo0VsitI0KyVtErEahNFbakaK0VYVoDzRXnnXXWirrES8ylLzEk888+xXcC2wrUJftBs5jmptTam1NqbERPNCJ1FbY0VqKusVcisUi8885311555559Sp+1NqbU2ptTam1NqbU2QV5lSfiE0FaKxpLY6zjGYzNqx5nnnXXXXfWGabbNk2G2HmeeedPUzzSq5UZVZFZ+1NqbU2ptTamw25hzU2UDzdFLSrRWoNFZVYTJW1torVKdchy8885zqp1555557pD9qbU2ptTam1NqbU2psXrj3vP7d+fB879ileeciv7Nvn7YoD+7g2AipuIoHkSwVWwbEEWxRfY297sHsEWd73vbzt5YHR1JJMq7umlTdUB9Rd3gE50t0ignOc0nOqLhY2nbba8EXkaTfUSSSEAAAbSTQAAAJJsNd73vfURTvedEOxUA/ALPYisinnnnOdLrRXnnnnn33Tam1NqbU2ptTam1NlVeYS5pSNoh+15orzzvp1gOsVXmVJ5lK8855qp+x+zmptTam1NqbU2ptTaKjiKxV5qOSXTzzznfXXrzzzzz97ptTam1NqbU2ptTahzOXcmX5b5u222d5zDnMOcw5mGRnN1NqbU2psXIredPPPPXXXOt555559902ptTam1NqbU2ptTan7jzzvkV553znnnnnn79Tam1NqbU2ptTZfucpsBzapabedPO+6HnnfXWdeeeeefvlNqbU2ptTam1NqbU2kXnH79+55115555598ptTam1Nk33icycxzU2Tc5KbedPPPOc555555+++cTmcxzFsmybnFTnOJzUMzhzOXctu7ttt9mcxd5mZzd3OZrnMC2TZNzkpznE5qaULzetL+wiyCCmteoGa733vec5z9LFFstwEurDxQJJ2akkMqqu8yZ5VVdg9qicAM73verqruTGcqqCe5VXVC6uq4k73u6q6q773qR0AAA387NbySfAI6ZmAATSa1pNa0mtaTWrjfNzDmptTam1POPPPXqh5331155555++U2ptTam1NqbU2ptTZXmHe9z9rX79z9+/d2pIpIpIpIpIpIoc5hmdZrnMu5bd3bbb7Ocw5zDnMOcJFJFJFJFJFJEe4d73Mzve97zqm1NqbU2ptTam1NqbU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Fd8xOnbbKSaJoGIm5vVt5y84ARBZIcFQoqsSEESa0atttoK/DLdW22+vEFly6vOc5nFTh8omKisQgIsBGCCx4iOJiomsmtct+t9NW3eUt+ur9eXV9stvoHCJBgEEGQVYlQWBi4ghiYqBkury230W3Wuc5znu9+in0QkRCBAU5lzV99tvqqFGjZC1VorL+cKuc1jSNsMCDGAA4KhiCYbjmjP9Xut97eX09iKsRJGNwXBwjiOZw1znbb7xggQsui2230pcBggsQCEISOCGYETMt3Lbb6UgQZBRYtggpEiBmXm7ltt+BBaIsRiCwIQVWCLBSCLhjMv1uW3hyKC1NmCrg6EWJmX3dt3y+jxgIty+bsm55NpJKSc5JJPe1ptmGAAEbXdTUA7V1d9ptwAKkknskeaAOmwHw4A+GuG09k3PpyRGnwarYOHY2+aDoigSSSpJARoB9JuSSeajg4B6HgPAehwDKurvMzYGdNAEc12TFzkkFo2egT3oefYvfffRB0JMJJJPpCAAHoGtxSSSdgNttKa1ptN609LQH+DV80VdZGbZI2r7vv7nclrTT1pXW/PPbbURySSSQ5AA9Bkma185Mkk+ZGAAAkvgNkkkU3JIB8D9AOSSRSSQAB916HA80fJtt++Yk+abbfum2klzSbzSnec99706C4AB6A459YPWuZ3NJzWxbNZLPzOG9NJZpoA6dBL6BsADJPu9773viZIcAAMACT6SdmpAANHQwELbaSnY3637Vve96Aj8QeQUUwWcwel77vzeYV6HgzMpmszMrMxckkkme787mmn1++uXiBRFiKjEFiK9oEJgGjYAETX2taaWtNa0PDZsAAYfd13veznO6ttt94EOZy5rdtt8OqceYAhgC70uTPOABOmuemwPPZO973vSSHngAj30SaXok0htJbMw8AEfY2kiCADvgAZ4fd13vve96AACkkk9TY169NtvTSu/a5dXXmZnnPcrucx8PqHAJd1dyVJJIAGdvl3V3ry7q71VzM3zH3XtVJOdJJD5JAbAAPkBsAD1rG03pyTcknYL6fbaSS7xZpoXhv0AjkkAA9NAbADxpabTfe953ve9AAAA1JPpMk61V1d/DvhxAOm57ck5JIfXQ4SSESTelzPdvE00+5p60jYenQiOhnDMzM+qqHA8N1Q4bN3dVRurocA+seUD0OAfDgk9qSckgADL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9iX7SBncAXsQEewFQbBFb3AA727QjA6GwAU9kkk++O973O9A2T6QPjYYmBw02kj1NoA98aRpLhk05pUPukttfofefd2JyBuLv9hYBbi9zDsQ+73Xe49idgFgF7gd9BDBOwLLDd+tkCJJJtGmmzSabRpgaMSaWgAO2tNLM1mtLTzG0lmazWi7zV88bSWW22/TOsYw0C7Vy2+23vaAABd8XLbJP0AAAzuJ54mSSSfoAABNiZJJJ+gAAE2JvM5mX7zmZnltts9AAAu1NSS23tAAAu1ctsk/TDDgHRPPEySST9AAAPk97nznPtfZ79mMZmZm8wTOmj0EAHe133vd965ck7Ne5QADMzD6Tcl3UknlVV+VLq6rdbDnvrMzMzAMCSTJvn3fIiXwEN6tvn1spbbb92SSSSSSQJsTczmYv3nMzLbbZ+AAAu1dSS23tAAA7l8q2yT+gAAHo755NSSSfoAABNk1JJJ+gAAE2Td2/eczMtttn4AAC7DveySewAAC15S2yT9AAAOTene973vPNtttttttt/B5XvZgCVPy+huYbz6Zme9/d/fg2SSfSakAigDve9739UhO973ve2UtttdoeATne9798d73veySSQAZsJPp5kk8wMzMzeszMzO5rWtaAAZyN6m+crnMzKrOW3z+u5ADPBpzDNvkXflttt5kc493c3Wm45u5u3bd++eW22+95dzOZm60a0Ltu7tttvsxzK0Dl23d22232AAATZN3ZJJPYAABNk3dv3nMzLbbZ+AAAu27u2223tAAAu27888kkk70AAD77mtaw4B76AJAGAAT6TUkkknYpJA7zved77kmdkk73uZgBmGZmZmCSBme5mZmZmSSSSSSSSSYGVV3V5km7skknsAAA5Nk3dkkk9gAGGTZN3ZJJPZwAAt8t3d+feczMtttn4AAD3HL5bv3zy223tAAAuybuySSewAADk2Td2SST2AAATZN3ZJJPYAABNk3dv3nMzLbbZ+AAAu27fPLctt7QAAPP3795zznuZ73MmBsDMmZrMzMwigdMSaX33333x3q6JtIySbmu971ppYa3qADy7qq+6y6uqzPfczM9v2knkk53qSSB9VXVJufVDlD16Hl0KBlXdVWZmec88kkk96AABNk3dkkk9gAAHJsm7skknsAAAmybuySSewAACbJu7fvOZmW22z8A91u8OHDhl23fvnlttvedYxhQu27u28tt9gAAHJsm7smSSewAAD+nkm7skk/QAACZPJN3ZJJ+gAAFeeT3d81vM57qquq/fv356NgOqkkkkijQH3e9737PJzDnj4e/MDMD08FHqXV1Ukn6SdzV3VU08P37M+wAMzMw72SSSf0km7s73vf3QAAOs3vd3b85zMySSd/gAAP08k3dl5nMy232gAATZN755JJPYAAByb3u7ve97390AACZPJN3ZJJ+gYYcOs3vd3b85zMySSd/gAAJsmzzyXM5mW29oAAF2Td75JJPYAABybO7u973vf3Qa1rWta1rWtazk5We55nc5mYPtgOqkkkkigDve973JPu43wBmZmZmZm85mZmZ8k73vcySYDAkGXmZn2au6qpmeTve973ve9n2STd2SSfoAAB1m97u7fnOZmSSSz8AABdt3b5f2ZzMtt7QAALtm7skknsAAA5Nk3dne97+6AABMnkm7skk/QAGUbGbJu79+c5mZJJO/2YZn7W8ZjNYzd5zMzdaE2Td37LmczLbbMYwY5nv6+W7u2239QAAOd3vd3e973tnQAAFb/eye55/f33znt88887fqABzZgAHRTvO9+7rneikkkO973vcm5idmvq873uYEk5jMz3MzMSp37vTTaSkgAAAEkne970kkDA2cNPmZkknyffZJu7JJP0AAA6ze93dvznMzJJJ3+AAAmybu9l5zMy2+XtAAAtvz555f0knegAAYST5uzve9nsAAAknzdkkn7oAAEybnkm7t+c5mZbbe/wAAEk+bvZJJ7AAAJJ83ZeZzMknk9gAAYZNk3+88kk70sZJJJJO+8O73uRBAewAXIgiezUQWaBCghpAF5ret9t9zXeb5agvIALfMl+uwF2qkBA9gKlgiXuZvosASbQIRTAS18x+jedXL5z2XbPgQ9AXAF1moAvgCx0R+3mrgdYAlk7udzTwCTBPdpXHDPc9z1HK7xdUvj2+MNGlfIPNpcYNrHGISAbAWALvve+6AX7zffvNxBeTze87efd7222aANH333v33wD2vA+57lVd3u9VVa+EFNzPfd/d53tFRD2ILqKIuQQLYVtMtFaiyqXOUnCU4wlxqJi2jYtqltEayaxbG1ssxNrIrZGitV3rQESrq7ACrurpoAl3dGA3Lbzn3OKC8IgsVWArAFgZFaxVspG0K1kmLVUEGKCyc5y228QWkt2W23zgANg6bI0AS16k8kk887dVd3U0PPVtoewRRIiMIkAWILEFZ/O9753fe976ij2e25bbbfrZbb9yKSAiwxcVQyc+4c5zl4ChZbaW28BLAACS8+5Oc58ciKkAWAgpogZOW9NxLqqu2h8OJV1dND0PP1VdVmZmeZmZmqulXV3VUOSTs9u6qqaGwHXGwdIoAFJJJJ2aAAJJJJIAMqqu8zMzzMzM9DgHw2JJ9JqSAigHAo+AjQB2akkknw4B6HKB57JHocA+UD3e09mdPRkqrqlVV3mszMzJJJJJmACSSSSMpq7u71dVdyYkiC8iq61hC4ghnSa353vac5znOSYcMzM9ztZl+Star7fd973udzABO973veoAEkk8kkegEvV3VVlXV06iqvvvu/O/d72222204WM+yRMhIqc3DHNsubWt/bjYzWZ0G03HAkAwxkMwmTLo0wITRkRjmZjmRkbDDUJJI5JFyYyGJIyG/M8ttoAl1V2VykknvOyQ+ALlSSeNpLve9nkkNAAd+9+19998Eno9LSabSRmeZmY3JJJ9MADve97vvepdeac27PpOy6q7lVVVeqq6ua1APYPAHe973vegASSTKqXq7qrvV3d6bMzMzASSSSQemPLuqrN7zMzyc73zvfe5gLbbb99znOHIoHOKDRIgjPrbbYCFttt++BD0BeiiHEEMFD77u+8xQOT7vOdtv1uWKBbbbfkFqCy2222gLQESALGEQWS222222g3QDXQEEkkkkauqq7oAiVVXeearOZh343VXVSTAADwHoAAAAAACSSSSCNAPpl1VXee65lZmZ3MHANXdXYBAAAHDd3VUa33ve9+6AAAAFAOm6q6rz2VDnN+egDg2o+Pp53ved6kAAAAA6bl7vVVd2rV3VXeqrcOcsQ2oDVhgW337/f07O1dXc1uQHZdVd3bQfHjzJN17NzEZx85rn333H78B+C9ulbcvFbdq6VPeimwzA7QB3e+973tZ3uASTJJJjQzMzEC6s2ZM9zM5mZmRoSSY4GSfp3ve9725LmVlZnPjDAOMwczDm1tZY2jbatpmMwtlmNqXnnnnPSVOuvQefv3Sk9m2Ytq2cYOJPOgAAOUu55bu7785zMy229/gAAJsm7veySewAACbJu7LzOZlk8nsAAA5Nk3+88kknsAAAm97u73ve9/dAAAmTc8k3dvznMzLbb3+AAAmybu972SewAAHzU8k3dl5nMy2+X28OGMyjGbl8t3dttt9yqAAe/e8nOZ45uPOM5f7fn37fLbMknd5mZmOqkkkkigCu6u6qt873zvfe99UQZ5ptJC8ADwaXRJNSSSQcmNNJlXdVmszbpuaq5JiTucaHtNeqO+6u6qm3BmiAdXHK23T2THju97TDvQAAJk3PJN3b85zMy229/gAAP08k3dkkn6AAAd3vd3t5nMySeT9AAAM6nk+bskkn6AAATezdkn2d/dAAATJs/bu3+5zMy229/gAAJsm7skknsAAAmybvbzOZkk8n6AAAZ0zJ5PN3ZJJPYAADffQlZWtV8OzjbdwYVubETN58z3z3q97zYDqpJJJIoA73ve9yTMzM9zM9zPsyvRmZmszOfZmZ0273vc73qSSfgBgAASfvroc3vdJh1rWta1rWgBD3mT5PN37efMbzmZlVnlt79AAA+zyTd+SST9ADDhN7N3edrTSA2CazSAMzACAmgDMDgSLulrSZr3Da4eZu8xZpLWm0ldXVt2k/USGZwABNEhmYpWmkBsG19oDmZgAd6foSMigffsAXewFw5AF355n79+8vLZJJkkkrSaKrLdW20k7FJJJJ93vZJIiSSSTMD0MzMySTve9zvepJJJJJJMzMzMzMwBJnw5vaYfsrWr/VQue7162krq233xpEhmZ5ptJAAJr0DeZkrTSA2CTAMzAABNAGawAkTQghnm9buNpK23l02gBZgAAmiQzMkkkbV0AZmABG1vvefVJN5nOZ7nnme/v3fwHAPhsB00Ane9739JmZmZmeXdVRlXdVWZ6sEkCSSd71JJgJADofVV1Q4zMCRJAzAbZ0BNRAbyb8duNpK6d1dXSapLmAACaqoXMAAbXmp3szJJOprv33czINsAE0AZyc4XxtJW3d0mrQzMgACaqttzMAASfe9zM73ve9TU+6f3XfqoPIrSVeZQvmJ0xD164S85ytQ/v7qo8yJeaK80V7xPrLZM1o0ivMoPMuta2sbziQeeuSI8yqvNFeZVL3E203ppNW9tuW2zvve673veyd+++++++kknZqKhiV1rTttrtvVaAeoA4gAaYYAHgHiS4AEk73ve9iTTAA9Ro73vbfvAQt0AJyCA7j93mZnOK87bRqSZ3nOS8bSQBzzWtLSVoZmcADwSVQGZgARJ973Mzve971NWSZmQTYAJoAyec4XjaStt4mrQzMgACaqttzM73ve9BttzMtttB/RGILDsTCDGtmYmsbn7qlHOP37955559pJ5v2m20gNttI4VpNcTSttvbblkk773uu973sj7pppfa+0/vvPjO+i0zXNpNLDwA9F7mNpLoAwAUkaaUE7rS1dW3dqxuqrX799l1dUd8Rqj9mY+Tcn1VdVJuRsDbou595Jl3dVNVdV5qTG97Ku2ZmVaAMm9l+bSVtvE1aGTewAE1VaGZgACTkkzMkkkTUkmZkE2ACaAMm926+bSVtvE1aGTewAE1VaGZgHe9BttzMtttE5ACwTH9g/Q0TQC9Jfa84BZ22SSbggA+Awkk773uu973snfvtfffffSSd870U5JNJNIGAHQNgB9Nd+X333x0kJJO973pJIW22222TO973vfbIGZgNsAE0AZN7L82krbeJq0Mm9gAPulrT1ptJa1VbbmZbbRXSYBmYAETUkmZkqbABNAGTfnC7bSVtvE1aGTewAE1VaGZgACTkkzMkkkTX3tSTZ7q37fvmc+vn1vaABsAJ6Ngnvw158OdTtd73veiSTDdDWZWZkzMeZmZntZhJ9JOTDAkkmASSSSSd73ve9JAzMBtgAmgDJvZfm0lbbxNWhk3sABNVWhmYAAk5JMzJJJE1ADMwABNEkxZkvraSAOJqmrluI3u221NBJizJQASYBizAABNGuamkmkTu1rfOee84H3od73s3JB8Ngn0mpJISTAMZJcki6qhgShyqMzzNXV1WazRuTD09MHQAD0AkkkkkkkkkkADWgABNRGg1q3XraSt3bfU1bb3MtttqatDWgABu61pK1W61bbbUqlbbrVttomojQa0X1tJW23xNW24b3bbbU1aGZgAAkwDMwAASZr3W/ftDTTfqSTehBgg+5J4AsQWnMAXfgC+e+S+pXoVvXYrgD+7EuCtbG7/uV3ldatiEt5vL6D19bca3pfKvBrQEmouALO+d5q6Na90t7zuuTnms7J81g+WaKyQj54x8RANIjJv698973u1sWQ2mJ8BbVGJaK2RWqViRFEMEQiIrEFwwZLd2323EABqp8ige4qI4gulAy3d9tvhxBYqxRWILLbu3LbxBQNgjct3bdW8EBNLBVEigXLd222tt8LbbtUKAlt3znLaIvogsVoao19Kh7qcdRWSukaa3d9ttVBWs+QWZzX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AJMAzMAAE0AZmAACaAMzAABNW23My222poAzMC/JNK23jattzMttttTVtvN73aARNAHN72ABE1Um7bczOK3Fbd2prUrazmXz9+/fv37P2BmZmPQ4B8NpJOp3fe96BRGgJPZJySMzMysCd73JKneySQADw3oAA6SSSSSABze9gARNAGZgAAlVpvWmrbczLbbbW1rWta01aauW22iumpbdby375tJW28TXmlq01ctttqaAMzAABJhNGAACaCaMAAE0AZmBfm0lbbxNYEi1zPG0nfcb9Gk3e/fW9NXSXkaTeIxpNhjSb400y7aTduNJu35Jp3jSb+tt3b+/Y+G0knfe6013u+6ro8q0nJPx7TW6ppQOMCdnskgSdaaXe9rSb7NKyUAfgAAAFtNP11V3+5+5dVd81bbmZe221NAGZgAAkwDMwAATQBmYAAJoAzMC/NpK23ia8ttzMtttqaAMzAABJgGZgAAmgDMwAATQBmYF+SaVtvE1vXiSbzEk2rKeec8835+7zXv779+n7qSQD0OAfDYHsm+9753pT1O9y5JJjMwASV3ve96kAoAAAZmZmdzV3SQYoAZd7tttqatDMwAASYBmYAANzTMDMwAATQBmYF+bSVtvE15bbmZbbbU0AZmAAFWk9aWtJNLWMtt3dtttmVmczGMMzmYy23d222+ePMRmbEZ5555znPPPfwjzzzzv1iMzMjffO/E2iukXM4qmza3fr33z0AHsRDmvNe7AXEVMn7eeCjOZKZ4nBzGNodwbaY6Y3OxwBKCQeYCOPjEg9kQnsASrd3ee4Uz0FrKYhsO+ASukuPE22xjA41VEY0xsEkdASYAKMQlnPovg85x6+135Jfs70+5570Red0aNTk1pDMmALBE2Iod1v3fee872gIeTFAiKon0QX2W7vVEq6urDYI6AlXd3VVRvVHLb7b6CKnh5gAMMcAVs9tvv1vLKjRJVSSSQltAlNH13V1daTkn05nVFJrV+l73fe+85fdiDBUN+VBA3d1Vaurqqvn33nvnl8/hzGTDOZoHgPRdW/AqI+qhEeTnu+cznLwQGy362W3zgCyMVCCAwQhZd3zlLfeCqFUWArJbbaW8wuW2+8nIfAocne97OyZz3ypNtAeH33oEbTTaizMkk87Jy6q7aB4D0OAfDYDpqSpJJ2UAAcAd06bAcyqq7zMx96O3dVXk3MPRt4Dzsk8kk5AfDYDpoAihQJKkkkhGnw4OnnMqqu3mruqrebzMmfYzt3VV2vTzw9G3gV54rzqt7m7uqr76ck7OOgJb60gK97L750TjSAnOcrlGc8/fPlJAd+73s7705FA5zn3Oc+6e86DZklhikj+akBLzflP4fD57fe93jpICpoIKrfZ7nuev3PYkBnfVcy6571c+CbCHyyAg7vp7ue8D4ENeS8953uKB2Wcurb5bigey5kknJqfbu6qpHng2bu6qg8k1MPLuqqW3ud96duKBb9cTJrXup1EDmzAF8QWILzxQNe/e97e28UDAQuW22/CpkBHyQQIqfRQOTOb5z7ntligXQHpu7qq4fe3dVXo9jorp5wdN90sHxTh4NHvLuqrQ5PJUx95d1Va8705D4Q20zT17ttJaAOB3vzaSzzTaB9rve9+c8z1xIDj96vd9ybbSA4PnL5zmXiXSge6urfLd3iICaIAkYqF2oFuW3mr4FYt2oGrfN23LxPZdqBuX5PJNSbu6qoD5Ru7qqAdV7lXVe1nl3VVmZ3O5ysqbu6qgrxwB3Rs9DzrZeruqrne713d3VV92c7HgBRTw8i9Pj56HgAL5Mururqvqu6u6v3zWe5nku6qskz30AAlXVXbWwHZV1VXbQBu7q7AdD4cqrqpBu7qqEa9JySSeyOXdXYm6bfDyZVVdVWZzPvh5y7qqklTHx03VXVAO9N3dVXNNg+N3dVUbBPW93dVRvySTzckDpu7q74B932ScqTUkBKAy6qrydzOVnmZmbu6qvQ8OgCpPpN1V1U+k2OAfUD6qq5NySSKNB6cHw7o3d1VHod905d1dni2/eW95BFvmrbe+97FA17eezzd1k24Q05t58EVJJJI0fDmyDbqYdFve22228FRMSCqnqoQVXyKNtB9qo7Uqrq9SASqqruvquqbPB72gcYjjRxrjS+P4P59k6ymAFnkx6gXN4IL55b7f37iC9igj5FRt73YibNNJtLYbNNJsPQDYEk9kmKSSTv013ve9ADMzMzBJJJhJLq5JJfszNZnuZmZWYAAdau6qmgDLpNmk0mzTTaNNMAzi/HnNtJO27aTSuUPPOfdbVZjaW1mJ5555znPPPPPLbw5nMxjDM5mGW27u22228MzmYxi23d22225WZzMYzDOZmFtu7tv782krbfPFpaaWrbczLbba00rptattzMtttqTAMzAABNAGZgAAmgDMwL82krbeJr3c3vl0/FmLMvt1fg7J93vQPQ4dNvh9weEm6q6rqSdnfqcm0mlJJyQS2AAdAWzQaSaQAZJO997XWGZ7d1VZmZmZmZGqq6oABJJOzU1AAy73bS2pq0MzAABJgGZgAAmgDMwAATQBmYF+bSVtvE1bbk3u222pq0Ob3sACJoAu97tttqaoGZgAAkwDMwAATXfOd81vdVy9VmffZkw/YGZmY9DgHw7w4JNd73vekAV+zMzMyszDMzMzMU73vfmSYGYCNAAAfDmZmZmYAAJoAzMAAE1bbczLbbamgDMwL8k0rbeNq23Mm7bbamraZmB6AcTQYG8wACJoAzMAAEmAZmAACaJDMAAE1NNJttfaSTbbmkk0ua1pJJrfiSPfTw8NNpI6XgAcAJr0OCHw2B5J3ne96AkkkkgeA9BJJ3vf11V3MdN5mYABJJJJJJJAkMwL82krbeeLToXPN2221NW0zMD0A4mjUhmAARNEhmAACTAMzAABNAGZgAAmgDMwL82krbeJq23JvdtttTVoZmAADUB/aJPMCvMhXWJTpRoSefuIr1bXe3Arc45pzG3vF1mq81VVd1dfd73nP3nf379+A8B6HAPhsDyTvO970DpewzM8qrqsPj7gZmZmSSd73qSQAAAEkkkggDMwAATQBmYAAJoAzMAAE1bbczLbbamgDMxgACattuZjtttqaAMzGAAJq225mO222poAzMQAAmvrbeZltttTUWb2km/O4mm98yu3fvbSxNr623xK37duL20OAck/D4bAk73ve9KAAD9mHjaSADwkkjTk0k0pqc73vee9G03IQ8zSabAOJNsMAOJtNmkwAACSSULbbmWz5tJXVt2mqFzLbbbU1QvN7tAOpqAbzAABP7SZNmYAAJKIDeYAAXSdC5mW/XqTStu01bbmZbbbamrbeb3u0AiaALve7bba2u8L7ne881y/W8a73spS6tDwnZySScgAe5mZzMw3JPKq6rvfvu+/HrzyquqJPJKkkkkgBiTSA9QAw1J9998fdSaXfextNhjaS4AHoADNICQutJJu2ltvbS2283vdtAiaAMzAABJgGZgAAmgDMwAATQBmYAAJq225mW221NcAM83sL42krbtJgGd3sLbamrQzMAAEmAZmAACa753V81rflv3Oe6VvZq+u7u02+6adt2+W36nxwJJyUk8DgOzWp3ve99I8JKkkkj9mczMzMz6aki3ne973vvYJNuSQD660km7idttvrabtoeNpsAAAknyTSkwAMzAABNAGZgF62krbtNW253e7bbamrQzMAAEmAZmAACaAMzAABNAGZgAAmrbbmZbbbU0AZmAXraStu21bbmd3bbbU592e63cSvvvnE1bey56wAPPUSHgAcnW0l3U1PJJNySTvV+dmpUmczMBmAzoBmDve97dXS+++kgBs0mmwDiAAAJJ3ve53ve98qDdttzMtoFrattzMtttE0Aa0AAJqGguZbfOtpK27bXLbdatt9tqa2b3sBd1mszNazMzMVdLs3vYCrqNGgzm9gX1tJW5dNrgGtAACaLnmveniSurr7Pu++1JvWdk5zvnvvstqq8tvLb3v77PN6rVXnuZmZ5+/a/HocBJO973uwHdH6sz7MzN+dB2jMHe673ed73M+du6bgaAABtNgB4zSbaaAIm0pJk973Oxh2SYm0s1mpJ3vYkzoZmAACaAMzAABNAGZzYF8TaVt22rbda7bbbKmrlutAB8CTNhmYAAJoA1oAATURoOZmAXiTSty6SdtutW22/vym5AQgC8vQh3WGkF1nMwIw0Ec5yK42593SLrbedc1i2684K487zvfpj3iBL3pVOAJQztlN2AmTsppgCTHQMBKOOU4gSraoo31G9zLK2XnbLfHECXUGw112j3jDjTziiEP1ynUQKqlvlxgywjASatyXYcxjpjQJOt8TjsEDYCTjHAEsZz5569z6c8fZzO+9zWfvO8/YAs5l8ISQ/fU9ESMiqHc5333tvKIsJqgAGmCDEEioEEkkIgxhuADgqpEFkttvOXjQFgChIDLbbbRFpABLltttqaC20sUC+23iCwQUNXV4U6PAepdSSfSbhKvzd1V3Vr1W61VUIGgQIIoyEiqsE1LbfrWicRFgSIoyAKwFYQUGy223l34K9cKvrKtqhs0VhWtFWSv0VlVyZorRMg2EkCQACRQWAAZO9773v3bSEkBCAC+ApiKnnn9O97979biiyAiwZFFhIoiRBbnOc7b5agvEFgi3N223dqHIEQXwMBV1EBdMEEggpESQVQyAAGAxLl9t5dffqV/TVEZm0gYViWWgWRkSRkkIgsS5Jb7bctQSom+4hptY2zAmwbWtTaAD4iZCQYQEU1lvn1st4ILvKF1d61wEourupTQSVJJJCNcA+dLurvmqqr4BPirunAPQ8kkA9DgHxqSSSdjQBAAAAftZmYPk3JMHw4B6HgPAehwSeyTcn0OOmgHZUkkkCgBGtgO9NgPhwDe/uKPADnOc0AVF3VV7mZme5mZlA4B8AYm6u7vWrq93dVe8+1zPMzO5gAYz7eZme5iuzve97ncm8ADckk+muzZwD4UHoeAA73K9136t1VXf08n33uZmAA1VVVVrV1V1etXd81e9XVebB9AADve973ffut3dVTR0BYNAcIPjU737Xd9+68gyqq7979yqq7fZ9zO5qZkr2STyQAUdrve973rSNCNQuquprUkkklgD4cAADwKehlVd39mZnmZmYE3d1VSpJ7J2PQAUqrqlVdVuvaq6r0K99dGwHR3ve973XQEAcyqq75vdVdV52ueZme5nZMBQAABdVdpvbgHKq7vl3V39d1VDk++3Jy7q7+k3EdAB7JOSSQAGXVXfdXdXV1mZ57mZmegBy7q7A+HKsD4AA9JySSSAAHZJJJEaq6u+XdXYHyPe97lXVVdeZXKz773zMzAAASSSSQcu6uwPgSSSSQAAAAAA7M1sGZmwHNAEkkkA+HAJsB1ABuVei5fbcUCz61A4RQWILIRBZELltttognAFiqSKqwBYMgqshGJcttvOe++++9vt1r+a3zm0E5z9f37987bbfT6hsAt8m5J5JPZyTknerv333304D1mZmZmYAGYJdXJuTfe9eSSSSVAXmtJJu1ppW220RrSSbtAJPufXvY00aT9N2+Zm9vWm0tabVuJNJW469aVeecK6pqMGypskN555datttqTAMzAABNAGZgAAmgDMwC9bSVt2+aSttzMtvbbU1bbnN7toHU0AZmAACTAMzAABNAGZgAAmu5rSLeW8adtp8ahrCTySTkkjw2OBwE8k8qrqu/vZ2fZrPMz2quqzrNt16HKq6phPQ3VXVMzOZknnXe33MKau6qmVoDLuqpjMzMzEgkk+k72TMySWtpK27TVtuZnbbbamrq25mAARNAGZhJJG0aAMzAAiakkzMkgAmgDMw6fK6aaVt2muW25mUAE1WgDMw8AB/n00vUrbczL5baJrzTTTczpzhw/D7623gBJ5JJySScmpA2eGZnM7hPJud8/ST7MZ5mSSbkkT6SSQdkxJpaXe979979BtNySAASRSAABJ3v3331baZqgFuZlO96JqSTMyVpl62krq3E17bbnN7gAJq2hmZQASckmZkAATXjQEN7zwAE0QDeZL82kgNpokmZnak0rbbU1bbmZ2SANoDw3vCSS6apyJtZlvy+1p+37ttvYklbbb877bTgHe973vO96Tfkkne9+++HJDYACTSkEw8AOSd73vZAA7zv322ml998EkgjAPEwA8TabmmmwAAne9z777z4nffYb3uSTKusoN72/du6qszOVdBuc4Crr9mG97BVXJJvewKug3vf7MAE0AZmAXraStu01bbnd7tttqatDMwAASYBmYAANtqec+k9m873fnsmffffO/ZHAPQ8EkkkkOA8knO973dACSSRJJJIDvdd1d1Vd+++PsoZ5mZmZmZgAEkkkkN72EgmgDMwC9bSVuJq8ttzMtttTUkmZkkkiTkkzMkklE0AZmABE1JJmZJL1tJBia2AZmABamgDMwAASYBmPAABNZ96lmAbPQ6SSSTySOeCeySSQ4MzBJJJmZmZmGZmZmCSSTAl1cknne9eSSADLurvMmZvMzMAeCVV1TXo3u9gZV1mZm8WAXraSurcTU1bu5q2221NCtzeW2gdb+Ia2Ftt5UlS6tt+tu01Aw5vAAOpohvMQABE0BoAAG1FoNmaAAE1rWtNJvXTSA9qttvb9mrd0PAzPBID0Rz0Kn5mPqq6oPK7rOD6quqYb8KHlVdVhU8kk5VXVYEk757r2QbTckgAEDTabAONpIkkkaaXqmppskk+UmSSZmSSSCaAMzAL1tJW5dNq23My2221NW283vdtAiaAOb3sACJoAzMAAEmAZmAACaAMzAABNAGZgBImrbbczLbbW1POzl1vvOcSTfO/fbSzz3Yc9nbT0AD0+MzXMzEnZJJh4ZmfGmeGH3IEn4eDHsmB4Cquqm5J3vvWXdXbV3V2MzMzMSSd73qSTYP15mYb3sR+u6qrpNAGZh8BbU1bbmZQ+JiaklN7wABNEkN72AW1NUwN5gAETQFu95bbbU1ugXe9222pokmZkkoCV07bczLbbRNe5oA4ASUAD23tt3bfDs5JJP3x68JJO970B7JjwMJJJCST77775ppfffSSCTbNYk0gOGk02BttNkDjabAnG03NXWkk2AAZbZJJO9zM73veypoAzMALG0lbia3bbmZbQE1QOG94AHU1JJmZJJIk5JMzJIAJoAzMAkiakkzMkkkTVAMzALbU0AZmAFjaStxJ8DyeI00m577zz76+iX331klAqtt4re23YBBps9SuqzMzzMzHgSSd73oKAALEkkkk+++xJpfffffSfSDabDANtpsACGiOQDxtNgB0AlJJMzJ7JIVNW3d3vKAETQBmYAAJMAzMAAE0AZmBJImgAzMAsbSVuNoAz7ewAE0EmZklAEmAZmBJImpJMzJbbRPsn2qcgJ2IL5rXQF38eeALorMr5Ibbde7Tyr3l/Ks5d8vpNuxIO+138NN7s2r78v5znOfPAInzG22OgAJwtIEwAL7vM+fO/F3wAImMgCSoBBQxFdWhi61skcFbaOKnNbBOUrG1w0y5uLc4c1tmm5yiGIJICLEUDUEXLbfbbQEoCwRGRU9WW3dtt8QWIVJS3y7UC22+W223i1VISSIjFEmBEE8TRHRgg4QxUXRiAKS23627iC22nur9bb7bznDltFB8jgsQWBEQC2322tr5QQE0azdt+t9qI/e9+DvfO++d73nfEFuIL7raoBtVR3SuO2pJwlaj3y7SukqZV3r+HMyTIXdXe81V1vQ9Hz26q7PD0eUtu7bbu+Co1ERwRZCFJLffbbqxBYgtQVkBWxBcmW3225aCAEAA2aNKGoW237ll2gvAbLZ591d+S7rve9kkXK0m9NpMAPAOnjSbggOJCJAkIHMEF91d2/e2/W5baPhySSA8B4D0m52jY662A6bu6qgHQ8B6Akk7NSQHX22jwcfDj4PQ8B4SeSScnvkHvXWwPpNSSSEUACsVVXes3mZmZkzQB02Feinn3o8ejmZmZmdxvkqST32vpjz0PBYAMaumrb3dVzVVJus8r37O9zK+8qTknskx1SZJJBPfnmeeB8kgAADxKSe++d7znO9keh02SSSSQAFfe1nnu7qrtPZ79M7mACVfuq99988u7qSed72AAa97NzUk87EegPjd3VUrQAABVc73vfO96H3n0ys3n3udxJJJJj4cN/CT6TvexX2h4CXdUq6q71V3WgBbQApJJJJACVX1NuTnOc6gvmZwsve/d73oI8KS4oF+++++PYffYoFttt+tt9RD1EPUQ9RD7e9+d70HoeVV1Qek5JJBsB5V1bbbfKiFRCoh50FT7740iLn333fMxjMzMAAAFVd1dAAJJJySQ+G6q7sB19uanN3dVUknk9u7u+YoFt+vl0IvQF5EF73zfcUDMmZ7sB03V1dgOySSSQ5QHw3d1diT6dnJIAAPAegmljabkkkn3YJtJ/PTabA4AB9JkgAEkkkkG7ursjVVdUOmq3d1dgOxLtoAlNBJJJJCSSSSGXV3VUAZmq0oeum3o8888k5Jze+979qquqgPhw+G+JUk+qeyRW7bbblEWiIVERkRgwQXBxVTIyaIqB7NWXV89uW8+lt+vlt8Qb1enrhtPp5dVd97vvcfT7s++/g+878j8/TZKk061becavbbu22zySTkkk5JJ3fe9/T3cmZmZmSSSSTFgASTd1cm+97Od73skkrTSttt891pJN20ADpJQD9ly3fMzOASSb8zn35vxzM8GHMM5gG1NqTZLaz9+/d0q/aPWs1tbZqk2RbEzW1rTbaNmZrbVbUP3nKutNlstMrbWbZppts202sabNpbILa2Ja1rWlp6WlbbmZfbbbU1bd3e8oARNAGZgABdJ225mW22iaAMzAABNAGZgAAmrbbmZbbbU0AZmAACatpq5bbbU13zc1hvgG16E+mp9kkFnczObzMzDpJJPJJJJPKq6rve98VTg9qrqknJJJ5VXVQo9DlVdUI1JPK7qvtfEkgApq7qqEky7qqRdXVPJEaDYB73ua+zve9okmi42rTXt3bbbU1aGZgAAkwmjAABNBNGAACaAMzACxtJW4mrbczPrbbamrbczAABJgGZgAA+6bDZmYAAJqemGnmt/bvuk3pLTSaXntvbLaAAeo+A3mZmCfs2Dwkn5ud73v52fYfH6rzzM9GeSPQ8ZmZVXVSck73zrLursPP2tVSbtt8bTduXSabpJJJO2SSSSTs02kpJMzJJLW0lbiattzMttttTVtuZltvQxNAGZgAAkwDMwAATQBmYAAJoAzMALG0lbiattz7e7bbakrQzMAOhLxZpq5bmZbbaNrufbZp+59tJNNe+++Vq+Xzlhuhts0AcaNHxsMvlttttne9+7rne973nfs9PSdJqQ73ve97MkkkkgSSS6uqkkGVea3VXVZmZmYd73ve9l1pJNgW23LZIHxvLbbmZbbQTQBmYAAJoAzMALG0lbiattz7e7bbamrQzMAOhiaAMzAABJgGZgAAmgDMwAATQBmYAWNpK3E1bbn292221tQ79DxXT1z3nnvnqXnnnz5pa1rT9vbbbbWwNo+A8aV8tttts70PQTv33qd6kSS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TVtuZltthpNAGZgAQ0mgDMwAIaTQBmYAENJrQvuZ7mz33z18zO59mPmjYOmwH1VdU0bEaeyfffcqrqntbysmDPqq6ovckkntVdVhPNd73vEml3vZzve9++Okkk4B08A4AHQCSTUgBttJAQAzMCSQaaq00rbczLbbLptXWtJW25mW22XSbrWtaTttzMttsuk3WtW25mW22XSTunbbmZbbZdJNAGZgAAmgDMwAATQBmYAFQ1dNq23My2221Ne8iWZWry323szQB02AAD2R92fnva7luxMkuSST6HJJJJ9I5d1VA+XdVRwASSSSQe0HhuK0DtB+5zmABE1JN73uSSSJoA5vewAImpJve9ySSRNAHN72ABE6Bze9gAAk0BmYABG15ppUDMw9AB3TbWtJW25ze7eW042krpJK23Mz2222prZqtb1u3MyZM0SST6TczMzMzMzB8Pj3udne9y98yJn0uSdmpADwUegSSSSTdVdUOXJOSTDMzMzMBsB1vexJBJgGZgAAmgDMwAAbQBzelecttve6bSV0mrbczPbbbamrbeb3sACJoAzMAAEmAZmCAATXoBmYAAmhBsN73rekAcum0ldNrsuCnFvfn7zzzz9rO/tzNHZJPpNwAAPZPvX1eL66nUqTypJM9zMdNpJMkknKq6rvep7OpJJIAD1dXVDwbNFDt3vc7JKmiSc3vckk6mqAZmAAJOSTMySSRNCAMzAAE1JJmc2AF+bSV0mrbczLbbbU1bbmZbbYaTQGze8AAiaAMzAABtVJNzZ7vffr75b7Z2NEkk+k3AAA9HfvPPFbu6qvnUOqACSSSSJJJ39JhxMpPZJMaau6qgHQEaGZmZve8zMzMq7bbmZbbaVpW47d7e95bbT1tJXSTttzMttttTVtuattsNJqBmzegAOpogZoA9ASYeGZgAAmgDMwAASYBmg9AvEmldJo97Ps1zvPL82kr752/Qzu9B4Omtun7MxmZmYo9Hft+auwLdZ3e333mkB5973ve51pAd9O973t9aRVSOSSd739gmdNyDMzMzMAASfJSZMzJHQCpqJ25u73lqAImvOphhmYAQ0mhBsN6ADqaCBmPAAKqw3vYFXQa3sCrrG6zOZvXmarAvG0ldJogZVlxppW3dtTVLc+2t3P379ewTmvaSTWtj+QWIn6ILnvukEHmPMij+84eav6qNINFZFD9iVf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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
