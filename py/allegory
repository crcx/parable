#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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4/diQL3PTeZXe832xIk13Z4HQAAAu29gAAur1qqkm/fJrUm9NehZ2GwAAXfrzwOn3alSfbklV9cv7r3z3i7tuqkl1NtgsuVbewGgC191be/AAAu6qSXq/N89e++fHQKTe9gueevA50ucrVSVO61qcklVt48+cH3lVJA+OnwegAC7b2AtoAu6qSN7AIAL9bDgu9et+B07zV35rn3l+1X0kqvN+d3HfdtIpgJUAl2GNdZxoGxCWX32PnN3ksBJ3wBJ84ZXNrvO9fVXbUlx1yPYAlU949dcmLG+WgS7599M9MAS3eCEmgS9JA3t3110ruKMjASbASxvTnpU3ucOs6zO13mWAld+spq87pfeSmcoYy3sC2DLkuVUGpVddAJXdAJNTHudbF11YCV7de1+0O16+AJYAlbIDbbkWTt9eC14wbOeqm5ECW1zXoIK9fuXdck17yqqc5XgEuD97r8++pgJT2Vb6JA+bETlMyx5vt7yZKvm5nLOd96dAS7cDK43Lu+57nuucwBKelcvPaZ7mAJVyey7dv05y7O1gxAq4T289x7vhm9iSDYUpVSqqSt8eN86fWuVVQn1VJL899enS9NgF8bPQXe3ngD4PQdqIHu1u7yc57pzJOzDN5RT5EgPHnNJlcyvbft7u96WHmhBWuZdDRmSq3d9uxIIA6AAAF23sAAHaqSGwAAABfjYOt8PxEd8ysb3KzN3fbPe90tIDPPE8fJnrWvd+866DAH2jHwXbewHwegv65Kk+5vjnhfbt5ODylK5PZ743zlnMRurXnMJu8kvjM7670dpAakB7veciQHMx069VSYDoEGcxpAVkyiHrK7yjlX3pHiQFs5d150ysqFRpANZnO/du2gC7b2AADfaqSHN78HOgAABcu/JFc395N+739rfvnosu+3Xz7734W7PKqSHgdN9Nh0AC7b2AAC7qpJ688DoAAAX42DpyRqpo8BpEgOyDN2+ZROZRxrjqJAe9de3M2927b2AADtVJDYAAAAvxsHTnbk3rzySpPvNzU5x5707dp7ftVJNJocdAAAC7b2AADslSPt++PB1YAAAvxsHTtzd1vl+PeeeuDvlVJDwOgClJ7N7Xbe3QAB2SpDYDpsAAF+Ng6Xer+1558356Lt953fnlVJLa+cOgAABdt7AAB2SpPDwOgAABfjYOl9l73I354BuqkgDoAOc6+981rXn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w71UmGhzzwVnPwrnpGngryK+iusK/fvyL8i8vRXgrlXgrgr26xGZoIXeNLoAklnZd83vvb5ISA17u6HKqSfX9569eurOmwAAfcHnoAA5VSQeAAAAH3J7VSTXo94XYANVUkALAB8HoAA5B4AAHKqSDwAAOVLSt8qpVanaqVW6qVXffnHe6883505oegABJUgAABsB0ADnw9fAACVVSp3vJW67VST0959wABsB0ADltPAAAuqkjQAAGwHQAOXqVFVKrz2amtSSq1JKq6qVXPeO/HbABuqkgDoAAAd6a+nn2+fS6kq/PfuVUk72/AAAADup3VVKq5Kqtz1596FgA1VSQAsAGwHQAAA3weDoAAAeamr3UuqklvfPDo72qknp76OgAbAdOmwAAdhsAAHaqSGwAPpf3vKqVW+eccHdHgAAJKkAAANgOgAd4ePQAAAHIPAN3Jyqkm3h8dAAADfTYdAAuS6qSN7AAAAM74eB1lzyqlU2Dp3yqkh4HQAG/Nebv1sOgAAAAGgC0AC7898tJKrkqtz77365pfdc9l6pWxXLrrwV596fBXgrtPEXa9yvJVa81JKru9pz3u59t477C2ugAA7JdVNe6rbWw6brupw9enS5L93epvrz7586brzWgOdNy97jwHTs57/hb93zN+Z3Mu8AC6vW31VJNa93u9/evToAFtAFtAFtAFtAFtA39PfPPPfJtt4825viNvPvO83662d5PdPt1KnnPp5VST3e+96FymgAAO21sAAFyXqqkjWwAAbAdAA34Bzp2GtbAcuvdfVUkbfHOgAbAdAA7DYAAOdqpIb8AACABe9vAAAL22HnnnhbX3dzffvKqSHPuF2+6beg8A4IAAAX82Pg8A4O19VSS2vD4AA6bAfB6D0HwABdt7AABz376dqpIb453p2SpNHgC2gCAB02AAC00ATzzzxJUgAtoAgAc7JrUqqk3KqqrdVMfLyK57c/RiVniK8vvDvycnsVy4tFccUlvsJdmO/O1zl711alHMbFHz5/Ece8Laiul0pXnLxK0dRXa97c+Z3dM5tDp6C9qPajNqo9HPUj3gl79PunZ8qOfaj97an4F8yJ5J8mwTvv3jnNnNtkrOEO/kV7w8ivrPO+kV1kVzMK77YVoB3cmOtyfonkDu17+6nx3Fe8UkYUW/YQccqAqRqBK10V7jY2Nj6fnhV139+72J5F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kS/aAPNCEvNCPNJJC60hD33vd7vPenve3Tjveru/JKk7qXd3d2kqRJJJUjd3d3+9I9nvvIdYiHuq91Pfee734Ruz3vdPNCSS9gIJ5gALzSQCW7m7rrVSqNgcAGgPqqqkkaakqqlWjXmtbN72C5UaG97BcqNVKkG97BckaG978B9JGoN72C5UaaPN7BcqNDe9guqjQ3vYLkpob3sFyo0N72C6qVVSpGqkqq9Yh30lcpDnOUO++CDvv+6lVd9/eoHepfdA+59xRffv3+9asLvnLvd3Ycdne9373u13y7u7qpVVYHtVJHTe33tVJVAsVKu93d37034D57JUg+ODclSNNRqB6Bo+lVKlA19UqTdt72C5UaG/PPAdlRqDe9guVGmjzewXKjQ3vYLkpob3sFyo0N72C5UaG97BdVGhvewXKjUqpBvzzwHZKke9cCvuqrvA7y96k66oJ17ypLGCA3dpG7NaEhbsS1msAEjWbq/dXd31euXe+9Xdne973vevvLu/e3q5UlSwBUfPKjUkkpqmp83UqQLu+1V3upKrupKkrupUlUu7u3QAAGgPpJJIWa+2b3vwH0qNNHm9guVGh5554C5UaHnnngLlRob3sFyU0N72C5UaG97BcpqVUg3vYLlRob888B2VGhvewXJUXfcpJIph1iQeY2kkssq85xobNgkkkd72hIAOvu7RuxCEre7A3ZrQJcL91d3fe26bu+Xdne973vF3d3d3UlVYAHlSqlAcLu/qqVUl3c8lSqvVSVV6lSVQDoAD2SUD7TYOVJKkoH29bN72C5UaG97BcqNVKkG97BcqNQb3ugXKjQ3vdAuSmhve4C5U42e72C5UuNnu9guqjV23sFyo1dt7HDclVKn7BXvfBLmWjbFW667h3IO9UD3Ep7896e6o9xUXuEq91UC90kXuBXuVPdIT3JIQLWIFrQIDdm7ABD3d33vc96d6u7c5vnOcOXd3d3Vru7u7kvUqSqvQ8gF33vb73calSVV3d24AAA0B9KpqNVJJJUvUtubN7BcqW2e72C6qmmjzewXJTV6t5sFypcbPd7BcqNVKku297BdSo0N+eeA7KjQ3vYLkpob3sFyo0N72C6qqrzVVKrW5UeA+q23HkqpU3o8PqqVQPtBd3y733th7znOc5bUlSKlSAfOtVUkaB229VUkNgDV37d357JUnOr9u7B4By7u7u71aD03VSUs17N6kqQ83sFyVGoN72C5UaG97BdVA3754DtVGhvewXKga0BVS25s1oFyoGtD4VUem97Akpob3sFypeueSnklVVJtpANAle7zd4t2IEtZu7WtCDWClUD7QB03YH3Oc5x3R32Hg4qF3d3fb1u3tSVGoF/CpQPi2t1JVegdAPnjVVJL9u7+u9WAvps3vYLlRoa0OG5UuRubN72C5Uum9m5vYLqpcjezc3sFypdRvZub2C6qNDWgXKjUG5Kk3sFyo1Q3vYLlRqhvewXKklaqTUD3Skr3HvvEVXvz33tRHuu/eAV8yDNFe++9Cl3qiPcSqkgPpJNAHTd3d3b7mubrnOcN8u77erkklgA+8jUqSqNvjklSG773tdu73VSpUBqHfJKkagehd3d3d/Sx7H1VKqqFvq2b3sFyo1RpvQLlRoa0C5UvU03s1oFymoNaBcqNQa0C5Uag1oFyo1BvewXKjUG97BcqNQb3sF1T9+4K2Sv2Svm77d+9oqXfffUq9de1GqaqSSSNG5VNNSSSA+0AdNgOfc1znOF3d3f13KqpZAu7vbVVKlRqpUkqAL73vZcvV2AABdgHQ+qpKlRqqqSoW9mze9guVGoN72C5Uag3vYLlRqDe9guVGoN72C5Uag3vYLlRqDe9guVGoN72C5Uag3vYPCNZu7JN3d3wCDXTQJU0hC6/jPFcRmzZqdN/k3N1VhXGZ2i250AlTGbQAl+AErz7PfjfAJPp9973ub0SR5Al+LqgEmewBL3vxheAcO2UcYU0RloSTKat8JCmcZHx2zjbtoq3AdEUZaBAIScbbauTGsaKGWw+sh8iuWts0W1SOd682zZsddfenjNp1rzdZmO9R1jvHey6xc7BKgEoM/FfXYxtC6mrdPWS5E3c66WbN2h73xKmG02a22pdu+vPvY7hTDHScY5HEgRAggpqP8ODQc3LxjZ97He6jrojvQV1+dCudEgUX4iRXl5Qn4spfiQW+KKLaL7ArPxL59J76R/cznD7i+AEIbSEutEYNoEvr4/vG3yfBXTJWpWQYFoSYJNoEh/JAWHN6fWfc3RCS0uBM/vu+/PX37xS+/UiyGyGSrW533zd3ZvkCWpCExtACYhJnd3d33RILmru7BKlVcSSSTc+qVrf078eeL4VUk7pzr56LlSVKjQAqSJqSpqVVqVkrGbCsK2xU297fv3793+/KV+NSpmhMzFjTVFg8kJSVW7u7vdNASaQl9ABLxznOYiNtrYtUtTCMpZRqC1VWpGlGGhZtNmsmY0sFpDJMitorAbTN/fd++3d0NaSAYITQ2AJF3d3c3d3v5333U+wbJF3uao24ScskrVVVVU1rcAEqVKmpKqpU1bQF0UnuJWMmJWYkssim2s1tpttLUk1KNU2ANprEbNLMW2mlmzMWGBZNFaiVvvvvPfffffT2iyVhWSsits2TCttiWSTIWh7pSNgrKjSU596/c/fv378B+FaozDRW0tmhl9UaKcUTRW2bW0tqJMGJW+de++9+++/hXuxVsYK6mpJJJvXoPrXElSq1JVSamvAOLoS7soya1tW253333333/ffyvwKt6zMzMzPbrukePgVVSXpuAOweaA6X42Xd39d35Y52qkh3z09ng7KqXr67u7sHDdVJGmv8eZmZmYy5JVW3rYC0Bd3dy7uwW0Bwt7sBweByqkmzj6/L7d37dj4PAfXd7u7uzvv7M1mZzMzNWETVVJBkkqmwakqT4zzFVJM1mXmbkqTPNlSpTuZfvZrTaSy+6MNCTS1y7O9C20lpGaD7e3uxIDd31/BG036NoSA10wEmxqvfYW7r7IkA6+uabp6z21U7sSA3777dFZtdz7K5Ru20lquGdquL1S20ldeyHKzS37fFr620kd71eIe5zWhFNpIDudzKbSXsqkmlmZh5tJYrDe/BvTaS3QG8+yvsy0mlm7zBZrPjQWk0gsABVXM3vTaSxZms7W/XVJeSTdPLzejttpI8BnxZYXQ/vP31HGhvnDm2WyTbauYTwIDbY2kxhRBwcjcYYEIFNEmy2M2rY2j+3TnFHMdaRtHMWyja2nNRuccY5ea664zM2mxjcg3ENokjUGRkYiNRpJNzp1y61zbWaLjOZONcyfeuRtHTXdq5jbZ1zNXMbYzmnGc5cIYxjbaSjI0Cg5PO8iQHe/b99934+LbSQHxdW+1Sr66rvbbSXe9DoGbADtVJMzYAzO5m6qSZrMysxlc23VSQvPszNZwLbSQGjEmly0m2aDRTaS+zNs97099EgN3a3Vp9NWX9JX3X9yDxIBpAMqt7y/VzsfvXSQHK+3u7jR5pNo53l/uevuoefHvnvtJOIrSJorUaa6WmmtBfCkmkBw8kknlUvU3VVdoiQEEEubPZsBBucpIDnRFdc+d1yd+8abSWVfD3j8p9zl9kttJSXyQWgvgW2kgPt10T/EFXJ9etyTbaS7J6/by8zPvbwPg6Lnvmo8BZoh9U9lHKqSPmndfPV+3f3b+uzh69HzRXkqXUqT26R18d9qPf8Yp5zjCvsV5FapNAkwAX0QJQSRneX6859EgO3m/Xma607fW+m7X5d3dSSSr+uwJJJVJJVaqSVWtVVSq0g0fLu/ddl3ds9qpJmYB8AAGZgAB8V8INnBBoK6B9zaw9OenPtazHZ84DuZngFyqq7w4PAF9vN8HjbN5nlVJBz4W+Lu7u7u/R03VSTnuwcXd+T6ZUlVckqtNvY5mZgALu7u7uwADzve+d13vQaqpI6btqI1VSSzwH2gH2+iQG7K3a3b9z3u52fRIzeZe262B8Q+9dz3ub+fHzl/feeW8qVN1UkO86i3z9rMzMzes3VSTMDnHT3w73RueGjdVJElSfDxrl3d1L1VSpJNXd2Cdhu2nx77J7VNIXgGZBu+de++++/ff8IXvxEb+REMYI+aUYX36kvrggSMY5L/BWn+DdZX+pnrvvokvgD1qqTzCFeaqPmErzzlD/Du9Uv8P6q5F+xC/ZR+/cgP2SKv2kF+1VVKkmY8prQB02A5zO975KlTupJJO5nlAclSUVVVUpgAblZqJtNlNlILTRRTSKabYW2kszM7ztJpvtJNJs973gPAAANJsMzMzM9XqPfenvvPlJV7x71KTj+EP86GpWUY1ohlHnAuKNLErFKvWkbhJcVKxJaR5lHnnr116VK609ZVTzKpeYh5r3ZS1rWtmzeedSP2LaXrUrmq3OJzFsmyc1Dmcyc5xOaQXMUHmVSuYlDKMlDrKWxAc2FYiqmitCrKNrJV5hXnnXOqqldYpJ+wql+0P37iId6W0u8Vc1W5zY5pbFsW1NpbUEnmIdSjzkScVYxTQmlGlFlGplGr1qXFGouccCqyjzzzrrr1Ieso9ZR55556ivalmFZK2bUPcm5ynMm1Ni2TZNk5zicxHNBHKgw/tJR1qS2QOorKVhWf379znSS6wVeaDzRJ5551VVfv3E5qbU2psWybXNbUOZNzicyovrEJ1Ff45xFZSO8UbQeeec51UdZE/tSTzEl5550If1KMiwW1o/smyc1DmTnOJsWybJsnOcTc4opeaQ4SWkirKMVVNQaqmCWQmiZorrhSNkVS8wV5zceYR+1I/fv3RSp77xNg2Tm5qbJzUOaTc4nMWybQPuFf2u++chahzUoKq/opNyc02kwtJpXSSpJ3aaqk2qoWyq2lzUDzJHVpFeee+c6rzEv7zijzzz96lv3JbnJbFtLaOc4nOcTjnC2gvuUV1FYhZRgleaoLmqVL1uIWalba0oyKyjQawOZUq4o0RaowpXnm3A8yR5iS8886QO9TaW1Nu9W5wti2LYti2oP7VFT9olelGop6sir9+24i+YoP379+9Sq7UYqa0jKNUl3i2LYti2LYti2LYtoRlS+f3FL7/jlUfWH3PuBLT559+9qrxSrzQHmoV5hX3VVX37yUl9yKv8aV/jCv4K+4VwCP7AV1qE/aSX7CqV1oSfsKJFJpppFJtpFJNpsrKxZmZmYJJsMKAAz74bSXe2k0u9ttdBppaRSDTckzMxckqs32SpNVUkrNgSVIZJUmikUtUttppotGkUikUuFoLzMzzbavl3upKrAx2gDJJVZhuASU7qgA4FtpJLw2003Ekk6bapU0lKYE4o0k2yrbNUYyjRXecsqAyVojZjG2ispK8825BPMD1WqNtpbMWIttol5SvOQVeeedUpPkjEL9i2LYti2LYtlzcxbFtIKxbijQPNQcUakKao2wiyrKhbKSlqjRSmUaqqvPNzmKnmpF5vMR55y++c5pQ2kU/aIXK0ZRiTKMqWUbzVVXMZq1rKNSrLEjUMXmkeddc6jzFVemKM22yVmtpBMYIiQQhjJKyTMtvmTJmTrFsWxbFsWxbFsWxbRKeaQbzr76I2pJ55t516bbecpR55536vmnMWxbFsWxbFsWw2gpyKzRWq0VgTQrLKNgtZRtKNKMoxaJlJorEGhlf2klLhGUOsJRfsVX7m4UX7VR+yFX79+6ndRilV3i2LYthtTam1NqbU2lQcygsKzRWSS/sgXBWoi2g1RsoyCZVkp1iuKmK2MK02rNsrIrUbDRMtWyjImSsFLKWJVlGyjWUbCq/cFfubhJftLu0FjM2ay1mY2yF/aop/f3908iZHuptTamxzOamxbFsWxbUpJ+1UJ1UbaJqjBVZFdblqSYKNFbIrSNCslbRKxGoTRW2pGitFWFaA/tI/c5zCP2qQv2pJfv376o9KqbaoxUneLYti2LYti2ptTamyET+yRTqK2xqjKh1qHFGolP37dc/eeeeedyF+xbFsWxbFsW1W3eq5hsgr/GVJ0QmgrRWNKYSeJyJESIhmJNTec5vzxJEZG2tpbVbarzXnnnV7WvMg4K1DSjX7FsWxbFsWxbFsWxbRVXm6omQyjFVlGg1S0jZtlGEXXFXHnm3BeeeeeefCVfsWxbFsWxbFsWxbFtTXN/fvXnoimxGKvPOlHzPPPOgHnnJ3lVVd5d6B3SeU0mm8ptN5TzA2kyk03QAAJJsMKAAz6/vvvtjTa7Qi0UjMzOLMbeYY8zPe8vGkm02spJPMzTWDabtFIBpgG8eZlNJvFzMzAMAAAbSYbSaQAHwJJsAA4002gBNIptpJRJG+ZDYvPNuTzKPPPPPO/l+1cxbFsWxbFsWxbFtA81ScyJWylXmeso865c0HmoPNCXmrzznmC/Yti2LYti2LYti2LZQr9KNQ8xXEnV55uuee/PPPPP3wti2Lad84WxbFsyGZDJm8nk35vG7u7t7mQzIZkMyBbFsWxbFtT8o3nV5565znm888887+FsWxbFsWxbK2vNOYti85deeuKPOt555555+/FsWxbFsWxbFsWxbVVfthMtvOrz16Km+c4m7u7t+5kMyGZDMhMi8mTiZOUldNqqTVXbTaqm02rQVuwAM8OqV4tqbS2luchc5yXMW1Npecm6bu7u3qZG8ySZznJk4zISYTITI5zJmTnOTJxMxLS223vUyEyEyBv1yrmLaLaLRI/sUXm8889/v378NNVUqmjclSpQeoALaDMEk2d1pJN973vOJd6G9e973veDz97w0nQeZ7JmpMzM7ySpDfe95fe7kqSqXd2d9kqQHw8eg7w+D0MzJma1mZn799/KrYti2LYti2LYtd9+eirrrn79+/fv37+LYti2LYti2LJUnGZCZiW3n555b9tt+ZkMyGZDMhmQzIZkMyGZDMm8m0ttt/PbmTYti2LYti2LYti2T9y/fj8ttvtmbzmZDMhmQzIZkMyGZAti85eebeeeeeeffxbFsWxbFsWxbFsWxfuX7957pXXXHmvNeeceZefuFsWxbK2v2nMWxbFsWyecvPPXPfXnnnnnn78WxbFsWxbFmZDMhmQzJvJtLbbfbmQzIZkMyGZDMhmQk1OMyGTN5N03d3d9uLYti2LYti2LYti2L7dyt3alkzhygEI+YkCEhsQlbEhF4V61SJ8yj+1VP2/Z+yhd4BXffAp3qK71JXeFR3lVU1KlQ3KlVJGqqSTQAtoBzfMklV3vfvZJJO5l+wBKlVTN1JVZdXft3u73K43JJKPTJUkzN5d2lRySVV+XTSb9STSbMzMBJNngAA2GwDodAAA4m20kUmmymk22BpBu7A4B36LYti2LYti2LYti2K8lu/mTJPHm7vyb93yaqSAfHB/I5wDzIn8eT+P4fnP4/j+P4/j+O6AABvJtLbbfaAABl5LS2232gAAXktLbbfaAABl5LfmazMk8TPN5mpu75M28AAAyWb5N185u7u73QHeOchCEam6bu7u+zURDQM3k3Td3d32gADbaVH9iRdYVc0T9oRV+/cih3gB/f390qR/a93uqF7or33ge6FF7oVe+8ivf7+dRDJmZn1VUmZj22gHN85ndd1JKr7VdzBmZ7yaaa8ZmPMwBILSZSSbZSbbRTSC2CSbtFIMzOZ299ptJW2mmu3aTqqmX5d46AAAA+qpUbeVVdZbyWlvbb7QAAMvJbv5JknieN3k3d8zVAAATeS1vN3fd3b8AAA3k2lttvthDAMvJaW22+0AAC8lpbbb7QAALyW7+Zkk8ebzd3dv6AABvJa3m7u7vdAAA3k2lttvtAAAy8lpbbb7Q+84222222iF9+fOoSuuuu0r+8SSv7+4VB+0gn7+96vf73oJPfeRCd6VO8Cu9Ine71Fd98oiNVJVaAFtAZJUmd877JKrve/e1VdtJpA00rW6wAO55pNl+ptpum0kPbeT7UqVKl9RmSS3zJ4kyZJlZUrMzC773tSpLkqSVL1epUlVepUkqgHQXd3d3dg2DlSpKkjUakkqp7/I3fk3Td3d32gAAXkt/j8zJJ55u7u7egAAbyWt5m7u7vdAAA3k2mW22+0AADLyWmW22+0AAC8lplt+23vwAAC8lu/mZJPPJu7+bvfAAAfd3yX4Td3d339G8jOM4nCc5mZJzjheS1bbfvQIyVzol8lltt/fRtttttttvP3UieaiT+yH9pJefzhLmFKvNf3nFHn370FXmUVeZKV3pUO8o71A7yVXelVGpUlU1B4gAtoBzfOc5n2qqSv1/p++weru/z8W+2I+ZmYCpQe3f13Pr9uwC7u7u7sZmZmZn0rNSqrKmZMy2+Szve97++gAAe8nu/MyScd7yd729/AAAO3yXTJknzd3d3ugAAd835Nny2299oAAE4vks73ve9vtAAA8vkv4ttvfaAAB3xyS/JfnzWZJPN5rd3zJNvACEJxN8ndbu7u7tAABzfJdJMkttvfaAABOJfJaW22+0AADnJJmX94+8/JiC8tS0kJC+Yj76JCFle++wEAjdgVJVR15GjclNSH3iD2fB9eZvMzMy5JVZ3ve972u9zNg6bZmADypKjVZmeSZqNVHZKkVq7vve9Xd2PWqqSAD2SpLu/qq9Rw9B9JUqVBmfTMi2232gAAcvk7d/cySebvkm7vmqAAAl85k5vyX585u7u7toAAfPnnnxvkurbbfaAABxJb8l4ttt9oAAHL5O1bbe+0AADnZy/Jfm/mZJPGtT5u78nzeUAABzfJdP3d3dvdHvHOYRnETzfJum7u732VoAB4zfJu/Oc3d3b3oAAHOe9587yd/eZk+SZkfnz57+P3yiPnzgj5lI9/v3V+74o7xVUqG6kgHKaQAW0A5znOcyu5j1FtPpUqiSUzMF3d8u88DhN3d973q7uwC7AOgD6qlSQ7b+S0ttt9oAAHF8lu/mZJPPN3d3b0AADjfJabu7u+0AADZvk3zeLbb7QAAMvJ23i35bfaAAB+TMi+S0ttv3oAAE7yd7v5mSTzy2299AAAl5O9Lbbd7oAAE3k3S/ltt7+gAAZLyWlttvtAACPz77PH2zMqEd5kyZOEkzBhWkjIbMUm+cQWyqtm64hzKOsUc97kjrnL3756qNI/YD3nXrlDYRerXQyjUJMEkxvHE0wEmwuRdIdpEa6VON0XKvnqEvenekQJZM59nucrrbqMnGqd0wEtoqgEoFU4DtXJXI5bCq9Mb3BVRF2pJE5I9siKajBIJbP93+n5VyJd7AEHfP8u/jx+WVd338mkrYgBedW2xwp8AK2+X2+7EgO79p4pCajGxgiKK9Er508SrzJXcVuRHaK75iUWNsSEih0CaQW73d9ntnQBoEm89VHqqtMyTqhzbp1777777+KrsrR4Xd/V2pKrV7vy5YbVKiXVSpuqQytSNSaUZ2k4uCXXN5fqSpN35tfr6DwDg84PDkkuaqaZZRmlNoMu1GrhxSuVN1VSTegCVQ99Bz33kqpeqk1qpRjFPee869+fOvffeqo9VGyFqrRWX5wq5zWNI2yxlrArTbStpNWt071f6jWwDDq7TTbdNNVTpfQSgoNRCk0rd3d3nkxANeh73ve9w02AmIEmgBjGNqCCQGiTdt7u7vDRgxNiQk0tYAkNDQEm+17u797lR3IyZRq1oGkaLSEoROb292t3dNaQJeRZBJKCoQk6m9uej23JV1qVJVNvvQ+ckkg99By/1SqrTMzMzMVU1e2gHZUquxt54BwQDge6Lu7vl3ux6FubF3d3d3YAABqXJKrxtsO26aC7vty7uwEAeFtHAdNh4PF7u71d39Y9sPQ9u7vy7uzmRpsCwADueyszeb1nhB48YHg5219998IPBldK973vd8GABsPtgwv3yDwHg/ArvbEbNZVV/jY/sodYrZNNKqdU14vTTVU06pStTn0hnllZmZmQDnNmZnx1/ZVLV7V973fTqzGaAAASXcAJeMzMzMyuZmeAQZmZmZlXrmfvX7FX379+wPnzlP2B/YVXrRzXz29/fYHgWwAPmNNLPNrypJLdO6Q1TmTjCTCMTJiWJyTxkk4mLbfb7al0DQAV7v3a737p8mYGwACweZmZ3MwKAACjx7TaS1fve759zA0AAm0n1Un6k2m1abr1piw+3wAFwzM2AAsNZmZPg9BmZn2/em3HO32pJcqVWpVRANAk0JL7wDHAKe1u79994F1tobqa1lbzzPMzMuru7u7vM4PAOXJqXu2/PfQcmVKU3JKk3JKrzU9zf3uZmYvNcHgYPg9Z99mOSq57Ur2pWVK+y7zM2BHd1UkMmZmZd51ypXdufPuPjPMzMzAAFnfkkvk2lrnLzBq3Tbb8+a3ozA9rmQ8ODkHg9N1UkXKlU14AA0bqpIzlbqpVa9qpValdN+dO3nJHTeszMw6kgNAAHV8Bs4AfNW2m6eZmszMwX3vtNJJd2rprFzNc+5mW2kgHoAAD4oDQAHzSttN5mbzMz2AABmV67u7vLalSq4PAs9N1UkHg5Q8A5UHhy73leX95W5Uld3qtajzlVJPGnOltpLD3UcDYc4FtpIPJL7dZrMzPszsnh54BzsqaPEaqpJd39V3fnbaHH1VJD16HB4ByDwAXd3d5JckqtVUlceMz6ZmYAN3d3d8uzYEdB4BwA2AL+qV2VJVaqr9JLQ5myWisBtPIrcZsRTQAKA5PV7293eJC3dy93dza4ISN3a3ebu/HfMnvReZ8P5oy8RWYIOwFJ3zupKlTnczL5KlSoHskB9IgAtogOc5znOaMgL95KqFUzOC7u78qSqvA4y7u/ald73MGZoBd5tmZmYeBAbSaQAHwkCCLjpUlVJ1RtbI2VtS2VWybS2G1FtApM0Ntg2ZmwZjMTZsts1tDbZmGYzVNnXnN3d+/kxGGZMzJu8yVgAfMMSRIkhEZMhJN8m78/GZJHnm7u7vaAAAm8lpu7u7u0AABN5N0tttvQAAGXktLbbb0AABeS0tttvQAAF5Ld/MySeebvzdvk6ABOjm75JKr6SSTKqkqp9u06p3Tu7tXbaSu6stWltt76CMlcMvJaW27t6AG22222AldE8wEm4Gm848tHzIkIb7yH3x760hL7YkkIN3aAEa0CW7uvomo0bqpI1KqDM+ZrMzMxznOc5iXv50JBKr6/qBBtG1uzdkbQkvHdQgsob+2sOe9FXQQZXuQv0BCX3Ya/u/evh9vbVTx6KlSeSVUqNTus3msC4ub1bbPe973ve9mZmCVaAAPNtr2GkFUAZ3KAAB3k73fzMknnltt76AABeTvS227vdAAA3k3S2232gAAZeS0ttt9oAAF5LS2232gAAXkt38zJJ55u7u7egAAbyWl3d3d7oAAG8m6bbbfaAABl5LS2232gAAJkzJDMkknhq+3dapd1KZT2navfLnEmkny57bTT7Jn6+NAFgAQBznOc5nc80DM9xtJXAknaMz3vervpk6BrMaeZeZfe95JUmfavy7wWAAAAZmTMLbbfaAABmxib5N35PzznJmSeJrWZqbu34AAB2zfk2b+bu7vugAAS81vzzm223vQhDDLyrxbbb7QAALyrz5y223voAAE3fNbz8/GZJE85rXzeW86AAA/JrOCb81vG/m7u3ofvHOYYYRiZMl5V4ttv2pYZkkTnMySOThCXlXi27u+zdkyTnHCM5zOTnutzzNe/vff379f78GgfQTxDwDhAHOc5y+969eGZmZmZeYu7u+9uwd73vOcLu7D6SpA9NAFgAuZbV4tve/duZJHJwjHGZJOcchMsn0+oRTRjQIp/P64fSL5/NGlxICR8jOCJLyrxfy3d3s/WgAG8l1v5u7u9/QAAJ1fJfi2232gAAXk7VttvtAAAvJa+azJJ41rd3b+AAAbyd1d3d3e6AABvJdbbbfaAABmZLyrxbbb7QAAEe+e9/JJVfRvzn3OVzO9737MzBoAtAAQBznOc487sHQgADwC+rkqTySpNXd9737q/LsAPGh9JUne/ve/ne973ve97221eLbbfaAABLyrz5rMknm7u7t9AAAnY3zW8b+7u7vdAAA3mt4222+0AADLyrxb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BYBzW+TnOe/cHgjILu7vAzMzMzpvve95ne55gZmZnJKkHhmZbbbffb3vfne9773967z3ne9732gAAXld438zJJbbe/oAAGzfNbxbu7vugAAey+Ut73v70AADPee95zndkyS232gAAXlvOcttt9oAAF5bznN/MySbbb39AAA2b5u85y3d3fdAAAvLec5b3vfvQEo4ZCS8t5zl2RpSSDWU3Uu1d1dVap3au71rfjiSbKvs7d+879epP3Oc5+/Lu7vd97Y7Z0C0Ac5z7mufp3MzMwH7MzM/ZlZgH7AkqS7u+971d3YAMzMzMzMu7u7u7zPgC7sADzlpNKrtVdq6SKsLu9PlNpSsy2+fl5OoyeOAc2b83ec5+bu7vugAAXlvPnnne97330AADvO95zndzJJbfL7QAAMvLec5fttvtAAAvLec5e972+0AAC8t5zm/mZJN3d3v6AABs3zd5zm7u7vugAAXlvPnnne97330Aqqqqqqqc6Xv717++43roc+9hgkAWZmZ77t3gu+3Lu7s5znOczuZmZhq7u7szALtmZmYLXd3jgzMzMwABd3fvvvvvbJmTLbec5bkyS2+X2gAAZeW8/fPLbb7QAALzvec53ve9+9AAAs3fm7znPn7mSTd3d7+gAAfYy+W8/PPLbb7QAALzvec53cmSW3y+0AADLy3n755bbfaAABed7znO973v3oAAFl8t5zm/uZJN3d3v6AABeW8vnl3d3e6AAB885zkzfltt9ve973nbu7x2zWXmbu+XLu7vuN1Uk73ve9y7l5M1JUm8zM9wtN6qpJ8890zDyqkn3CpUh98zM+r6d753valSd96F3d3d3bjTTR9JUh8fH1Ta2g7kqpJmZnvnnmZUqTMzy+9AAAd7znO973vfejeOcwwwwiNc3ec5u7t+1EQ6AbOW85y22/egAQm873nOb+Zkkttvf3AAB3vO+ed3Jklt8vaAAA73nOd73ve+9AAAzeW85y23v3oAAFl8t5zltt+0AADvO95zne97370AADXvn7998+Xl54kyT5+1zv79wbsDtgXfbl33q/vnOcZe8zDZhQHwAGs973ue9vxizOdaaXe9ne9DM15EzM+zMgAAABmZhwptJAG/gC+ctyZJbfL7QAAKnLec5vzMkm7u7t+gAAe75u85zd3b9oAAGy+W85y22/aAABned7znO973v3oAAHed7znO3Jklt8vtAAA8vJ5bznN+Zkk3d27foAAG83eb55u7t9oAAGzfLec5bbftAAAzvO95zne97370ANa1rWta+15p6MvMwNgO2BerWjPd+9zmfffHToGuADOAAGZmXmZmYAZ3ve53vcwvLu7ySpB4ZW8zMzMy8D073v5bbec5bkyS2+X2gAAVOW85zfmZJN3d3V+gAAbzd5zfN3d32iejhISc45iROJs3zd5zd3d/Zu5kk5xwIiInV8vznLbb+9jJXALzt5y7kyTd/d+b7QAAKnL95zm/MySbu7u36AABvN3nObu7t9sIYBs3zd5y22/tAAAnpJ3ztSTd3d/H2tttttttttvznjbm5YjeTnLTRu97nuyABvRYAHgozMz3u+Xvd7nufOc5nczMzMzAC7u8BmZmJKkuXdnve8ZnigAAPYZmZmZmYFgAB460W+c5yXve9+9AAAvuS+T5fnOcm/MySbu7vf0AAC8t5zt3Mzd3fdAAA3l3nzvz5m2296AABl53vOc73ve/egAAWXy3nLflt+0AAD87yed+c5vzMkltt9/QAALzt5zu5mbu7vugAAby7y+eTbbfaAABPq+d+c5zve9796A22222399lTraBAL7sAEqyAIQ3bQJUCDwIIACWVdXv28nvV77UCXWCvfOfOfue+vBXlUxD3FTrJXW44qASbQAlb22893u+9uXzX0EHAEoAlIgSwBJ95wrJBtAJX3M32aAlnRdaJ2LCc9cqcyVkUqnXmLg0VU6NerlHewI02ISAfoAlAEs+79AEvXWT3zVSVXder+88u+3msG9gLs5znOc4bu7vvTt1k+BJcTF2djafBkkInHH8Elt69fu/39+/fYSu8o6wjmlTao2WmUYpoJzhLlIuWiXGomLaNi2qW1Q1k1i2NrZZibWRWyNFZW0PBb6VKpoAuVUqNBd32qqTcn3n379+99/e+yjuyjA1DVGrSjNQ2iVsqM0lqZCtStVUlVrXwX828upKpNBw9XJJKaPgW0v67vy+1das+D326kqqjQ9+v9+/HmSk0lmmFaK0VZ/k99fMzM+qVUrNDYDpoFtVU1qSpVMpKJJBHvtN3fb4Eg177x73vdBHmAAN+3fa93fGtCSGAkwQJFDCPd3p75a6klU044PFypUaHwe/pKkDMzMzUqJVV7qqlVVc0PHFvqqSRperu7u76aALQAEABsS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Psq9+99vkHhCWiEmIriomxK0lc5NsbYTCtFZqVjMm2azNmtzXMbTaDKNbFhW3Pv379+/f77I2sUxTEaisK02WaOjc/e++++/gNG6qSDslSk1VSSalVJJG+NDd0EAeHqQlBJDYCSG5Jz27W7vveu7l3aSSgAqqlVc1VSpXk08u7vt9qavdgNz7JJVbVpUlVk83nMzuZatalRmqKdwpc5NRLJGwrNu0nV1+AACn5pthd5mZns92vX73ve9jqpVc1UupJ9549enRKkSV3U75s++C9BAUMSBLHW7u8326VoAEECI5ugbAXaAB+lV5Kl1mbzMzuYqqqNaAJ02A4PAPg9Lvy7u7+seAcGqlUPjdVJDdgAC7u7uXdgW0C75d7u7scHgHweg9B8HgX9d3u7ux00AWgAIALB25tfh96Pbs9B873ve970AF3d3d37Zl61rd781K5NTetay8++5n2ZngHA9MzM5n0++++n2clZmZmZmY6bl3d3djZ4By7u7u7sALvy7u8klVepqpKrWZfvmZmZhu7uoQe9zqRrNaplcpWNFsbYVIRqNdLKIU0USA2x0iNpVQ1K3c53d3QFgCwALu7u7uwALu71d3dwWbzMzMdMiB8AG139d3327HsvUPNH1tX2qlSpfm7u7vhdSpJUaAXd3d3dvQfB7UqS7u/bu7yVKr7MzM+zMz3jl+X97d322wAnElSJKk3bzXngAABd3d3d2HhuqkgevSfeyVJrL1PZ9rM+vLzAABd3d329WBVSVS6qSNAewHwABuqlUF3y71VSqu7sLANm32SSq3575JUqszM5eYwABd3d3qqlVd2CwB6D4AAN1Uqi7u+Xd2ADpt6MqVJmczMzMwANTdaXd3fe3uVVSpYHSSqoD27u/bu7AANVUqru7u77YAABkkquZMzPczMzz70PnQA6ZmZmZmZgu7u7u7AAtqqku++/ruzUNmshlHajKOVoLiJykpwVaB5bnXvvvv3339VSVNtgWSADve+d7jXvMXU4+8M6toA6bAAB8d73vecXfb1d3dkAPgBfervzver+u73JUgPjYADwDgDe93d3jUkmZmXdgBhSaALuwABpr8KmlJJd3JJMlNqVVJSSXdySTJSbjVVSckl3ckkyUm41Ukl3ckkyUk5Tkku7kkmSkmgC7sGACaALuwQAJrl87WLm91M9zzLvMt3ejYOmwAAfH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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
