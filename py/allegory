#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
# BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
# BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


#def bytecode_round(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(round(stack_pop()), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
#    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack
    if type:
        return stack.pop()
    else:
        return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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O7u7uwSODuhASwQCFzSXNI7o58+7o7oQjs5nMQAjrhJCS5gIEG7u6G5rAW9Hd3td7u7u93Pu591AkhGvWgSEe08ySqvOJiQd7zve911m7YAc73ve967V0wBve972S7rOGAN73ve4lXTAG973vZKumLu6YA72u47jve9bq6YA3znOc4dq6YA3ve97JVWwA5znOc4lWc+7u7uzMzMztQgQS0ISBU0ISSV5Afb646JG2ITrCjnNSSnvfu0JznNijnNScwE5lzCKwbwAZAdODQAJJANgAGQCupJJCLuruySSTtdLuquqA4AOzHe972upAndzMn0kGAfVd1VVUnZMbu7rMkHOc5znEq6YAc5zve963V0xQDnOc5ziVdMUA5znOc4lXTADnOc5ziXdMAOc5znOJVWwA5znOc4lXTADnOc5ziVdMXd0A5znOc4lXTADne973veeqT3ER5m2UjWNMusQ+743KJveqo5hJ65rTmp9zXMRXOarmVMXdVVXbFA3gAADkYaAAD4FbDVXdboPnBkApJJJAu6q6FgKozdMXVXdsWxXdCQLuwSJ3Z3bS3YQIN6AADmIFVKqzJOSckibkmpUgxug++uqqrqTsmN1mSDnOc5ziVdMUA5znOc4lXTADnOc5ziVVsAOc5znOJV0wA5znOc4lXTADnOc5ziVdMAOc5znOJdUxVVYDne973vXaumAHOc73vet1Zz593d3ezMzM7QAN2EAltwW20JBY3d3RwwQIV3coQCOfdso7oBCDmaoyxdVdUDeAAAODSSSSSA+BsAAyAn3OZ5zlRFXV2RgEkVd3d0BySSburqquSECDbEjpQIOYgQbUbvoEife7dztVd0wxTDA0A+u7q7u5JJjeZNQd73nOcSrpgaDve85ziVdMAOc5znOJVWwA5znOc4kxdUxkDnOc5ziVdMVVWA5znOc4lXTAJvnOc467V1pkDe973OJVWwCb3ve3Eq6YAc5znOZ2oEgUMBARMA3rJdtuGJIJJkW2MZMUTjEqOskVznNvckvsqpHMiicykQcxSlzFUOZUuZKi5gqHMA5gk4yZq7urwAIwA5Q0kkkkgPgbDt1dGQGQE72SSTYskkklzFXVXVTA1QfSSSS6iKq6uqkk7nfepOJJJJBgDd1VMVdVbF1VVdVcxUZu7rITe9724lXTFAm973txKumAHOc5znEqrYAc5zn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O5ilKUpuG7u79+om798+/fvn2993v8pSlKUpSlKUpSlKUp3fDd3d3ec/e++++7+1SlKUpSlKUpSlKUpTcN3ve97znOc5zv3oG5ilKUpSlKUpSlKULuG7u7u85znOc371SlKUpSlKUpSlKEtwTEQNZKDzIkfYqMy/a1cxW8oLxzrWG6l/YpE7x/e6iO/vtkp/ZVB/YFTmFSOZEcwlRi6uqumLu6Yq6q6pih35TQCMAMc3JqfVJ2bkmgN7D4HwNkzmZmYSm02t2bIpNCZNkAhQC9JJMk9JJJJKkk73jve9SAHve973vbq/YptpFNtNID8gAC7u7uzBNbS5TaqklmKuZgGZiGQlCWYq5mKbeG75u7v74ibfb7ffv3z77iG9wGhKEoShLuCZKUpSlI7hu7u7vOd9999939qlKUpSlKUpSlKUpX2XfDd3d3ec5znOb96pSlKUpSlKUpSlKUj3Dve973vOc5znO/eqUpSlKUpSlKUpSlKdw73ve97znOc5zv3qlKUpRsGSlKUpSlKUpuG7u7v78ib9+/fvwPv33zbspSlKUpSlKUpSlKUgbh3ve973nN9999939qlKUpSlKUpSlB9gyUpTcN3d3d5znOc5v3qlKUpSlKUpSlKUpSPcO973ve85znOc796pSlKUpSlKUpSlKUpAIXP18WsEkFXeom0gEB8xHvoEAF9P22IBC7oSQgR3ek590AuYd0cd3UA3GAPVdVV+z0yUdm5JqSSe2HwPgbDQD1exO973KejL3p73vAAfmk0Uw600fJFKU1O5mZmZmZmZ73arqSQB9dsUHwN3V1dVY97de93ve95znOc5371Sk2yUpSlKUpSlKUoHcN3d3d71E+337n2+fc+/cP7c7KUpSlKUpSlKUpSlKbhvm7u7vvN999993vVKUpSlKUpftkpSlPyfknkpuG7u7+/c5znOc371SlKUpSlKUpSlKUpHuHe973vecDnOc5371SlKUpSlKUpSlKUoDuHe973vecDnOc5373YDJSlKUpSlKUpSlKB3Dd3d3e9RPv0+/fv37vfylKUpSlKUpSlKUpSn0t8O/3e973m85znN/apSlIlFAdmt5+1+/SSSvvvvvpyAAAeam9dkkk7dVVVO8AADQ12q592ta13k2Sc1175575+9KR77pSPcKJ370n30CEHNAAB3Qkl3bu2tem7vd3cjADHJ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EH5Kq/IfYPZUB2P19kQ2F7IC9lBHsCPYUM7gi9gBHsiIPYA7Iq9kA7394hHAkAPyBSSSTPZWZmZmXmckkAPHva97w2TUgbODCMST6duro97n7VLae0mUJG79tJtboe60ikjp+KZS3d9om1tG7uoopFz8mpSX6m5SDiSym5zja+zP2Zx5TRScpSkkUkWm1xNFMoopdAACJNptFNtlJptFMCgAPXd1VTkAAAm4kkk/Xk815rnOc5ksAADNx3JJLqqrLvO4AABm+5vPc72vv2ffTkAAA18nvXZJK+/dqqnIAABNy9zc72vv0++nIAABN9dkkl5PNea5d85zJwAADN4nJJLr77KrO4AABNZ7jP2ZJda++++nIAAB5N9dkkl19999OQAADyOaebvT936SpPBkUHTBOzEnZJJIoKBJOzAB0yA4mZJJNwDZOfGNeofd7Ven0qTU973ve701oDr3vZBJDMzMAAAAlST8m1JJOySpJJPX3q793kAAA+1PeuyVJdZPNeauqyfAAAd1nsTJUl1VZVZ3AAB3e3dZ7+SZJX3379LgAAHnd8m+9kl3VffTkAAAm+933sku6r76cgAAHnkb73fZEl848x5rzXHHnnPPPNc57qs3AAAHue5m8zMzd327u87gAAGbk3+73JOcqvp3oABo71P0m5KnLuq+k6BrBs80eP3NVVXVeNaqqxz77fP29736d/fgyNhNsEkmOdrve952SSpJJJOzAB0yAuZzMyszO5JMEASSJtABu7u6lu7q3QAAkkyVmZmZ70zM2mntJINADJP00APEkkkkggDgAe9d9BOVtKqXKjDMywnMMzc/fs/b27vvvOcFOXN387ipZWUVFZububvd3Pff3UT79+/d+dIm9jzzW9tmmmbk3JmZdy7qsyeatsAms9zN5WXmc5dffZ3oAAE33u+9kl3VffTkAAA8m+932RJd1VeeeaqpyAAATcm5JJd1X31TkAAAzPczeZ3Mu+zzXmucu+/AAAVru8a3n2ZvMrMznLuq5AAAOtv3s+kkv00SAOAgCekqSSQMikzM8ZmVOSZkk7MeAdMgODQGweAJITMzMyRIAABKQBAABIHTxzZ+PxJP0n4AAofrq7q/e97Mkku6r76+gAAed3zm+d6727qq8881VTkAAAm5NySS7qvvqnIAABNybk5Jd5PNea5y7yUAABOM/Zm8yszvOXdVncAAAzffe+97knLqvvpzoAAE33u+yJLuqrzzzVVOQAAD4T2Tcrvar6ffVOQAACt97vt97VfX993nQAAOx7Jufu9qs75rzV5q7yUAABPtH98vvy+rv3JN/GEkvkkkgYFAAT2KSSDNXdCmZJJOdmADpkBwaA2D3vV6/Virumjz6Y7KurklPfubu/mmtj3eNtalugek5JxuSSSebak+obr9hycq7r6Ym/pn0z5GQK5MtVrrUl/SZ5rzWtfpzcne9nOXdVOwAADN97vuRJd1VeeeaqpyAAAeTcm+972tVK++qcgAAFz2Tc5JVcr76T9bRhgNBRRdNzdzvzvec3nz5v0N1UzLKJzES3zvc73d333nPnzfvbaIyIibxrcm5mMy7nfNea5zmvPNccyWAABzPczeZMy7qvvqzmAAAST9JyS7qvvpyAAAa7ve5J9JUl3VffTkAAA1fPb+7r3b8DTXmvNfv37XvlXXt55r2Ku6733mxkB0wA7KkkkgUAIwAdMgODQGwT2p772jbnve38UK977wbUODSTMzZISmmpUm5m5mZmyQAAJJAAkqd7JJJd1X305AAAI1vvd97JLvO+a81zl3koAACZ7mbkqTOcu6rO4AABm+933uSXdVXmvKVOQAADybk3J2Td3VVU5AAAJvvd97JLuq++nIAAB3U3r2TclyXed815rnLvJQAAGbk33uSXnLuqzuAAAZvjnM73Lqq815SpyAAAa6nsSdk326qqnIADGMYxjH2d1jWse0O+nvBkB0wA7KkkknTKgBGADpkBwaA2J6j4k+Bmg8dM5Hh1JPSTwk8d77ve9771ntsXV0NJJ4HZJ13ve9l1X305AAAO6m9eybkuS7zvmvNc5d57Kd3sAAZv2b7WSXeXdVncAAAzcm+9yS7qq815SpyAAAeTcm5Oybu6qqnIAABN97vvZJd1X305AAAO6m9ezud773vvu/kT79993p7V7SUtLZmGZb504G7vvXPXeztaqfOKucrnE2uc3hUmhe3da15Ss5gze9A08dZ7jMmZuu1VVmZNbbAANfb7ydmm6uteWu/vfM+3++5y8ye9732vZ973veqe9jwHZUkkkCgBGADpkBwaA2JJJ3smJJ42efdGjwE8xV3QzdXT3veO/ve5FJskk3M3MzMwkgWm0AfAFSSSy6++nIAAB3U3r2TclyXed815rnLvJQ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k815rnOcyUAABee5me5WZnOcuqrO4AABm5J7yTcu7qvpyAAAeTfe9972S7uq+nIAAB3U9knsl1VffScgAAHs973vveyqrJ5rzV3MnwAAGZ7mZ7qZl3d19mdwBNtb3przEk91JmXd1X2cwaaZprbYamme5me6zOVVffZnIAVVVQfLERDoAhAASAF/FJGRGpT7Qjx90I/ZztI92I8zXQjoKfulBpI61prTMZuSVJswnI34g81I0CD4j38bO/R7vOfqxwOSII67k+LqqiYa2z15NQYViwBA0hBICB7p+6fpD70B5orqjvt3PS00xV5BhvzJHENxLmRTLsGEoQIlIAb85z3vzn791XMrMZkxD2SssCxBhUskjRgC0JZJRiRpquc65znnOagq5U9SV5oQaiNyaznOuec5zt9xI1VZSjIhx3V3R3dogEihAHR3V3dPdokgUpNpAmgQJNCOjuru7u5d3XvD7q6wBcUuc51znOc4keIjEFZJZcKk8RpuIxI2DJnOdc5znwon1nkRmvvuvvOc5vhR+ZJFbYSQJeQIND6QppCBR9V/X99v2WxpjYzCmEhkqXItKmJGFNRGtMWaiM1nOdc75znOqR45NAZilqq8M2pbaRGGs5zrm/Oc545RGWZjDAMlgjiRme865rnOc8ULrIjkLWVzn3fM85znER3VYqZwyFNBa1pigyqWSSZDGwQ2MGKGkiAYn3Vx3d24JM5SzAkxkKyEGojJrLMIjwnA8QQ555IzBVCURCCMvsiNJBjOb75695ziq4IzGZSj2Iwo1nOdc+5nOcoTyMs+EZSWrm+dc95n3QqnsRkl9r77r68k/CgqAOgETTTXazM/ZmZibafZJNAcGQ6Z6YAIoO1dXVGQoS6u6YACgJJA6c1yMNAfTW1abz93ne76NAcGQHTABFAJJUkkgjAB1iSSSchrIG3T5jAfA2GgODIDpgAig1yVKl1U3UkSCMAHWJJJJyGgASSAbDQHBkB0wAQACgBGADpkBwaA2TUkk+kGw0AMySSOmACKkkkkigBGADpkBwa9VXd09j2bq6973ve90HwNhoDgyA6YAIoAFACMAHTIDg0kk+kk+B8DYzJJJyRkkknpKknsrM9izMgAAICSS7vraSfeyTCTieU20nJxptO6f5U6o53oGB/QSSVJJhJk+Xakk2yFEVuTjkAACRJN1JNDIDp27uuc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ACfnGz437wGhJuSSQA0STffXdXVST0k8kkCSSSSFSSSa00ltbpu7u7vZPJe97133mAAATckk+kvWru7yea81xzJ6AA19vze83mZmfZl61fec5d5k85re9725gpZWFtu7u/N3099995zfvSNsIiCmme+5mZ9mVVV99l4wAAJrPd5mZ9mVVV99lwAACbkkn0lVVZPNeau87+AAAzeZmZ9JWXd1WcwAADN5kk+kqqr76XAAA0am5JJ9JVVX30muAADvv7T7TenkrNeqn7d3d3cjSW7u7vnt6T9JJmdrZKnZJNEHBkB0wARQAASSZg5JJIApBMACSZmZkgAAEkklVcmZHqGqvobq7q6piqq/dMgngbD4DZznOb277GMYxjGMYxjGMYxibkkn0lVd3k815rnMn4AADme7zMz6TOea81znOXedwAADNyST6SqqvvpcAAA8m5JJ9JevPNXd3VTkAAA7PdySfSVVV99LgAAE3JJPpKqqyea81d9yfAAAZv9mZn0mXd3VZzAAAJrPdySfT77779JcAAA16nskk+n33337suAAAY881rzcvs+4u7+q+eZVVWXWZ30DaTUkkgA0GjgzySSckxAEUAAASbkmpIA+BsfA2oBhi6upUk7v9Unnw973ve8AAAANuXd1znObJ7GMAACbkkn0++qqzvmvNXmT8AAB9nvczM+z77779l5zAAAJv9JJ9Pvvvv0lwAADXdJ77JJ9PvvvpLgAAHJ7JJPr++++kuAAATc73vfpWqqqzvmvNXmT8AABKZ+3mZn2fffffsy8AAAm5JJ9Pvnz53vvaqtcwKIL9Rvm7u7894Kc5znzdzdaa5yuKlSpcpUq/P4zlJft73dvdkkkiOZk1JJIANJ+HBkkk5JieAigAUAJPAPekAPe8AkkkklXdBJJJJA9d1dUKA8u7oGgJq+tBvu971vB39j9jAABm8zMz7Pv37vdeeazud/AAARnv0+k+z79+z95mXgAAaTWb3P2ZlSvtfffpOa48AC57J+k+n37Pv2XnMAAAzeZWT6V555qvqrknfQAAOx7J92Sru/vqk50AAD9Pe9++72pX79JXAAAO8J+97JPr+/fpKgAAHk3OTvfp99rzzX30lwBVVVXt9/svmAIdz5Zzv93moDv98N3u/P0v9Pv3vb973vgKAGkkm5JmT8HTD3gRQ6ZBTpmrugSSSqkzJ1N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AMEjBSmmpcUn42qSTS3dNST3d3ZIBw3d3MzMqqqqrJyAAATckklVVVVScgAAE3JJJVVVVWd815rMnoAAGbzMzMrLu7u8zuAAAxJJJVVVVXJO6x+AAM3mZmZVVVVWZyAAAeTckklVVVVScgAAE3JJJVVVVUnIAABNySSVVVVVnfNeazJ6AABm8zMzKy7u7vM7gAAH7T93Mn7udutfPPvV++7V++vyV3eP6lVVT9sDd3d1sD8jwHbqv2/379+/fvekkkn34NhoDgySSckxIBFACTck1N1IFUJJAAk1JJN5q7pJO77166qquw96ve97Sa2mkAATSSSa2QpNoAJne96XeSd9AAAqeyST77766qTkAAA8m5J3v3330qpOQAACbkkkqqqqrt9AAAk9kkkqqqqrJ5rzWd2AABNySSVL1d3dzkAAAm+973vaqqr2qycgAAHk3ckkqqqqqTkAAAm5JJKqqqqk5AAAJuSSSqqqqs75rzWZPQDRo1mvdd17r3r7Mr77MkmarMzMzK/fmgOzGZJJOfA2GgODJJJyTEgEUAJJJJISVUn0kgJJEkkkiSd73qSRJ+qqu6r9jFVV1RJPx+k/AdMgHPd73ve+9+9jGMYxjGMYAzckklVVVVScgAAHk3JJJVVVVUnIAABNySSVVVWtVUvoAAEnskklVVVqqyea81ndgAAVqeyT6SqqpVS4AAB3U9n6Su9u6r77uX0AACb73skqqrKrM5gAAGbkmSVVV99JcAAA8m+97JKr79+krzNPDAJr674r793fjt7y/Zi/b39rD4A1e3i3fgAC23RVW0D4973ue972veDgyA6YAIoATlXdSerQPe5V3SVmSSfJtGZn2DUn6HE2gA7JMzCZmYZ2cmAHAmZhJmYDTQAF6lu7u7u7su+9bevvu9vAAAJvskkr2vvvqk5AAAMz2XMzKqq++zLwAADut773v3e3VV99nNeeak76AABrNyTMysuvvsy8AAAnmt837yd7d3Va881Vd7zoAAHNeZ7Pf0kl3+vVVUnOgAAX5qez3skqq1X30lwAADXdJ7JKkqvv36SoAABN8nZJVV5X30lwAAD339399q8zXmv22v2X7PevdM2Yg5JBAHgPwSSdkk+kknwNhoDgybD7pg973ve89XvAJJJJIEkkiTMn4Pe773tBuSa73vUkiSeYq6uqSTwTwAAdqqqteeaq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AIR9733veBHwIyodpZGqaLhSZENFiWi8886888qBzWltmUHiowDzzzrzzsVHioyWS+TiW2NUo4lGCGk1JLUmk1E0KwTAo8886887oi52jEvEtUee99737I+EelSNQSNVkCCbAK8486887VHKaRPUsKyWoBoDUslio0WVGiyK8886884l3SVqYRHiWEvPPOvPO0leJZUZLEviZRd+ffTSariaaabS60/1nZu/v327u7u7u77MzLeb554nYAAqmA+7m/dzfM3Nzb8FT9ImCpksK1FlSGSyWSyQ/X6+frzztSq8S0S+Jog6cpcCWS0kpksqNoUWi0KMlkDzzrzzpJXLYaKjtLEslqWSxLJYqMlku+/OvPO6SuUxBd99/O++yLlNCXioyBpKYlpLEsllRtIFktCWSwoPPPOvPO1SvKLKU+JlBcUWio0WCWJZVGyJktoDEslkJksqMkNK8886887pSeUvg4qUHBLKsq0SyBkDIGoGYlkslksS0WQeeedeedyEeJZUZLKS+W1aElxRZIZLRUfj333v33xUcpog9KjFLKjJZLzzzrzzxLxVlWJfE4EuJRiWIwjKMIwjAI3ve97REfKZzPv31ubm5u89Zu7uZn6vnfly/AAqqqAAAVVVfNze93Nzd5ubm/txc/n519+dkvxMop333330Sru2rCHhLUsl555155wnXXXPXXCeJeJZmGZSaiTTknZKTWJp4mnxp5mGZSUhhRLd3m7gn333PvtR5esSRqfe9zMpRp85xuupNJJ/syzJ+/ft3d3d3d33ve1A6AAAqqq97m95m5m17q/KPKCRqCR3d7u4G36xGLEve932UmgLCk0BYUmgLCk1GnJOyUlnE8zM7mUmqA70pNAWFN+rqbbbTS/Znzvzvz9+ABVVUAAAD3333335KXE1CvUyke+89995L+TknZKc43ySdkpNAWFJoCwpNUmw+736MEtR3d++3NqhKP1C4N73u+9g0BYUmgLCk17RNJttRp8aTTTSz3n337+deefr8ACqqoAADd3d3d3djabTXmnxtPnq971Jr5pyTslL8uJLMzO5lJoK72k0BYUmu9rvaTUaYTslRcaXJJ2Sk0BYUmgLCk0Ak9zczMz98+fPvff79+AA5ubznOc5znOLc16AAAAfdzfu5ve5uZm5nzc31iTaa96vSU0vlzjTknZKTUknZKV8SQXYUkgLCk0BYU3Fx8ack7JSakk7JSaAsKTQFhSalVnRtJNpr73rhn3AAAAAAAAH7ftoqH4/Gfj8fjH8o1RMjVI7u93cE2SdkpNAWFJoCwpNAWFJRcT405J2Sk1JJ2Sk0BYUmgLCk1baTSa+77+fe++c4AAAAAADd3d3d3rTiaaS96vd9S+XElxpyTslJqSTslJoCwpNAWFJqKSdkpNRpyTu7gm79z77E/WgZAlAkQnve772gnIShKEoShKEoShPvuffZ8JQlCUJQlCUJSFHpMhO/Jubm7+8vnfV+/fgAAAVVVAAA97m95ubm17q98zc9es3PXrNz16xKEoShKEoShNkd3u7nwlCUJQlCUJQlCUJSm7vd3NEoSj9SZCUJQlCUJQlCe97vvZolCUJQlCUJQlCUJQm7vd3NEoShKEoShKD0ZCUJQnve7734R54ShKEoShKEoShKEoTPYj733vZ8JQlCUJQlCUJQlCUpu73dzU/EZCUJQlCUJQlCUJQnve772aJQlCUJQlCUJQlCUJu73dzRKEoShKW9iGQlCUJzia99njPVzt/fv2d7R5cr3Z42t77veVW5cXC5337z399+9+878+feXEak0TExSWk1QtlNJlPJNR71ch+58+/ZPNJ3wml/l/4feqTQrSd0nEVucU5CtJqKuScpOUmlRhWIMSyBpRkuNm5vm5reOc/doAAKqqgACqqoAAqqqAAAAAAAAAAAAAAFVVQABVVUAAVVVAAAAAAAAAAAAAAAAAAAAKqqgqqqAAKqqgADzL1VVAAAAAAAAAAAAAACqqoAAqqqAAKqqgAAAAAPffe0+J4m+yapNJpOk+Jyk9k+SaFdp76nlJ9hXyT1Pe5vzd3czrz18+d+EAAAB55555554AAD3ub3mbm25rc31/J/J6zNz1u4tiW0LapWaQtqS2SFtVbJVsBm2Bs2I22EbRNkmzaJNimyU2SG0qbbBbNiLYgbCUoZqE2bSWbNZorGpMwEyi00pDREE0KNFEkgSTEEwRFKjFTEfr79fr9faSwRENEwqL2EoShKEoShKEoShKExKaZRkIKYgIkoKKiAWgqiIKPexXnXnn2XPSbJsmybJsmybJsN7wnPvvvfvvHibJsmybJsmwlCUJQm7vd3NEoShKEoShKEoShKE3d7u5olCUBR+IchKEoShKEoT3vd97NEoShKEoShKEoShKE3cR3u7nRKEoShKEoShK9DkJSnve772aJQlCUJQlCUJQlCUJu73dzRKEoShKEoShKEoShN3e7uaJT6chKEoShKGEhhIYSGK2taww10DMDEYxhhhSl61rXgAAHnnlubVTsAAc1dS6l4BfJYl9+8fe++PE2TZNCUJQlCUJQDQm7vEe7ucEoShKEoSg/U5CUJQJXve772gnIShKEoShO5glCUJu97u5olCUJQlCUJQlCUJQ+9733vZ4ShKEoShKEoShKEoTd3u7miUJQlCUJQlCUJQlCbu8R7u5wShKEpfZglCUJQlCUp73u+9miUJQlCUJQlCUJQlCbu93c0ShKEoShKEoSkL2LkJ73u+9miUJQlCUJQlCUJQlKZ+OffTu5mZ7es3Pe5m5vv8fe794qgAACqqoAALN2vPLmbnr1m569ZpQlCUJQlCUJQn32I/ffcEoS/WLkJQlCUJQlCUp7BPe97QQe97374ShKEoShKEo9BkJQlCe973t0ShKEoShKEoShKEoTd3d3RKEoShKEoShKEoShPx73uo+9qPuv4gyJsmybJsmybJsmyc733333zRKEoShKEoShKEoShN3d3dEoShKEpPxZCUJQlCUJ73ve3RKEoShKEoShKE9es3PXrNzt+91X7z9VcAAAVVVAAB63Nqq98zc9es3PXrNz16zcoShKEoSh/VkJ73u++R9zBKEoShKEoShKEoSlN3e7uaJQlCUJQlCUJQlCUJu73dzRKEoC9gGQlCUJQlCUJ73u+9miUJQlCUJQlCUJQlCbu93c0ShKEoShKEpC9gGQJe97nvkfQJwhWhKEoShKU3d7u5olCUJQlCUJQlCUJQm7vd3NQo9JkJQlCUJQlCUJQnve772aJQlCULZNk2TZNk2T10S/XvvPfvv69/X0AAAFVVQAAfNXvvvvvXH4mybJsmybP1pxk2ShKE973fe1HkJQlCUJQlCUJQlCUpu73dzRKEoShKEoShKEoSg9Hve+97NEoShKEoShKEoShKE3d7u5olCUJQlCUJQlCUJQm7vd3NEoShKT0ZCUJQlCUJQnve772o8hKEoShKEoShKEoSlN3e7uaJQlCUJQlCUJcb4pJclZlNLMy8yk1zepNOfuZczP3v27oAAAqqqVVVA97myb973vUmgLD5p2muSTslRN8aUkuSk0BYUmgLCk0BYRp2muSTslJoCw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vxVVUAAAqqqADrc37ubzc3rc3vc3rc35uZu/t+37fjfxgHI7md7qPBO5u87u5yqqqqqrtne5yqoWH4+5z77BO9zvcE73O91TtNcknZKTQFhSaAsKTXM77x7Pyafn77x55zn4qmA6AAAqqr27u7u7u+Tfve96k0BYfmnaa5JOyUmgLCk0BYUmgLCk1E3JOyRp2muSTslNgWAAB+aT579Xve979+3fe973ve9u6AAAAAB93Nqvt7zrosPybkkkAAAAAAAAibkkkDrrrrrrrrrr13m5vWecvleXOFVVQAAAAAAzd9bm8zc3m5vOc5zmpuSSTybkkkAAAAAAAAibkkk8pJJAAJ7en27XcWrvpt9SafE0/ck5JpO1OSck0mkymk9k4k5SYp5z5+8k8k7hWJ5EtJkVkixMFaTUKxHEoyXEuJRwlxAZLKjJYg1JwSxLAZLgS5S4S5S5xQcJYImSwi0K5Uc5ScSbkmpNUXEXAlwiZS2JalhWJVyIuSYmU1JyTImk0K5JpOUn2TqQupMTRNW2naadJt8tN207VaZu5nt3d3d3d3dAAAAAAAAKqqgACqqoAAqqqAAAAAAAAAAAAAAFVVQABVVUAAVVVAAAAAAAAAAAAP4AHAAAAAAAABVVUAAVVVAAHmXqqqAAAAAAAAAAAAAAFVVQABVVUAAetze8zc3vMzN3zc3zc3rNnqdkjyk6k4nacpPYV5K9K5JcS4iuqXaBwK0Sc9efOvHgAAAAAADd3d3d3eNP3ve94AAAAAD8m5JJAAAAAAAAIm5JJMMSacafvtO6c4AAAAAAAq973hp9afzTjT60/fbhgAFoKAAAxNySSAAAAAAAAAARJuqne9eeeud/Pvdc4AAAAAA3d3d973ve9TTzfe96mn8m+SS5AAAAAAAAIm5JJAAAAAAM9973ve97gABVVUAAAqqutPN97vgAIpJJPk3JJIAAAHe973ve96AAAARN13Pve76e++3d3d3d3d3feqqgAAAA3NZug666AAAAAAAAAAA+TckkgAB1111153e/fnnnnnOAAFVVQAbu7u7u7u7u7qb973veAAAA+TckkgAAAAAAAAAETckkmQadfXnc885wAAAAAAAN3d0afWn8040xp6m93DLQUAAAABibkkkAAibxZmZmAAAHQAK887867udHXnnAAAAAAbu7u7u7u7u7vve9ne974AAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
