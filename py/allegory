#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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jDGzEYmuzVEHQOpVNXDYW2JNK2SSRNXMt3bbeJot3vGniurlz63aT2lmZjtt+tokczMbWB8AA2zGnmPMSSC7u7u3VOqadQFpezl99j3vb7jxeuya1VLUJ4eugB7wAAAABJJJIAAAAAAW22NvxfABUv2NPMWY2lcTVxreNpXLl+0rq7aWsWN22/W0SE0AfW2/JO222xNVW222pqTRjTuXLluk1bJbaJCaALbak7bbbE1atbkV4mkuLSTu9c4u9fzXcb7mu91ZfX9gFrttVtAttv1+tp06RtySSQAAAADRhoLe2+s9bba2pNfsadtt42urLbb20SE0AcLak/rbbbU1JJJImpkNNO236iWk0FvKAJoAskbRmW222prG+XrGHnWdO1ikmlq/Tsk3XoEOFCCwx494AAAAAknrbb73veNgAAW2Qt930kkjak/badxqSbXFiSxY3mX8AQNDTzE5IK2jSBpdwAgWpq22dkTVVp80wA4mtWyW2pqSQk0lE1mG7vCXve94R5AENICXDv6DaDCeiiZYl1Vp3Ue/R9p3ypoX1E97KMbe4hVNbOJva99fCnva7U2YAAC8gPttPMDQHDckkOAdTZua12STUmAmWd5jve96mhY+/tJuZbb8mjlkttTXZJ3tEqk5bbZE1U5JJ1L9iYZmr7TTAPk35NzvZJBGm7uZ7QWZmZm6IiNaJ6PvRLRuTc1RWQ2EtxoG7J+SV597fvvvo7O7pr1+mMzO283PAbOgb4SZibu7u/KSdlNMMASSItt8AkHveq6l3ve96mvXM1qv9tpgBxNR97223df2ZiS0xtiAAYsxOZbbb1NRd73vS1tGNO223raqkkttTUkne9bRg27bbYmouazNW3lt/C/e75e9vt+73uelhd3i7u7k7J3vS7xd2AAAASB5Bu407230ne+ksqa5ixp4/2NMNABxpaySS2RNVCbALa2pkkknW8x1NySSWtoWNOmgA4mhWSFtTQrbZ3qTjb73ve962sXxXecYytaWj3OBZwSvABLXFd3d2QIAbaegDRzEAu7u770IAABbbbIXrb9znPd96Jr9jTtsksTXrbQK3tCAABNmLMeLMxK2222rMzG3ix0QBYriWYm8wqPvmmAHEu4pJJ2RNSpu20tbUy22zqa1O3dSabriHCGyH+Icc2cI1D79502JApEgTEBh6RAeoQHv2epiAwCA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YZd35N2298fqrEUm8GwNj3LixTT3M6qBMSmnvkjbhzh73uPitv1tv1AC228Tdt31BrRq27uJbnlv0533ipq222/rmJvDSwAAGN2222JqSX5p0TYHE0QC2gmi222Nq5ltttqakkkkTUklTdtqa+NTfO5yqk1fOQuewAAdAyABmXd3u7skuVE3cpNySeAACHgAoCAAlA9bJJ33ipO2/vmmAfJoXQAATUkkkiTkkE3bamrbe9sTVxW0+aYG00K9tttTU73pJEnJIJuSJr9ry3veoGvFHvTUDoGQJJJJISTEkkgBLu7uySABLJJJJ2DAAO85zgX1J977LT6W3iawwAA+Q0sWPEsSzGnJJC2tq3lttqYAAVJyG2nBt23iaGjpsABNdTLpSSRNGdazVvyttENq/fdtsn37klimTvPEpf3ve973vW222+tvgAADt1d3ZJAAkkkkkCS7u7Q02nw7znupPva/3zTo2wOJo4FABNGWdsnU0Z9mrbbYmu973vepPvaj5p0bYHE1DpugAmulskiaMWSSSRNcv7f6Z1G6pX3EO8ou+uP7Idq9VwQ9NzX325vevqur5IDWCA64zz6RAUgTQkeYAuYINvsVCAbQIC31XMO5k2d3PXXc9MEBAgGkBYgHQW4cXBr64baQDYgJ9md1+EBovNG7EsjIC8051KwF4zHaLFjlIQCpAFEAxATvX8ICvOn6ATolpAec9wNY1izud1stL4AAAD4Ob7rve9AAMw721Vdk5nyEGJiaFSSQGtIDzEII1RshtMtQ0rKDnKTiRy1RyyGpsramwm0VZk1i2NjZZibWUNoahqDhcqHGoaJlGQxlDWUbJLaQ1piwVlklvOKOtdPvCDmNhFqrNMhqGVDz9zrU2EZ5XIr9lL+xO8SfucVMhqC8Y/tICGIR3wgLoRQIEffffR3cIC+942rIGlJJNqbqKSc4AbAImkipJJLIAAe8AAW2220DzTaG0lc01mNpK420t70sM0kk8xe1v7nqhNngAO0APe97no298md3z3vUQAAB9bb9baAAADAADgB8AAG+975+xtN9xtJrPeq/vvvvu7u7uNxG3DaIY2kghwDCG0lWMeNFBGImACwbKCgUsUtGt7hkQRwrCMttlrFnUpiNttQNtKHA2QhtNkRV1e93d3d3d3LW0lrFJJOw2AB0AEACAPmmAHJIVQbu7zd87QSSScFSpJtNAakkmbtvjoAASSSSGwCtfYfa6XvJG0lE2ljTczWoWgcAPgLbbbaAAAFu7u7u4JNpAAAEu7u7u7kkkm5CaaftCbE2JsTfvvvvve+tA4AAAcLd222gDTYmsabeAABfm1beXlv1TSQmk0NpLtZA2BZUmGnJJJOySSSe/qHpG999999999Q9UWQ1moWYAAAABoDSAIEAAAAAAkkpttOSSSSSrTSRqllpmgAhJJAAAAAAAAAAAAAAAAAAAAAACmAABgIAC980kxNJBWMaAAkkkkkpppSbWda1JJc1JhpgbAAttttoAAAAOWJvOdDnPuOmiuWFWUtyucaFskrGAaSQoaAEd999B30fcezfYW00L8QsbfudN6D3p7oABd3d3dhKkkkgECSAQD19jT9i8S5bbb4C/XGnbfy/NtMUUVViCsBQWKCRBSCqVstatZsTaay1kd8CPp7lwuxAmyVbNi3v372C7NsmkhgMbYPoSMZIwTa96qpC9wl3HE0cC0ATRLbJG0ZllttpmYks7bbbEqkpL9806JsDiaOBbQE0WSd6mg1matttiar7Pb+W/t6uNOBvZ+98tiDBTT2BYcGlZumUmwNxzru8Nu4klKgZLANJgABd5KM2bRWYKw4rTYYAzLu70s6SwUa304k+c9lp9ibu72mu3tttqanSSSJq4sttttTUkkkiaikPmnRtgcTRwAAE0WySRNGLLfe973hGMzfSEFNt5MjCv03Czux+7O/ffaYAHAECAMyR1JM8kuGALq7u7u+kkkngDoGQkiUknU37ve94HW13uPK8007nk2aXwbTWzofAAmi2SSJoxZbbbampJJJEYsx5iSVzV0tYldaadE3rDQd2sxrEdD4A+GkW22xNGLLbd3dprHsJpLImksdrypNJbxvh1tllb97FwJckku7v0kkOCAAA7Ji7u7u7uQAAAAD3vAEnfSd96Jov4NcaZgG01bbbbU0IC22pOSS22pq2222pq5cpppgBxJgAACaAtttSdtu7u7bV3vvhNJY3vG8Zrhs4Hu+AACSYTaSAAPFsLbfAJv3gAACmAAAABbb33fSSe9U1bdv8aaYaZhjaAAAE0Bbba2uZbbbYmpJbbamrltPmmAfJrmYBsABdaAAASdtvffffcvX0vXOhXyVaVRrIpa02TNaMUrZraxtKH9hEsNs173fe9vnvTMkkibk8l6qp+9z3ve9u0AHEAfL97wdA2F9tJABge94Ch5pv3uBE2RGdxNtz1sktTVtv7jTAPk0BQAE0Bbbak7bbbamrbbbamrltPmmAfJoCgAJoC221J222/v35XulqGe6caZrZmj/MP86uA6hAkNgCThJQv36j90JL8/zU/r/d+z7e8zplXlN4C70IxhtJdkkkIru23cT9VKigM+8sNOvbBtyd3JJ4hTbNySakgAAkBhxvyazved771TVtv7jTAPk0dAABNFtttqTttttqattttqatoZxpgHyaOgAA0i222gsx5jTxo7u47u7uAzoBfmJQq6QJHIgGE1jVI1ywwTxJJJIIEBSbAA7JMySE8atV3bfHPFMAvgACnteAD9Z+sk/RNCtpxpgHyaq7bbbU1XJJJEnFJJJE0VW221NWahpp22/JoXbbbamhSSSRJ97JJImqmktaz2vc97x5Zw/eAADwaQGAHqF2AHEe94CAbL4AAnZJJJJLu74cO970LTXe99pp3d3pNC6AACaLbbbUnbbbbU1bbbbU1bacaYB8mjoAAJottttSdttu7uVVKks4VqXlt+rOtbx5arHtmPXm/WBuBNS7GkpJJIWpJlKSTUptyigE3kANhJJJ2VIAABJd3fG2cO970LTVt/GcaYB8mjoAAJottttSdttttTVttttTVtpxpgHyaOgAAmi2221J2222Jq4/s/DSaWJpLMTSWJOxWf4hqH9/OIdofP2/d0Odod+odyOZD+7KuIZ7310bz9x586nV7C1ggyfWUXkcyWGyRfrJCRAMEECAZvx5mMj6EtNKHA4ZnbT++mH156+OdvLL188vL2oug1tNjZYr3StmhiraKsSuLAXCmlFirlyZMgZLhU64U4UMitQ9zlDVWqjUOeCS5DicqpwwR78XTJNA0itDXVBeOOqGI6hj7iU6oaUdW5Q/uKP2oK81JLuh+PnR3lLvaxlsUyqtEujlKsRlBsy3KG4TjgnCtocD6bq64oY946qGbM1isWQ6ofOiPNQ7OZcqGUMGVOzik5TnOYqyVs5mxNmMuapw0/udSzpTYitqGoHCrVzNkni1w6Q5zS1rbZNmZQyjUjdc4lkNmyo6oZR/dCnUa33JcfuJ5Q1X9/deMk/bgr7/b77TaS40wm/pJyeOa2CaS33QQ+IgMO4ABQABA0ymAABTAAvLE0lc3bae97TuNJpBptdx7xYsPb7370C223wB8B5e93zTp37btt3y+L7oAAZJJJ200BoAgaUAAAAAAKmyScEmlu71mwAkkkiu+pbpJtU1TSUrFJYsaTRjbT1rTzA+CAAAB9JNySBJJJJOS8Xd3dkAAAAJJJLuySSQlJpLfVhtpGgOgXaqrskklx1JNd73bbSUkgAVsxrMAC2JNpXLbaBW0urGYHwFjSry220OgbACO5bbd3NicTSVNpKlgwGgAuVJJJJcqSAAFttttAt1aAE5IW6adt3cAtNaAALbbbb5SaSTS973Oe973kAXdtt5aABWk0zAAtjaTfFixrHmV5b9aANtJAAYB23Vltu2mkAB0CSXd3rVypJzfJySZyNNIAAAkkk5IbSaQAHQttttoAAABbbbdptK0A6BjTSAC2XE2lvGmltppW20sqMaZ8AHA8m0uNNgHwE97SbAAA2mmkd5znE+AU6AAAGw00wD4AOIA+ADgG/vJJoC+3v22neeWaTVwcp6GurSUxV1WacCWVNpqYWVWUc1Ow78phLlLGoAXR7nAmZIFvmmAAepgaYB8g17PeAArL4Apl8AAAW8uNO+76Sd9GnJJ/DjTtu01eW22gmi222JOSSSRNSSSS1NW2221NAAADTuCA380wDnEmGySSRNNYpNJcpKIWdGq1r3DhTTIdm2ExKack7AzjoaADdpXUlVKackgXqYVzeWnJ2TkAkkEABE2UAgkmVK9nldSSd9+rzFmZjTzDAACIxK220Kmru040wD5tcRgAAJokkkjaqWXVtttTUSuK222pqNXFacaYB8mpd3d3dpq6eiGKxnS3N76e9cx7m9+8BALty226vuT6b1JIU8DbDgB94ACmAQNB73gDJF3ybk7PeqattttqTttttqattttqTlt/caYG0Ymr220tTRhbbOpqqSSSJPve97ZE1JJO9TW+fk3Py98ente3AA6B5gAaTYHgIB8AHPAAdA97197XgAAABJABz0k3+xp2/tpqW22gJ8zMaAPgD4xp5izGnmGAAEMaeYsxp5gAAUWNPMWY2wAABZjTzF9rTTACACzGnmLMTYBzjTAOcWY08xZjTNAAEHixp4md3dXd3daExjaExnz77qPhpspqLut4xrS1YjB4AUknZVkkkkAu7u7u7kTcAAsMBJJJJJJJJLu7gV3Pe9709EnixZiTxYgAABJ4sWY08WJAAACTxYsxp4sQAACQ0AAFTQAAAmrbTjTAPk0AAANoAttqattttra/az7mt4Adhb+AAC2222gW2220vrbbb49sADoBbbJJvy4b73vvVNW2221NXLdK39tpgbSZwAAG0W222pr62221JySW21NW2221p3GlcSuO020wNts4AACa+3J7ea+38Vqb0m5yeg+cIUZ3TT2E3u7u7skV3dJu220l9bb807fB5t+933jYBbbJILh3ve9PJO2222pq2222pq2222pr8AAAmrbadTYG2/lgAdAG/seLEnmZjAACpCxgABU1bbbbW1tdyY8tTRsLA9RskmpLkwm5MySS5zubzd3f0MPBb92TfrfAAHve8HAtt9U3VPW231TVttttTVtt/daYG019iwAABNW2221J22221NW2221NW2060wNpr4AABNW2221tZ89JNIbSX7SuUMyhqr+4ocVah/dq/v7z7/UUexdLwGk5Jm7JNqVhNyZcAx2+Xd8A8gbdv5tJUxAfve/fv3gAC5QNCQFxXH+bSX7G0liLb2n6pq2222pq22nWmBtNfAAAJq2222pO2222pq2222pq22nWmBtNAAADaAC2+Eb+j4QFwICvt7RF1dXdV77Pt6/1d3cTckkgwAACSSaackk3G3JJJJJAAAALbbbYm7l8rbbfF/LGseNgABWm7bbbQaMeAHetMDaaAAAG0AFtqattttqTttttqatttt8I973vdiF3dIiONHTEBwkmAKohtTXPMJCV9iAMAmO6WgA6but2NAxLahUpat5d4QCzGScSTEI5AgJ2/277f3RTGLWQ0DYZQgNugq4YqoqrIJWogkA6QBkCGkd+RvRvl5ebIhEfG9VV90a8vgQPrJJ063TpDE7FOukXm9lgVd6i9aDMgV4vPBFa45RXvrm9dIJXTqBCvySQ8u7bYJMndQkikJiUdefO/O+7x+/uRQfrS2SP7IcxlYLWfdUH6RlH7fplL39nwINtCQLGCD7O+6n3pQs2pndr7r7fk0lqjbTiL7rRWubNSjnMtOdmZOzMtNJcmmnmTerwrkmGnqSZmVuSoGWmdAoETDTu77dzsXLEnKxVSlhtUjjTxvnAyeAKtNPWvk3vcOAQ4RfNPmldmvL6fewq0m+TO3XOc3zJ7vL7TTDVNgcDTT7gaANmE006bPgNBpplt+ty+Ftpnve9r2fH3QhdnIY46NvT4QE2QIDEgGkCvGnuXvvHgrT0mzQG7e3Gm1vEmn3MTSWNNXE32/Uh0wxpmABO93caejGnhzYElAFA+2BDO5bbb2iNh8BhN5adZju9Xy10nNNOoBoOiGklZh13TTz3DYFsaeu408u/AEMR9ppzA2cvLdNPLq2gcK0bafdmw5d2NpNraxLHjvzT1bu0uziVeNnzT2HPg+WrGu5fmnq95eUwNNMADorjTtttsFzyfF75p+96entryumnbVu7ttAmBoOADOcafGnxp8af16AB3DTTDuwPgAOd39rGnyrS2uF7yXlA4AfABmAawAA800mhJJJlAABvbTkk1JJd4u5JJ202kjAAtiaaSuW20DTTSCBoxpkPjGnbavpIAAcAAu1ltt200u2gLoE8k0l72173gh5p6TYAdC01pNhsAJ3GnctttvTWmmGjgB8Fttt1aAEOm2ml8HEGc7bbYqAAAgC+TfQNgHvaaYABMCmNM72pak+khTqAAAAAEGAHA2B0CaDTTDl1TxiED99bQgz636YcpscOUKPoi/fAlPC1B6YLrCvSNCdT37769d/F34V02mk0nmkmlm5U8X7niLUkk3dskkkgF3d3d3cu+970urJACwAATYSX73pzPkkBv8IP2QkC7ukAF+YgR+aS8Y00AAFSdttttTVttttTVttOtMDaaOAFtTRhbbbE0W222pqSSFtSdttkia79d/tJb+QF58m+9OX93iAym5OzWLYlmSSQsBZKCk2AGQ7d7u7kgG2mNsBAASSSXd2bOPnA6muyOS21NfgGAAmra7TqbA22g6IABOQA6AfJIWAAETUkkkiTkne971NXd3d3dpq13aWETWQsxZrwbC5qS7fpJqSQOWSSSSHLu7vlyZJAAkkKYAW233fd7+405P200IIAAmrS3lt22rbbbamrbbbak7bbbamrbbbamrbadaYG00cAABNFtttra1iTaS/LG0k2sXvfAHxZ5W22/q7bbaBbbbbS2SST82kvB73ve94ADoG0gAnlbbbfVNW2221NW2221NfgAAE1bbbbU0AAAJq2222poAAAbttttBJYAAAk0mmY2k0lcaSuBpRe/PP3dQ8ZDahsX9pNGbxtJpy9tvPe76bn4uW22lVt8HybD3p7ugAA95NgBptAAEAAAAA4AfL3e97391Nz9+2mgAABtABbamrbbbak7bbbamrbbbamrbadTYG00AAANoALbU0AAAJNq70riaSxLQ95mJZj+2AXh+vOVW/W/qrbbafveAALfWpJSSSFp5ppe94+zEmkAfJtINHvZ75JJoA32Jv9Ff3QP36pq2222pO2222pq2222pzErq222poAAATVy2nzTtu0mHQABNWSTsu0nd3fLu7bXYexerpZT5j2FPevab173tFt/fJsLuRSSFL4DSbA6g9AwC2kvV2NNKU09Xd2ckgCQBabPVSaSM0AX8RvzVtvwRph9tJcSNgcAE0W2SRJySVJ26uVNXVtttTW+97JImqW2gCa+kkvWnQ22jZ0ABNfumZ21WtLeaVN1SSVbib0Q7nGTxJO36SS7u5JJ45NySal2cu7u77dSxNpQAnPVSaSMJgAcaaR70000pJ3RznOB1tROqu7LbU1U7bZImqv1tv3WnbptbEkrly22prkkkkTRitttsTUklttbUnem2n3uJSalbkkklpq7ppLNLHCArDnvAHgDwAAU8AAW+tkkkLfebfvb9STSkDSADBYEnfL3e953vvW2tNV3ue9kiaqtkkia72puQ6klbpJW8kkvKktW22xJkkkkTVVtttqamSakNpu3TTttttqa3m82U+7Nr7kkUed1rMWNZkNw+t/Hi2q2/vIAAKeBABb4TYW7JJJDrTSAkkkjTSgGDbKSbTA9zjXdd5z3ompJbbak7bbbamrbbbamrbbf0aYaSYAAAmjAAtiattttqTttttqattttqa7+s+vtftJvSaS77T4PM8MIBl1aDK5MZAKKkIq0YlAxAMmfd+r9eaCBxAgGXKgdfsxCAuwgQDcNICGyekicm2bEVfVuzuakA9rbbm1NoqYnZjSIuAgtN9MCAYO9sOtZEUxiAqG98ekQDpwIC2e+5496cMIQ3Dj9905dfq/ROfvs3b/SxAP9zv66DW1KfzfOiTqxWmqGTbZotZ9xcUmkZDUjZO6GZK+qx6c6odEL5/OHHS86gvlnGFTqExVbNqJk+8jkRjaBskZRmCb1D7xR0yraFs1DIa0oxHyhhOTNQzVtI2JsbJNqhqqXOXLEPiOVD7lHWEZbSM2iWofshyhiP7RzGoeHA9xLqyrJRpNhHNJOFp/ahyaKmtbCVpVoaYq2bLZttYGn7nvVXMqabWNsyqbBta1NqTtpzNlmRXzih718EZrE0tqa+xJt7zeNhQTc774+tvL73gCSSs12QTSWtAWcAznOZJJO9JJJIdPAYAW5ZbbSni6STWY09NNnfT76T3A7JJyu81JySQOAGjm973sC5JJJJcxW222hgHwBToABaAAHQ1d227FdSLCaSmTewAkkkbd3aumkkqpNpPMbe8esSXNW36lAAAKfW2/WynQ00zAA2W28ttADYAHbQAuzRA+IHk0lyd2mkjvu796319h0A+CgAaLare20AwEAClrTVttoAwACy5bbaAAAG+26t5bTybS773vfe973u8t3frbQAAAEJsTcxBpp7PgAvQAACSbkk+ADQaaYAcD43cadvLeWeTSU1pX49z7vve8bALy222gAagaAAraSjTy6ttNh8m0vmmlsApbTTTSttt7agAAAC222q0MAkG0lymk0wNBJO3V3dkky00pJJOQ0n23Vt7aHAD4A6GrbbbQAAACyZJJClMSaW2mkdA2dD7yaSkm022I5zvQ94AAAKlUuc5w70ADbTSAA6AAAAAAAAFvN/e572RN+6rP1XGqGobNQ2kshos0gQxAMTYgQ2NMXtvfduTKvfwBnWEq4Tp5ydHd36SANsAAAAkkl3Z27u7u5Lkku/KSe1VJpIA94IpVJoPvrqgE2GM/VUpsBNpG7CQkaykL2sArAA9rIUgoxVFVRixBW3mNtrMTbaWAbAAbQFttqattttqTttttqattttqattt6jG2Gm9gABRJAABUnbbbbU1F9fVb+3pKqxWxNi12sdO7TZYveWx0AbTZIBhcAMpsAJwkE2ABy+97O3SskEBJJINMG2ASS+pucO970u01d3d37rTlGJoDoACaAtttSdttttTVttttTVttpGmGk0B0ABNAW22v+PjSO7u7u8IyIQIPfsGNMvHf7J451mfw7jvz8ekP2y220A2HLbu20rbk+km0XzTSgAAEkkAkkN+TSVxN1nV3d+9aattt9GmGk0fAAAmiu222pO12221NWq222pqW20jTDSaEcAAEz27u7ugt3d3cS2eyTCR/kO/jWwaSaONuAia9b9IsSelQOickkkkJLskkkJ3ve96XYpTTggDSYENpppFMCAdnpJJ79UlKrbZGncTWrJJImvwrbbak+2223rqat3bbamrZJCNO4mjeAAAmpJJJEnJJJKq0nV2rt4v2+8zndb3tHD9pNzvd9zvoF7bq5bQLLbbbTcl3d3d3YgDQAABJd3fDh3vehaay2239WmYk7bbbamhYABYmpJIW1NW22dgtNq6tttraskklqay2221Jy2221NT7k5m9ffj94FfHeW407baEPAAB4LbbbSySSSW220APNNIAADOpzGec4dTQru7u/W05STu7u7tqStttgDSAACpq223rauSSSVRNSSSSJqSSS2poAAiautZnMTSWOpYtb6LuqrmK724bTfpizs7ab9AMbDTTz3vcTfveqOW0TYAcskkk800qASQIFNNIA00xABtpSuc5znrba73veSfqmrbZOw0msAACiaAACpoWW222JottttTVttttTUkkkiTkkkkTVyfstOLWu7TSU72cX5Yp8e9wvbddl99d37wAFhiS7u7u7l3eE3d3dqxppdxppAAHveLbbbb+fe973vvyakkktrbWrbbbW1JJJImpJJJEnJJJI3JJJLUlq222JqySSWpqSSSWtJ8/LM+75dXfGc5399w9M76U/AAB4LJJIQttu7uQTaRWE2BopJpFmWmkQNNNIPe9xppez9mJpL9+ckne9/VtW2ySJqSSSRJySSSJqSSSRNSSSS1tq6tttqaskkkSckkkiakkkkTUndqY2kuqrhxV/IXB8Pwa1qSrf379HM9f2ft01+71W2/WgBLlttbVoHGAAHmml40BlppAA2wCMANtNKNvHiSSd9Y0krbeW2tq22SRNSSSSJOSSSRNSSSSJqSSSRNW2221NSSSSN2222zwEV77rd/vNIPzSA1IB6Z8ICVrP21M7duNunNTEy7Mn6842QDev43zxfJjPejfXE3fz5JeaBEUShJoEY0CH8yAo/IumI6tDF1rYlxDbRwnNbRXJGNrhplzcW5w5rbNbnKhyrYRoUyGSNgd1yrUNHD7yuRZttVaTdmnk6a6cK4zlI6chVyh5/OpzXRahphT3XXgF2D+/dnmoeeUP3Xch3UruRx20S4IyP3LsjoVaJpG8yfeUPfH7pB8ojojZnx0R1Q6CtlHWoc/cKHEn506R1uvKHhe48/kO1XzUOkXJmmbMfvP4zzSppldtNJXtXd9xbAtNJBgsKxAOkOh934DYABgVW2ziAPuAHxbbbbQPGJGM1pveNXXs+57nuaDV+tvL4C3MYEkBu03XN72HQkkkkm0tTd3u+bvV0DgBAAALQAABd73veL1Pe5rf3ve94ACSJ/Yvg++STA+kgAAALakk+knwAcAA5bpp3LbaAAAHXMkkkAADv3aYcOgW2gAdA2a6XVt7bQAXcA+C2NpVNpLE2sy22gVmABIpJJAAAAIlxXVv1tp5tJc0L2e97vveE26hYaaYAAK4g00wABN8s1JJKAABwA+adt+tt+oBA0EkimkmlLu9Xd3wV3ayk0lDfOcAAAAC23wAAAGrammnbe2gAAAG9223vbdJtI+DTTA3CGzNmmnu2/W55ermGnJ2amUmkJpK6TSQZAwBi7vlvoGkmkAAQ1bbb202gALDRpppBu22XtoAAABq223toAYtNNI+vTQfcmjzbT68SaSph8QPeAAADUHGpOSdFcaYAGmmkFAIGLTTSAAJStmAABUYb8k2+cXcXU3dZmZt7zn2hiXdStqZZQ4uUXMm+GhBjttIC0wQd96dy/c7+/egSUJZjX1O/u39qdJbb+/W222gBbbfrJoX13d8u7u7u7nm373ve9vlUmkve973vemt4cUbCCiqL4kqOrtgYqKRQiwlsmylbNmd99+EqvpjzrZbNrNSmwW0ma2tZbbVs2ZmtsjZDY2WyZMrbWbZhUWKorBYIMFBVJFBZAI8xLMSWZmYsSxYrq222pqySSRJySSSJqSSSRNSSSS1tq2/W21NW2STQW7u7u6I3d3d3RHyk1hDg0o9k7Eif79qJJd9C8TdvtySVN20OBdJu2lM7frxXFbqgAAAAAAB5p+ztyTWtST34battttqatttsbUkkkiTkkkkTUkkkiakkklrbV1bbbU1ZJJIjGlsZmZiRu5f6KKCorsYkwYCC/0KFvhTt/WdnrJ33k/wAHjL73vAASeuk3d3dlQaaVga9VJpL3vG2ml72PUk0ve8AATp3vOcOJrnOc5y+t97nve99bTqlVOsWY8y6tttsx5izHmWySdUx5mY8xVK+j3ve8eE22mxtvAfvSe972nmmxjwC3SttjuZizErZJJG3MeY1mpU3bbU1zGEm09XrVtlJvVLgEv2+WJu7v0k9fZJJCgAB80wt+tttAPJ+zSb97214wBkm5JNHqpNJe97K73vOc9ba73ve971J8kkkia72SSRNckkktbampJZE1d2bu6kXd3mYCzMzcwRpu7uYI8ZERb3aPOiW6ugxNjba6EGNBN33fvzPZmftzfv1+Vtv1oEAACS222gAebbT973vABJBppABE3XmyX3vuDbXMc5y+9TU73ve9Sfe+kkiakkkkTUkkktbaurbq21NXkkkiTkkkkTUkkkia3zS179v3vF8fNP3v34tpbbQAAAAtttkLbd3JJJFJJJPNNIptpeqk0lj1NMAPe+5nOc5DzTxYlbby21tW2ySJqSSW2pq22yRJySSSJqSSSRNSSSSJq2222tqSSSWpJ7/GvC6+rmLv2gp+qbvtfZ+XgOnU2Bt220TYB8ea8HybKYDT5u5vPB8HT4AAAAC22364vNPM/JaySSeraskkkbUkkkiakkkkSckkkiakkkkTUkkktbatv1ttTVtkkiTkkkkTXpr7JixLe/j2L36fv2X8WQNUAtvgADoI3+94ACT1u03bb410ACAB72JNIAA4+c5zhU1FJJJ+rbVt+ttqaqy2STquLMWZJJJIlixZikkk6pmZmK222y5mKSSSqySSW4pkySS8TeTcT1oPgO+/W2y5bbQQAAcAAAshbu20OgaTYAcDQfkHve+/H78RuZmZ+zMzMz43d3d3MzMzM01m7u77Gnlttt73ve97VJJJO973veyW223tTZJ3QRfb+az7XM77m/vfsv7dlwbZwA+ABAAAAW22yFttoAGj973ve9fettGIO7vCVm/vTu79uZhmZ1Pd3d3TMzMy7u7v2ZmZmbu7u77MzMzNN3d3dzM3d3Zl1+/Vt36pEBVx0bWTVfvSfWCCs2e3hAZkTuCAnKj0Ovb7u7eiMtICH6yQYa9vhKeqtyX5332+++aCPooQHyQEO+pUiGQ6GRkK3PRxPvMQE0rfNAM7NMuJRW19TxKAAAcAPt913v3e8AAzANTN7A2/fzze39L57HpHZGI5SpsI0Rzk2xtkZDUM0jGZNs1m2a3NcxtNpqGkbU3XOaRpWlTIaNhtdnarjSmkDN1I4qbSVs/uiLjJXbs/ev71DndvtD71rYjWRDkOcWSWiNrK4W+2qOb+7pH3TsPnXS8Lmf26VPrUE/sZQhEAkoK++QpSOV+mEC2vvsj4fwgkn0nZde0bABFDPrbfuWm/gA4FttttAAAAAAPgPXMzV1vGurFrPX3OcN5il3e7uySQDCYBG3nt1fddXSyYkACQE3bbbJQNAAAS5bdWgcDQAKSTyaS6k0s7b9v3ve94AAnOtoxeMxM3k0MNIqGWlZWcNGFMYYWizMWba1mN72set287AAAAMy2222gAAAW2220AAAskkkKgANe973vEDyEAcAAANJst5bZ9d0DiuI1A4CCtJpmAABWkkmYAB9ppyT6Ql0fABwA+bYAcAPJtrnve97nve9923V+ttgaAAA51N4m+pvra3Fn330kAAAAAttttoAAAB8Hzt5by693KjM97TT57197oBbbbbQAAAC1tpK222gAAAFtttummlQAIGNNIAqtlVtoAH2c35Nt+973b6lttt8AAABjTStttsoAAABbbbbQADTTSAA7bq28t006XYAAB5tgAAeAAAMWngc++5pJtPnAAgJtIAAAttttoBA0mw0aaaXd3iklfwgJz7fGIWUJd74S1eGmJA81hWKvkqxVyslchwUcKNSeXEq883d/R91HvnK/tftHsZjSWsSXsSbmNfb5uTfp63dtt5bfW2220C221SFttoAAAABibtttvOc5x8nmkvyxpW21WzeXMxK223tWJVrMxO223txKtZbbb1zHJJJ1td73tm5mZmZGZmVmePCr3ver3vTDaDfT3in6vb91N/roQAH5N+97YwA4mwKc0AL5NyTcjT5MTczIBsAAkAMhCgAIbxN913ve+1JJOSakknJNSSTkmpJJyTUm7t7sbu7u7qzMzMvczJzNX6kKGMQw973Lbn5TWvbvLPZfr+9Pe1QAt8AAAgALy222hbQNgAdAAAACd73vD8u972yd73ve9imL9bbbJjTtv1tttskneXd3G693b3bu7vc3XL1m7u15oW/hx++ifvve54/T3tAW231ttttAC22SQ2m7bZOSakkm5JJAAAv3e973vjvOc5zrXK5znezqeTUkk4n3O973vZ3ve9vWnK7bbZJJJV2SSTve973sXJuT7X2lvPvc59y2fvwW2220tt8AHve9622SQ3baHQNGNMADoIAAJ6d73vuVd73fexKY/pqST9xty222973ve1drbk1JN9zve97FJJJO85znOxZJJyS7TeJpLansAF0/fgA0AAS2222gBbbJIW/g973ve17xbe220ALeySfr79LbZOd73vexSSSTnOc5yRZJJJznOc51diSU3Mkl+adltts7JJL1TNNM9Fs5kAl+pplbu7zdyU05MSSTUqU05JmSTN007u7aerxdzMk8bAACySSAe8Bb6ySeF3veyTve95zsWSSSc5znOc5znOfom5JJJ2ySSqSSSd73ve9m+bm/k64apbBRrRTUMAP81SuIa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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
