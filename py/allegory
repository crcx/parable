#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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ppt0AAANHG2kgAPUttkkLb2ngPdAAAALEiCB3Uu7u70kkkjbbbgkkkjbbbbbbckkkkJMUkkkbkkmSSSSAkAdVFJN0aS73qTSTfQDZAD1tttTSapbbbWrdtGk2kaZpBttgFtid0mkpqaSTc0m0kWQvrbQAAALEmmraXd3d6SSSRtttwSSSRtttwkySSRySSSNttwSSSRtttwkByiCcdGKaSTQmten3p80k20vvvvp60AbYAHwJJsAAttOJJJAAeAaYfGmk2j442kj29NM22kjSbSXgA9baAU0ABYkm27dpvVttJJHJJ73n73vRSRSSY222w223G2293d1tNttxttuAkh6tFPclpaqAv2FfvXvvvoeoX5fHAPDC222pXe02kroDiAvQttttu0aTaSLbfrbQA2mwAAiJBIMRDqSToW224G224CW5JJCRFJJJG224JJJI2224SZJJJADJJJICQBwISQDQIISIIHdc5d3e7yBPdbZdBppmgAKTemmHuAdC3UkkhKFukBw0mzRwL8BAAPvNNzakkhYpJJHJJJN3dyOVJJMzMeum25IJJI93d3czMkcfu3pe4SAAA7vmn3e95d3d1+saoAFtpxtLhtABCySS27bSQW/Wy9tAPgDoHyXte973jzXve970ickkjJbbbjbbbgJkkkgkkkkEkkkgkkkkEkkkgBJ6vWBd0ACAQQ0SCEtNJNJI02w6G3ApfW22pJKltttt2jSbSQbAPfaaYcafLbb63bSaYW2+ttAAAAvFp60om00tKSfSHqtSSSRttttttttttySSSSSSSSSSSSSSSSSSTu7n2AEARUiCBu2N3SAC21999fetAA20wAE20Sq2223ZppNM00kkwA+AaYAfVGg6AAAAAAAFiabaU1qSSEkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkjfO/fBIB+g/JoykBFf3FFGMiwUgoLUdOBKJmYMAiuOgkd3P1sgeZmQ6Q6Q586Q33z39757/nou/aAXf61kgHukA/WX9a39+ZDSe6WGnGTcgEceas2qVOpXGLzl0w0IOYYGOoSBISRqqxds3uzSIkzC/M4QK6ZttrKbCWybFHF8NbWzrn3MOCKBxqIkhWTrj+JsgGyAVe/PdaME24xRiPaWIt1AkkpmUqTGxlteYQkMDCQYpEWBpsxo2fOx3uo470Q566Q50lcNez8lJC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O+2mwAtvrhwAKaAADibttz2e972VKpP8tPSNLZvbT7pmkaNNmkaTUuy362xNGlrSugLb5JJSSSSNqTckkqXk0BzvdtPSNmjXQ4k+Ja1rTC3ttvda02tCAABtmmnrT1pJK2222uIcQ04wTS3hResvT7jAG+4q512q1p6qulPfgAzAAAAACSSSQAAAC222Qvm3nskkzEql+009aWtNpGmkaa5ptI18bPto2caW9LTYF7bamhAH1t4k5JJJE1JJJKlU1bs00zXxs0G00FhbamhAFtqTkkkkTUWt+9Pk0lPLia3zf33vPqXtJ+1v3tyXL+0fBeO21W0C229vbaePETd1dtO3dtp8AAAWho2FvrXnskkglW1bv9pph4Dzai18AEATVttkiTkkkglU1bb9bamrqm2mFvbpNCC2gCattskSckkkiarPMZ7h51pytwk0tTddqq3F9oDXCBBOQzhmQAAAACSZbbczMw4AABbah3e982239CRJ+WQeREk/ABgYQAQRKQAegcGnrSdtEW2tI9vYAFqakknpE1IcadoBxLya1wLQBNCttkiBbfgTJICIQAORIAtUvkJYGi/Vgu0CfZnh72d+V9B74DEQfsF+54GkoyDl5LSb4s7cFMzfqmzQAALFbxAAeyAFHAOps3WtdAAO9MM5vHOcCWny8JvsTbb8mtHi0ATQ5bZCpP0ktu4mtOpySSJftJi1M207bepsTc96SZU1VbZJAC223ICFERXq+6rSQEd1qzBjpILmtbiSn3p8vzblyXDM2AHb9eb97xLyn7Mz7JmZ97A4Ju22/kBDTTzN5mACLbcC3DyxL7777Miaq1X+20wAPJquSW2191rSSG2IAAYtaTugACJqqSSS1tGmnbbb5tVSSW2pqST3vNo0Nu222JqL683vfN2/W38L9nszOevZJyZcy27ttoQJJlu7bmZmZmZmZgAreTTTmXPe++z2WVNfaWmnp/tNMNgB80t6kktkTVQmwC2tqakkk83rTqbkkktbQtNOmwA+TQrJC2poVtskSY25J3vetrE8mc4xnWsRovmwk4JTgAqVxTMzM4ZhmZnzT7mZnc9szMtttkzAAAAAAttqjbz3vZJkTX7TTtsksTWW2gVviEAFqbulrT0ta0zVttti1rWm3pacFbbYrpLWk3rUV5xp22h5KaVtt9ImoJu22Rte1JJCxNc99Eml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RwrCMttlrFnUpiKrKKyVopYLFLdb1vvve973ve9707IC3pSST0OAAeABAAgDrTAD4DNazPrby301mAAexaWkm01mZ0AOW24eAACSSSQ4AVruju/F99I2kom0tNNzW9wtA+AOgW2220AAALbbbaYk2lmZmZmZhbbbbQAD4MOtPN/NP5p8afGn3MzMDoAfAAAffe+afrz77v0hQBpsTWmm3oAANaA37YePg6JpLE0msSaW8zMzMuaDbTLbb62ge++/qHpG99999/fvyH5RZDWaiWtW20AAA2BtW31vrQAAAC223TbadtAANVNJZ3XGnnczMpbbbcAAAAttttoAAABbbbbQAAAC22y6tAA0CACfY0k6mkg1vfQDMAAANNNI8l3negQDobaYHAAttttoAAAB8OeTeu/W/b518ek2caoaJuHOWVNpI1YZTTxDSSakkwumKpTydrUOGnaw9w3Z03rM/fj9MzMzMttttzDQABmYZgAEAy5pp5pZmU0AAACR8aaYfl+baa1paRVWIKwFBYoJEFIKoCy1q1mxNprLWR3yEeu+46jyM0qqjZKtmxb99/zsF2ZYyQQEVB9YTiYIRZ77WtQn3332k0IC0ATVltkiTnpBN22mtaSWoQAKkJKw71p229TQgLaAmrZJ7yautakgm7bE1uuXmd+XfubNNMN0/Z1cpBghp7AkODSk3DITYG6ddczhtzSSVRQZkoyGkwAAmckGZNojNCkOKU2GAM1MzOlnSWCNm+dOpPvLy0+973San2rbbamveJJIk5JK27bU1frbbamqpDrTtt6mhAAAJq2ySRJySCb7u4ERCdLAoYkk7sIDM/Mqi/ea7z9+ffYwAOAIEAZqqcVVZ5VTRgATdYqqqggAB+zMyZmczAtt8m/3u5JMytqzf5XW2ndXS5bxNHdAdABNW2SSJOSQZPd3Ajt7u7u4eQSKQAHlXUKQHVRB5dq37i1po2tAdAOjStttsSZbbbamrhNJYE0lhWoTSWsaNtsCKu8TWwrNVQW2/gAz2LMzMzMwC222wtttoAAGZgAWzLZMiaFfwb+aZoNmk1bbQATQFttqTttttqattttqaurqm2mAHyTAAAE0Bbbak7bbba2pnfbE0lvMbxvOeGzgX2wAAqqwm0lVUAYWwttwMLbbMtl1bQAAAEgCGW22zKmrbx/jbTDbNGm0AAAJoC221tfatttsTUktttTV1bTrTAOpr7WgOAALzQAACTttttqa9+2+cdVH9QyCs0omZbJmtGKVs1tY2lD+wicq/u/8vt3e7uqqqqqTdVaVxEO75d3d7lFVVbVVR1X9mw8BwLnEkAGgzMAoY03mB5Nnkabbfsk97LU1bb++aYB1NAUABNAW22pO2222pq2222pq6tp1pgHU0BQAE0Bbbak7bbbamzTT1DVmma2Zo/zD/Orhv85FNiSbjDbu8q6w27i4eb3ZfDm8ZZHcpvAE6EYw2ku1VVVFKZltzSdxCggDN2sNOP32Y2wnwB+3hmm3ngL0AAC26vatJ4mtZPSTKmrbf3zTAOpo8AACaLbbbUnbbbbU1bbbbU1bQ180wDqaPAAA0i222gtaetNPWmgBAAJHPUJ+kD8SZN0CjSAIZq6TPzn35+X89+wAAMWYszNJvMzMyAcADAE2COgZnwU0BcAAKZvAA/WfrJP0TQrafNMA6mqvW221NVySSRJxSSSRNFVtttTVm4badtvU0L1tttTQpJJIk/ekkkTVTSW96zeZmGLWH72BwAMDaA0AZQvAA+RmYBAOFwAC4AAAdttmTJJLlTUk/dadtvU0LwAAJottttSdttttTVttttTVtp80wDqaPAAAmi2221J222201rS0lnCmpy27jOtbtajV7MXOZuQKCqqZGkqAAyoDiQB002zWazNgB8AZmZlzQAAAVUzM8bZw73vTqaJmbqONOqrKav1tttTVkkkKk7bbbE1JJJImpJD5p206mjwAAJottttSdttttau987/z97EcIYrFZ/iGodeOUO0Pvzfu6HO0O3qHdDmQ/uwCTQIAyh7csBZ1DX6+azsPIAgZmVowN8sqGDzxc9swMIAhApAE7+HyNCvqJggwKgqQfpiq9+HzrEhxsojPqDeKLoNbTY2WK7pWzQxGyhqRyaqpyiyKahxyZMgZLhU64Vcoq0oxV5rhVgwVirnokuQ4nAXKypXvbq0llDSK0NdUF5x1QxHUMfcSnVDSjq3KH9xR+yCvNSS7ofj50d5S72sZbFMqrRLo4lWIyg2ZblDcJxwThWwcD6bq64oY946qGbM1isWQ6ofOiPNQ7OZcqGUMGVOzik4nOcxVkrZzNibMZc1Thp/c6lnUW1KNiNQOFWrmbJPVnK6lXOZM1tsmzMoZRqRuucSyGzZUdUMo/uhTqNb7kuP3E8JACJP316ECCOVAAmfKfUSANBPvS8kn0w+3wE0lz2wh0iA0e0ABQABA0ymgAApoAL9YmkrrltpmZtK6STSDba9p80tLWTnpM9ni2++5bcAAxZmZjTpO8dtvPrhc8AAGpJJPWmwNgEDagAAAAABU2ST7Emlq3cuZmYAAK2JfaSbWmtNJGt6S0tJJo0209729aDoQAAAOyTkkgAAAeLu223DMzMzMzMzAALbgAGGk0l9FttpZ3MyZmWrWrcACj0B2ScbaSkkACtmmtaAC2JNpXVttAraXlpmg6BY0q9W22h4DgAR3VtttPsTE0lptJaW1m8zuZmZTQAAU0AAAfW3lttAt3aAEtpbtp23hoC03sAALbbbcUm02kjM++zMzEAXltt+tAArSaZoALY2k38tLTWnrVere2gDbSQAGgPW7stt400gAPAAW297TQHvvHgOcxppZmZmZmYAB4DiTSAA8FttttAAAALbbbxNpWgHgNNNIALZdJtLmmmlxppW20sqNNM6AHwYm0vmmwDoEzNpsAADiaaRUq173vJ+JA8AAAHDTTtt7bafIA6AHwXuJprvLbxp36rW00ttvaT83Z0yRah0a05VJpqT9x03Fnu5DJ/EbSs9xd8ZMw0fvZgABbjTAAMpoNsA6g3mswACsDMzMM0AAABb9dNO57JJ7LWnbb/D5pgHU0eAABNFtttqTttttqattttqattttqaAAAGndCA51pgH3yTDgAAk2lyEqQsmYzm9nCGmB2tsKxUNOqrtZnNzM7mZmfVK6DWjTTAMy9Nqn3GmEK5QFVVCAApNkAIBsDSN4iBTjvez2fq9aWta009aNAAERpK220Kmry0+aYB1tfI0AACaJJJI2qlq7tttqaiV0rbbamo1dK0+aYB1NFtttqamHoIxlanZ0u5rF83u7AoCZmJmZnEm52c3JIUzE3mNvM9mbzNgAFNAQNhmYAG7VMTdvrcqattttqTttttqatttkTV0pbf3zTDaNJqfSSW1tWST0gI4d3d0gBbbbYIbbfSAisf4Ce/B93JM3nIAHgMYAG02BgEA6AH2AAeAzMuZvAAC22SQz72vc/aackzqav4AAE/ta00AdAOmmnrS1pp60aAAIaaetLWmnrQAAU009aWtNPWmAAFNNPWlrTT13YAeCmmnrS1pN60AffQnve9rbCKLCL6+973ve8fDCIiwj73vb973vbFhERQj+X3566PwYpWfZzm/a3rvV37Fm8/ZmYgCGrgABmZbbbbS4W224XAAAC22SS4vb973sz8LWknpaWtJPQAAUWtNPS0taSetIAAAWtNPS0tAABWNgABU0AAAJq20+aYB1NAAADaALbamrbbba2v29Tvy93v33A+JZb+AAC2222gW2220uSSSZc5gAeALbZJMXx73vZlTVttttTV1btW/uNMDiTPgAAbRbbbamu2222pOSS22pq2222tO6aV0ldO040wONs+AABNd57FrnMOn3U2ePxj97DNZz7TT+zD76223AVt0m7bbRS5bb1p24GNvM9mHAC6oAkBfvvvvvoYk7bbbamrbbbamrbbbamvwAACattp5Ngca6tNgB4A7p6WknrWtNAABULTQAAVNW2221tTq1+XDmZmXMz9rPsA6FDabDgAU9OXltv6GjMTeZmZ6hwAAAMzMD4LbYm4vEkmZU1bbbbU1bbf3mmBxNd0tAAAJq2222pO2222pq2222pq22nmmBxNdAAATVttttbU38t64k0htJftp7oZlDVX9xQ4q1DztX9/eff7f2s/bul+zM6mBy3A+RrabDjMzNy+tvsDAbdv5tJU0gP2Z+/fsAALbZJObXtP82kv2m0lpTPX1/fqmrbbbamrbaeaYHE10AABNW2221J22221NW2221NW2080wOJoAAAbQAW2pI1rT/a2mku7TSRkImt/aS799z7vbnsh9+6AI+AAx5mZmZmYAHWmAHwAAAAAAAAAW3ybupimW24VfnptAABWkwAABu6erbTzTA4mgAABtABbamrbbbak7bbbamrbbbamrfvvvchPe9hDvj4dJAPEkQCKqmd9kISv6IAwCY7toAOm7rdjQMS2oVKWrfXeEAsxknEkxCOWQCok0lYChvRAP1vQa3WKqKqyCc3MxkPqGhbEd+/0+/3Pv6/X7ZbC/h32ta/PXuvBAfYYZwxwwgCENBF11Kd7xMCPWKvbQZiA7ecqUZy4Ue9c3zq46vevsS8/VEJ7upIAlC5CCSMIKIBIF683MOjvqig/Wlskf2Q5jK1U+6oP0jKP2/TKXv75/EffEi+Yizxh3ReNP07zknVh8TE0l3PmmLLO9zXffZ26z3uNMhwIcKmkvHWnwPu3aoG2n0Dhz4NGZxp5MzNZiw207bLSC9cTVRiIqMRDahHGnjfOBkKqqlYaeMaTec9rfvent9O0guxd++F5M+Q9woE60+rd29U+f1zbTDdOAfBtp+0GwDhom2nTh0DYbaZbe26uC40zMzN57FhtpnhrS1s3PosTSXPltNJebSWm0lfmnyX2YYFaewT6ve9fc+RBItAEFpAgBEEcgS+zvQ8aNNM0AE97l009mmno+4BJQBQO8Ahr2rbbfURwOgaD7jT1wdvb6qYe004oDQdENJKTDxjumnBqs1VTPWnjkNPV5gBDSO7ac0HD6/W7aeru2gfFaONP3DgfXljaTa4tJaenetPdvLS8Pkq9NnWnwPuh1bsa9q9ae776/U0G2mAB4V007bbbBfYn8s608zJkzixXbTtq5eW2gTQbD4AZ8HNgB7Rtph7gHQAPb47eqgSnwB8AdAAttttxppNYkkk81mZmZmffNMA6AW7tACVNpI0AG7Ymmkrq31oG2mkEDZppkOnNtO21d+kAAPgALx6ttvGml60BeAmJNJZnFmZsIY09psIHgtN7TYcACc9tp3Vt9bfG9tMNnwB0N222+3aAEPHGml0PkGt/ett9FQAPgEdDdxN+A4QMzbTAAJoKc2kl3yXu+77wB5AAAAACDQB8HAPATYbhPd36nTcID382yAb/NvcrkUa5CX158O/KJ6WoPZqLrCvZGhOoF56xT+Gp8lPJpNJ90k0u8ur+n7979gugB9a8AAMzLbbbaetttw0YGZmXMzMzMbeYAASY20lf4bQbbSYHE0k/2k0mv2m3VppoAAKk7bbbamrbbJE1bbaRphtNXttttbVkkLamgALampJJJEnJJC2pruv26BPups8fX975VVZTdV2tYliWaqqqiQFkgITYAZDt7JC3A+aeNvMxZmZmAAABnvefvezKmra7bbU1+AYACatrtPJsDjaDwgAEooAeA4mqtW222JqSSSRJySSSJq2222pr11rDnMyZvM7+zPsynQtf4DoBmeuAABmJsANtohmczMuZmABTQB9beLPs++/fNP379xNCCAAJq0t+tvG1bbbbU1bbbbUnbbbbU1bbbbU1bbTzTA4mj4AAE0W2zMyk+w2mkrUJpJtYjCDXADRU6lTM6t/V2220C2222lskkn5tJYGZmBbbb64AHPsXr2SZlTVttttTVttttTX4AABNW2221NAAACattttqaAAAGgAABNAAACTSaZptIftCuBpRe/PP3dQ8ZDaiWtJPFppo1zTaTTl9bfsz2Tk/F1bbaVW3A6mwzJntgABltt+tvMAAttttoW2me373v3k3P37iaAAAG0AFtqattttqTttttqattttqattp5NgcTQAAA2gAttTQAAAk2pbxcek0lpLY+LSWtPvugX4/XtVtt/VW220/ZgABbnrUkrbbS0xppZmHdaSaQB1NpBszNZ1JJoA9E3+iv4A/fqmrbbbak7bbbamrbbbanNJXdskiaoAACampJetO0OpM8BABNFtkkbVa1bb9ba2oZqTvE/t5tX7Mvk39mfu5bTqbC8kUkhS4BtNgeQZBW2TpM6maaaVQ09TVVR0CQSAJTZcQmks1v5IA6fsrQAdvmnbtNX62iTDZoTRu222pOyS22pq2222prnZJJE1S20ATXvekvmnQ42tnwUATX6Yoa13v3NLTetJJa++xN/Bl5vmfv2BLgBbaAH7PHwB0twTYW2y6txNpGZmHv2tJpIwmABxppF2G2mkBOuc5sOJqYpPe9222xNROSSSJr9JJ35pybTRrokkaNAFTX0kLbUnbbbbU1bbbbW1J7x805Nmk0a+AAKmrLtJLulvO5ige/YAfgDAAApgABblltttC5jbzOZpJpAcQAbMzMCc/L9J30n79W11rUlySQEcO6SSAhvgTJ5gAd1EWu65JLU1q2SSJMkkkiaqttttTU1JuQ4ie6iD3d3d3cCLVq/d7HLGbJBCnVJBBm/Bb+MLarb+xAABTAQAW5bJMmZKoXWmkAAADTSJDBtkJNpgH3zXt+++zImpJbbak7bbbamrbbbamrbbf0aYbSYAAAmjQAWxNW2221J22221NW2221Nfp7kzf7ab2mkvvv1PPdfowgGXVoMrkxkAoqQiqfe0YSaEgCbzu/1r9b50IDfsIBTmt5RGu9wgGsCkAWsgFROewuczadt1v2jmwkNu9cW5M1DWXO5eFu6FNxfZSAIO+7D2zlunTSANe/H2EAdNIA1DvvJqethiiEqVfn3re5+YPt53+Vqrvy0Ib5zv46DW1KfW+dEnVitNUMm2zRaz7i4pNIyGpGyd0MyV9Vj051Q6IXz1w46XnUF8s4wqdQmKrZtRMn3kciMbQNkjKMwTeofeKOmVbQtmoZDWlGI+UMJyZqGatpGxNjZJtUNVS5y5Yh8Ryofco6wjLaRm0S1D9kOUMR/mjmNQ8OB7iXVlWSjSbCOYk4Wn9qHJpC1rYStKtDTFWzZbNtrFWXfPOhzQstmrbWgtqNrWptSdtOZssyK+cUPeviSaWt6TS4pvum0393fdNhSJv7OBbfrmYAAGuagYmku9zMuezM5znAAJMAAMmYBoAt1ZbbSmF2kmtaae2mz2c59mZMzugA8AZnszM7nvvvvvszKAABTSttttDQHQCngAC0AAPBu8ttuK6BbTSRzPvszMwABt21XSSSWtJtJ602+ae9JL7dt7SgAAFO229tlPBtpmgA4W2/W2gBwAD1oAXhsgdIGJpL6e4mkj2e5mW5c0eAOhQANltVvraAaBAApa01bbaAMAAsurbbQAAA563dv1tMTaWZmZmZme+t5e22gAAAITYmxNibE2Nrq73bT73oAXwAAAW3ttvaAbDbTAD4OnOu7advr76zE0lN7V6Z932ZmHAC/W220ADcDYAFbSUaeru204HU2l1ppcAKW0200rbbfWoAAAAtttqtDQAY2kvaaTTzM7mAS6ttwDjTSAA8G0/W7tvrQ+AOgHg3bbbaAAAAWTUkkKU0k0uNNI8Bw8HcTSUk4m2xH33vBmAAAB3ve9AAA400gAPAAAAAAAAFvTv9357v5X98Wflcaoahs1DZFkNFtRMhlsibNZfvvn3973mcuuTaSWt4SjvK6W6ro5mbqqAbYAGZmZmABbcskkhaAAflmZ+7rSaS/fv13d3YiITSV3nKScQl2F3usuISTiG13uJU+53L/OBzAf5ynE2xts222s2athsFtQreeedeeeeeeF5553bbU1bbbbUnbbbbU1bbbbU1bbb5Gm2G2uIAABNW2221J22221Nd0pJWcQlEahbE2LXcdO6TZIrtbHABtNlUBhcAMpsAK4VQmwAOT3va7MKSqAKqqqhpg2wAAqU2d73vekympttv6NM0aTQHgAE0Bbbak7bbbamrbbbamrbbSNMNpoDwACaAtttf8fTSAAImhaaTSv75aWnpfX797gjXfe/gCPzwyQ/cLbbQDgfW3lttTYNuZmZlTI00qAAAqqqgAA3aaSmk3rltt/RNSSSEad0mry222pr8V222pOWu22+dTVq5bbampZJCNO6TVEvb73ve8CI222AW22+EI52GfwhYNSC029Mxt3BF7+rwFsPxozJiYAAGBbgAGEkkkgrpp0QB1PMwz5NNLNPMzMzM5L6dkmZU1qVW2/q0zSa3ZJJE0C1bbbUn6ySSJqSSSVVNXdttK0zSa2W22gmtW222pOW222premzw2DJqX5b1a6u7Hb35QJjdtP6e9z7q5daBZbbaWSSSTEAdAzMzMwAAmSSSZE1ittt/VpmknbbbbW1bbbCpq22gAmgAvrptSSSSqtq2222pq2222pO222xNVd96e1zvPvx+8CuHvrdNO22hDAAAwLbbbS22222222gBjTSzMzMzM6E5JJlTUkkn6NO6SdtttoNc3sACRNGrbbfJqqSSSIFttvoCJJJGCG222CPSSSdxIpEhKOpYlV0VaiOYjvaDabusSdrspu6AxsOtPWZnybzMqPraJsAPrbbbbjTSMwADpQQ00gDTTAA2mt73vd9adwmrbfW2pq22T00mrbbbamrbbba2pJJJE1bbbbU1bbbbU1JJJIk5JJJARynynsFVtggB68HwQf3vvt9z7qc6fnW/v2ZmZlzNhbbbbW0AbTZ8wBGNNK6aaWZgBmYW22238/e973s/JqSSS2ttbttttbUkkkiakkkkSckkkjVttttTWpJJImrJJJampJJJa0n9+Wtd9i8vYa++9+78ZNeyU/AABgWSSQhbbbbcTaRrabA6aSaRmcaaWGZ1ppYAbaaRFxCaSu9wu9z3nOXLamZnve9TXeySSJOSSSRNSSSSJqSSSWttXdtvdwI6SSSAGSSSQESSSSAiR2IiQFxa3iMa2NOkhRKXYfW3rt3eKhTs5fersSXttvbQAl1bbIW22gBjTSzN5mcaaQANsApgBtppU28WVVVXbkaSVtv1trattkkTUkkkiTkkkkTUkkkiakkkkTVttttTUkkkjVVtttqIVz6c0/zkSB+VRIA6IEAVwnwIAsUuQfbdyt1XMxXl1d/UxMzX4UAA/Z8HEz8US/n2d+5c3rZ+PpJ8wIXZkJGBDqBG/s4UeoumI6tDF1rYlxDbRwnNbRXJGNrhplzcW5w5rbNbnKhyrYRoUyGiNgd1yrUNHD7yuCzbaq0m7NPDprpwrjOUjpyFXKHn86Oa6LUMYU/tdeAXYP792eah55Q/ddyHdSu5HHbRLgjI/cuyOhVomkbzJ95Q98fukHyiOiNmfHRHVDoK2Udahz9wocSfnTpHW68oeF7jz+Q7VfNQ6RcmaZoUJVswc0oaZHZTSU7UzPcSgJTSQYJzNbMzPEPB33QOAAGgqttnyAO/AHS2222gYaSNJG9t80ldmb+937Pthu9tv1wC03vElmZU373332ZMwAAD5Lp9b9ffXtoHwBAAALQAABe973vllMz7fO5mZgAEkT7pdDvUkwOyQAAAFxSSdknQA+AA+t207q22gAAB5zUkkgAAe76mj48BbaAB4Dhvxd231tABe0B0LY2lU2ktJta1bbQKzQASKSSQAAACJfK7t7baY2kvtizWZnszBNuoWjbTAABXSDbTAAE3ZJJJfgDoB8Adadt7bb2gEDYACH1JpFt7bb7FLVxJpIzvvezMzMzMAC23AAAALammnbbaAAAActtv1t2m0jobaYHIQ4a4badt5by3tNtMIdOJNLE0ldJpLM5mZmZu223IG0mkAAQttttpxAAWGzbTSC231toAAABbbbbQA0ttNI7TQH0MbafnpJpKmjoBmAAAB777774EaadADbTSCgEDS200gACUrZoAAKjW8SbckkW9KJv7eta1rV5zsq1J6EbFpoq5OFOZtAgCA1qRIA0oAgffdce95R/fnqBJohaa+Pe/ev7c8S239+ttttAC229smxdtmeVVVVVVVVtu7u7vfIhNJXd3d3dbhUqjEgKKovySo6vzAxUUihFhB0toja2tfv37tA/zLzNptbMxFtVNktZszTbY2trWs2yNqGxsthkyttZtmNkWKorBYIMFBVJFBZAJFAJABJJBAIIdXd3d3AjpJJIAZJJJE1JJJImpJJJa21be221NW2SSIGSSSQESSSSAj42IgKVCDBzuVYJ/P24kl7IX5N25ySSpu2h8F2m7aU169vyulbugAAAAAABjTzXrqTe9yTPw21bbbbU1bbbY2pJJJEnJJJImpJJJE1JJJLW2ru222pqySSRLyJlNtskSPfyswDM80CUAgAQM/KNC36nr+s9MsnsxP8ABhq5mYABJl2m7bMkUNNKQNXEJpK7s200rvFwk0ruwPvvvvT6Rt/MENtt9CPzuzu7pxBSKQSKQ6u7u7nxSCRSHdJI4ikkUguA7q7u6cQkkUECwF3WO7u4cAkkEgwB3UO7ugIkbb6EmIpEKpwJ7u7gQ6oFoEhP6/fVvNJvul7Lhf33ribtv4D9ZJJIUAAOtMLe222gGJ5rabzM4szeZnMPrbzP2tJpLMziknveytqSSSRJ/SSSRMNyRsETZJJ3EkOm3JARUbfSEhtuNg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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
