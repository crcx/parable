#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
# BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack
    if type:
        return stack.pop()
    else:
        return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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9G7pu7v3nmeXnnnm/dqUpSlKUpSlKUpSlKcw3f7EEN5znPP299997zilKUpSlKUpSlKUpSnIBCVAn0zN/jf79+VN3d33vuPPPPPN54pSlKUpQcZcgDIMlKUpSkEdw3ec5z993vl555v2qUpSlKUpQl9gmQmQZKUJ4JvRu7u7+/e99997z7cEDMwTJSgaEoSzBAzMEyUpyA3o3ec5z9+3vvvvefQlCW4iGZgmSlKUpQNCUJKqrsr77gAof39/f3R1/bu+ebu85zkcgVIoONNJJAT9FJJJJJJJJBJJMFgcAASSTDwHwBJ2ST9JBJtoAAAgfgAmNSez9xZmAekkkkkaSTJIJFNAfBwrySYHwGZ6kk00vXdnrnne973qQGNh8J73q94N79znOen79dUGZgmQNCUJZiAZmCZKWYJkpuG7+/Km7u77755555vOwaEoS9x43UJZgmSlKUpQPI3o/c5znv77fPPOe7zpSlKUpSlKUpSlKUpTzejn3332/ve+++/PlKUpSlKUpSlKXbJSgdt6Offffb+3vvvvs8+UpSlKUpSlKUpSlKUj309999977777789UpSlKUpSlKUpSlKSOg39SSN3d+vPoWMx48YH4+hIbQN/QGSlKUpSlKUpSN97777zzv3nvvvvv3ylKUpSlKUpSlKUpSlpc++++++77777778+UpSlKUpShDfzAhpDYkNj3d3d73ve979wkc0hylKUpSlKUpSn32/3X9nn45cP67a8978988gjvAqh5kpeYi8ypIe5EfsAfZ+y/ZJLmJUXOaAOYpHMJTmRUOZCOYq6ujNVV1VWxVXV1gAADCumWxo4NB6qqqv3ue9733veAA0kkwSTTky/z9zwTG028SONJpZmZncJPycpJtuSSCTSR4+ADyaBpPEklfuvP2VNIj9hEfuqb65znAXOfc/czMzM/JJ2SBYAAHU00mik00imkkg++hbs7u72Z72ZndSQ2kNpDaQ2kUpSlKUpQnM++38qc5nOZt7755/Hl77htyf5kckGkGsgMlKU/6MxSlKUpTpI/3X+P9/v9/v9/u+eeeeeef77VKUpSlKUpSlKUpSlNw++++++3vvvvvvnvFKUpSlKUpSgNzFKUpHcOc5znN77777733ilKUpSlKVTaqm1VNqqbVU2jiAALu7u7MG1VKUpSlKUpSlKUpSPMOc/jlsqbbO77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JGVz+qejeiEgDiPkCcDb++7qz4++kngF96rZTD5ghNFIzgZn7qOT5oOh1ebTacppppdqVj5iRz57XsUvfaqr9r3q+JdVVvsg4Ckkknm23BHyAALu770wpbVVyqqkqp85xOqQ1vy3d290G2szMzM3JTOc4ucbzjWmgMMKxi/sXd3V3VTnOc5fs8WABesXd3d3VVW932GAADBiax70gF2ld2k7qwUVOqqqqqqvx8gCw5drFVVTsAAAmse970kuZznHe4x3ve9ueAAAvWJJJJVYxV85zl+sAADF6xd9uakqsVW9zsAAAxzCfRNybkqsVW9zsAAAZzkBNoEDiBAlHohrzHBCfdCkJZJNcy9yrqqqq5nU+urqq7Pe9OMAEAAoD3vV57Hve94dMgOGZJJNzJP0kk/SSZlYrbau7mGVoAHACTSvYHx4DP0PkkwoMz3q9di96eyRSSckkknpJPkk5JJLAQABfe970wqqqqqqqqqviNKid/jf27u78c9zAXy8hPPPLmwAAO+xf7F3d3f72/36+2AAYDuJ9a7lSe7Vb3PcAAAzNdT3pJze/36dgAAE11PeknPczjGecqp7gAAHJf6P0l3fJ5nOcMd111+5rl6gAADeMmDC/okl3fNyqqr7cE1oDABevn65JOb3ve52AAAeYT6PpJJyqqqqdgG222223fUKh0Tn1z99e/ffd3Pu7us7uNKNAcKAKRgA6ZAcMyQOHHwPg3PpPtc573h4SST2pJJuSJJO9+qqvmGOdq7rqaialSSSEkkkkkkqQQFAQPd73vTCqqqqqqqqqqQ5mfZznOd8jkvsGyr7Mqe57/YHue9PsbJz9kZgUFBRJjubbu7u+d9/eeeeb8aUAx5ipYZRG227bu75393333v2+AOZZROY45iDvXLd3d3z9+/fv278bRNkqZlhHMESkTetv7d3d8/fv379vu6qZlhOVEWbnLd3d3z7kA+Xl55nm86/AABjOLv62ru7vm5VVV+vAAAF6i7kk5ve97nYAAB7DE+j9JJOb3ve52YMAAMPb333eYxV1XK7TW/uSdvvpJNjwwARQAKAYUjAQdmJJJJwzJJJuQ+B8E7MTtVV970FTkmZJImZJJOTtVVsSSXdSdfVV973XepCu0fawDfve973ve973vTEkSSere97lTsAAA/J9EkkruLZznHOc5O3OgABgx7DF/Wu7uVv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c5VVu+2AAB6/rmpJyd73nOVPQAADPte9r3vSVve97nIAABJ8mpJJW973ucgAAE1JqSSVcznOOc5zl+4AABMev99eru7v3KrFVV9sAAD7V5++v5JPcdSZk8PenvY973vedlSSQZqqsUAIwAdMgODQG5O+nJXlfUknzPsDpJ5pP9zKlQN5u78217BpMDvZJ+f5bmZmNPM5WZNAJIq/JJ57vv3r/UYSdzMz8lnsrDqkmpNJHQ/fBoZl3d2Z4AACak1JJOcqqqp2AGDDDGJqTUkk5yqqqk8AACak1JJOcqqqp2AAATUmpJJzlzOc473ve3OAAAXq71JJL73nOc5frAAAvUmve96qlVVTsAAAxxPpNSSVXqqqnYvTGtYwYwYwYwYZtd6kkqrqqq+2wwwWAXq71d3d85VVVX2AAAW197ntP0xn7es3WNfvqYxV/vv36b+6kB0wA7KkkkgUAIwAdMgODQG5O880+emvp1G+eB8k99JqSSbRVVeKqrH4Os5u7php78BJPHveE71JJNwZPSc5VVVTsAAHtaRjX01JJOcv2c5x3ve9ucAAA7f13q7u75yqqqvtgAATUmpJJzlVVVOwAADM1JqSSc5VVVTsAAAmo973vVKqqqdgAAHZrH0SSSvX7Oc473ve3OAAAXq3ve96cvnOc5frAAAvUmpJJzlVVVOwAADM1JqSSc5VVVTsAAA7rWnZP2vcoSTkkknJMSeBFAAoARgA6ZAcGgNyd9Un257OvAzXgOmfaA4npJPSSeD0ne+97wyQsptoD4mZme94wk5IB713d2ZAAAIxqTUkk5y/ZznHe972/04AABervUqScvvOc5y/WAABermpJJzlVVTsAAAx5PpNSSe5yqqp2AAATXva973pzlVVc8AAYJNY+97Xve9Ocv2c5x3ve934AAD3td73vec9znOc74AACak173ve5yqqqvsAGLGjMn0kk5yqrvvnOByDMsYIyIzFTMsqiOZn939+RK979933t73u930wUn4OABJWe/GZn4yKABQAjAB0yA4NAbkSSSqq997GFHkkk5J7XgD0rMwzMw2w+DbAAkmySSSQAC0kyT6TMkgHvXd3ZgqVVSpra5tI+ADfEec473ve3OAAAS/rSSTvKvnOcv1gAAXqJ73vdvvOc5ye8AABmak1JJOcqqqp2AAATUmpJJzlVVVOwAACMak1JJOc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D2L+lz6VJzmMYzyt7nYAABjife/e+9JOc5W9zsAVVVU7eRkpmCIedN3idEtNESzIzBfAnff37+eklwRB38dfv3u7znFFHdxFTd3oQd/t9UH+UDd3d939+z+A6YAWijbEmaqrkkqQlSTsxJJTFDpkBxlPCsWx3VVV5m8AF6642ksPhAAeUkRTbVN66RSA+BcbaoL1pOT36NPJSk34Cel891JP3ffe+mZJKkkkSUmfSCTbYcbSRR4D4A97196YVVVVKqVUzkk+h+D3tG2su9NgAAVf3pPpV3fe95vd+sAAD1/SYn0qTlb/fpyAAAZmuz33pJrHOcr9nGM1U7AAAJqSfSSa5zlVU7AAAJr3vfeknL4mc5xyqv2wAAJyaXu/1/Xzl33lfv19sAAC9dv33pJyt/v05AAAMzXZ770k5W95xjO9zkAAAMYxn4uOtpO6Xyr5JNKkr7jX22b3ek0r9JJ9Cve973fe9nykpijpgAihJJJKkARgA6ZAcJUk1feccnPU+gKkkwADAPpMUq8zmCzMMzMJJDM973veN0N3d3dkknUk5JP2gB8Ac9fe9nIAABNdnvvSTnOXM5zjvOXNgAATi/13f185d973m936wAAL173vvSTnOVvc7AAAMzXve+9JOc5VZxjNVOwAACakn0knOcqqqdgAAIkn0knPd7f2c5x3nLlVijKIyVMzMInMVOZb/bu9b55u++++fv1+9esMM400XqSfS5VVu932AAAY/J973vvSVVb3nGM+qdgAAF5xhpaZfa3va999u1m7AAnwAS5JyRSSTxgDhlQGw+oARgA6ZAcJJO84k8Zp6gdD7w+oHnTdakn3g9JJM3d1JIOgA373vfpJJPpPVVb3KnYAABNST6STnOXM5zjvOXNgAATi/13f185Oc5V7v1gAAXr3vfenqqtzc7AAAMzXve+9JOc5VZxjNVOwAwYCakn0knOc3VVOwAACp9JPpUnOcuZznHecubAAAq/pJ9Ku773vN7v1gAAXr0xJ+n6TnOVWc5xVTsAAAzNST6STnObqqnYABtttlPmCFlb9TdZfvTmXf3vtz7u7u6e7hwZSSTkmIAigOmSg973veex73gdMgOEkkneg9dVXvevwARAfNEn0pppypUk+JJ+zMwkkCTMzMwzCWknJPpKkkkkwAD4A97196dgAAHsT6SfSpOcvqZznHdc5coAA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Nax8z+70fp+7725t+1AAAHwAS5JyZmZl5lZAIooAUHve97z2Pe98CcZAcJ7Ane+ckzPSSagbbBGPHmkwJJmZmYZKmXmczCSAAGloA/AGgH4/EnvX3vZ7Zx8421zlcVJbvN3ft3bqt9qr7awAAxS/ru/ru6qt+qr7AAANz6SfSpOc5VZznFVOwAADM1JPp71VV+znOOc1jk98AABL+u7+kl85yqq+2AABeve9v965O97W9zvgAAPYn0k+lSc5yt7nYAABma9733pJznKqqnYAABNST6STnOVVVOwAADs7Ws6rH3te573vA0BwZSSTkmIAikYAKAEYAOmQHFJJO84k9Y8xVVYSTvlAHve9720kkkhJMzMzMzJJJIAAAAAHwBznPWznOO9725QAAF6u7+kk5zl85zl+sAAC9Xd/SSc5z3Oc5PUBgwBNST6VJO97yqqe8AABNST6STnOVVVOwAADM1JPpJOc5VVU7AAANz6SfSpOc5VVU7AAAJqSfSSc5y5nOcd73tygAAL1d39JJfe95znL9ZgAAL1JPpJOc57nOcnqAAAxr31d9nH377vTna7dng8AB8AEuScmZmZeZWSSC97z1e973mw+oARgA6ZAcJJJOE8ZHve9973jckkkk973vAzMWCkmZmZmZkk8knJyAAHkkwPkE1JP0knOcqqqd8AABNST6STnOVVVOwAXpjWsYMMMXq7v67u+c5VVV+vNlTMsJzFTMs3N3et3d88877773nzuKmZYTmKlhm5u71u7vnnh3333vPncVMxowxphjuF/Xe/ru75ze97vmIsAAmL+u/313d85JnOcc5zl+oAAC9SX9JJzl1VVfbAAAvUl7/SSd7ve9znQAAJr3p9JJzm973OQAYxjGMYxiu9tivb9ve/e94D4Gw0BwZAdMAEAAoARgA6k5JmcSSSQAJJJNSTxySSVXpJ6siSckkgAAPV73ve+kk5ze97nIAAB6fSfvpJOc3ve5yAAASfSffSck739ir1nOcc5z7F+0AABir+kv67u/d73HOc5frAAAvUk3+kk5+/fv0rgAAHce7ib+m/pJv776bgAAGfa930/SSqre+VOwwYMhNbkn6Sc5zlVU7ABVVVVVUkcAPx4opvKSynmb821mZ8tpgAAC9Xd3+kl85yqq+2ACqqqqj00599ff3egEkkn6SQLAPgCSxnnTOh0xGAIodM1VWCgBGADqT1krGcXd1z0k5z3pJJJjJKSTkkmSZIANM/NtACBNMCQoA8B+/SSS5JJJJJJDGHAPwHve9d3OwAADHjM+1JP0k5jnOVVTsAAA9mfak+971Yqp9VVOwAADk+7J9JN77ve5yAAAXf13f0krGMZqr+qqvtgAATXJPpJOc5VzGMZ73tzYAAGb1d3973qqrvnOX6xista1hrOc41povV3e/03Jzl1vd37EMM400Xq8Xe73d3zlb3u+dAAAvOc5v67/Xe7u+cxzmq7rjl+sAAD2N3+ze7zd3dAwPwBOySfSSSXJOSSST0lRgCKABQAjCSSTkTEnvXM97KyZmZmSSfSSAAgAMzM95X6pmZkACF8AAAkkkuSfAAdOge9fe7nOgAAexPtST9JKqt73OQAADM1JJ+klVW97nIAABNSSfpJVVve5yAAATUkn6SVVXM5zjnOX7YAAFMr+u7v9d3znOVVX2wAAJqST9JOc5yqqdgAAGZqST9JOc5yqqdgAAE1JJ+knOc5VVOwAACakk/STnOc3ip777vP1VVVVVXvV69KAb+xd4ghvnnm77tsH75BDNt6QQ3cQQ/kQN76QQ3cQQ3fAQN/kEOvN3d63d944MkknJMSoBFAAoNh9kqZ+zMz9eT7KWZ75O5mfszZR1FcSTA/PrbQBO3MwkkkaTga0mkMAkk3MzPwAACMWwfrqrqv337V1V1Wsfv3677+u75znKqr7YYMAE1JJ+knOc5VVOwAADM1JJ+knOc5VVOwAACakk/STnOcqqnYAABNSSfpJznOXM5zjve3NgAAVf13d/ru+c5yqq+2AABNSSfpJznOVVTsAAAzNSSfpJznOVVTsAAAmpJP0k5znKqp2AAC9Ma1jc3d3+3d88885wB9993gd12A5lhGVgD2uNJpfu/JJpFwqu5f3bv1+2797dzJJJJ8DYaA4MkknJJnEAigAUAIwkkk5GpJJ0Sese973veBJJJUkJJO971JIAAAAAAgAH4DczM972yVqpcquJJ85XFGVgDvW7u/27vnnnnffe+7aRlYAxlYRlYI71u7v9u75555333vu2kZWAOZGE5ubu7/bu+eeed9976c1GysJzEbKwtt3d/t3fvfffeflT333eHfaNlYTmA2VhQZvW7u/27vnnnnffe+nNBsrCcwGysLbd3f7d3zzzzvvvfTdRsrCcwGysKNzd3f7d3zzzzvvvfTdRrMsIyIi3N3d/t3fPPOVVX2wAAJqST9JOc5y5jGM97jHd5+qqqqqqzzf4D5t/YKA59iA/2vNdd/eEp7kLMRbzQjIjoQ8zfc/hQL+zI9yqHurIshyKnLrrD4pVNVUIEDoY+9IIVRmVTE4qMpAgjsc1VyEMGhvGQxDYXYCCYdUI8TrJiiID6euvrqJqRF9AQhQC8ZHy+8CIHh7OMi5z5/XefXfxzABefmm83c117zuyYxlddZ4CxE2kKpq6++9v33AJFuEkMAASxoEHn076VJ2qu6qpiGQHQEq6u6q6M4o5znfOfEI7d6qljVqSNQsuZ5w70G5JqSVUgCWwCUwcqru6dST9J6Tg203X3wgALzJf5NJKkm2v3Y0mmvzbVNtJv67/d/L8/v7BDCQ+KkknwNhoSqu7uqqu1dVeKu2HfjIlWi5nOe85nOc7+EZYxmSmEjKBnPureO7tASS5IQMEgb7u7uO7YGQdYYqVV3dMAhn6d5+q6urr33t+73nveVV1dXbO9aDY1VVdVjOWAfINhoDgyA6YFAigASSSSSSe5Jxtr5SSS1PhJJMADwHru6MyT6SZn0D7obDUkk3JMgOmBPs4D5RIAoARhwaSek4JJJz6mmkuHAAsh5try6ovvsz9JMz4H3Q2MySSckZAdMDQxWDahsPhQEnZiA+OmZpkHZ9d3WpJNzm4PgfADUkkcGQHXcTMkkkUACgBGHwNumZVVVXxkNjd3dfSRtsPgfA2GgODIDpgZBHQAoARhoDgcYMg1d3Ww+c2HwPgbDQHBkB0wO0ZIoAFACMMgJGfe973ve573s3d1oDfR8D4Gw0AMySSOmBsPopSmLu6kkk3NPfI5pc4b6IGA2D+8kiL3M++r7u31vkkdUzPkkVHX2dvV2UkjX0T0+7p7ocnEk/dzmTl1++Q2qpL44n67DjbWHIfEnTN3dcwy1iSGHc3d0Pvhkzd3QNyQD821QBwsRONtSekk61KE22/rXAX0FkFnYt5U7fb+++5+++qaFzXOc5znvGSm8JZnmYhguZS43u+29etJGvu7u6+4hJGV3U688p+rMzxsfaHTPcCTclTUn0MO059d3WHx84hL/NtVySfpPRRttop1fzbVAH4CTHd1nmLu6aBGKfZu7ruDRxwzd3TsxN3uwOlJHp6e7vPq7UAIUjSBTCgQW1d3WQTSXLxdU+u7rRv4ZS+YrGH13dZNs1Bm7upOSOKM3d0AV967qq+r313dDrrVeqZu7oK+aHe7x3ue930fdZAVO973veY7m7uo5oN4AVKmt3d33t7qvu7q7u6BItCtCtClCrvkCSSXYm02kvjhOyBO9bakk72SS+V7KXJJOyVdVdUxkB2Vd1V1TAVqfczd1dVvm3Pu64HBqqq5Bm7uhGN97nve97vu6UhB3dsHR3ufdW/ACS++mjN3ZSRmeQS5PScSTkkknvKqbap+V3d/pONtezIJtnN3dDWw+zXOc7Xfvvtb73N3V1WgOdcGg0Bx1MNb+eq6uqVdXVYppnC+AAcbanpmZeZmdySfpUnpOJJyzI0BwAaHB1XBqSQIxJJ2pJ+lZxtNLMzMzPVIZTaSYfAjkp97WZuqzvNZ9q7ut62aESSMBso+cAEn3qb973u+57w4NUBu6q6qVdS3MVK1RYRO8kjmc53zzn3PjgQD7u7u3AAStIDY3a3d7vAYxGNGNYxfMO/mPwzXTBLqNGPECCLgQjzzm4jzzn9/dxH7KCd/tVD9+/bNJpFJNJPofFJtthYB8BJLknFJkk5JiVAIoAFACMJJB19JJJ0Hve973ve94EkkkkUnmCSTxJ4AAAPXVXVexV1V1XsZxnOYkkk/ST+He97zmMcu4wAABepJP0k5znKrGKnYAABmakk/STnOcqsYqdgAAE1JJ+knOc5VYqdgAAH7E+k996vVU5cznOO8ufsGDIE7rXL3d39fLqpyt32wAAPT6T33q9VTlbnYAABma973v3pOc5ytzsAAAmve792eqpytzsAAAmve792eqpy5nOcd7nGM9ubACqqqqq8qraVvlLnP27W9PBJkk/SSTsknx0y4MgOmACKAMmbu6VJ3k5qfQwkkk5EkqSVqqq+j49Va8DorTHvYqqv2w9v0fSXVzzRN3d146Ke9yMVVW0AAEYcy972/e9+nrvve95yr9YAAF6kk/STnOc3VTsAAAzNSSfvSc5zlbnYAAB7E+kk/Tk5znK3OwAACa973v3pOc5y5nOcd5c/AAAXqe992/Tl97XGc5xy/WAAB+7f6bk/Ts57nKqp3wAAE1PXP0k5feVu+2AAB7F/SYk/Tk5znK3OwAADM17vfuz1TnK3OwAAD9XO+/d/a9mO7m/dwZ/e973vfe97zYaA4MgOmACA2HxUkkkhhJJJyJiTMz0mfuyLQsAk5mQCek5FOZhnMJJ0k8knkYAAAdqqsz73vGhyc5VVOwABiy9Xd3+u75znKrFX284RsZRmKVmWWZlZ+3rd3f7fN888877O992GGcW0bv67u/18vnOckxjGe9x2/0AAAfr+u7v9OTl973nMcv1gAAfr+uSfpyc5znucxye2AAB+n30km52c5zlVip3wAAH6fSSfpyc5zlVip2AAAfmJ9JJ+nZznOVWKnYYMAB+n0kn6cnOc5VYqdgAAVX6k2m20rptN+pNJtHQ7fSm2sDfwe9773vebDQocGMgOxMsgQACpJJJDAB1JJIruJJJEkkkgVVWACSfrqrqkknhPEkkkkmNJypJJJck+AAPwHve9o213lz8AABM39f13e5ucvve8q/WAABepeMZiTc/TnOc9WOT34AAD28ZxP36STc77nOcqd8AABNd73v7snOc5XPAAAYifd73v7snOc5W8c8AAA5znP3O95znKrnQAAPTH3ve9+96c5zl3nOcd774AADve93znvd73vOc74AABePe97fvfeeeed99+fVVVVVVIAg8kAQ5JH9kUv7IqOlLEUu/2qI8af6sUELMckyPMwpooA5H9K1d1fO9nqm9/uOfvwD4Gw0BwZAdJlkCAAUAIwEknpn7My/2VmTLnW2vpJCz8kmAeD3weAk9O9SS6q5X0gAAAYe373vfvdmOc57ve+5zlVXu+AAA9rHve+973Oc5VV7vgAAJ73t+96c5yqqdgAAF3JKkl85yqq+2AAB7E+kn0k7znKqp2AAAXf0k+kl85yqq+2AF51rGDDFru7/Xd85zzvvvfXY0yAcywnMAbetN3f7d3zzzzvvvfeWk5gDmWE5gDzf7Dd3+3d888877733bScwBzMwizBTM5b1u71u79555333vuk7Vi5KNZlhHHAEPCUQ/g391+3dzY2l7d3epbvvt3ivd3d7uh9JJJckz36fPh0wDIg6+BtQAjAB1JOSVmdGwB+D3vEkkl1V+xnve92DaaWYZO8pNNKQPzTaQcAPybTSKTAAAJJJobu7u7+3T3ve0bays939y/AGZYRlhkLmWEbc1Dd/t3e/PPOjnnnm/b3IOZYTmAOZmEXjub/bv9u797zlVV9uZ0znONaYYNXqSfSS+c5VVfYAHtaAzNST6Se5zlVU7AAAJqST9JOc5yqqdgAAE1JJ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WJYWiwsFhaiPhaqn4vxdFyV+L4ui9V4Xgvi+L9BciwMSTJP6nWTJmZ3JnWSZkmSe333e/fvr8AAFttttLbbbaW25JkyTcmJLiCP7Ij/CwsLBGC0WC1UMI0iwjBecedf0/p/Tv2RTMzNtrYXSZJOMVRYWUVapoSjC0qvffe/ffClLk2xaalxqInoWEYywWEYRqVYXvvvnvvoXoWI6GLNVTgJpVWqYLVPffe/ffaKuaxaxVeiMpXvvvfvvgI9EYWF1OC01VDioYCsLJUYLC1CwjRGCh7773774Spymp3iPRYj3n3v33wXNi2xizVKvPPOvPPBHI0UeiyLC0qVqlaLCwRqmEapkl7773775FLlMlB6LAvffe/ffBS9FhGFgukyqdlHeKmZkk7ky/G/fX34AAvvvcme++++uFttttAWTLJnckyZPskyZP0mZJ1EkwsS1U1AMLCwtVV551/T33wJXotBdJpKu+RcAsLKomFhG1FU1TRQwsKvfe/fexJzNpgR4LBYWiwsFhYIwsLzz3v3F75FLhMRTzzzrzzwqcpoF6Iwq1RMFoWCwsI2SKapoFhYKr3zrzzsqXlUwk77TiqHWBe6Ku6poI1TAWqmRGxRhbVKwWFlIwsI1VWi988997AnkXScIJzgSc1TFYrQWFWFWFWirMFhYWFgtU0q887887ig8FhGFlC6m01FzipTmqYBhaCPPffPffBHKYXGlS9CNQsI9998999F6VisF0nPILmoYLCwtFhYWBb333z331C5TjqMzJkLdcvv78AAFttttADqTACzJmTPskmfszJrWv3797JJnkydQuMijzzzvzzxCuZtMkcai9ATUCaAnnnmeebIaVq7IYBN5mOOyN4LzzzvzzhPRei54L333z3zieb3gs2G4SBzzzx8dkNBFauBOeb3DQTQeee+e+9zkmdSTUmSZkLdbt/fgAAttQGwAAHsmdyZmTWu9H0k5DQTUNBMzLmbn7QZmczNkFeLsgrxe8IczMtzZD0JmZcx4ZoDeZzM2Qrp4uyCvF2Q4EAkA+988r559+73vffffffbaW2220AABkzJO5M3JncgQKE7sCQld873ZD4JmZczea0TWiftBNgeeec882QV4uyCvF2QV4uyGBMzLmb8NQMzOZmyCvF2QV4uyHCEmTJqTOsyZJkk/ffv298tttLbbbaW2220AABkkkyckzkmd5JmtdjcD8a0EzMuZsgrxdkFeLsgrxdkFeLuGGpoIvF2QxeLshbu3ZBXm99zJ5kmTJN9ZJJmSZ9975v33760tttt+kx999999998smOgAAFkyyZ3kkgBgTRJJAXfczcPjUNBMzLmbIK8XZBXi7IK8XfNQF5xdzDUmgmZlzNkFeLsgrxdkFeLshwCSSB57nmuc++tAAAAAAA7Agb3vve7+NTQTRNBMzLmbIK8XZBXi7IK8XcDDWZnMzZDAmZlzNkFeLsgrxdkFeLsMNSwCQDve+196d+GwAAAAAAOSZoAA5zfe92Q+CZmXM2QV4uyCvF2QV46DDRMzMuaIYEVrqB+yBvRDM931olCUJQlCUJQlCUJQnwe97fXhKEoShKEoShKEoShN3e7aJQF8YBkJQlCUM66mTrqZOupk1MkzJn33vm/X3638AAAAAAB3JnUySZ132dfTJQlCUJQlCUJQlCUJsDu926JQlCUJQlL85glCUJQnve760ShKEoShKEoShKEoTd3u2iUJQlCUJQlCUJQlLu73b3kMhKEoShKEoShKEoT3vd9aJQlCUJQlCUJQlCUJsDu926JQlCUPrIShKEoShKE973fWiUJQlCUJQlCUJQlCbu920ShKEoShKEoSh9mCUJ73u+tEoShKEoShKEoShKE51zqWCyLRaJNgjCySbVMLVOBZLhiuv58LnC0XSf4/9vvIWEYXQXFQ41TgRhZA4FwFwFoRiWirBYVaoYL+z8X8Lp/Xjjvzvn38T8AAAAAAAAAAAAAAAAAAAAAAAAAAttttoAAAAABbbbbQAC2222gAFttttAALbbbaAAW2220AAttttoAtt5PevfVtoAAAAABbbbbQAAAAAGTDqTACgAAAAAAAAAAAAAHtkmYFhYX4vxel+LoLwXosI7LwugvRHYvxcFyI58583z220AAAFttttACFyXP9n9mJqTak2VNhGWVbUU2BbSVW1DZIbCM2xGzYTbYJtKbKmzaKmwWyFspGxLaFspbKg2BRDNCo22VS2rYTW1lrEasDNVmFaaUlkgmgFoogkCSIhiCIpBYqYjd+fnuksERLRMCi8hKEoShKEoShKEoShMSmmQYCCmJSIKCiohVoIgo97Afb64JSejIShKEoShKEoShPe931olCUJQlCUJQlCUJQm7vd+oLxOcTZNk2nu4ybJsmye++9+LRKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlCUHp97Afb64JQlCUJQlCUJQlCUJu73bRKEoShKEoShKEoShN3e7aJQlCUHoyEoShKEoShPe931olCUJsmybJsmybJsnNIn33vvXnv778AAAAtqTAOAPvv4XxfFyinpYLzzj+eb1Nk2JQlCUJQlPzBkJQnve4D31glCUKUJQlCUJQlCUJu73bRKEoShKEoShKEoShN3e79M8JT8TkJQlCUJQlC2TZPffevfePE2TrjhNk2TZNhKEoShPe731olCUJQlCUfEmQlCUJQnve4D31glCUJQlCUJQlCUJQm7vdtEoShKEoShKEoShKPQe97fWiUJQlCUJQlCUJQlCbu920ShKEoShKEoShKEoZ5MzMzuZOskkyvfdb9fvwAAAC2222mTAD2TPMmeeV9MnXUyddRK+YchKEoShKEoT3vcB9uC2TZNk2TZNk2TZNkybu7qoHpB3d32iUJQlCUJQlCUJQlCbu7uiUJQlCUJQlCUJQlCbu6juiXsXIShKEoShKEoShPe9wHsJQlCUJQlCUJQJQnt3eiaQrQFHochKEoShN3e9EoShKEoShKEoShKE73vjdEoTZNk2TZNk2TaN5wOv6P5/Pvu/z6/gAAAFttttADcXhdddfP4mybJsmybJsmyUJQne970H6gcwShKEoShKEoShKEoTd3u2iUJSJfOLkKUJQlCUJQnve760UoShKEoShKEoShKFN3e7aJQlCUJQlClAXsQyEoT3vd9aKUJQlCUJQlCUJQlCbu93QchKEoShKEoShKEoShN3e7aBewDIShKEoShKEoShPe931olCUJQlCUJQlCUJQm7vdtEoShKEpfZ3MnXUyddTJ11MnXUyayTPvrdcv778AAAAttttpkwA5JnmTPPDr4ShKEoShKEoShKEoTd3u6DkJQlCUJQlCUJQlM0rx0fs2BmZzNELby6IW3l0QtvKhNkFeOiFt5dELby6IbgTvcyufvv3e9AAAC2222gAkzzzzxohbeX4JsBXjohbeXRC28uiFt5dELbyoTcNBNQV46IW3l0QtvLohvJmZ77zmt8+++AAAAW222pMAF+kxJiTPZM9kz33373qZNa15qyZgm7vNhO97zsJ3vedgyHvec7YjRAW85UJsgrx0QttshbbSG4Q1qBM995zW+X74AAABbbbbbbb7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mkSISkZkaGJaEqgWikUiUKmEpQqaoImJqApmGmgWgSgSkCqQooaqgWqEpSkopoaQpiUWqIhqgYqVVtorYk0mhVtQ0TQGJaRNjaKtUsiaZSywolsKorCZIprKiMJkqFZRaqthMJqBVhNUllVTRC22m0QKBCkBopSqhqUoUSlGiKqaRppIlgjhSwNCLkiUES0glIBQpS0ERDWlshskNglNiqWytgkyVlEm0lDaAlYTIYTIltUqjUmQUbQjYLVLVCjVLFVMhkA22IzKlpLapZDapYVsKwrbNZsyaSgQpVUpAoaKWKKigCgSlGgCkPe9vtBwTd3mwne95dELby6IbCW75dELbyoTZBXjohda811Mmta811Mnnkmffc1rfP378AC2222lttttLakwBJnsmfSZ9JnkmWE88y6IeW8vgTZC3d0Q5xOXUN6hbu6Ic5vmiHOXlQmyCvHRC28uiFt5dEKky9+++89fAAW2220ttttod73ve974EoS297ohbeX4JsgryEdEQmorxQmwFeQjohbeXRC28qE2ZN735vqZNa15rqZNa15rqZE7X3333j4AC2222gAC2223vJnfddTMmtXl+CfBOEMzOZohq22Q5znLohbeXRC28uBNkFeOiFt5dELby6JBAnvvnnvPb98AC21AbAAAHem9773RC28vwTZBXjohbeXRC28uiFt5dQghNK8dAW3lQmyCvHwJsyb3vzfUyd795zW+ffW22235bbbbQAAAN+eeHUzJrWvNdTJrzvzqZNa15r6Dgne52E5p3nYTvM5Cc5nITne87oOTJve/N9TJzyTLffdc9++ttttpbbbbQAAAWTCTPpM+kyyZr33v33qZLby6A3ot5y6IW3l0QtvL4E2QV46IW3l0QtvLohbeXRC28uiHaE875zzPH1ttttAAAAAA9kngTwIr3ugLby/BNwFeOiFt5dELby6IW3l0QtvKhNkFeOiFt5dELdea6mTv77nNb5998AAAAAAAPJM888Opk1rXmvpM7mTe9+b6mTWry6IW3l0QtvLohbeVCbIK8dELb5rqZNa15rrJuTOslt+g9b+AAAAAAHUmAO8md9r1Mmta818E2QV46IW3l0Q5zfNAW3l0Q5zfEHBNN3mwnOZyE5zOQnPoCoEA/QC4qV/MI5FoVaLC7Fhdi5cKnVT3zvoI7F6IrCyJMLUlqhhapqhGFqmFoqMLBFx1963vnnv7z+ffffAAAAAAAAAAttttoAAAAABbbbbQAC2222gAFttttAALbbbaAAW2220AAtt6ky22igB7L1bbbQAAAAAC2222gAAAAD+AA+AAAAAAAAAAAAAAAAeyYdgAAAAAAAAAAAAAOpM5JM6i/F+FyLCxWF+LsuBHxdlwXZcFwRwVYWCwsLCwuy8LwvCTsvCxcC8L8X4vueC1U7FhYIwXZaSTPe/dae2gAAAAAPvvvvvvvvsX9F/XG22zG2TY2bGUxUJUQ0ESRNKhMsSD3EVXnfn56J5BSKgFVEoRQjI2EtZDKwpmtszDamBiCguCYiZCe97faDgm7vNhLby6IW3l0QtvLohbeVCbIK8dENa15rqZNa15rqZHkmHvuue/vwAAAAAAAJMSYkz6TLJnvvx8fEZAd7znfA4nKqqrdzm2VVVWta0E0W85dELby6IW3l0QtvKhNkHe/N9TJrWvNdZmta813y85rnL98AAAAAAAPZM888Na1rX0mdze98fgiq22222223Aiq4EVW225JM/ZmTqSZ1kmffW23778AAAAAAAO++zWta1+kze972kze9rgRVbbbbbUIquBFV8FV7+kybn1vlt/ffAAAAAAd73ve973gTnOd7bbfwRVehFVtttttttuBFVtttttQCH6SGpAJEJqZmZkmd5Jhd2399+AAAAAAOpMAfskkk888+a1rWtyZve97ttttttttttQiq222Ettv6SGBkmZ1kmdaky23Vv79+AAAAAAAtsmeyZ9Jlkz2TO5Mmfe++/bLd2oRVbbb8qqEVW224EVXWta5rWtakzX6SZf3nvvt/fvgAAAALbbbaW+yYyZ541rWta/SZve971q2+qqhFVttuBAVW224qqE/ZmTiO7bf374AAAAC2333333vfffAnec7cFV/BFVttvqqoRVbbbgRVcVVCKrgE8988888+++70AAAALbbbaD6SZqSW376224EVW2222222221CKreuuuuuuuuuAuQsLC6qcC4FhYWqYW/C0LgLBc++di6F2I0X8CYWqGqJotEYWCMhxUMLguKhwLipWFhGFoqwnAWCyVhcAuRcC5FzlKuBaVIwtEmEcEuOAuIW4FgsqnFTgFwUZFsFosSyVcCTgWi1TBcC0iwsI4FhcBcFJwLQmpJA3AlAm4E80JQmebuZ59793ve970C2222gAAAAAFttttAALbbbaAAW2220AAttttoABbbbbQAC2222gAHsvVtttAAAAAALbbbaAAAAAAAAAAAAAP4AD4AAAAAAAAAAAAAAAAAAAbkwNAAC2222gAAAAAG5M9kkz3MyTNSZopcBYuBGL4R2L0XQXBfuZLuLwVcEsVHXn3Pf733774AAAAFtqA2FkzgS29bbb+CKrbbbbbbbbbbbbbbrW5M8m9963uSTOZM1Jltuvb98AAAttttpbbbbQJMsmfSZ7Jlz33z6hLbec57bbb4EVXFVQiq22261rXJM3ve9/X7333336/AW2220ttttpbbbbQckzzzw+kze973rWtaTe973uTFVwIqttttttttttp3uZmZ9993ve9W2220ttttoAALJnnnjX0kVW222222222222221CKrbbffec5zn33wFttttAAAAd73vAnITnO9ttttt+AiqoEVVCKrbbUIqtttttvnmZmZ9993ve9777772A2AAAAHffZrXnmta1r4Jbbzjbbbbbbst3bbbUIquwnnmc5z77620ttttoAAAAOhPQnwT0JmZn1tttttttttugnwrXwIqqEVW22223f32Zmfd+999973333222gAAAA777Na1rWta1rVtttt+CKrbbbbbbbbbahA/gADOpJnUkmdSTOpJltvvv79+tt/AAAAAABZMsmWTPpJknOc+9tttttttttt/BFVttttttttttZMk5mZOpJn31tt++/AAAAAAADvvs+kmb3ve9yTN73ve5M3bW21CW28bbbbbbbbbUJwJIShYXULX8qai57/C5Rci0R0IwvS1VSdC5Eel2LgV0FwWAXBWiNFktguBYovxfi/F2XL+F/C+Ln+ffAAALbbbaAOpMBb7bbaAAW2220AAttttoABbbbbQAGTFttttAAPZerbbaAAAAAAW2220BZMdADJgAAAAAAAAAAAAAAAAsmOgA/gAPgAAAAAAAAAAAAeyYdgC2222gAAAAAFttttAALbbbaD7wvvvufvvvuS5LkuS+L4XpfF8XBfF4XheFyXheF4XJcUi+L4vi+L4vi7F0XgF4WVDwXBchcl+L8XheEcl2L8XfYvAjUsovhYRx/Sil/I975xb98AAAAAAO973vfpIE5o5z76hISfwGpAzMzLbbbbbbahOC7W22/hVbbb1VfAmBKGdPfde+39+AAAAAAHe973vQnoT4J4EzMz62222222223AmZmZiEVW22lttttr7mZme/fd73ve96AAAAAA7yZ32a1rWrbbbbfgiq2222222222221kCSSakz333z333774AAAAA73ve973ve97QnwEQiv32BFV8CKqiq223nOc8VW22+BFV5dW1CBAn6SZ1MzMzJ+Ae/vwAAAAAAA5JlkyyZve2+9a71rWta1q23Vt5bbbbbf34JrQTMzMzAmtBMzMznJM66kznOc5uSTOSTLPvgfX8AAAAAAAOSZ+kmZmta++2E3CK8dH7AmtBMzHNiEXi22222221CKrbbbbbsJ3uZcz99+73ve973ve9AAAAACTLJnskz6TA/ATzzzz9bbbbbbbbbbbbbbb+CeBOc5zmta1rWta17Jmfv3vvvvv778AAAAAAtttv6SZ+kmdSSZrWvvta1rSEVW2222222222225gTMzMQi73v9qTD3z33339+AAAAW22333vffffffffgJbb3qqqqqquBMzMzFVVVVVVVcCZmZma+98888zzz77ve9AAAFttttLbbbqTEmfSEkzMz75VVVVVXAmZmZiqqqqqqquBMzMzPwE8AnKQmpohNaAsws1Q1haYRmSzJb+n3CLngX8Fy5izVMwvhaLQsI+KxWIsL7cVNSOQuS4FwBMFgGCwLC1TVNVMLkWqcCxWBYlgv6FcAuAsIwWFhYLSU0WlRYWCwtFyLClwFwFwi74f054668/ffvvvgAW2220AAttttoABbbbbQAC2222gAHsvVtttAAAAAALbbbaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP4AD4AAAAAAFttttAAAAAALbbbaAAW2220AAttttoABbbbbQADyTPZJM5JnJJncLsXYuSwuBfCwXZeF8F8LBeFouBYFhYL+sXnvjfq/fAAAALbbbaB3ve/ARCaAiEQm5IfwaJzmzM/fvGa1BaVFpVHpCZTVFVRNMFSTWpJDWggQ1rzzx88VVVVVYRcAmZmZiq22222oqugnqtc/fv3e970AAAttQGwAkxJgJ6E+Ce++++oRVfVVVVVVVVVVcCZmZmKqqq4ATvnnnnnnfvu973vQFttttLbbbaAH0kz9JM3vb+/Kq+BMzMzFVVVVVVVcCZmc5ze973ve973vy855znP378ttttpbbbbS2222gB9JmSa1rX32973vfJM5znOc3vaqquBMzMzFVcCZmZmKqqq4Ezn17ttvv3y2222lttttAAHe973vcCeBFXvVVfgmZmZiqqqqqqquBMzMcVXRbeXqrme9+7777777bQAAAAA+kmayZrWvj5VuBFVttxVVVVVVVVVd73ve975JM/STNSZbbq39+/LbUBsAAAAAJMSYkz9JmZ777755+8CeeeeeeYE80E888888VV9CeEnnnnnniqqqqqqqqqvgTwCd9999999/fu++2220AAAAAPpJM8kl1b99gTMzMxVVVVVVVVVVXe93nOc5zkmc5znOWc5znOffFttttAAAAAD6SZyTOSZ3JJM/STPPPPP35VVVVVXwJmZmYqqqqq73ve973ve9a5JnOpMmflt5b7+/AAAAAAADkmeyZ9JMk5zn31tttvoqttttwIrmYqrsV4qqqqvIE4BPJIau8NfckOdAmAEhgL8LC4RcCxxEaosLJci7LgXIsLFYXQWFWqfuBRyEci7Fhc1DmhcC4EYLcCwjBYXIuRYLgRwLgWFxVSwtwJO8kkz2TNe/da5q0AAt999999WgAFttttAAPZerbbaAAAAAAW2220AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwFtt+tvwAAAAAC2222gAFttttAALbbbaAAW2220AAttttoABbbbbQB999996rkWC/BYvxckcCPi7IxeC8Lkq9LBfiwuy6F4L8A0R+C/oL+F/P3797+8+/n8+AAAAAAAH8JJH5AaUaqt3B5Fu/PzoGkUtKVU2LYlsRsawo2sw2trNVmomyNkNpNY2MY1QFNMxNSAU0BEDIyBRFRUQURVVRRJVE1NFUlNAQStAUqiwQUsRrRrWtGjRrRrRo0eeeeeeKqqqqq4EzMzMVVVVVVVVwJs/FCffd7187fwAAAAAAAIToToT4J555554qqqqqr+zMzM8CZmZmKqqqqqqq/feeeeeeffu973ve973oAAAAAPpJn6SZ1JJFX9+wJmZmYqqqqqqqqqrgZznOc5ve973ve973ySZIW22/vwAAAAAAAbkzcmfpJnMmczPvltqqv4IqtuCq22222qqu975JnOc5zn776222/gAAAAAABuTOSZ9JJM1Jm+t/ffb3ve9qqqq7FeLgTMzMxVVVVVVd73vkmeffW3dr4AAAAB3ve973ve973vwBPwEtv79+VV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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
