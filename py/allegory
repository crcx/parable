#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        if a == b:
            print('ETM')
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        tos = stack_value_for(i)
        type = stack_type_for(i)
        if type == TYPE_NUMBER:
            r.append(format_item('#', tos))
        elif type == TYPE_BYTECODE:
            r.append(format_item('`', tos))
        elif type == TYPE_CHARACTER:
            r.append(format_item('$', chr(tos)))
        elif type == TYPE_STRING:
            r.append(format_item('\'', slice_to_string(tos) + '\''))
        elif type == TYPE_POINTER:
            r.append(format_item('&', tos))
        elif type == TYPE_FUNCALL:
            r.append(format_item('|', tos))
        elif type == TYPE_REMARK:
            r.append(format_item('"', slice_to_string(tos) + '"'))
        elif type == TYPE_FLAG:
            if tos == -1:
                r.append(format_item("", "true"))
            elif tos == 0:
                r.append(format_item("", "false"))
            else:
                r.append(format_item("", "malformed flag"))
        else:
            r.append(format_item("", "unmatched type on the stack"))
        sys.stdout.write("\n")
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=0):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
#    print('OOM: GC & Increase')
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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UVmmM1a1khciVGffO+35sIiElMTEREUAFAZEKEn3jbbtz7PuZmZmeY1EQqhQkjvwB4MyNipZn5mkPmPaTCa0oH5v9+7/efv37lQ4I69coG6o2wlfu9f67/e7r3fQ6UJJSo4ieS27beQlCTzj4223ugQOCAv7nOb5znvPQOlECFFwhqJaPxpRNICGv2ZvfmZmCAmJU4xlE5kIeKmI1YGihrUBFECqblVG3reZneZnqoC7MUlro1jIje+c5znn3PlV4woO+d7bt+fgm1SSiIAKL8B9f44hKNk273d3alOa3mARMTEABRsD9cRP78/d37d3ddN59mZmdzG3Tbfzbe5ObDzMzd3TfAj4AB45bbbb83xttsPAfAA6bb622KCgAoA3a3d3aDOZmZmvz04AAGGqYHCSSU61xS9W/fbu42+Ntth4D4A4gLAO4A+ttum3xy28yszOZmNt+YcAADNR4D4AOtpt0228ctzvMzMG3nRthQAUA/m227bYAAAzgA2/bkoF8Bu7u9bTbptt45bbYo2BnYmcrMznczM/e8Pvgz4PrvM+zMxu23xttt+e7wAAMCko1bu7t7+/fpmMyMzMzMxbQBRsGbiJR5BwpjofBkxnczMzMzInPgjOl3d3jbYcAADJ0QAAzXJwOgHSSXChH6q19vX32vo+++++7X5QAyDUVy1Oozn7vuDuup2gAb0sNWtOrVaAANGrUnm1OfdFbOvN+e6/R9fRy+n7777roWESengH0Rubuu+xC374lbnFC+3fq272kcnflO7e7eRvIXIhHD4+A+Dg4J+AADXEalPBJJtt+c49NrUB0IPkvQofHP2gUSG7ta93m1s40+clKIjYXprsRCiOQoiPNvN4ruqzMvKxmmZmZmZmXqzzQeNOtkVanJd1UF+tJFTL0Va066JNlEVARFAUSJSlIETQFUWrRG7VKsFNTNLfatGhiStmtam0aIWJGidQaCiIpJIWamGKoiiJ6LU+mvuvtO7nM2lEKMr3tLW7u91zxKElu93d3dS3c04AAa2222zVu/RDbbeZutttgANt6leHy4lCUcjiz519oAVfFpyHKpt9c1rem3u7rbbzMzdcbMzM83m7t7u7rUKEJKEVQIVESoBwBCBXSCEoJQJACSs2vvvvvAF8C0k22/vo4kfyqvvgA91Ntum2a1CJAADNjPc1TERER2YhJJTCU78v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P3ORyI3O/2+bzMwyjQj7w461AKqZmqiqqjvte973hUVVVVV4ffBkZU+zMzrnOem96N2S8OaFrm9ch5HNZngueOamZLZmXLGs3zM3nc5mszcdOA72Zm7vnyFmczpJEQFklqwCgPk5bfyA+CgArA5IN7fdqt9reyucSmUplKZUwubyt5zQr7e93cWqZURK3iiJ4uTKlSt5u85oV9ve7ubsRHOTyZUxzkcjnFEb8TuhXe7VbutbMTahdatEfX199c53191199798jrVonURo3n7M3vJK/ZzmZ9jA/b2AGNbjMkq/deeVne5k9NAABNXnMcySv2c5mfYAABN2ku6/TnJPoAAB5N2ku/1PPPOSqk+gAAEpSDkCa83sd7jvYHLvXOc957z9mWZmBaC7973o8qjvte973hUVVVVV4cA6Hw3vW25OKd327rvy73Z+zMZvefZmY7YD9GAF4PDjM5mbzUTOZk5JJJJJJPpNpLuuclVJ9AAAI1vV399M91553ue+5k+AAAmftSXee8yqz3LwAAD9n7W7++n6c5J9ADQAeTer1Jd8/TnJPoAATMy0fLjzD470BzCRK4h5hvlEVt3u2oW6To3W92q3dULdJ0br470BKHkt5ld670RMZ7mua3zM3mezMUaALQXfve9HlUd9r3ve88XF3d3VeHAOuDo3vmT9eZmeq7iLsM+u6qqpd2AzM3mTM5mZmZmZ9mZjpd3d4AAYhou++9MySEGRSN5+4E7v3d98wwAgiEhdUDASDdd9RdssUbuzuhXe7Vbu7ELd2d0K73ardIjkwBIN13pVMFCJQSDdb5RF3vvbvlC3dkG673du93Yhbuzut13pVAJQBIN13pVARCdY8r7vKJvlHvAebltgtBd+970eVR32vfe9vwqKqqqq8OAdD4b3k8zMzcTOZMzgiFdDGZmD6YlmGe/fv379+/fvz8AWAAG28ctttt6BIN13pVAKESgkG63yiLvfe3fKFu7IN13pt3u6oW7s7rdd7tUAlAEg3XelUBEIYDdd6VQChM4j4G63yiLvfe3fKFu7IN13pW3u6oW7s7o673aoBKAJBuu9KoaSxSj1dSUJWohJ9pQ1CWvv7aQzPee99qHchrrfPP7iQ9RLKh/aqHmbUP7rznffShqpD+9lDUq6azWO/t71mNb3aOOu9GtW9daNkKn6ETvQoHe+rLqrah27UM3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kKOcni5v27u7tVVVW7m7xcmVMLk8ufoUJK+JKEuuJ5yu7W1u17271tt9bbdNt/O7+u75eZ26v7XlUVHve92In2gQALi7vfecu77fJmQMmszMzMzF3d3d3Y3d3kxL11uqrz954PiiG2235ttgAADAA6F3d1Un0AAA8m5JOSd73tVJ9AAAJuSTkne97VSfQXvYBoE3+knJPvfffcrzWte+5koAADWbzMzknc99973MvAAA0xkk5J3ve1Uk1engAeTcknJO972qk+gAAE3JJyTve9qpPoAABNySck79r333Oeeee+7zJ+AAA8zeZmck73vc88++z6qqqqqren1+72oqfoFPu9+v797z35SuZReZKf3f9uU98UNKBxBAH08veBIAS3dv3hKNHkRS2hX1UglqoqkqIIAoCdRJIxqc92nSuji1AkAX5h52eit3rBOoMGhV2KQQRKCBigEDfUbWnvRqdWkoiQ3Pd706hUfyoHehRe5RDRPK3b1331uM1yOs96ma9E+9vK7XwiJJJgQpUAssJT7asIaMGEZV3mD17iwgAAIAAn7QSSRnsfsxzPQROWhYBUXuzMz93mZtUAyzMzPgdDguJmYiJhp4bFxExExEdj7YAJKFGgCCBRBIRikc5dJ67uCSSQBEAIupvV3d2adiYiYkPijeTKgddddcOc5zmeZmedIrAidd4CI9CwIAJsab/s++f0kn179UnpPSN+bbtuMAgEADgSQgTFO9JUkZJIBik6RSRkCPGMSeaiT62qaczfOueOc5nwomAAgIAEBKSRjn1B023I4gyQSIgLfXXv0zExM59kdyq9mYmYiYmftAFzETENSD67u/ru74B4bAUaEeHFoGwdqsmZiJm7u7zPZmXEzr3Xx10PgfA6HAPDYu79d6u7BaAAQALaAKN5ExERCImInXvsRM9n7bbMvDocA8Nru7v13qz4D0AAgAW0AUbvjYPUeiZrpz46HxrVLu7u7o0AWgXd3d36Jm7cAAHm+YoSSRJIAWBSiOtt06bz7MzM7mM6HAPDYCjQo2WABAAtoAo2A8PombjrY90XGneB8DocXFxX1VW6XYo0AWgAEAF3d3d3ajeZmZmZ7MzcTNw0HrtuJkH0EV7NamO6id1sWECEiE58Ccv0rpn32+drxYJcJNUohQmcK96TLuS9BKQUcVXl1E+2vSPgTy5xe9JPfFIAJAP4URQJvqcsSSP5bJJJOA5Aa+7q7ZvgSrcnskU+77sBP1D4Z9vnnDnmedC2Z3nWZ+w4An4WAAI60AAeCAEgAb5vsW51m89z330XSvmuZmnMz9hIpuRGv1CBKOZvYsVr20Pe73LyBPsrakEmSesEyVJNtugS27btfze4mR86O8VuJlLp07sjnImT75t+dS2d6oj4Otv3WmoiIjkongUojhYZleiZWnUAei9XBw6OK24vt3fIjybckkYABANBAkjaNAkipUsEqVFs0Gn42UQHTfqbEkY5JFSnPSSa3623fYvw78HXnsiJmPQ1W/PPeOxM48dc+Nj1+ur99d8s4B6YkAtog+C3l/NxM3Z85Eyt1ro6HzZXKpo377r33zOIir7AIsACByOe85znnOYCYPBIAiSZJO6UCSAJYJpSpJJs4EkgCWCalZfdcdgAgOwTrdyNzbknk1G+Rrft/DoAPfRETED492ueyZiIiIvvL3fPXmZyJldDwtoqqrtVuZmgAHhztubN3d7j1ditVelbORETEfFreqI55MzcXfbu6X4cBkxExKIiYnNZmcvmZuvszcTPPtU4KAUbAB8DsABzIzNDyWlXgWgABbTkRExAHvoGfamIiIjM5vMzMzNRM0A9MWcakHRwPgdaEkkEikbbxt25JJgJADBJINkIEALoVJEE7lUDWazD955mszv0xVbMAuZiZifRMzDZ8VBuq7Wfyz9FfuZ6JmDvelQ759sR75z9zuQ/ZCjv+0iSA+iFCSJUKIhUHxKSiICwD4u/ru9+X97vsj7dcqio973veBAuIloLi7ve93ceu9gYAMAADcxJmRE6zOZmYuYlQx0vl3eHQ+HmTEpLiiDiUQkiUlEfSSAHQtK7uqBuVIAAJuSTknda73tVJ9AAAPJuSTknda73tVJ9AAAJuSTkndd72qk+gAAF6n7ck5JVV/C9eed7mXQAAGoZ+3mZySqrKrM+wAADN5mZyT7ve1Un3wAAE3JJySqrnJPYAAB5NySckqq5yT2AAATcknJKquck9ga1rWta1rWta0uObcZmZnwOfA74ce5773vt+u/fe9ryqKj3ve94PomUB0LaN84HZBAANkJt8iIbb82fYAAA2PDMzM+iZyZnBmZl3d3d3eIHAev275JJJOSVVZevPO9zLoAADN5u70Nu/eu917MzJHOKYXOKI5zPt79u73dtRF3dVu4KY3iiOcnimOLiiOc3m7u93aqu93fapjeKI5yeKY5xREpcni37d3e7txEXd1W7gpjeKI5yeKY5xRHOG/c3d7u1Vd7u+1TG8URzbenm2MzM5mVVXq2ta1137Mnvda8bN6eb2DarRGvtefffdffXffe+vvv3PgbVaJ1pS0b01NZveZnMyqrnMz3M8802b083vzzTZvRSt5u7vd2qrvd326lE8meKY5yIUrnEYaFV7l733vbu0AHQBu5bfzu/ru+XmX27m36io973rqnBAAtob3sAEfgBjMzMzMzMLuLvLu7wMF3d3d3jeTKiHLlvjltt0wADoWkld3VBm7rzw3tvTzZpo3m8zM5mVXe3evPPXuZOAAAZu8zOSZ3var3MvAAAM3Uk5JVVzknsAAAsT9+knJKquck9gAAE3JJySqrnJPYAABNySck7rve5evPPfcyUAABNZ+3mZyTO97VZn2AAAZvJJySqrnJPYAAB5NySck75553va75z3lVVVVVQAANalEB8lVJL7n3G3QA9oAOgSOm2/nd/Xd8vG/q7Va+qqKj3ve94EAC2hvf3Gw+AAAABdxd1+iZiIu7yZkMwu5iIu7u7sAAZeZvMz7M73vOSewAACbkk5JVVl688737MnQAAM3WZnJM73tVmfYAABNZ+3JOSVVa1zknsAAA8m5JOSVVa5yT2AAAd1P0krknda1rveck9gAAF6n6SVyTve5evPO9zLoAADNyTOSZ3vOZnuAAATWft3eckqv36TsAAA8m5dzkld73znnKqqqqqhVQTuEVD5AslJfYKPc2xId5phX2tUjNRExEzHfdzns/ebj9+2D4HQ49dfVVbpTldqub+qqLj2VVVTMzIAORMraHznLKnfbu7327u5mttt2w+JbbbbxjbXdVVVS7tEzgBgAMjMzmZmZnJO68873vnnlVJ9AAAJuSTkn7ve5evPPfcyUAAB3P0kzmZVfv2Z3AAALsnP0lckqv36TsAAA8m5dzklV+/SdwZ5o1trZre/PNNm83ob3du7tRFVu5u8mVMzMqUtnd3e7v1U2o873MvroAAbz9kmczKr9+zPvcAAAvU/ckrklV+/SdgAAGr0n79dzklV+/SdgAAHmtea19q9+eQkplal3nwXu60s3b2kt3327xXvgK6N/X73Pe9v34rtV7dbqj1RVVVUCABbV23sAdL5d3d3YvUzN6u7u79mBADFFH+ABAkmzKRJAEksEED9K2SX6IiEk5UNmBwAbbehu7u7vSaqqURtk+gAAFT9JJyVVVl688t7mTgAAGs3mZnLqqzKzPsAAAms/ZlZ2pqe+95yT2wA+3sCb/Xc5dVWZrVZn2AAAZuSZy6qq1557NdkugAAK12ck7O17Pfe/pPbAAA+1P13Vyve9qSe2AABdJy7uuSqr2T2AAAeTf3305KqpJ7AAAKfY99/V7O69V9J9zzXvO5mZXd37dML48fW23275d3fwHu+9fvue83XvT71VQsCZkCLttzXtD59MyDMzM5MyDPDYyPZk5jsREC6qqqkRExGZxRDbZTbbbYNmqZShJbu7u7uTum7mZmclVVa88kn0AAAm7u75J3ve5evPOsZNgAL3sTP3MzOdne9zmfZeAAAZuTk9rI17739555yT2wAAL1P0lTtSPfe8k9sAAA5mYdC7v4DJUqVsSlyVMS4nfgN7tVX277y2ULkqI5yeKY5xRHOHAPbW3d/bt6pjeKI5yeKY5xRHOC34Ctrbu6iI7u+1TG8URzm9+NvNeb23vP0kzKzfe97WZl+YN+eba814bpUEaoEpbFF7F7F+9W+xD7vz/af371gloGN3fo7u74PHQbfbvl3d/aF+rnvc97zde9Pqq7txaAAQN730PgIu7u7v82A23mZmGZme94UKEszMWO9mYUJI4oA3ebaShLd0KSUJGAAA2222226vve9zNeedzLpWmtt7a883tvTxt555DOZmZdbdv3q3cudUxziiOc5xSpWyAbW3d3lbuZW2jzXjWzTRszc5JM7nve97555WZ9gAAGbkzMzue+972sz7AAAMbkklTve95J7YAAF6n6ZmZ73Pe97zM9wAADN3eSZ3Pfe95me4AABm7u7lTve97555Un0AAA8m5JJU73ve1J9AAAH6qzbv3a2kq3d6oWng364AAq02+ttvt3y7v3MK+qtVqqo7VaqqqhaAAQN7/czMzMzMMAGF3d3d3aLu7qqrMmZP5zEQkmB1AAADbbbbbb9qD4AJKvve95d+4AABep+kk7U73veSewAADM/SSZWd73vMz3AAAJu7u5U73ve+eeZevPPcycAAA8zeZmZU73Pe+9zLwAADufs5knvZ73veSe2AABN3d3Kne97yT2AAAeTd3dypvve95rzypPoAABNySSp3va7U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AAGbmXmbqd753v1SfcAAAm7u7lTve95J7AAALE/SSe1O1XeSewP472AB3P0/SZWdqv2Z2AACZm+LiXu8iFCSfaO/XVfg3N3fgBum2+5l2yq5VVXMzK+qq3VUdqqqru3BAAIG9/n1ZzM+zMwi7u7u7sA+mJB0F3eRETEBeC7u8zY0FMWH7Xmta1jMzMzMzKvtVUzXnncy+AAAdz9MzO1M991Xvvcy8AAA++zk5J2p3ve981592S+AAAfT9P0kqdqv0nYAAB5N/S7lTtV+k99meb3rRomtI61a+1z7773v7zwXzzr77npE/URWq5jOZzM7Wd73t3rzzuZfAAAM3JJlTPffffe5l4AABm5JJUrve9+7JfAAAJu5JKne972pPoAAmZmVPbf3xzVczFbubj3WQkq3d3fRt7unRcZ665VVXFK+qq3VUdqqqqoEAAgb3kc9mZn2ZmGTIAwvAAG28zMyIjME0mHVAAUklCRMKAAkkl3d3d37bXnlpJJqSVO1Vck9gAAE3cklTve97Un0AAAm5JJU73ve5evPPcycAAAzeZmZUz3ve1mfYAABNZ+n6SVO1VfVJ9wAH29gm/0klTtVXJPYAAB5N3JJU7VVyT2AAATdy75dSq5J7AAAPZ+uSclV73uXrzz3MnADR40zeZJy53ue+9zMho0aNHhogkF8gADXTAB8hiAW1fs/d737P2/v0uSSOh9d3afe373vcH1dqvt1VHaqqqqBAAICInnP32/sz7MzMeXd3d3dg21EyB4Gl39d5A+ZmO3d4GRE5IAAA22228zuVTuywa7KmVMqZUyjRo0aTckkqd73vak+1GmnjR4Hk3JJKne972pPoAABNySSp3ve9qT6AAATckkqd73vcvXnnuZOAAAZvMzMqZ777773MvAAAM3JJKne972pPoAAB5NySSp3ve9qT6AAATckkqd73vak+gAAE3JJKne973L1557mTgAEkkl9CF79l/s/ft++lySSJZJJ5tubtbu+4K+qq3VUdqqqqoEAAgbRM/C7P07u7u7u7uttttsbzMzMzMbbbaUBd1VVVLjIiJiK3EyzPszF2iZAzMl3f3333Ps73vbnqXgDUG/DWjWbzMzgXd3W7i3Z5M8nnOLnORPJjfgDpt3d1u5s42Nttttmbkk5M73vazPsYNtjbY3m5JOTO97369eee5k4pttsbbbbzckn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mTETEyEfRKhJIz3vcUR7wFAREERBEQKI73vegAwAiYmYkVVVVVR4c4DszNzM3zcTExHe8e75sBRwH3lVf3JmYiMiYiIhqZiIiK9xorMzZYUbmZiIAUAByC2pmTw3ERMQrvO96UAARF3Gp7qJiq5VUrUbiImIvZuJkZ73nEVD8QCNKoHOc655znOZ3aszMwsAAAbiImIAU+bjkRExDwv5q1TN6u7qxcNKNg6eNxM9bu7u7u7IyZiYic9mZwLu7wBDUTJsG4eBRbRA5EyB5d3d3d3znOc3lQ4KcKVmSxMKGlqmYmd6jXI3EzEzsPAAg+iZiI1Oht023HYiEl73g6fd7+O33277d5mvYiIjYW7vewtzd37d3d7d8u7t9b9973vfe8333ve97zYaALH7Oc5zMzMzMwEQAF3d3d3YCIkLuqqv0RET+P2ReerWpiYS3e1u6ePcG23p6IiFq3d3QDK27u9DnwAAC9T9d3fane979J9+AAAm/vvvpU73vfpPvwAAE39999KqO9736S/wAAE3d3d1O973upPovewABqmvM081nMzM+q+9+1r333X7Mv8AABxg1rOSSfVne973X2Zf4AADjWs80NeZyST6s73ve6+zL1rHAAprX7zTOSSfVne973X2Zf4AADjWPM5JJ9VVVVr2e7AABPxt+uuTcri6UFZfvBXz422I8B8AHbuuVVU+pXPe9VUfVVVVUBoAsETPNb1AHZmbHxED6Zktp1yLu7vrbkkkbuSN49ogtt5FrVNN038CZ999yfSSSSdnmtSfru7qqqq1f3oANGj7PszMuqqqLTBQvgALou7u1qcbMbKhd3QC627u93dUIjd4dAq7qqbxQtSG+tsuYz132wahZShTAFAZeL13YNQvQHwz1xXt+9mImMOLvPe73pc5qZw4M1gnt29376AjvJPawTKI+/NAlAIEEDHet4HG9ALR4D4AO7733ve8dD313fve3M7d3d/sP3MzM1mAWG9ub2AsyIAXQAw9xg2223g3me94SUJZ4+2ZUTERf59ERMQbaiZiI/PwF/gBRsBtt0Xd3YChA226Lu7sBQgbbdGe9773t+URu8SS+nd3d3dt3d3e7qhaNtuqqtuwEoABuqqqptqEIAAqqqqAiE22269G+971em5UQHFCAAKLu7sBNFIj6pckm7mZkjBDujwyjaAAIPqwiELu6+7u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iiwgpKLKou1VdqFtQ/KHai9CLCLCLKKwiyiyhSiyososgrtQkEX0RYBF9UNqH5QlDYJ2qulDSi+qHahtQ8URe0RZUENCAh/bkVUR65+5znO9AA3d3d3QAfLqgCAAAAAAAAAAc5zmYBJIAAAAAU22ml+SapNL6oSgIB/QVRP5pRZRZVRIUWAAkRZRaQBSQFJEAJAUgRfc879+++399rWt/KqrERFU0oucqqqqzMqsQBTqBFVYRYAEQhFkVRUhFlEQ+9999+++++1rXEFBAt1VVVVVYoqI/CiyApBDIiwApACkIiEov3vvvv333P379wEXgIsIubqqqqqqwRF+7EVMRUQlFhRYRfv379+++++/fv3FUELVVVVVVWKIhxVEkRZRZVE57777znPvta1xVUT5AUlFlFzlVVVVVXSqonSqJKCgEIsqqpCiyiwArACkKKQoAp9777799999rWuKCo26qqqqqsFF+UWFQ+9999+++++1rXFFt1VVVVVYKIhzzzzznOc5rWuACluqqqqqzMxUFPlFlFYRZVEQgQQgVhFkVElFhUSEWUVfvffffvvvvta1wQQC3VVVVVViAiJ8osgK+n379+/ffffb1rXEUAPhFgBSUWRFzlVVVVVWIIvJxpptXv5ttttprjaXG0qu95u+3QABu85z03y7qtSRwAAEkkkkAAAAAADnOc5zgAAASSfm0pJIFNNpJLU22k/NgpIAIwiwisCLKKKEosIsosAqHnnfm/vvvvta1xAFA+EWQFc5VVVVVVgAiHZ2IuKIsosIAIyiyqJSqiLCLCqCQiwIIfe++/fffffv20UALVVVVVVWCAKcUWFFhFlFhFkRZRYVRIRZRfOe/fv333329a1xAQC3VVVVVVgKKPnPfffec5zeta4oi26gqqqwURflUSVBCQUGRFhFYEWUWVRKQVUZRZERZRYEVQ9+/fv377777eta4oIB8CLCKDnKqqqqqsEFR6RFlVRIRZERYUWEBSgRSUWkQQkRZRZBFJRZVEgBQlV9+/fv377777eta4oAD8ABnK6zKqqqqwEAUOhRYACFWFBCBBCRBCBBCUBCIEWEWEWEWFFhFkED379+/fvvvvt61riogJ8IsKiQiyqi5yqqqqqrBUUXoUWAFCEWFVE9+/fv377777eta4qiW6qqqqqsEEQ+VUSAFYVEhFhF1++1rWvvtfb1rXgJ8ovwAEqsKL1yqqqqqrvtBF7AFJEWEWUWRWEWBWQRb99rWtffc+3rWvkBW3ihmYfddVVV0oVmN31mKL+950gig8vP3ffP3Pt72AG7znOcJAAAASSSSQAD27qgwAAAHOc5znAAAAAAAAppJpJam035NNkPfffPfvvvvt61riIu8qxQzMzKqqrBFAfOe+++85zm9a1wERC3ihmZmVVYoZmZlVgoKfIiyiwi+/fv37vve8SRSqqqqqqqqq9+/VXeb3vObs0kmJNWqqqqqqs4IvwiyH77Wta++59vWtGqqqqqqvgRflD379+/fvvvvt61o1VVVVVVxRfhFlD379+/fvvvvt61o0AAB35znz585533333ve9t3eaAABl5555VW7vnOfONAAA/PN++++73re9a1+BLVVVVVVXOteAAtffl1d1VVXvvj070ADd3d3dAAAAEkkkkAAAAAADnOc5zgAAAJdhiiL55515v3e971rRqqqqqqrih533333ve9t+8+gAAdvO+/vvve97b959AAA8y8vfa2t+5znzj6AAB+d+c5533v373t237z6AAB35zmd8753ve79+95oAADvz5znnfffe973fv3vNAAA7533333ve9t3eaAOO/mVX73n7977zmub1rXgJaqqqqqqzih7z9+/fuc3zetaNVVVVVVc3h2ICK1X35dVdXVVvz3MOO9AA3d3d3QAA5d1Q8ASSSSTt3Vd73ve973p7d1QAkkAAOc5znOAAAAAAKaabXW0qTbaa420qTbSXOe++/vtbVu7zQAAO/PnOed999973vbd3mgAAd8777773ve27vNAAA98vfffa2t3fOc+caAAB+eXvvvtbW7ugAB38/Pz5znnffffe9723d5oAAHfnznPO++++973tu7zQAAO+d999973vbd3mgAAe+XvvvtbW7vnOfONAAA/O/Oc979+/fve75vWtGqqqqqqtdfv2rn7xVAD2Ub59u6r7V1dVd1dvmTJyb3oAG7u7u6AAAAPlVdAEAABJJJJAADnOc5zgAAAAAU2kk09bSzMvN3d0kilVVVVUAHec+c8777773ve27vNPz8/AADvnffffe9723d5oB38/ADzvvvnne97bu+c5840AAD88vfffa2t3eaAABl5555VW7vNAAA78+c5533333ve9t3eaAAB3zvvvvve97bu82qqqquKGZmZ5z33zznOc3rWjVXFCrCaqxDznvvvvOc5vWtGqqqr7Mqq8tJNppUqbSbSSS+bSqvgDu6AAAG7u7+u6qSd73ve9S7qnwAJJJJIAAACSSSSAAHOc5znAAAAAAAOtpBSaSbfyTVNtMX8oSqiBxD9+879/c5vm9a0aqqqoB73585z3v379+97dt3eaAAB3zvvvvve97bu80AADLzzzyqt3eaAAB3585zzvvvvve2/fv3n0ADikbze973d2d719dVVVVVVVVUa2lze973d2ffv3n0AL8/APzy9999q379+8+gAAZvnnnm72t3eaAABl5555W971rRqqqqqqrln7zPEQAe4BCquq+/Th0AJOc5zjdAAAJJJJIAAACSSSKPoADnOc5zgAAAPl3d1ddvnPPPM873ve27vNAAA978+c57379+/e9u27vNAAA7533333ve9t3eaAABl5555VW7vNAADv5+fnz55Ic99995znOa1o1wTMx+kTrqqqqqvelD79+99++++5rWjVVVVVVXvAT3n79+/d7dt3eaAAB3zvvvvve97bu80AADLzzzyqt3eaAABl5555ve971rRqqqqqqrFF6hEBTrySSAAk5znON0AAAkkkkgAAAJJJJIAAc5znOcAAABKq6+1V1l3VfKoFDzPOvN+73vetaNVVVVVVe+cUOfv379zm+c1rRr4zM+XrrBMzBMzBMzBMzBMzBMzBMzFPfv37337777etaNcEzMEzMEzMEzMEzMEyEzMEoShPOe++e85zm9a0a4JmYJmYJmYJmYJmYfQddYJmYJmYJmYJ7Iffv3vv3333Na0a4JmYJmYJmYJmYJmYJmYJmYJmYJmYJ5zEPfffec5zmtaNbEzMEzMEzMEzMEzMEzMEzMEzMEzMT6dfsUPta1r77f3Na0a4JmYJmYJmYJmYJmYJmYJmYJmYJmYp5z3333nOc3rWjXBMzBMzBMzBMzBMzBMzBMzBMzBMzBPOe+++85zm9a0a4JmYJmYJmYBmfdAddYJmYJmYJmYJmYJ79ih+/e+/fffc1rRrYmZglCZmCUJQmZgmZgmZgmZinW+YgCAeed85zmugAbu7u7oAABJJJJAAAkkk3UkkgABznOc5wAAAGVV1Luq8uqq7v777565ve961o1wTMwTMwTMwTMwfuuuhMzBMzBMzBMzBNeKH77tQ13+/ffb+5+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CZmCZmCZmCZmCZmCe++++c3v9+/ftmtiZmCZmCZmfS9dYJmYJmYJmYJmYJmYJ+/fv3nPVDnNa1rZvQmZgmZgmZgmZgmZgmZgmZgmZgn379u63fa99fu7vegAbu7u7oAkm7u6kgAAAJJJJIAAAN3d3d0AAAG3dV9BO1Dy8683v9ve973s3wTMwTMwTMwTMwTMwTMwTMwPo66wTMwT9+/fvffVD7777nOc4bE5mCUJQmGYJQlCUJQlKe++++e85zm973s4JQlCUJQlCUJQlCUJ55555znOc3ve9nBKW+xDIShKEoShKEvsE/fv37337777e972b4JkJQlCUJQlCUJQlCe++++e85zm973s4JQlCUJQlCX2AZCUJQnvvvvn3qh9999znOcNiUJQlCUJQlCUJQlKeeeeec5znN73vZwShKEoShKBKBIhPPPPPOc5zm973vj9I5CUJQlCUJQlCUJ7777596h9999znOcNiUJQlCUJQlCUJQlCud6xFX7sEzz9+5+/fu/gAN3d3d0ASLqkkk5JAAAkkk3UkkgAAA3d3d3QAAAfq9/c5zznz98/fs+vrnOdcuEJR9BkJQlCUJQlCUJQnvvvvn335Q+++5znOGhKEoShKEoShKEoSlPPPPPOc5zm973s4JQlCUJQlJ9OQlCUJQnvvvvn33332973s4JQlCUJQlCUJQlCUJ55555znNKHOc5znD8JQlCUJQlCUJQlCUh55555znOc3ve9n3wGQlCUJQlCUJQlCUJ7777599999vfFDnOHQlCUJQlCUJQlCUJSmvffffec/c5ve978BLglCUJQlfSZCUJQlCUJ1+/fv3v3332973vZwShKEoShKEoShKEoTzzzzznOc5ve97OCUJQlCUJQlCUJQfQZKXQCBffffffffb3vYBu7u7ugCSSSSAOXVDwASSSSQAAAAN3d3d0AAAHbuq5VXS7qt1Kk7vN73+/HBKEoShKEoShKEoShO+++9a5vetc3s4JQlCUJQlCUJQlCUJ5533znOc1rm9nBKEpb7EMhKEoShKEoT33zv7778offb39zh+EoShKEoShKEoShKU88775ve/37etGxKEoSh+zBKEoShKEoT79+98++++/fvtaOCUJQlCUJQlCUJQlCeed975znNa5vZwShKEoShKEoSkL7EMhPffO/vvvvta+3vYJcEoShKEoShKEoShKEz33zzvnOc1rm9nBKEoShKEoShKEoShPPO++c5zShze+c4eiUJR9BkJQlCUJQlCUp52eeVVXVVn739+39+/AAbu7u7oAkkkkXdU+AAAJJJJIAAACSTnON3dADt3Vd73ve90kkbS42lxtLe85wJJAFqaqk1VJqoShKEoShKEoTzzvvnOc5rXN7OCUJQrQlCtCUn1kJQlCe++d/ffffa19vZwBKFaEoShKEoV88775znOa1zezglCUJQlCUK0JQlCUJ5533znOc1rm9nFH6yEoShKEoShKEoShPffO/vvvvta+3s4JQlCUJQlCUJQlCUJ5533znOaUOb3znD0SlvsQyEoShKEoShKU9987+++++1r7ezglCUJQlCUJQlCUJQnnnffOc5zWub2cEoShKEoShL7ByEoShPffO/vvvvta+3vYJcEoShKEoShKEoShKEyv3WvAF3vBADv3nnv79zm97AG7u7u6AJJJJIAAASSSKHgAAASSc5xu7oAAEkiqus88BIK7V18+VZQlCUJQlCUJQlCeed985znNqG985w8fpMhKEoShKEoShKEpT33zv77777Wvt7OCUJQlCUJQlCUJQlCeed985znNa5vZwShKEoSh+zBKEoShKEvffOvvvvvta+3s4JQlCUJQlCUJQlCUJ5533znOc1rm9nBKEoShKEoShKEpC+xfffPPvvvvtqG9/c4eCUJQlCUJQlCUJQlKeed985znNa5vZwShKEoShKEoShKEoD733zz77777Wvt7PhKEoShKEoShKEoShPPO++c5zmtc3s4JQlCUJQlCUJQlCUJ511znOc/c5ve973vYbu7u7oAkkkkgAABJJJJAAAAA3d3d3QAAAAEklJNF/vgAkAWpqqTVUmUhR9JkJQlCUJQnvvnf33332tqG/ucOxKEoShKEoShKEoSgA88775znOa1zezglCUJQlCUJQlCUH0ZCe++d/fffffvta4JQlCUJQlCUJQlCUJw8775znOfua0cEoShKEoShKEoShKE5533znOc/c1o4JQlL9ZCUJQlCUJQlCfe+d/ffffbUNfb2diUJQlCUJQlCUJQlKc8775znOa1zezglCUJQlCUJQFH0OQlCe99ffffffvvt7OCUJQlCUJQlCUJQlCd+d985znP2ub2cEoShKEoShKEoShKEwznOc5znN73vWta1rW/27u7oAkkkkgAHy7qgBJJJIbd1R9AAABu7u7ugAASSfKq6Z98BIK78uq99zzd3dkG0t3W19mXe7u7JoJe8n+pNVSaqEoShKEoT33zv77777Wvt7OCUJQlCUJQlCUJQlCeed985znNa5vZwShKEoShKEpPrIShKE9987+++++1r7ezglCUJQlCUJQlCUJQnnnffOc5zWtqHOcOhKEoShKEoShKEoSlPPO++c5zmtc3s4BfYBkJQlCUJQlCUJQnvvnf33332tfb2cEoShKEoShKEoShKE88775znOa1zezglCUJQlCV9LkJQnWYJQma63nX7rs+5e+qLKLKLIIhtRYRcBFgBSUWUWUX5RcQRekRYRepFdQi9iL0IvYi9966MFF+EXwRcUXARevVF7VROxF/dqKIdCLKgjKonYK4ocUP3PfP3N7999/fv37nQACSSSSAAAAAAAAAAAAAAAAAASSSSQAAAOXdUPAAAAAAN3d3d0AAAAAAJJJJIAAAAAAAAAAAAABJJJJAAAAf+AA6AAAACSSSSAAAAAAkkkkgAASSSSQAAAAABJJJJAASSSSQAAAAAALAAABJJJJAACSSSSAAAAAAAAAAAAABl3VEmSSSAAAAAAAAAAAAAAAAAASSSSQAAkkkkgAAAAAAAAAEkkkkAAJJJJIAAAAAAAAAAbu7u7oAASSSSQAAAAAAAAAASSSSQAEkkkkAAAAAAAAAAEkkkkAAAAABJJJJAAAAAAAAADe973vYJtQkRTah2odqHQi9AmwTYJpRe0RfyiLCi7BOgTYJtUMUMBFxQlV2oYIulDbdVt1dXft3VTzByASSSRu7u7oAAkkkkgAAAAAAAAbu7u7oAAAb/KHah5d9737vetfx/CqhQBQUCDSqUolKKUg0oLSotIJSI0KFIoUKJSqpSojFQI0K0CNDSoFItAtIFJSUhQpSClClCtFIhQFCMQpQhS0tAFClClLSBSEQlKLTSKUhQBSNIrQpQiFIqFAlAFCiEVILQK0DSotJE0NKjQJQJQFIUAFA0o0NAjELQKEEFIjQLSoFAhSLQgUiUhQUC0oUClIU0rQFKUIBUSqFKIUKRAglBSFABQiNIUqtAtApQLQlAlALQqVECFLVCUqUINJQjStAUABSqFKlKkStCo0lNIUIDSBQNA0MQhQCFKJSUoUBSoBQKFUglBQMQNCASpKrQBSJQNAUK0KAUg0oNAIUqBQULECrQFIjSI0oBSDQgFUoBSIhUSDSgUCoVEqlCq0itIhS0oAUIlAhQg0ADQKUCJQ0KA0rShE0ArKkKkkhSAVSLRSKSJIgUANIDQAUAFFKIlIErIBQJQLSLEIwpArCkIBCkotCJQqkKQChKkqIUlKowpIqypAyJAIEKQqUVQpSgxCKQpIpCkoIShLIkKIUjQFAUo0oAEqQyiSAUgESUMqQiTAKUitCJEUNKUgqwpLApJKkgIQkAFNCpSLKkCEqQqzKESgFBS0lUtFAsSIUUtKBLICsqQpIpKjKkqCEjClI0iwpCLSjSEQUI0BQqISpKKypAAECsCsqSgNAhQgkqSghRTQUUzABEtIUqKyJAIkrIISpKMrKkqSoypKwpCLIkhClCkKrKkKBIkii0UBVBQFUDRVUqikKkqCEASiVApAIQKQpCkKQpILCkACSJAoQpCkqQKwpAIkKSBKki1QBS1RSlJEUVTE0IFUotAhSoEKQikiRKkKBCkIhLAAFNIMKSpSIoQpCAQpCLKkiSpKsKQgEiQKtACUKQpChSJIkgJKkqSJAokiSLRQES0BElNA0xUIU0NKFFUFNCUgFDQMSoSBIIDEiCSpAKMKSIsqQKUKgUCrQpApCoRECQDCkqUKtMwATCpVQpIkqSi1QKUKrCkCBKkiJCkAlIDEUBRQU1QJSjSBQUlC0MyBSUxIJSERRQoSJFACkKSCkqSIKSpCAMKSKSJAgLCkoBKkiIUoBKkgypKUqkKUCkQpIpCkCkSIREpQpApIkAwpKikSgwpKkKQgEKSCSDKhCkypJQhQNKFNBSUNBQFFFUDQ0IlMQNCtBE0UFMNTExQ01FBLRJDAjSAEKQgtAgsDIqDK0soC0ApLQsCkiSCoSpIgBVIiQKSKSJCkqSpQDApKkpApCkCBSotCkokqUCkpClQpKBCpKkikqhSKEoBApCkCkiSKMKSgUCwpINJVNCRUUxC0AxNFLQgURC0A1SFFLU0RQUBUVKNUUFDQUUlUVUREMlQ0M0xLUVRFRSUURQDVBQ0FVAIDSiiSsIDQiAEqQALKkoKUAgwpArQKSpIAsKSowpAqQpIJCkigEiQMqSCBCkokKQA0gpCkIBApApApCkKSAEiQpCkqsiQDApAJSpCkqNVSkSULQETQlKUI0UgxAFRJNRTSDSBU1SRMTUNMQ00gFKlCU0kQjSlIUBENJSxCNNFMSMyC0FAiUqSpAqRApKEiVQDIkiSSpBIILQiCMKQAoRCiDCkCiLCkikKQCCwpAgQqFAISiBVDQAlFCVUNSlALQBQpQjRFVI00p9991SlCUJQlCUJQlCUJSidwhRSUgDQgUgUJQACFCpBKiBSCKBSqUgQpKsKQKFCgiSJIgAUKkqQIKypIIpE0KkKkqQDQDANRMyNKBSAtNUIkRRStKJStL775599999rX3FDnDBKEoShKEoShKEoSg+nz288+++++1r7ezglCUJQlCUJQlCUJQnnnffOc5zWub2cEoShKEoShKEoShKE88775znOa1zezj9OQlCUJQlCUJQlCUJ775399999rX29nBKEoShKEoShKEoShPPO++c5zmtc4oc4YJQlCUJQ/RkJQlCUJSnvvnf33332tfb2cBKBIhWhKEoTzzvvnOc5rXN7OCUJQlCUJQlCUJSF9i+++efffffa19vZwShKEoShKEoShKEoTXnvgJ5znvOftc3ve9akkjd3d3QABJJJPLuqkDgAAAAAAAN3d3d0AEkkkkF3Vdu6qXdVu85zvd7Jze+CUJQlCUJQlCUJQlCXnnfXOc5zWub4ochKEoSj6DIShKEoShKU9987+++++1r7e+CUJQlCUJQlCUJQlCeed985znNa5vfBKEoShKEoShKT6chKEj33zr77777Wvt74JQlCUJQlCUJQlCUJ5533znOc1rm98EoShKEoShKEoSg+jIT33zvnOc/fua2obhKEoShKEoShKEoSlPvffPOc5z9+5rXBKEoShKEoShKEoShPPO+973v9+3rWxKEpb7EMhKEoShKEoT33zvnOc/fua1sShKEoShKEoShKEpT7OtRnXOec5zgSSSRu7u7oAAAAAAAAAAAAN3d3d0AEkkkkJd1XLuqlbvON4kje+CUJQlCUJQlCX2AZCUJ775399999rX2+KHIShKEoShKEoShKEpTzzvvnOc5rXN74JQlCUJQlCUJQlCUJ5533znOc1rm98FVTper9TXOZ973vek8Cau/vgAkASWtNWKZpaAFajIhIUKxRCmaUACtRtQqUt8BIKuszzwEgq6nGVn3DgCSSSN3d3dAAAJJJJIAAAAAAADd3d3dABJJJJD5VXWVV1n3wEgq6zPPAAkDW0tbrMu93d2TQTRmXYB3p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c5vfFQHiar+CpNLnOc573veABNXd3YAAAmru7sAAATV3d2AABraWpqszMzd3dAq6zMzAAq6zMzAAq6zMzAAq6zMzAAq6+cz7VXXg4QADnOc5zgAAAAAAAABJJJJAAN3d3d0AAAC7qu3dVLuq3d3d72dBraWpqszMzd3dABJerzTVc5zl+975tL3gDj9XmmqappqlznOX73veAB+rzTVIyxEvfffe/vvulDmta148uIkGWIkffu97nve9JJEtaapPMzLAJJBtIqkqpVmZmAatADaaqkszMvd0kkhTVUlmZlgEkkKaqkj77f13u5u7oAAAc5znOcAAAAAAAAAJJJJIABu85znCQAAAAtJq7uwPm0gAObSazMzd3dkk1tLU1VZmZu7uySCau7sAJJBNXd2AkkVdZmZgAVdZmZgA7d1XaarMzM3d3QATV3d2AAAJq7u7A+bSAA42r1JpNJIptNNzM3NzZugAA5znOc4AAAAAAAAAAAABu85znCQAAB27q72qutu6rd3d73oAmru7sAADW0tTVZmZm7u6ACau7vAAq6zMzAAq6zMzB5d1QDjau7uwAANbS1NVmZmbu7oAJq7u7AAAE1d3dgAACazmtttpNebTdNNJpvnEmue96HvAAAAc5znOcAAAAAAAAAkkkkgAADd5znOEgAAA1tLMzM3d3cbSAOpNY0qrMzLDoAGtpamqzMzN3d0AE1d3dgAACau7uwAABJbSzMy93d0JiTUTVGZ+zA6ATW0hNVd7e7u7JNE1V3dgBJATV3fwASQE1v6m03VJpvyab/fe973ve8AA5znOc4AAAAAAAAkkkkgAADd5znOCj6AABLuq/VdVV1XOc5XO73vQDiTQmqzMsOBJDW0tTVZmXu7uyTVXXPffffRAKuszMwAKuszMwAcqrpV1899999NAVdZmZgAVdZmZgAVdZmZgAVdfJv2quvGPQABznOc5wAAAAAAABJJu7u3dU+SQAA3ec5zhIAAAXdVLuq7dXdV5NNySSePeAOJNCarMzMDoAHm0tbrMzM3d3QATXMzMwCABiTQmqzMzAIAAmru7sAAAdU3zMzMAJJI/r5EgyxEvfffe+c599ve97fr5EgyxFVO973Pe9PAGJND9Xmmqf6vzTVL7ve9z3vTwANbTVV+0vzbbvM9z3ve8AAAHOc5znAAAAAAAAEkkkkAACTnPfXOEgAAAAPJpvyabpJpvnOc573veANbS1qqS9X5NrnOcz3ve8ACXq801TXOc5fve94AHrTVN95znM3dmgGJNCarMzMAgAq6zMzAAq6zMzAAq6zMzAAAJrmZmYHZJJiTUTVHOc5wISSRXXvPPJHvAADnOc5zgAAAAAAAAAAAAk5znON0AAAHKq67V1d85znO966CrrMzMACrrMzMAATXMzMwCABiTWtpamv37nOc5u6aAKuszMwAKuszMwALvnvvvvogAxJoTVZmZgEAATV3d2AABrartXXzfPO9773vegA5znOc4AAAAAAAAAAAAJOc5zjdAAAJLq67V0k0rvczd3dABNXd3YAAAmru7sAAq6zMzAAq6zMzAB27qu1dfN5znOd72dBV1mZmABV1mZmAAE1d3dgAAHq801SS5znL973vAAmuV95tN+TTf2Wv37fBu+uuKr+i7J24c6uc+vM1zzOb94FmNKLBICkHmIi4awUXCkIVEglFhiGISIYRd/uuoFeSK5Hgi9iLnSixUItRKLnoi4ABCiwAp4ABAAQArKLKLCCmCiwiyqqkCLAChIiwiLKLAiyiwiyi4osouCLAASCLKKwIv5VcERcBFlUSRFlFhFgRYQUZRYAVWEWRFlFhV6UWAEAxEXAS7+3d3VVvnOxGwAAAAAAAAAASSSSQAEkkkkAAAAAAAAAAEkkkkAAJJJJIAAbu7u7oAAAAAASSSSQAAkkkkgAAAAAJJJJIAAAAAAAB/AAdCSSSSAAAAAAAAAAAAAASSSSQAAAAAAAAAAAAAAAAACSSSSAAAAAAAAAACSSSSAAkkkkgAAAAAAWAAACSSSSAAEkkkkABJJJJAAAAAAAAAAB9qSSTkgAAAAAm7u7uoAAAAAAAAAAJJJJIAASSSSQAA3d3d3QAAkkkkgABJJJJAAAAAAAAAAAAAAAAAAJJJJIAAAAAAAAAAAAABJJJJAAAAAAAAAGJNU0031tK0mvzab4mm/QRegTBF/AmCLgi6UIRelDShKEiLtRYEEIRYRFhTdJNN/wbbf5NYZvQNAAADnOc5zgAAAAAAAAAAAAEnOK3d83QAA3ve9a8UP4E+EX8oQi/lCVOpc/Z9rX33333Ob3980A0KpSgPwkoYUt1TTaqm20lVJLnOc573veABNXd3YABV1mZmABV1mZmADt3Vdq6+bznOc73s6CrrMzMACrrMzMAkiaLq7sACSJrLMzAIElpNa2kJ19+8+89z5VXXo2TvQAc5znOcAAAkkkkgAAAAAHl3VAcCTnOc43QAAAA2lG0tbS73ve92bpJGl8ffABIAnX3MzASCrrMzMACrrnvvvvogDEmtbS1NV+5znObuzQATV3d2AAAq6zMzAAq6zMzAAq6zMzAAu613PftVdXf33O873vegA3d3d3QAAJJJJIAAAAAAACTnOc43QAAAAdSa1NN+TTfe9733j3gDzaWpqszMzd3dABNXd3YAAGJNCarMzMAgACau7uwAABJa01SzMy93d0AiTQmqzMzMAADW0tTVZmZm7u6ACau8zAAq6zMzAAq63fPD30AAbu7u7oAAEkkkkAAAAAAAAN3d3d0AAAHKq67d1V3Xt3Vc+c5zveugq6zMzAAq6zMzAB27qu1dfPffffe973oKuszMwALvMzMACrrMzMACrrMzMACrrMzMAAa2lrS/V+zMzN3d0AHVVVUqqqqq5eu6u8z537dV3u967oJJOc43d0AACSSSKPoAAAAAAADd3d3dAASSSSSXdc7z5z33333ve93d3QAAHfPPM8qt2SVVVVVVNNU1d3dySSSRNXd3ckkkkTV3d3AAA1tLU1WZmZu7ugAmru7sAKuszMwAKuszMwAKusu7sAADW0tTVGzM+vd5vW0t38AEknOcbu6AABJJJJAAAAAAAADd3d3dAAAJJJJJqab42lTaXOXfObu6HeiazMzJJAKuszMwAKuszMwACau7uwAANbS1NVmZmbu7oANL1edXXOc57+/fv34FXWZmYAFXWZmYAANK7u7AAAElWb+pNN+bTf5Jq/e9+n79+Akk5zjd3QASSSbqSSQAAAAAAEu6p8Abu7u7oAAAF3Vfru6qq+c5znPe970FXWZmYAFXWZmYACau7uwAANbS1NVmZmbu7oAJq7u7ACrrMzMACrrMzMBJJV0q7uwAkkTRd3YASSNqft/Umm+fXYHO96BJJznG7ugAkkkkgAAAAAABJJJJBu7u7ugAAA7VXV3777773ve9UGtpamqzMzN3d2SRNF3dgBJImi7uwAq6zzzwECrrzMzAQdu6rqarLu93d2aAmsy7sA6SRNXd3ckgACfq801T5znL973vAAkveaa/Y2kNpHM/fvff36fgAbu7u7oAJJJJIAAACSSSSAAAAbu7u7oAAANu6raq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85x0AAD88888873ve1XIAAD3z57mVffa379+/ftu79+/fv3790AAAAAAAAAASSSSQTnOc5xoBJJJN2qvvz5znvz5znvvvvtbVVyAAAzMzKqquQAAGZmZVVVyAAAzMzKqquQBw445mZmVVVQAAGZmZVVV3585x0AAD88888873ve1vNAAAsz8zKqrfOc+caAAB+ZzLzyvtb959AAAv2zKqq5chVVVVV+93nXFDzO+ec/c5zeta1rWvyhq3d3d3QAAAAAAAAABJJJJAbu7u7oAkkkEB8ARtpdbS1NN973vdmmhFKAAB+/tmVVW80AAD9/b9qrd278+c46AAB+fnnnnne973d25AAAZmftVbu3IAADMz9qrd25AAAZmZlVVXIAADMzMqqq78+c46AAB+eeeeed73varkAABmZmVVVcgAAPe3M+P3fv152Hhy5d+iL+8EWEXJRcEXai4ovQIvgi/vTOnFDQi4osIvgqCEiLCi4osgKSiyisIsIsosCsKLKLgouKqJii4gi4giOIYouIKDAqDgqJiIpCLAouSAgHaq+KHt1W1dc5PffWgAAAAAAAAAA+1JJJyQAAAAAEkkkkAAJJJJIAAAAAAqrqSSSSAABu7u7ugAAAAAq6AEuqfAAAJJJJIAAAAACSSSSAAAAAAAAfwAHQkkkkgAAAAAAAAACwAAASSSSQAAkkkkgAAAAAe3VBgAAAAAOXdUPAJJJJIAAAAAAAAAAJJJJIAAAAACSSSSAAEkkkkAD5d1QBAAD5d1QBAAA8u6oknskkAAJJJJIAAAAAAAAAAJJJJIAAAAACSSSSAAAAAAAAAACSSSSAAG7u7u6AAAAAAEkkkkAAASSSSQAAAAAAAAAAAABJJJJAAAAAAAAAAFgAAAkkkkgABJJJJAAB+2CegngJih0odgi7BJVRPyhtRfVDxQ0oeKHam1NCL2iLsRfATQi6UMUMEX8odiL+BIVE8EXsRfVUT0RfyiwApAtv82201+aabpJNN0003+ACAAAA3d3d3QAAAAAAAAABJJJJAbu7u7oBJJJJAZmZgAp8uqzM8wAXdeeeeABd15554AF3XnnngAVVeeeeABd15554AF3XnnngAXdeeeeABd15554AFVVUAAZd1QPd3d3d0AAAAAAAAAASSSSQG7u+XdVu7r2SSbqSSQC7qv13Vc5znOd73oXdeeeeABd15554AF3XnnngAXdeeeeABd15554AF3XnnngAXdeeeeABd15554AHW0qTVXd3u6Ekja0/bv5r79ubu7oAADd3d3dAkkkkgAAAAAAAAABu7u7upJJJIABlVdZmYSSSXdeeeeSSSSRtffffSQQADRVVVVVVVVd3dhJJJrfOIAAD888888qt3d5oAAGZmZu9qq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAA4ZmZlVVXIAADJ+/v7Vfaqqqr7u7u7oEkkkkAAAAAAAAAAN3d3d1JJJJAAAAOtpcbS5znOBAANbSrar9+/AAH5555553ve9quQAAGZmZVVVyAAAzMzKqquQAAGZmZVVVyAAAzMzKqquQAAGZmZVVVyAAAzMzKqquQAAGZmZVVV3585x0AAD88888873ve1XIAAD77Zn5XlW7u1VW7u7u6BJJJJAAAAAAAAAADd3d3dSSSCA+AAACNpdbS5znOHSAAiqqqqgAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5A+OPgzMzKqqu/PnOOgAAfnnnnnne972q5AAAZmZlVVXKqqqqqrX4/gRd899z33nOc1rWt73v8gfd3d3d0CSSSSAABJJJJAAAAAAN3d3d1JJJJAAAAIk15Nc5znN7u6SKVVVVVVACxmZVVu80AAD3LMr2t2uQAAcfmZ+5VW7V8ccADM/f2qt2uQAAGZnMyqqrvz5zjoAAH555md73vd3tyAAAzP39qrdrkAABmZmVVVcgAAMzMyqqrkAAA3nfnznPz97ne973tVVVc5859+7u7ugAAAAEkkkkAAAAAA3d3d3UqrqSSSQAAAAbSzMzMAADW0q2qqqqgAfnnnnnne972q5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5VVVVVVG+dZgi/KLIiLCqyIsIsIADCLAigwAEioiQiwAIwIsIr0oQK3efv379+/fgAbu7u6SSSQAAAEkkkkAAABJJJJBu7u7ugAAAy7qv1VVXdfruhFhFhFz333377777e97N1VVVVHeZ+5VVV8gAAzMzKqquQAAGZmZVVV3585x0AAD88888873ve1XIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AcPgd+fOc8888873ve1XIAADvnnnnne972q5AKqqqu957xRflEWUWEWABVSTTapJJtT6+8973NngAAA73ve96EkkkAAABJJJFH0AAAJJJJIN3d3d0AAAAGtNNxtLqTX5tN973vd03QBFVVUAA988888q2qvOc+cQAAH555555VtVcgAAMzMy3d3d3mgAAXnnnnlVu7vNAAAzMzN/PnznKqr7yAAAZmfuVVVcgAAMzMyqqrkAABmZmVVVcgAAMzMyqqrkAAB597z5z586+c+c+fPvP4FFxAFJRZEWEWBBCUWRFoEAlUSEWAFIBBSBTdNpvvc93x7fAABJznOW0uHQAJIAAABJJJJAG3dUfQAAADd3d3SSSSAABG0tSSbXkmm6baSaXe973097wAiqAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5OAADMzMqqq5AAAZmZlVVXIAADmZmZVVVyAAA/eZmZVW60aqqqqqq1r9xRev3nOdn7O/3vus35zOt+de94iLgi6Na97OkRfERf99/6J/45Ig7+Y4gjg3Lg4eIZRRXoVp1LQNx8Ngr/d91m7lf6o62IK9/wW8umjeC9Q2ihYfS2ODNIhicp/Eenz+73/DQn1Hzf6X4/Bfnf4qGSs3b5Tbcs5/K1cvp/w+0/BYzzu7jwfxgl30XP9vN/7b+j5/wf0/86H/ZAoqiBSqIKf95/hP5f5M837BvK6oSUXzqywrK8HzPBIJXzu7utKw7ipq4WsmriYqYiJqtJlTU0WWEKrqoqHPnZ62aQ6rhJ9n3fxESRcxZ3Och0Qr5dLvDO9uuZX6Ho0SoqqiDSAzyRMVgTUvV6OKtRhC1rWZVYlnaLFqVMgFxSJeheZpaVq8K7ysm0GHElbzO+3Xh35d4IiN2ovSiyi+CL0ovv4UXtRZRe1FxRfRPBF6BF6UXEV612IuKL2ouKL2IsiLCL+IRdRgq9GKLIiwg/pACUXpRZRfVF6UXFFhF6EXtRfBF6FF9UXQi+HWdYovai9kCtn5Re1F6UXpRfURfwiyi+CLKiHUqdiL0ovYi9qL6IvfQi2+v34RdiLsRdIi4osIvQi6UXxRdbEXBF7XUoPgiwi+KLoRexF/CL0ovai6EXoRcUWVRPwi9+KLe2eKL52ovSi/hF7EX1EELSi7EXpRe1F9EXxRZRZRfFF7UXBF0a70CvXQi1ddZ0CtvoFfyi9HavkonkKLgi9Ai/lF0Iv5RdCL0IvXsIvQi4CL2IuKLiiwiyi9AjkPai+iLAi9CLgi+CL6ovQK3nvQouKL6osIvgi+eArZ2IvWdiL2ovgi+CLsRcEXYiwi+3f7o9iw0Ahkg9Z0WEtq6uuyD0uyiCvS7R/iCkAABPToMKRUcEX3xRYAT9Ah513kCvQi5ZnQi5gi4CLoRdiL+E3CI6UXwRehF8EX8IvPO+uzrrs1h1+97/G95wAO8newk7Px+6c7VZnb/fc+k/Lifzab6mL6IvQ5kisIuPSi9H68EW6EX0RekBAwRfJRY7EW8UXoRewHkgh0IvQi+CLzoRe1F61mIrWlFuCLKL0Cv7DARexF2+Qo4ovSIvQi4ovgovQL3IvYi9gr1772ovSi/lFwRfVF8BXARexF8UXtRfRF/ComPL+j/Y/6j/puk+P+jh/Iw9TR6qJ6B+otQfyfYnckASLlYxC/39PtFxYP6vztpIqLi9MbgYDylMEttgnyZeeI+o9pHdnGAHrKiB6j/L8QQ1oHsA4wMAHc0NTB1chg7DrYmuqp0lIXjEEiyQtBliKAQqHTok7X2Z3C3EkXwuMUcZHovDJQVRUtz2e3ZJ14LqurLz3sT09NwPsRFsNLxeLlrwK0fEEPeSuSRmFhYrbAEW39WDC9QrMdwOYr1zLlNkxNCiZgXvnfK00uN9kDOMBnDq4qsd5UyxJsNwcWFchGkqTJ6MUgFM53Akp3gwz6KdAzG/nytxYVoUZFCKg5g9JRqCjvxm6gqFTqrRWokh0YS4UcNx0BBUqCiqT0rhRBxIoqvTfuwJJ9ZGqDVOoWQuz12acJ3hB+hsBIHRryXhQZoTvWqc9i8BsF6hMdMec1qIwPuF+mnEDAXBE4nj0kTsA6tvQ7h06Bm1ercwWgAwIDLFMChxo6zkBEthYj9jhVBeatElFF+Qo6X55VlNQluEC7X7wkXsV7UpUbiKiKEw6BWK95qk0VXCrAuOCwIGKwLTWgBmjBTCEIpDDUPFFE9tHkEKKFKsHR5Dw4GnHAnQDWu/fsYh07/GQNglhezcu2+fATnXzFM0bjiotHZm7tzDckG4jeNuBXsHaAcRnukbOWNIx2U6bBdRbbyYdbBsYDQqvgOwBswow58anO4L2WAexxcbnxcCxGyivs2BXO0iChQNUaqwDoBiDElBlUBUGgIYGqapYOqfeUHCAIFutNwtlABK5SPcowTsoGqUFCjHRdO3mMpVRbffjZOQajALAOzHO6WGZUb2skjrEDaQGJECnVtUK+GQ3sLjCWZVBBRwWBQF6cmiRGN5chuual+pmohDI6iz7NdajKAdAwqFGVmYam2Axw3kV6qSwVlfHcQ1CoyFlCKgO43DDJkwCnEUwEfY9NeE4bgQTyHGg0SOGtyZw5EnY+Ix26d/ATJIx11GtC/RRE+JCgGNvdhsdITgCrgKCenLEBW2ZPC7cAoJTpBG0LmHCEK+mAJY6FOXnn/5igrJMprN+GWWAAzZ0NACACvuAABTAIbz6vioGiLDYAA1qQ0BWQBTbKKCgASAWzVSNKEA0AEA0AEA0ACT1UjSoGgmpVPKjCaBSSVNQ00ZQkFLhCCV41SqiJ9SCqWp1aFRFbUioA9P3/A/L7hKKPzr09lHdPBtWY2baktbogIpy0EFGvrN+dzPiJSm7bTpWaR45q1/r22ls9r1oiTSmRyfK853y77cxl1z17zi9dnOfX15edPnH3O+d56b67uSbs65y85eLrxdlyj313xb4VsFtvfNveZ25uc7grjkucuAL1ixbWlxylzkykXZVQ2JNiTZQmyidpKtj2gnsKp2pBdjsKk2ZraqReZcbYzF7JB2UqbFBbCT3uqpR7GmqQraktsxQtpIWyIR2Cq9lCq97iJ80hTuQJd3bnLlxYglri1d3ckT0JilW9c93b52z61tRsnCyXbZ49u7Xs9Ex2dbPdOcbXTd/KVAT71tK2CbbFXsr7tbSZDZJtBsVW0MaS2zJWDWaKpsqpsKUthRIawVG2yJNlJtJNkpmNkTY1tGq0IyCxtqU2LG1MjWtGyatiqxjVJsSVsatGxRbYqNii1FaotRawWs2rSosGDVpttFNpJtsE2qawTaitoS2U2tqqWyYTDSMbSFkTNCZC1E1INCYbSU2hTQmqJsmJM2UTJGWommCatpJiTCJs2LUTUkMSakVtSmJMCW1KYkyTUTLJGoqYk1CZqoMiaFWJNNkpkMkmqmgjQm1E20KmyibNrM2jKjUTYSYJioswptiTTUTIahgmomUk1EyhWyibNiJts2NrNAliTLKJmomomVG0GkmyRWhNIVpJkqxJhJoaWtti1aKIk0RttaUFGoishttqJqJqJqpaFYpaUMUsFLaiRijSTaUWhNRNiJiloDZay2WtrNbLKQYq0lNSWpBhLEMmRNQwo1gmNRNDLYk0JsrWssrSNRNiTImaA2zExJpUtkTMVDaUTUTFEyRlEzBsQIGKmaUM2pYEBqJqEahootCaKahiTUNUrUTGMzU2omorCjWirEmQsE20axJiTQmJNUqxE0JqJmmiZExUxlCbQmombITYk2k2o1ExCME1E2qo1i1oEyRmYU1aNY1ba02omomgxJiqTaVG0UVqpYBilpYpZsC2EMUtYpYpYpaVLUTRVaiaEwTJVGRNSJqJtqJoTIliTVFTUTFGJNSTNGymxGtM1mWmG1bSVWxJiTRRZCayo2JMpWySaiaCMExVLZRTQmkitqJqowKNRMImJNEmrYiaCYk0iaEySYJtpRaiZQbRS1SxQZUtSWLZNI1G22omRNKJqJkTUTRE2Ki1Ewk22WBINZmZawTKZBoltGybQGVLIlVsimyUGylbQI2NapWItQwsis2YkzVJrEqZZCq0pYRasFLFLATYqLZEViTZDYLRMJlQaiaEZEyhTEmomRNKFZE0SahaEMUsCmwratjaS2o2qbUBqJlE2oiZEwrYC2VGhMUWom2kUWJMFNSNNgitRNRTUTQoGJNQmCaRNkTUTKJtIUxSxSxS1a2xQxBrFLVE0JlCaEzEmkTUTEmJNVCsSYiaEyVWRMCaE0SZE0k0JqNqbQ2RslNiRNQ2C1CTYtiorVRoMiaqhWyUMSaCU1EylWRNVE2qBNCZKiaibImJVqJiTEmiTCTUTQmqJiTKUWkTFVaExJkTETCTImUTSEYk0JiJqJtRMiaRNRMopilgpYpYJshbKtitrFLKUsqWoUmyAm1SGhNSNoEptVoTRUGJMkksiaiTKJkosExJtEm1KrQmFViTCJkTImzImUEaiaEyJiW1VS1E0iYbKramJNlKthVZEwqsibUTSJpEyJqJoqtRMiaiaEYpYpaUtilpBpSyttjVjVosRWxWNRqxVtbSTazSqGSMUTEmhE0JiiaiaSgW1IZUsRBYpaQjYATUTYJqJtVG1EwmxLQEtiqWlLFLYUtIRlVRsraZmMpNpsbM1Ja0IbJCWySq2QSypZJQtpCDSlqJkTQUTNSi0JooDaiaEwFVkTSqGRNAlsRNRNkTKJpWa1U1Wg1tipmNoixSUaKZtlNbTayKhNqIZqLZUNgNGTbTQbVWVWbQasW1Fooo1RYzTZYybVGtraylUE4pXYQBP+YoKyTKayuYw25gSjJzcAoAj4oAAVVB2+RMARPvoEVKokqVCCqlFSSCjFDIAAAAo0NAAAAUaGgAAAKNDQAAACalVAZDQaaAApKUmhqaYg0B6cFKUR2yVRTfH78Hq8/NQWq2TTNWSrGlTNmYy2prSlJVaCkicoAXRJLgKSJ2QpJ6DVN6VVFQaqiGC5kRtEm1UraiNhRbFQ5gW1QDYqlzCibVJK1TUhyNH16c6bo469fUQslUU3EK2qokGFpVRLCwUzC0mKYLE1TVK1TFTC0pttlMFlTapqmFqqbLVMiNUwRtbRYWqbKGFWpGFpTWCsGEapojC1Q1UySbG2FhGFqlbC1TaLCymBYWhbUFsbLaqGJtUMLRYIwtJWFoMLQtU0LYptQ1TCqbC1TC1TCwtC1TSBhaqmFlDCyo2NlsCNgtU1UMLC1WFpotlTVhYWqYLVTC0C2QsLQWqZJtLa222020nfXMFsI2Fsqm0W2iwtgs0lYWS2qZhYmkspimFqMphYWFhaoaFhaqYWxK1TCbKbKapqRsFqmFWwEwthZSLVMKtU2FgWCwsLBYWEYWFlMlLC0FqmkwspWDElhYWqYqrCwqwWwtqmi2hYWEYWQWFpA0WQtqhhYFqmqmCwWqaFhaFktVWFhVtC2qlYWUrCyFosLVMJMLSm1bKphaoiyltNEVhaUrC1VNgFhbC1StUwWFgLC1TCyqqwtVMLKhhaoNqtqRhaFslTC1VNUyphYomFhMLVSsLQsLVVDYWJgspqpotRGFhZTUjVDYWCwsqmFtU1UwtUwsAapgsLVDCwWFlTC1TC2yNhS1TJFYW0WUQ1TCiwtEapoitUwKYW1TVDRYWUwWqmiwtUsLIjBaKtUwsLQsqaplTETVMLKmFsGFgtUyRqmqphYm0MLFTVNCRhaiUwsKjVMBWqYFqphVotKGW0NUMLSpqmFotJS1TVMLS2A1TBapqUsLRVhbVMFgsphYRhaphZQwsLVNhaoapikYWBapgLVNBYWKVLC0qiwtEBqpqptUwsFVhYRqNlQ0UhhaSpWiwsLIiYWVRWFhA1TSJhYUMqaqZUyGRkkq2jZUtpJsmxbZobezSALt1kAXh3+P93/v63fQahtI9Ac9V6nxdyRThQkC4l/qYA=="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        sys.exit('')
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
