#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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JvhO/XfecafO9E0B5OA+yx4qrksYqqslAACWADZltsyW15Ji2vZkALMiC22yZzm973tNcXeVT3z3xdad9+96u96G0B4gD1KTUmlJCToCbAttJJqSSQkxJmID4A9kACetObl3fvmnebTXOc5uciiS/j3t9728AxjBpsE34Z73ssF7776wMUzPckjYAGSzOb1Z0HZqks9sDobKqyV9d8kqr5LHDYq5GWbzS7vXffftz3Pfft23tvgAGwAAPJHJPpIAEiqrpu9G71u7ulleK9oa/SWy9e/ZmHzJQzACWdgNlVZKen7ySqvksQ1VZZuc3e1VtnvAAMlmZjZQCSn3I0z5JgHqa2TUkkiaPMzXt+Wkm01cQ/sh1kO8ousRxXxXBA/qur+/v2l+9XvvkgOYIDsqr931iA1BZDvUr3SO/nl0htEO997b17+40QEEA0gLEAzCvVeZ1WAg7e9BAdiRnotK9KTvt9MD5oI+9F9U83UCMbQkIbEAxATilStuOqQ5PQr77z7tCACtfL3r7XnzXN2mpmTzWZie6hzRTmqNqGyy1DSsoOcpOIrjCuNKtTaNi2FbKGsmsWxtbLMpsZQ2hqGoOFyocYjRNIyGMoayjaktiGsYsFZaofdu+UOtI6d8unfEDmNhFqqzTUNQyofPedYthGeVyK+6S/YneJPecVMhqC8Y90hzJPe+k6qTM1qZmQO98+d53vgA1fhwVRvezWg73ve970AFttttAAAB459Bz5d+++89XoAO973ve96bALbbbZQAs999nvr4D7777773vcj2xtEY2kgjgMI2xRtNPnBsGNMZQA2hxQGwIRNkG56ik0MdEaE1JIpGAyMbbag20o5Nam8mtZrU3vnnlAA7dyZcySNA728A+C22y3cmWg6IAFaVoHwvmrbeW3lOAHe973veguTzTTa+977mSTszJNZMzut76tHoeC2222gAttttpABbbbbQAM73ved77yTO9PPQBVttt7QyZiZNZMzNACABJkgABbbbbQXMkiTJNAWzIlE2k8TSWPFjaSzJJJA+APWmGBqTHI+t39fraAGDdtt1mZky/XtbKrQPrqTLq223743JjzegeG5MN228t3JlHgAAAAAAAAHgh6AAfGsmSbkxpzzzzwAAAAAevfeF77777+8588vtqj61Q0TcNcVNpI1YaqDz789+/39+fv7s9/xy7yV9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lVVSWKqqywzN8koHcsXFV3ZIckkkwO5Wd+b+svn6d++36Yk++d9htga3iTA5Muw9ALLzRiVurbbaTF2+31J2229vxJ5JQAACSeR5vvX3OszPgn7nOc5Jecke1VWVVV/MyXvXkmW2+TIkdATIkatttuZO5OPSqrLEAAlg2VVVlm7u7u7upqXTxsx+Xy2VXV7aABwyTJJJAkltttfwejn78A6AFttfs7r+na9+SVX977Jd3vd3d3ZY6qqyUAFWWKqBLGK77Jd3d8tnseKqssQACSgABLDVVWWH7vjnXXnne9+bprf54D1bbbvJltFzurrJlttr9QEs1J5MUksNoAAkk16fed6k+c731NAASe61qYAVqTNamtSZrUACTNamtSZrUgASZrU1qTNagFtgmxsE2V9D7777sBfeh9cBNjaE2enpJJuJPMWYk8xySSACTzHixtYsAAnJjaxYsxtYsfPoDuZ59ve/fd367vafBDwttttr0vLbbav4C/lszLfrb4AABJJLu85zl53E1ixZiaxZJJIEMTWLFmNrFgAAQxNYsWY2sWYAAJNSB77JgeTIAGZAttssVVVkqqqssVVVlnc8P0073c76v9p6HhTeTAHS8ttvt1TJj8KD8AADA7kz93Xe7nf68kx/fu5Lubu7u7ts1VVZYqqrJVVVZZ4qqtlOWQ5Ico73Jd3e7bvu7ugCaJJJJEnJJJJE19vza15roaaf333zTNGTuplecvLfmvc+0k7u/G9z1TJNOUFPJuSfAakTcodt+Sdve973toAAASSeaW8fx7v3YVNSSSSRNdAAATUktfZMHMyABmQFtsyW222oma1NTUya1oATE1ACzJbbbbU13z3SayaNbtthvvttD4AANAAHAA9SYdtuwA+knlAAALbbbaSbaczhyyTu0mdvia9xYAAAmpJJJIk7bbbbMlttttmS22vpMHJk8ANliqqslVVVliqqss6yc6ksntDLUMyhqr3ihyVqHvltpffu9F8bA+kfQDTTAtu5Mackkhyc51tJdAO2970AABNgEkyb31tJdxtJZOkN7SZ3via9AAATUkkkkSy2222zJbbbbZkttr6TByZADdtm7u6qyxVVWSqqq2zZZJ71Gkoc8757975afS+HZRAHDI6wAC28GwHgeW222pmK0AAwPy3ve97tiXVjWIAPtpMD31tIANgDV85N5Jzd3d3WWKqqyVVVWWKq22ZLba+kwcmR6ATIttttzJ28M/mIChJMATbfSFutICDmv79IIBiA80l+9eF9vZvvcfAA9uVkc0cWNFsY2NleoqmS5BANHt2taEt2LWglQQH3EtjLYeZTQNr1iA9QXKrp7zm2bbbJne5tZD6hqJ1n3v7eevjxYpM0fa178bnAAFrzyTaD3zPW2m5+Re70tBV3qH3UjZQrmSp285JRnLhR9/Xbq96+RL9/FzrYr5++qp0WijnX26e/3IoPti2SP7IcxlaqfdIP0jEg8/IYkL9cEkJffe+1gvnldAXPu2dDhuTOx888a3440byY9Xx4ceuSYPfLua3RuTPhy89NG5M+dPCOuSZu22up565Jg9+c95beTyTNTmTN36+06+760J/V9RX05C8TGC3Xzy7rH32576Avm6Hh9yTNXe58699fe8ajUmUeDZuTFt8t1buTKD5HXJMc7qbtv1n13I+eEAAiT00zQHPuY02piTT+zE0libUxpyew4bMMSZgAH3uNPNc57z7nOAEOB1r7Vttv1OaBofZryTLfL57aeNcD0+eNB4fSZfLrgem400EknJ9yZD349wjRnwcJOJNNrSxLHjmX228V7Jc1mNnhyd+ye67rvvnegAeW2+W2uTwHvw9kwPAezYe6HtMmWz3UzN2363bgH3A8kw32c8jl9t+7faPQ8K08vuZLb75bbJJJjQB77Jge+hAAszJI0AWTMkjQBvJkgDott72y3cmA99NG5M76HxyZkm13Jlp18AW7ky2234ABu22104ceh58Lbbd20POm8mSePWkOvF3bu0b+edN+6L34cANyYAnQ9ayfa++8++3kx8bAAdurLbbKAfffT77zeq+Qg6X/ftd3+7MuJsckwF+/ITnRtjuSwSFaGISVppCOaEG5BoS1/UJIWi/fT39xv+PrQIVsQhBTSBecXO075234A9CR0AAtskkkA0NMJJKYAW22gEMNASTdSbf13ve9t26ackkkkTUkk/NpMDxNHwAANoiqrLN3d3d3dliqqslVVVlitVVlitVVlm/oc5zfj737yy/Znz75VnjTknnY+peAAW2lvltttCSSQC973aT73ve9720DYAB59dz185y2JqSOTuWVerZu7mzd3dlnqh6HUsJwA1SWAGZsJQAMlmgGqywA32Sq9yzUHAAE1z3wvNe/ffX6lDydphJJLF0D0At3KAAFk5zn3CeULbaAAAEi/e/Zme5993bFVVZYqqrJVVVZkttttsyW23++kwcmR6ATIttqslVVVliqqtsssryU5LZPXqtJYtLMzPD7ngb9O8JJJOxSSSQCSZMSckkNxt85znOdbSVC222gAQwkk+207yySWxNdAAATUkkkkTQAAJkttttsyABMlttttmQAJkttr7Jg5PNYD4MmSZM81mSZD9oVwMhzUk9wjp/cQ5jSWYk1MSS1iaTTiX215qWzy3vCSUJznLJ605Kcl554AAWRc5znOWQAAA3d3dVSyn0PlX7WWKqqyVVVWZLbbbbMltt/vsmDkyABmQEkiaAAAG1JJJJE1JJJJG13E0kL7Sw0mkva9PEsx/etOhdavbJFJ0AkkkkhJNyakgNMJJJJIdaaVtvtxJpW2+ptK3VtvqSTQBzu1zsknexNS2222ZLbbbbMgATO6kut217Jg5Jj0AmRbbbbJlttttmS23vecTUkkNpMDxNbze1vWk/OTLzdXzTt332STvrTAPZJJJCSgB8goAabRJKHvGmHetNLvdJPne973d0EMSQHC5iak950dHhn5/bLNVxVu8k3d1Ulm2KqrLGQAAljqqrLO8zNkrkld3u2deuLu7ssMxALZsvFVUlnWd9bPfO/ffsbzEksPp7JJ2e0J6pJ2SQAD6RSSSQk5zn3M5hOptIttt53MTSXdJ973suWWT7v58ssiu+ZZ53mZ++ZYflXzJKvVs722vHju7uyzFVVkqqASxiqq2zM93yS5nTyWPPVVSWb0Gqts8s5mIGSx38v373l8898kvnLnJ7mbtT9cOH5kom+22222hINMADckkkgFtvlxJpW2+q2gE5znUbvN773ia3safOG22vVsX0AWWcUAJLoABJvNm7u7ussOB0G92VerKqqrbFVAlgGvve8kfPzyH376O83KBvdcyftKyRsaK79au9K5J0AOq22+NO22w4AATZJJJCQrTStttttrTSrTt1b822mAFl9sz4A1ZYqqrLFVfxJd3qS7ugJkaBb2ZLbbbbJlttttmS2ySSJqSSQ4kw0mgNgAJrM3l0m9JAfjH779TYgKlyA0II6CmICDbEL9I2/1bhiFn0EBI/2S0kk8iQD6lB0CAnqChAX6eua0gI2X1R8y686GOqq3YgGwd9fp22w9otqVB+i/mUXNISpdKMzMD1rztjEBcH7c7BAPHBAZvuRP732yfn79f7df344AabSQGOh+b+7JOrFa1QybbNFrPMXFJqHnEOSjZPKGZVfHKHCF8596OnS76VTy44KnUJiq2bUTJ95HIjGyDZIyjMEwmaq2hYjUMaUYjuhhOTNQzVtI2JsbJNqhqqXOXLEO0cqHmUdYRjaQzaJah7kOUMR7o5jUPDgfdKeNDKKyWwq5qS5TL3IcmipmbVIyGVZahsbTa22ahp+57ulTTaxtmUW0bMxbEvllzW01pR98gD6tAQOMQUdLYINaSLYH31/U34zPed773vvWhwGhty29vvWwC0A6ABoAqvtjzllst9toPAe3Jndd3rve931Rx0PlZMtttvaHA8AgvKHrR8Jbbe97AAAAOcXMbbeY00nmNuY9YkvtST2qADXO973zv3T43JjQOLbfbdWgUXve973fVDp02tturbQoG5MW2W/W09NHgR9TJk4AMA83Jnfu68737oAIedNnoAD228ttoAG8ybzJvMjMgAAAH3fcyfb573z3vnQADzeyIdD7XhyTHp07wD4ABsB0SZIAOTMk5kyTgFtbyZIA6QADoEItAAW9urbaOZMkA+HJnbq2+28oPg+GwPrQAC3VG5MDytSZJzJkgHy+W2+W2gAHnnnngDmTJAPhbbbbT43JhhgAE2m97893z5J+NMJxp4J4hN6WOhqGzUNo664k6Q0W1CGIBibECGxpogLb9v9+9tlDTO/iSZyTme/bNPtPqBi/u9VXtV3ccXpWRpgm5JJJIAAdVt77mJpLttoRTMTSQbjT+WrJyJKd0uja1jzGwAAklVVVliqqssVVybyW7vUs73dAmS2222yZbbbbcgATJbbYcSZhia2tLb61nm02U0my7RONP7t8iyQmfNOAdXwB4AU3QAAs5zm1zOWQTYAB23qT7bbUqE84c57ZJ3omg1VWSqqqyxVVWWKq6SXd6lg+AmQW22yZbbbbZkttttuf4abAAvEnbpNBvxpNLz8815zX1qy/cv5ppuHZzPx++cXp3rd3zdRVXRVVm7+ssRbbbbQACSTfU0l1c12STvRNEckVZKtVVZYsVVZYKrpJd3qWbN93d3d2WIABJQAAlmqqrLBUkhxJhpNZ9zk3j898+4uZj7mm3jvZUdvxzEnznOcs4J9AAChJbcSdtt+Oc5znLJUFVDxMAPk00jGWgFnec5zneyYltttMyUBZkttttsyW22uyXd6lne7u7u7ssVVS2PFVUlgAASwADSSvLZvJJDdPPueee++Z8QzPvd/Ae4Cr9vUl3d3d03VVV1AA1fp99aAEklJJL9d73vvY2p0AJtRNSeSTd3ZZuqmHJZs4qqlsAACWAACyVVVWWcVVWWAAaSV5Jd/bkWtedXe+9u973N84SS22222hJJJJGmExpySSTgBJJJK00gtttoc5znOd7tsVVC2AAGsselVWyIADuyTYCzJ22222ZC222zIlttqyL5iPe97fe94Rh8SOMQFZfwXx+GV8zb9PWn3NnZm40+w76AHrTApn05znN8Oc5znOSVppFuNO0LaUxppW96fJPve97+9k85Z1Oe9+++5+5LPlVVliqqtsAACWKqqyxVVWWAAZbDgAGCN3d3dEbu7u+4F5iI+PQwqrsQGZSFi+2m/DpuedxTfeXnFzDvT4D0+tujYRiqAAEX6yybyyyffffbu7q2VftVSW8/VsvD5U/WzMzMzJZmZmZ+JKAAEsAACWAABLFVVZJwABZLzlkAPQW2KoBLM778D7L715567N9TnAvPrvnOc7aCAAoBNNOSSb3zw9kk2AVNpXLdGJNIDxppAHrTSLT1qybz9zksk++/d69qH7ZKAAEsAACWAAGstj0qqyxAAJKAAEsAACWAACySRV9VZZj9vJ5nJLJzvknnnfvnrZyTOU9d7/fj6SmHyv5AANdCSSTnCSSQAK00rbb800rbbbaPd3fLLIffu3tV/EsAACSgABLAAAlgAASxVVWWAABLFVVZYAALJa9Kqsk87/HZ73P2cOWfcssGkB1CAzre7ogLIz66e9/Xs7dnvTfPie9fGmZr148ptjni79mVJnbmzfUhWifpZRus4UfEXTEdWhi61sS4hto4TmbRXJGNrhplzcW5w5rbNbnKhyrYRqlc5yoZDUjYHdc1DRw8uVwWbbVWk3Zp4dNdOFctcJWCPlO979FX393c8pirTCn9rr0C7B13zrs71DnVDzrtQ7qV3I7dRLgjI/cuyOij51zrJWiahvmT9yh7496QfKI6I2Z8dEdUOgrZR1iOe8KHEnrp0jrdeUPC9x50hLGkBEgUQxoY2MLv777rJ73r7t6LADe/XvLfb7360Ad73ve96AH2vGHp8AbPD593vez73zneg398PPGd3v777731QGwvve973qgBbbbbQ0AZuTNd73vfu9oAM2mZbZn2p9688kmDzvegB4W+W23yh344M9t3Jl1bbQA1Jl73ve/d2u5MB6aNyYtt9st3JlA+6jST8PpJ5JMacgAC3nA00/SScbSibSWJtZvU0k5kAIzejSTDRzi1zmknznPA4bkwPCyObbkwHqxvbcmAfZMyxpuTACXQA5zve99970AB8vLfL9b30+AA8kyS23y20AAAGjcmAfACZMmK1kwABweDp8NzMkA06bCnTgHw5Jknx483Jh2+AHTcmSAOltttt5APhvJkgtv1ttDRuTAPt222/WhqbyZIcBfpM+1TzcmAfG9m5MDrXzfNTnA+HN5MkdN5MHTU3kyS3syTST1vkjZgSAERh5NzzMbSW0mntkfOcLTRV4cKczbtkr59FXt5JZDXsPXvf3fv6W3uznLO9fx+99/Z8B9+O973vVFtttzJabyY9gOi21+zM73ve9+3mJpLve22xRTnZ8pJ4+40jGliySqqpLAAAlgAAstiviqyxUAJKAAEsAACWAACy2Kqqyw7wPO/Op9k35F9sv7OtkkA/PtlX7sAA13d3d3X2S70vnjx5F6VXllV8UyAeh8B50OpO73mZ3W9/d42uc5znOcSYAASwAAJYAALLY9KqssQAC2BmZmWw4ABl95bnWZmBLCXzvon2NvEsSTSMfvwH3e4uc5zs3wqfT5AHpbgWltttnJJJIoNNIA97mJpK235ppd7ruJNLve2220jTyc5znNneptTUiqyxMzMyWEgAAzk5ysnF7VVnGNjZoHvT3ve94bGxts97u7u4E2Md5OQ6GyquRk5OSc5FVUHqdcs4qycbXmP7Gk081Rvvum8xu4t0+p6k7e97bVttA8yYD0u8mW233q2220qdwuW2W2psAC9zE0l3vd+r7fPec53iszAAJZ6AAsth0AKyzpAAtmZmYBJQAzJYQAAlmZmZiS2HQB3CNKk7opLv2BE2Ntr6INaCv2fvz9+/Z994i+Kv6Kqq7uqqhqqqq/VtpgFttoFaaVtt63zf333Yk97nOc5yWABmSwAAWWw6AAlhmZiElAOjMlmeZmZkszMzAWWxV9VZZ+fHyck778+9fvz+/b++z5VVV/Kqq7uqqgSeNOSSfSSSQA600rjbS7mJpLve97+/fv32ZmZn4t/Kr6vTaqqklAACWAABLAAAliqqtsAAFtselVW2IABLM69ySd8673bk3kzN1/Fl/XS6ghgbaYHhgAATYVq221Wa5i/Xlt+v50byYD02APGv7e/6TNa5JzoAPxLAAAkoAASwAAJYAALLYr4qssVACSgABLCgAEsIAAstj917ycbO/fuTPN39x+7N3f0ru7bfQAAABB20AAbUmqHgB6aAwA4BC3EmlbbbaNP77u9771NCyIBkszMzMyS5mZmZJAAAec5OTkAAwnJzkZ0qqvIcDoB8svIqq5mZmY/ZH3oOz79i+dqvqvzFXbLu7vm6vdTkkXvCSSQAAAAAq007bbervbwDM+zMzMzCHIADkl4qq5mZmYwAAzMzMwFVXGSvSqpmZMzHzrrzq0N2a5zz14vul/v763fbbbb+QAAQPbby22gAHTYfsmSfv3732e/c799+JmZmZ77777+zMzM9wAAczMzMIAAZmAAAAFsZyyKqvP3vId/v3Xo71LArPn732evTRAdv33p3tEB8/fbBAVmqz2zgQfOvUXpFTl8Jb91x751f7eyCA5IDO/ft38Ef507EBnUvmQzOzbDExUzc1zm9zXJm9Z93h2+e0c8B58HqfPT968/tzr3+619jojhGI5SpsI0Rzk2xtkZDUNpGmZNs21mtbmuY2m01DSNqbbSNKym1QyGjYbXh72q6aUygZu5HFTZStuEWyVw+fOXdDvmNiNaEOQ5xZJaI2srhb5ao5v7tI+47D510vC5n9ulT61BP7PnaTjTb0vTTSj9zGk/tAR73ve9rZNAAGvRb9599d332mtGtA73ve970AEAAgBbbbbR8ODEmXve97O9UALbbbaAAgDzQPgLe973vVoAMX7uZOal1nNTnvMsaHcGFSEajDSyiFNFEgNsdImtZnOTWb5b790ALL2d73vVoAMttttp8bkxoL3vbbafDYgYctQfPTQPi8ttto6exqebHr23eSZMurbaLkkkxoC2222ngPQnmZgPQ8B6He973ve8A+B79593nnO+96AAd72d73vQADwt8tt7l0AAttttoAATMkn2h4AAD0PMmDeTJDps6ayZIAigAAAhuTAHUakwDWTJFusmW29tA2bkwCG5MW210N5MkHA8kytAD4cAd5Zu26v1taKDU3mh9n30mZM999F6TMkABbbbbQBrJkg9c3JnvddvuWazUzI2s1RqH6hqHDSOKuSDlFYl+nFD7+vj1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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
