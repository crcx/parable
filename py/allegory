#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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AFhxAFEZzy0sc0zgIh+2b7X3Nnp28Bby+u/PD0fg8B3MknJx0Eee3XlJmkRtKASEs4iHteIjXOC2Iiq97Xzz3npADIAnJnrdEAMgCfZme0rqZgDTz952HuqABa66AABuTH7t1517e0/fvf29+++NpfOOB6AAvboGl9832ZJOpkk53MAm9S89IARAFkAI9V3V6+73pgjjy6nM64DTquA0AC110AADnXva5Mvvs77vfs77/T9e/L4c678/eqvXO3REROuutq9ugaXqZJN3Mknf7915Zkk9ed+aKeeZM763z293rx155+9pPAfgAC110AADcmeo7eAAAAL26Bpd8mST2ZJOvK79neTPUySeS85znOcnvvvf6rXWTAGgAABa66AVwA3JnZ2Hvfm+T2dc6yZf0/WTvl155O3TbWm+8u9ZMy+3j39+3dV1kzm9HYaAAAFrroAAFy85kzrqeck6454FNh0AAC3x32Gn7czP3UySfrL+4777/N06yZcnToFLkrroBwAq7yuuuwAAtyZzm9dfunO340MTrroBZ347D3Sz3OZkm85yezJJ+dv3rVfu8mB+NPweAAC110ArgBbkx10AQAXx0Hot5467DTc9t657+7vmT9MkndztPZv2pD5IBogGqbZ1OMixQgb3nkt+9s2QArZACGzKfq16/VO9FTkqtlOSAOlcc6t1MYk7iAN5Grs6sIA97gQGQD62h7utdc6Z3cqVIApAMS8T01Pr5DQ0W6byyALvrKUXm+LFVNbidhiCW3LmUZl06IBrWEAZfPtaI1VZAF+uu8u8G11sgDCAL9JQJJKphz18sIaxAkPqpKZiAPU/KdrTLusnq59VXu14gDRe9q5b3IgCZysWkQkRHpg10jLFnu9rnJq37Me4b3XpAGoMlN3ddmtTZACWa7x+HOWQBWKd13ix2c5mHc2ISPC+eYogZokhIBJru88e+UbcmTIT9kz3vzwe6WOAF8dB6LeOdAOwPRuZlc6e++73+33qZ2Ud7K65cwRvsy/GZmVfq7vee+9u2HKDN557zr393OZPHXeqV1kwBoAAAWuugAAbkw6AAAAF7dA0s7s6ybeTv3nb933+LXXNvd5MzvnM8vf6c8948630tIfAd9854Pn7dLLe5Gd868668687nXnfgF9dHgPNmZ571Dp560/TsxjP07Mmfpmfv0zKzczXTqCLmvKvcoIfiIrUP0KqrzHY1mTPeTzzzvrnOTrzvqd9T9O+ru7pXAC110AADrcmHvXXY90AAAL26Bpbtkeed+A2d5MOw08QPwABa66AABbkzx32GgAABe3QNPZHJO+jwKnWTN66nI3Xndvnm86l55cmdvOnXXbwq110AADcmHQAAAAvboGnu3Oud9zM/c7nPfzzzs9069vWTOeOn4WgAAC110AADZmdevePz89UAAAXt0DTbOrnXt9eb7+are8mHYaAxieTroX110AABcmcdANOgAAXt0DS3l/c776dd9jTfzr9Mx3zs9aAAAFrroAAC5M86dhoAAAXt0DS7L11njvzwK6yYA0A82eJ7rU2cK13eq9lEwReVeZNHrUEVRmO+/I899UAAXt0DSy+uckgYLU3jfLxaMuYgCZa7AIylEASQAm7vDpsgFj4gHMzjpwDGL8kAdOdukMgDZLuR3J5zC6bUUQBZAHqoh6hwhxDyLm3xk26Ic8Q8Q6F+Q+oe9eocObpubk6y7y9AD7ZhmyAUIC4QBF9ym+9pJJkzMzMydu+/3n7faXMkyZMmZ3kx0DQAAAtddAAA3Jh0AAAAL26BpZb+yZ113Z07878NOsmANAAAC110AADcmGdYxiJZmfo2ZnfJtV669L973t95HKc6ItTeXYtWRRqrLKqcM+1mXd3iFU3o3nYo8paw2VK3I5Xfmh7v2acGNGW95i69ecMzGY3hq0+m8CBu6dGaxqaoMSAsA4mCGU9h7c1w19mOWUvX10DmVHVuuYU2zNmQ4nMm1NVNwWVEUoI7unlcWktM2BjrCVIbTmiyBzRZ6MJ28yG+9V20UocVF+uDqxAFJGYN0TcZhEw6lDxxtwSIh6Rpm3dhKNnqDbT1biPc4s85slZUrgtNTRZsXLvHuYxc0lDMpy2Z9iZVGY75R8dO7vFOLprbTOpzpqHTUUUvOXNDd0bvVV4ju53meZ4Prt4E6wJUpypF3kMNp7nM8zuqA9rmGtFRYneDlYeYVQadN5EuZcfrmxlB1ouGJbBT6z3PsvXpnvqTC7wR5w6mTfPW4Y4du9p1Dd1jH5M0UyauMdNC5M3dZrOIB7lk+esSCncb01U5YvBo53QAkp9O12WgdzGIuq9UVSFaUevarKqZczXIcqWNiRVKRkxIiaiXTqabZgFqOOyHtZY10IMQJ4+smshCSwrV1Ll1WGXME21zWZbbTpow5rHN9s5FZFIpGl5aSlWbMyO6vHgooaJMadkqBmKZq6nZijBVWKDOFI0quTrMLm5CyRW0Z7RJNCw1TPTmaxpS6wojxsnpuoJoJwM0GgVx7uqYERazSYouAa0aMGu6VbqBcR3Txh717m/N73OCQcpMBLMjC9wnkWhifjLrUlNIwtGmMUbcMyXTVIdFRsGknMvSahZdGGXEqKlQTiDFHq7CXgltmPtcGsqZKIE1O3CXA4lTU5usQjqlc0V6u8ru6VcsMLyVhd3mKMhCqRIvVk1kWESJDUZtOt3rdkqS1otBVUxvU2523jTXc7p1TFbQ671ZRLadytkLxS5NvNyxVolB47dJ3M3oUxKnOHcQTSb6Gs6m+s1nczI4Yib01VUVVWrmaskKFFjyuw9T31UZMCULvVtUTJ64y/SWrjUTmwyyC1EeVwYQpNJw28q6xZ13edz9732/e7a6yYA0AAALXXQAANyYdAAAAC9ugae+zk3k/Xp153+NOsmANAAD4Frrp8AANyYdAAAPffbxN9l3b351yefut85uKsiAPSgW3BE57rvVhXXVQQsWAqXZ6220B6OwAA2HQAANyYdAAAgAe+8k571vId9/vwb0dgoAOZMAK6gDQAOvweGgAfsmB4AAP277e8me68891doxjGJd888fnoATMAAAAAv50PwAAAFnlvr954bp73+yYPz80AAALXXQAAOdbkw6DaAAAL26Bpv791Oveb1w/d+fvR73MweDT33rPPLPfb3z9OpmdcnOuV52832raA51uTDoNoAAAvboGl97u8s3nskz9zMkyOfvN1a97mYPBoACAC110AADnW5MOg2gAAC9ugaedTJJ57MknW99z3l6mZnUSTOCAKSFhAE5RPW/Vem6QBXKLIAuTk1HV6r4gCSkPOrCCImTlEEE+xDq37lDtDxD2Q87edod9cQ74HSHSHOfUNxXf33zuXz5x5ppM5yZkkzMyeX9371+u39VzM3yZjt4NAAAC111jGA51uTDoNoAAAvboGnsu8dZ3t54ZM73H7r9tu2udTMAbQAABa66AABuTDoAAAAb2dhp13s65ecs6/fp2/fuz2m95mch0GgAABsOgB3+/L7kze5znOT3vrJjl5nfOpzv0UAG9nYadzMkm6/ceeGq6mZXAaAAAGw6AAAszPenZ+DToAAG9nYaXN5+lz3Zd8768mJFvxJNSpkVSMWKrcy+11VdnmSybhdT2b+87/b6rz3vzJllnTvv81tAAAGw6PgB8Hu5M7O/ApgA3s7DTqZknmZJOZkk25kk5mZ3mQLVPkhFhKSKlLVsgthKSBWhkNQ1D56bnfTG6Y42ae0OKvK9v1DlD2GofKG5QWQDalRO0FlQxWQrcJALIB3Q+MHO1DvHm5zrdfnlD5IeUNwHyhkXvZVnunzXOah4gbkAwJT0gM1kvMPmQbeIHoSbi57dmZJ1KHqq6yYA0AAANh0AAC3JjroAAAAb2dhp7LzfeuTv3rvzzrJ3znJzi7jWComJu5hsPAATZqZo9PhNb3VI25i1tyruiMVESLagj1xJFbtVre96cmANAAADYdAAA3Jh0AAHPZfeZM7vfnfL3b+qtvpFS27IV3atVKxSjIlTPSLFT32Xme211kwBoAAAbDoAAC5M46AAAAG9nYab7W9v055+778ejrJgDQAAA2HQAANyYdAAAADezucd5me+b+5yZ+k2dZ353PIzM5Oe7vv78qusmANAAADYdAAA3Jh0AAAAN7Ow0uz95ye/vM63nn7yd865hyd9zlxACBkAI6iT2ExC3vdhACRhACkgC568mtwvCAJPEAUQBtTgyAOCiAKuokUQBemIjKMq5nxu+jSefTee+U6yYA0AAANh0AAAAAAveXMx30GgAWckzN/dzJJ3zk7nU5z9kzZ03em8bkzpvNd916oJmdANAAADr8HhoAH7JgeAADvkvvJeuJ308aAA64AoAFvWTOunXQAAOgGgAdeA/NAAv7Zzb1kx+7/fvwA9708c36E10k88JOUkaSewkduEjhI0kaSapJhI4SNUg6+voR49hEyEfCuLCOQjYRLCa7moTLr7l799733gAAcyYAUAHACgA6896Hj1oAG3rzJnTngaVwA6AaAfDdO+z4ABuXk5OSc5yT9cmd9yOddnoAC55cmO+h6N4dgAAAAAJmadHv57euup13zMzrN13rrbujQALO+t8/PX49UAHeTAPRtc6AAB36Oz0AB7kwdgAAAG/smSe5OZJJ1zJmbvN97980efmqADmTACgAADdO+wAA9yYOwAAgAZeZkkJ153N3re/O/3fvnk3zzt2669znUyee+9+/iuZMAKADwH4AA307eAAD9kwPAdzrrRsySedcmZPZkk8yZ7LMz3JAO992+R77esd09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++qj+VFId9+N/h/Z/cnj+H8xlD36mVH0q+vsvV/D8p9/3/x/qg/BH4VlkTdIKy7syv2r8L1/h+FPJSCc972DS91UdMohAlKBolcL7JpyFQ+zjD71Jm/NjitjL93XNlE5LPImyYra9yZXl7fZ7FfuwyPEjKEiUJR5BBEE6TdT6pKJmElfdtvFk5zzvSeUEZhXennLt7h1xN07FiyAVRJEhChKVpvPEXmtktpmc7+X9/7J59bn59Wyj/f/7z7iNtqd6pzrgH80jm2hB9igJ/J+SOlImaDPt/K28qZzzvjgRECXxEnOXRNXtIBmr+D9+SAWECYxYApsG1MsRqIbKwltMswmoYU9w/dE8x0U1bbba21klsR7DgcqyjeqG6+dyRbIOed20j2ruq5s1lrdOIcobLupbjNxzmlTlr+7l9/M+2EBYSM7CB8NQ9IB/E/WKyA6tp/MpvBT481DuR88f6quknTUPNt03sGOKNQ/u/9Q+xL74PihiHTLbMtnTKH+6Vyo2myp9wh5octVxQ+cV0zMiutUV+eRLn05moddE+6bTe990stpL3sm4OPfcabSWvcvtqaeqrt3e7u90iex31aQmkvZTxV+x72/bz7gXRCd5A9v3ker3ue572k8ypJOSYbU97Pse9pr1Ne9he9jla95ml6hNLypVePTfq9v3p7i9lNpzb3mbv7zrFkNHeXNso4/0CaTdLNc9j1b77vvcSupTd81NSSe2U2bxkDWUYOjyt08033Pc97jnTMogaDAGQwnKu7u93XqSlLx7Pve97fqXve9oANgzIez73ve36ve9720sNOrvF1rXOXVLDadJpK02m20m2njeue96e37yx73va97z829EUqklSrlCrFazzJiqg9bBjGTUUbbo06M2wzNhs0m1NlZrYKo1omWskiCgxixPxKRGC4W1aVkiMIoyIKKLBgyRirpKlTpUqqlT0qxSrBZyz2/e973ue973ttipFJSSST09JJJJ4HJJySe0Hvb973vb8GXhpzDu7vV0k2n2yaADZ7u7NLjTSXmm2k21n29dLNFe5hAGt8AObADe+STWpJIATyH2qqq9pY973PB1JpRN1VVSpcKteFWUxVrbznOd79Pn8+z57UASF3VUvViSST3gAAA9E0UAAF9571JpLVNpKml6vc933te9abS57x02AW/eD3fe97Xve9EUlTTpbvC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k1fsHVBLVNM0sr75Pec5vuTPO/N75MzufeX5N++69szHABCu8qSSTh2SSHAOps3Na6AAd6YZz9177799cme/3UzN5bbf0ycerQmRm23dWTPd3bb1sycyzN3d3ZP7kxOb91ky23yZiZm++7u/WZLLbu7sme+++++7syc3mTp19eu0kGupxXZblIKSnQNx7h9REb3ze+e+fJ8Hl/Xvr331t7r++++/fb999+9+O0zLbb/QbKaYYAkkUu7skuycQlve9h1NWqt+xkwD2ZLm7tttzznOSRmYgDE5yZeANmSzd3d23MjmTLbbfcyWbu7bbMm7u+++5kcZmW227Mmz9e+uuu+rf1t/k/vvfvvu/b5u73v1++tvVttNN3frerb9999998ABJIrvPaafSznN7OF9tNbpU06fqaZ0D9knXN3dt3ZksTMC25k3m7u7vuZzmWZm7u7tuZE5kyugfpkS7urbMiW27uyYzM3d3d3MnV9t7667886559/e/vvr96JXgAlriu7u7IEANtPQBo5iAXd3bu/fAAAtts3Mz73337d+2ZP7mTLbu7dmT620XM7iAtmZeTnM5Oc5jnd3d3aJJREIUb47u7tOQJEQlp1VBHW09k3kttvu7MmpmW27uZPebu7q7MnfvyRx94hwhsh/kOObOEah77z3rxRdKLIde9IdIe/7z+7yAbAgG6kAoSProxLlp+WxiqjUSvQiXZ6uIA82iyANKIASv2EA3vjdB7Q86K7ukOuuqfMm4uZt74h598Xx57dG4hkOZDd/3zXG+skC5hrQU0fJoKJBo2Lmd56+znObzz6U7/tz7vlfTQtkl+rROZUcJNWGG/tQJwk39S8ZEn4+vdBYQGf2c/uKh6fLiHPvkR00R139cfJs5fdrmM43O51ablcl65d3c5jEImkigBUtAgNppI3gIYOAJpICwNLlqu573vQg2kgAESRdmJWZJAFaaalVSYGmaYElQIYxQqVnk+/Na/Nfnfd73velkGbAMmt0hCbrOe95rfAAAAJNXbfLbQ7Dw6y2222gAnvvt+mNKt1WE003d3o4ACAAHfUkhU2qppp06V3d3fSCAkk6tUucNd70IgAEGGmADAsAkkkkkEBJJJJIAADTSUu8pNtZTSVJppmDe0AEakkgAW2220EwC3ZLmZJy22pLSGJYAAwEWqkkudkEAABbblSSSSB2mgNA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9+++2TN9uf3mTLbfJkQUEyXl327vuZO+buszLbsyb+3d3dkzfbHmTLbfJkbw7oJk9tu7uyZ776mZu7syX/c/3u8cqlfsQ6yi6+d9PuQ8V2okCANrKv3tbruu/nogDUEAeyXy9RAdxaU+YL9iPnnfl2htEPN9vKlZVHq3X2X7wtGQBJACiAMIAVhtrd06+3VZAFIBn3Oe9v4gHSfMO9uJy8z733ffe6GvvOcSsBdsx2ixY5wpOZDIdfPvn8h98733ibvrUPvOyTmcycnPee9drV+AA8P3fvXvvvoD390Pe3v2TJPc5M5mTyZmSTeZkkcmSOao2Q2mWoaVlBzlJ5KPLVHlkNTZW1NhNkjWTWLY2tlmJtZQ2hqGoOFyocahomkZDGUNZRsktpDWmLBWWSW85I610+coHMbCLKmaZDUMqHn3nWpsIzyuRX7SX7E7xJ95xUyGQXjH9TTSWKTTUE0lvSa00kmgDEkTSW5drurIGlJJNqbqKSc4AbAImkipJIvwB98Atttto+mZkZkkvOsnKbSV020s5wqlYSSdUjGdbLUTcJJJOUH333377czO9nvvf7776oAHltvltoAMAPweAHfvvv2fczJme8zEmuXetgBJJJF3jXd4qmsUqptpYrCVIqpKsY8aKCMRMAFg2UFApYpa1vcMiCOFYRltstQEqKrKKyVopYLFLc1rvfe973ve973p2ZJOuTd3d912B6CAgeZMB+SFUG7u83fO0EkknBUqSbTQGpJJm7t+egG7u7u67C5POPOvV9/buZJNmZJzJmbzrrVo/B4LbbbaAC2222vpMyT7777777775bbbbQH4+eZGY209tPLTy09ABJqSSbkkkkm9820/b3+/eft1QyZiZOZMzOAHODr3o9bk0JsTSVJNJCTSwAAWVJhpy7u79toFzJIkyTgLbMklmZJnJkk5nJzMknOW20AOh1Lb7b7aAAttt5mZky2gOWZJPvOd5M+8++++q222/AAW2220ABbbbbQAFtt28tA4QG/vskmWZJDnXXgffABzJkj2TzvzwaPDrJg7BbbbbQAH5m+zM55+t/dd+XVlHGqGibhriptJGrEqTbTxTSSasswumJFfL2tU6aflh7pPx03oPenugAF3d3d2EqSSSASXd3dkkLKaZSAuVJJJJJEpuU05PLybTFFFVYgrAUFixIgpBVhbLWrWbE2mstZHPER7c5HqXyVrIBW0htbU3Pf6ewLQKxkggIqD6wnEwQiz32tahPrb5MiC0Jku23d2TN93UzLbXOcknNaCyJJdeeZMtt8mRBbRMlu7vvsyXnObupmW3Zk6ube/vP08/d9OZMOq/jSzEGCmnsCw4NKzdMpNgbjnXd4bdxJKcxAgdyGkySAF3kozZtFZgrDitNhgDMu7vSzpLBWzfOnUn3nstPve91Ml95bbbZk99bu7smbu7czLbZkv6222zJZuvMmW2+TIgAmS27u7smbu74iO7uINRvbQSWkk6oUXf1czD95rvP30GmABwBAgDMkdSTPJIAAm5iSBoD+++++3777v74tt9mZ/e+fbu/fXMl3r+l51ky8vJ3b3Mjzg8BMlt3d3ZM3d30RHd3EHZ3d3dx5CUJAHlPSSg6ZgjuXlv7uc5kdTg8Dxklttt2TFtttsa9SaSwJpLC8qTSWsaNtsCp72LmwmYFtv8D736fffffffffC2226tttoA+++Bbv1u79syJf46/ZMcOnJkttoJkFttsmW2222ZLbbbbMl5eV1kwH6TAAmQW22yZbbbbcau998JpLea3jec8NnA93wAASTDTSUA+W6tt+Pltt363by2gASBr6223frMlt7z+dZMOscczIAEyC223Mn7lttt2ZN3bbbZkvLa8yYHkyfucHYE9yACTLbbbbMnv+2946Uf1DIKzKiZlsma0YpWzW1jaUP7KScq/te933vb96SSSRNyeS9VU/e573ve3aJJNqDy/33R6Oy/dyQHD774U+yZn3x7Mx7HJJM9+3fffrZktt/v2TA8mQUCZBbbbJlttttmS2222zJeW15kwPJkFAmQW22yZbbbbZmOZLUNWaZrM2j/Yf7q4f7RTY206w2/eyvTDb9Xqefb8e4c3jLK7lN4AvQjGG0l2SSQiu7bdxP1UqKAz7yw06/v332Zhv4P7r59zMz70XwAW3l8vJn0yc+33d36zJbb/fsmB5Mj0AmRbbbbJlttttmS2222zJbTn7JgeTI9AMkW220nOZzmTOcyBAJI79QR9ID4iKhyBIpIAQVc2ivm78+T894kkkkECApNgAdkmZJISRNyKaH334rgvwCvuvgf13+u7v9syJbX7JgeTJZ7bbbZkubu7u7Jmzd3d3ZkWW222ZLvWusmW2+TInttttmRN3d3dkz33d3d2ZLMknXXPuvvvvn058/vfjsHx1BwPqXsD7762h2vwF+AC233737d3fvrMm7v95ky23yZE9AJkW222yZbbbbZkttttsyW2v2TA8mR6ATIttttky2222uc5OSd4Vy8pvVerW97Xlqte2Y9eb9YECSXY0lJJJC1JMpSSalNuUBJJLkkACygAAAku7vjbOHe96dTRd36VxpyTKav9bbbZku7u7qyZbbbdmTd3d3dmTd3X7JlteTI9AJkW222yZbbbbcmeb3/ff0RwhisVn+Q1Drtyh2h7933uhztDt+Q7ocyH92URJAFyey6BX0mP1c7645BAZdzhYY7Khg88XPbMDCAIQKQBO/h8nEv5ZOnTQ0anPd03N/h+cul+mRhpNz6BF8w1tNjZYrhVs0MVbRViV4sBeFNKLFXl5MmQMl4VPXhV5RVpRiruvCrBgrFXntIXkPE8qp4aEd9r01JoqyUZVnoovOOqGI6hj5iU6oaUbq5yh/cUfcgrzJJd0Pp6HR3lLvaxlsU1VWiXRyKsRlBsy3KG4TjgnCtg4Hw3V1xQx+46qGbM1isWQ6oe9Eeah2cy5UMoYMqdnJFxOc5irFXM2JsxlzVOGn9zqWdRbUo2KsVVyhjmtpLtrh0hzmlmttk2ZlDKNEbrnEshs2VHVDKP7oU6jW+ZLj7xPKFTbDO1SaausJJvpXTDaS2m5O513vd9H7rsmSTv3o142Dj3gFAQyYrgBXAX9dmSS87ttfffdSXkkySTDa5TzSpUdzzvThyXd83m7skkkEADmVvneW29/r8v3oBzd3d3210Og06mgAALMxu7++kyTlvW37777573ve8ffdDaEgwYB5qCIEPMIS3rOcPDQAebu97u6AD1erbbZAAAACSSS7skkkJSaS31YbaR5999v331s5y34FZwebu95mSTd3QXMcyc4C3ZMyS8ttouZJ7OY4eC7klzlttp6Owbl5bbbX76YmSTmZJOTr7r77z77776uAFcAD9be7baLerQbbVvWTLb24LXXQBbbbb9N3qZkkfffv333330C92239aBckyY4C3cyTM/Tk5k5nOXOW+WhmZJAOD23q7bb3kyQD0C23zyuD39yckmcjTSAAAJJJOSTKTSkkk5JdtttoAC2229zMktD0cyZIC3byZknfMmSd5Mkttq7Y5kx4D8fTMk/ZMwPBv33UzAB3MmSLJcnvvvsz1unoAO3MmW2+W2v0DwH4vn0yZPO7b3ky/rOdZ1mZ1mT3Mzk7nJiLUOjWnKpNMk+8dN0/ve/75++3/E6ku9Tv8+9++vPv7374Bb9kwB9XDrAPfuffAXB99998+4ABb+vMmX737d3363Jltv+H7JgeTI9AJkW222yZbbbbZkttttsyW2222ZAAyZeIO/MmB+/SYdgJMyT3khCyZrOfGymmBy9uSYlNOSdgZx0NAH36yXhHMmB99fHUr93kw09fffB9PgAibKAQDYGkVuhXjve94et1SqqpzOccAbHJLbbSzJe7X7JgeZk/RwAmRu7u7uZLJy9W222ZNkvJbbbZk3JeS1+yYHkyLbbbZkvM8++513PL3k6e9K9vXfeAgF3dXd3eLN913OO972XATYNsOBgMSSSS5Uk7JiQCSSu9XBZm77v31mS2222yZbbbbZkttt3ZkvJtt/v2TDqOTJv7d3bbmS7u63Zksttu7Jnvvvvvvsye++++3dmTz3+mZf6fefN+6+70Ho+wDqZg+GjwH74D0fffX77r4Bbbu7v3n7n7v+5kz33++8mS/wBM/c5zIHgeOZM5yc5kznHAGuZM5yc5kznACuZM5yc5kznMAK5kznJzmTOedA9K5kznJzkzOcD9+yYHn7mTOcnOZM5x0ASzmTOTk5zJnA/A/TnMmUqVUk6MQmNIVOqWKd55zfKxWtLWxGDwffQNcttttFttttX5bbb8vwAW27u7fp71777799/JzkmcnJzkmcAKnOZM5OTnJM5yABOcyZycnAC4zACzIAEyW2v2TA8mQAMyBbbZkttttuZP7rm/p73350ePdW/wBbbbbRbbbbV+3d3d+v3fwPQtt3d36fnvvvv31mS2222zJeW9S3+7yYO5MfgDMi2222ZPLbbbZM3d222zJbbbbcmXmSXkl5lrvJg7zMfkkkkTWs8FWck1N6Tc5PQfOEKM7pp7B+/W22/EtvJmW22pt+tt8yZb8fZmffe/fOwvKEgv79+/fv2vpMttttsyW2222ZLbbbbMn8AJkttr2Zg7yeTmYD0POZyckznOcyAFicyASWmru7u7u213SryzMgFgeo2STUlyYmYdgr3e73bb/a4++mZ999997TsAH333x+LbdmZs9bu799ZkttttsyW23+9yYO5k85OACZLbbbbJlttttmS2222zJbbXuTB3MngAmS22/fv37T5zxzdEfqH+4uUMyhqr+wm0lhNum0lvSbDfSij2LpeA0nJM3fx+jnUzDvH333W322+/HxmZb/ZkkrkH999/f398Att3d3vqe8z+zJJ/czJJyb97fb/f1mS2222zJbbXuTB3MngAmS2222yZbbbbZkttttsyW217kwdzIAGZAW2yRznM/udTJJ51Mkj7XU1jdJa3vO9as4dm/akkU3JJIMAAAB5kwH4AAAAFt9mZeb9N+tt+Wf2czIAXJMADMvM5ba9yYO5kADMgLbZkttttsmW2222ZLbbbbMltte5MHcyalm7yH5VgtttnXz91Uc3+Q0Lp3bQAdN3W7GgYltQqUtW+u8IOXWq9yutTdcoczLvOaNjztAfreg1usVUVVkErUYkA6QBySZzkmSePsm/dbcuXnJ11k6+mvPPPnW+JMN+6dOvXW6dIYnYp10i+79LVUrvUPcqtalUdvOKUZy4SB7K8yUyezsCE39JIPN72qEmd7CSdS0Udee9+d93j7/cig+2lskf2Q5jK1U+ZQfZGUfd9mWTF9+mSZv6ZMkz3kmSfevnnF7yZ7vnfe75CbnRNJaNtOIvutFa5s1dHOZac7MydmZZkk9eZM7P3l6lHWTPB27/HH33eTPt++KBEw07u+3c7FwTV1FKxVNqkcaeN84fd/fBZ1kzrryZnfevw1+bf2TPe532+nfm+FKWsJvfK5eN73nddObsw05MXMyTcmGnyjoO3G9ZMrt4OjrJi2+W8vyd5MffBg4ImGnORqlWJju+oTSWdrCaS42kqzJJf2TO9vv3z4uTOpmOh3b7eSZk75mSZ7zkyScyZLyZnt8rXrjmTHAb773eZM6cyZx+7G7QmnnY1z3lttvtR2eJKk3lp1mO71fLXSc006gGg6IaSVmH11vmTOfeOxbuTOveZM5e/g1yPOsmbw7fr+t6yZy9W0flyO8me9uz9e7uZJmTuck5nMvmTOre7V7fpLnMx5kzs/eHk6u5PeXzJnV9/X9XDrJgHqXmTLbbbqfvpn6feZM+++37fu59L1ky2zu922jeHR+DH476B7x1kw97HgHvXeW+Sja/BuSTUkkl3d3d2NJpISSSZQAAb21geBb1aDbMySOA6t2ZMkl5b7aOsmSGnTmTGvHfWTLbZ5+3QH4C95y2295Mk9tE9G/SZJPvu59990a+yZ1Mw09LXXUzDsG9+9ZMvLb7bfXXWTDp+Dw6ttt96tBr13kyTw/Q51+9tt92UD8I8Or9Mz0dtPvusmAN4V31JJ57J757576HsAACHA/HY9G9HWTG/nWz9kyTm/fuZkhv829yuRRrkJfW/eCQmQZCSbjIQxkgbhIkkJhPe7nPdO/s92HeECBNMmSed3l/t/v73++TwH63PgH331ttttcu7u7JUJACwAAbYSSSTvRtpK/h1DqZJg7mSTP7mZJk/uZmWcyZACyZbbbbZkttu7syW22tyYdTJfLbbbmS7u6tsyAW2ZN3d3d2TN3d1bZk85/dUb+8mY9fr/e/oO5mGvOrn0nYH1gLJQUmwAyHb13vZdkm2mNsBAH3wAPvffc999++syW3LbbZk/hgEyW3LXszB3mQ9QCTZoejuZLOW223Zk3d3d3ZM3d3d3Zkttttsye2qJnIdMBrwbC5qS7fpJqSQOWSSSSAm5JJhtTsDIFgEkkuVJJu7vKNm/39+yZ7/f3cyIaBMlq39be8yW2222ZLbbbbJlttttmS2222zJbbXuTB3Mj8ATIttttkzeZkySf05MkmZOudT77z37777z5fLLb5b/XLbbaLbbbat3d3d/sySfH333xbbb7fgd/vp7fN3fvrMlttttmS2222zJ/ACZLbbbbMgATJbbbbZkADIAEyd73ve973tKTuKVcyo8qsinffPvdQ8ZDahsX80n7daiXz77bf333v297/Ly221ZbfjyZh99v3vQB9bbf1t7+Attttpba+96999/vZmb/f3cyABmQFtsyW2222TLbbbbMlttttmS22vZmDuZAAzIC22ZAAkzJtvc7zkySck6Z3OSc5nnvgv5/Xyy22/1ltttf33wC3722SS27u5dwaaQE1VJNKSTSbSkxAo0kk4HuzM/tl/g/v6zJbbbbZMttttsyW2222ZvJL1bu7syUATJvN3b5ky08kx6NCZFt3d3Mlyctt/W25k19zd87mfuvupf3319mZ+++/vPra8mYXvdm7uqvw6mYPYfalt3d+t8tZMkcyZ5Q+34LBIAtNnqpNJFY2lJJqeLakkmr45lvUyX9bUmHTiZHVtttky7u222ZLbbbbMnfm7u7syVbaEye++7t9yZTttYm5LkkTXui7KrWsbpuqSSrexN7kLz139/f3xt+C20H996/B4t+TMLbdtXYm0oATnqpNJGEwAONNI94NtNT776+e++/vvvZkvEzrrq223Zk2Zu7u7syf27u+fsmbvUyOeJJHHAsyft3VtsmW2222ZLbbbbmTd99fsmbvTkyOfgFmS7epJPOTr7z76ae/3wfwfAFfALfrttttL99mZ9939yTJB3AdPvvvje/6f2757u/39cyeZObve7u7Mllu7u7MnvtmZuvZJLesnfLe93dtmTlu7u7Jjd3d3ZksttttmTebvW67mZb1ky2222zJ3zvnavPd7nn7d2bnPeuucnMjr0t/ny2y2/30AS4SKSSXZd970u7JBdaaQAAANNIsMG2Uk2mAb21zHN7Dqa73t3d3aTu7bbbMlttttmS223+3Jh1JgATI4C3ZkttttsmW2222ZLbbbbMPrXW/J+pIiSAMzPqPKb+iiAKm5kFEqopkAoqQiqfe0YSaEgCbzu/1r9b50gRv2EApzW8ojXe4QDWBSALWQCUIfqJp1iNmbz1jyCIMWW0pqKuC6nO5eFu6FNxfZSAIO+7D2zlunTSAKd46yAFakgDEd88mt9TGTAlKn6+ep5f1Z8znX1OKe+qRACc2ygBQlEEQaJ9EnVisaoZNtmi1nzFxSaRkNSNk7oZkr4rH5zqh1IXv5w46XnVVPbcYVOoTFVs2omT5yORGNoGyRlGYJvyHzijplW0LbUMhrSjEe0MJyZqGatpGxNjZJtUNVS5y5Yh6jlQ+ZR1hGmxLNolqH3IcoYj/aOY1Dw4H7UXVlWijSbVDmJOFp/ahyaKmZtUjIZVlirZstm21irLnnd6hZbNW2tBbDZmLYl7WXmtprSpOUkA9nAIDUgYdumQk3q6ZPe+90b2Zku73YEkkklZrsgmktaAs4BnOcgbvwD7fvhwLeXbbar5epJkqmnhpucM52B0NVJJOSSBwA0c3ve9n31AFcltttpweBXoC0A9Or3bbfpeE6mSR39+/fffffAZmW2XkkknOZMkznMzO+Z1ySfurb5VACvLbfLdr06yY4Dtbb+ttB2B7aC9umnjT6ZJP2+9zJI9+97++t+v3HoeFA6W2W+20OEBNtyZLbbQwBdvLbbQAd+29W/ra+mZJ99999999997+t7vltoAETMTMTMTMTMZk8nnnWTPPPAX0AFt8tt8odHWTAfjx35l6yZb7ff136ZJN66l8ffvPfvvvnYX9bbbQOtOgLmSTcmcvVtrs8mZJ5kyTsKtrrJklttvtsAAW222WnAfZkk95kmTPvvvPvht5bb8O8mSAenUz23q2+2n4PA9OrbbbQAF3ebu7qq5JkneTJHo7enn0ySbu9zMzEfv3vp98ADzzzzwAd5MkA9AABJJJJd6mjW5QmzidK03hU20lTaSqlqGyLIaLaiZDLZE3JzOTLv7a33vvHt/pJPP3UnN9b9/Yb9lt/iANsAAAAkkl3Zfe973su5JJJ5Ae1VJpL3ve973vCKpNJe9nKSdUl2u91l1QtqfPnJU+Z3L/cDmA/3KcTbVttbbbWbNWw2C2Ird7310GZBbbbMlttttky2222zJbbbbZkttt9jmZh1k7gAmS2222yZbbbbZk3yX6zvrknOecn76Zn083rft8mZ9fp7y2OgDabJAMLgBlNgBOEgmwAOX3vZ26VkgBJJINMG2AAEtNnd3d362ZLbbf7cmOOTIPQJkFttsmW2222ZLbbbbMlttrcmHUyD0CZBbbbn+PzJAGzInMkyS/36cnM5P1/f3vaOee+/4Ef2fPt1/drbbQ7P1t7u7u03I27u7u1djTSgAAEkkAAPv39MklTM53bbf7Zk3d3dbky8mS92222ZP5ctttkzbcttvuWZLZ3bbbMm3d3fbBHIg7yXs973veINbbbCG22+Ng50cfmq0t1SVNunBt2RS9etkixJ6VA6LAB8W/AfN3d3d1LzJlQPJnwQ2mmkUwAAz2+d13vQtNV21d3frabkydXd3d2ZCctttsme3d3d2ZN3d3dssyXq22rkxyZOlttpMnLbbbZM2293dxBKiI4zS9xL6p4sc1VHZ31JEa3TT+0vtvV5bRdtttXd3d3d+geD7777774Bv27u7v2zJ9Lbbf65Mcky22225kttt1ZkttoJkBfbzMm7u7u2zJzlttttmS2227mS85bbbbMl89933nfnf7+f3pL89/W8yZbbTXwB8W222rbbbbbbbaD7Jkn333333333j3r33337Zk3d3d/tyZeSZbbbbcnXLbbfZkvN3d3fZkbbbYQ223ukG7u7rIG222Qdu7u73NrFNpKupYte6KaquYrvYG036Ys7O2m/QDGw006A2mwLU3d3E3JJN3d3d3djTSgAAdIFNNIA00wANpre9737uTP7kyW2+22zJbbu+7yZLbbbbMlttttzJu7u7uzJbbbbZkttttsybu7u7smbu7u7syXm/c15Ouv3cySe/vfJ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J1zd3d/rmS7u7u7mTd3d3dmTd3d3dkzd3d3dmTd3d3dmTd3d3bczJbfLbbMlt3d3ZM3d3d3Zk/vd7/c75OSd99eP7k+/v39/cv8uihbfgHpHf998Bu/W9zMtt+degaD77kmSAP2fv379+WZNm7u7v9czJbfLbeMQkJcLu7u7tBCFu7u7pqSSDd3d3m228zMzGdu7u73I1at3d7CIW1pEz71j37+tt28ttpAD8ALure7bT0dTMB+Oj+gP6ffTr33333373333331N3d3dbbbb01G7u7zghd3d3c222+N3d3dbbbe73d3dz4iPp5vvaXVwK5x/Mu/n0r/d3bxmY/B4CAAW223JlvSTMkmpJJieAAsCSQaaQETe13157u/WtsbfrW7u7ujbbeZmZnNttvd3d3ebbbem7uxu62903dr5c59Xe5nXRAF5M323+vf36TJPPdazJJuzJJ1551euee7Rrrr3AgOwsEGrc8RFeu9dLlnvnu98qflkAfJANu/ZphUvLsTMs2+fG/vkgGam3zkk5Huz3908zmcn6/vn2toAfg879699899/AP3ATl+n7jPsmfmSJMk8kyThHKVNhGiOcm2NsjIahmkYzJtms2zW5rmNptNQ0jam65zSNK0qZDRsNrs7VcaU0gZupHFTaStnv92RdZK8eH38/v5DndvlD51rYjWRDkOcWSWiNrK4W+WqOb92kfNOw966Xhcz+3Sp8agn9nvaThVx3/fP6Xcfr39zJMvf2/uvpz6ZJu75u+7evunYIpzy23z9a78B+LbbbaAAA8H15ysXjNNcVLFFm98N5il3e7uySQDCYBHmebeXvdm/X50A3SZlttu7R0ANvLb1aPx0Cbu79MknsmSc9t87+++/Pz8973ve93fJDyfMxM3k0MNIqGWlZWcNGFMYYWgqOQqyZgy599vnfe97wDnLbbbaABbbbbQAu7u7urAOvvvvvvmn0B+ADqZi39bd8vdH6XkdafiFyTJjgBckkmOAedZM3d83W3p4D8HmZgPwfTMyfvvvvvv33333tvVttunQA/d5M3zJnmTGTO77bbaAA9Xq222gAPE64iHodfRPuc++6yZ999fvvQAAAAMzJIAAAAHHMmSANOZMkCuFQAPOfu/pmZn3333t++fAAAHMmSAFAAAAAdZMkAadD8dZML2AD7Mz7777777774AOTrOHffnUmZM88BpMyQAAADTqZh06yZIWd5mefTJI9/e69l72r79/K+H1rKNrNUah/UNQ4aRxVxRXCjUnlxKvPN3f0fNR+85X9r7o/tftDmH9it5k87/d7vf2/e2+d22/rb9bbbbRbbbN1bbaAAHHMmBb554836Zs5mT+FAd3d3PlySDu7u5wbAkiN3d3XBsC3d3u7Y5R3d3d20iDd3c3ZbbtuW27b4szy23y299c5JPObfFnnPfLv97Mz+vSAf0zPvvu2A/TMFfugnkzB+frfLb8fAAEgBkIUAS5qk3vGznDHe973fe473d3N2d3d3N2d3d3d2N3d3dbbbekQ223m+++9++/3eZJu75tt5+/peu+/vHvtvL5f7775QW/ACAX9bbbS2jsD0AFvv79+e+v6bu7u77777777s3k/rbbd3mTO7r7u7u7t3deZmZO6t3c3czMzXuqlqN3d8vMmb/TnX99139999++f2/fdC22/W2220Ftu7uu5mW2np4Hlttvx98fX+3d/bv181tt7A0229ZC2d3d3CGm229bbfPJm3Lbbd3d3ds93d3d99999992b1vu+d86nfn379+/W7/fxbbbbVtvwPvvvvrbbky3q134H56OnMmFt/Wy2lvv3v773379Z777369DVF7u7v1sRG93d3c223w+iI3Z3dpptt6bu7u68zMx6Ld3c3eoiEQBRvxe97x6/v70dugG22220Ftu7urf4++++++6++W3222lu7+99b/X7+223d/e+++++7N3d3dzMzM3Rbu7u5mZmMegG1q3d64I7e623fd3d2+7zrJn38n773v7775f7mTPufrb3acyYdA8ccyYOw7vMmW3vd1bf59998AFkAADpJLsvve9Iuc5zve85zm986q7u7u5mZmZmZmfWkRu7u7r7d3d43d3d1tt++/PO918512vtDVLaFGwpqGAH+ylcQ1JDWlRNQqSbbdJtJUm2902klOTtSe973pckkl/pJJM/vvvvvvvvvnAW7d3dUOx4Dve95znOd73vefMfSKtirGtQrFJzJkz7gH977777777u7u7rcmW2227u7u7xu7u7rbbb03d3d1ttt7BGo3d3d6fn1t++99STyhi1DGUMj/aTw2kqabbVNpKklvCaTwmcCw970TcAFttttBdv2TM6W2/YW/AFttttBfsyZP6223+3d3d3bu7u7uzd3d3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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory-main')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')
    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
