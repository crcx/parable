#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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59946L42HwAC8bB0trnOAbkyxrc1m9A6brQOgAWt7AABrf3Fky/fTnLz6c57Dni+tb5578q71xsiIm977V42DpoAp55JnN98+vLvxvzz36kAAALW9gAA7JnyOPAAAAF42Dp2TOd81rWta1D3gtbkwB0AAALW9gAA7JnDgfc875PpvW5Mvs9snNXrzzjbtrpoArcma7s4HQAAAtb2AAC5dakze55qTemvAp2GwAAXjYOnw4BuTLk22ClyNAAAWt7AAB2TLru9+7a49Ohib3sBeNg6XnHAWtyYA6AAAFrewAAdkw2AAAALxsHTWtffasyZJmSTjznr7wO2ZkJ7JnOa4HTgHwrQBb65wfCtAHZmeHHe995799ve/N6le875NgLnc9bLu9p+fe+97nvRdYLHfZmUNF+3wpW5MAdAAAC1vYAAOyYbAAAAF42DpZyzeSt84Om9dvt9yZ5rWeufTXndeeb+FofgB+Atb2AADzuTPPt+HHvVPcMYzycJM9yZ77kzns94nJxJ5z2XST9jT4aUx65zmAeRqJPup3zzm9a1N+c3Obn05u/d70AC1vYAAN9kw+3vg+6AAAF42DpbXOcA7OSYcDp4gegAFrewAAWyZ45wOgAABeNg6aAKm5M7vc1HevOW+ed1uXXlkzjzbe+PCrW9gAA7JhsAAAAXjYOlzVyZ5ybrnODpv67kzXjb0WgAAC1vYAAO5M38+09evlAAAF42Dp2zjfAV3kmHA6AxieTexfm9gAAWTNNgOmwAAXjYOnw4B31v3JjmuHzoAAAWt7AAAsmebcDoAAAXjYOl5xwFrcmAOgD76Ju3zW/JZrzVrnnd6m5M895577vkeakznMmOc8jz75QABeNg6Xu95kyZMmZk3848ehckyZMknJMbB0AAALW9gAA7JhsAAAAXjYOm5MvW3B03JgDoAAAWt7AAB2TDN4xiJcmex3JnNb81z116b73vc95nXM6lbl5dvjxUcdZZVSiu3VTJjqBGzLMribHtU3VNGEZHKTqPPOB7sp9GnBqTm0357hVbcVuaZIdWUCDJbsq6cZcBpiBtAayhhUPUexXpfap1FCcfpYOqjGXJe0QxqsKWqZktyqlospKmhd72ddq23wziNNrCOBytlFiNlFnlhOXmLd76rvWU1qpX60drGkqbMw3aJazBRbUZuaqONQYt4LhnIU7bZydoOW94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3TS8+P3C8d93jlwV4S7uCid4km0g20vMS9/STkh+aZi9kk92YNMaSSaR4AAcaY0cPzSXuNptNGNsxtfHhhxph5JyYpjbbcyYkm1MSTaSAANMeZvMzM9bbaDSTTWK6W2nu225JAA6AAAABJJJAAAEAASSSQaYABAACNtNpL2m2l3SaSamm202jMazF57762002uY2k0nPvouckBEkktsyZmUAGnMzJIB9VttttDw+H3gLQLZMmSdu9W213ve970kkkggACSSSSSSQAABNmgACQAOgAAm0ld7aSbxpLnONpJN4G3Q+tttsyTJVtttyW7yNTMkaZiDxtgEk1OTxtJTJiSbmJtJABmGZmZmZbbbQSaay71bbcAACSSSCAAJJJIJsAAgAASSSCAAJJJINpQ2032bZppNYmtenfTzTTSye+++360JmAemSZgC21ySSQD4SYetZJmQ+5mSR9vUmN5kkamZJPXodALLbbe9zMmZi7yZq224AMAkjkkEAgDskkkUkkhJJJ73vek1JJISSSCbaSWJ6aTazTaeknrMzJJJMupJmVAPqX2euD5hbbbZLvczJJdDkF8Lbbltu41MySAfADeTADuZJmTF3k7u213PpJIKSSQacgADaNAAEkkggACSSSCbAABJgAAm0ljS1rSU00msxppSftmSQhjTkkmzAxJmAAHzUmH3B4W673vezrtBqG2smNbtvbaXMzM9GmzaADKaAAgAB73ve8GgAPe97xDYAAgACSSSe973iAs87e+78ySSSfc5ftfWjVttvt7koFtrmZJxuA6ve9+ve7zJItt+KBfbbnczPJTUkkyNSSSAmABG5JJCSSSDTAICAAikkkikkgCACRJ1+5y9brrkCTzJWZEH7Vfv3f5vOlX6222SSVbbbbdxqZkkNh97qTDkmctvfe93kmTFtp1bbbbS3paetIbaaWkB4zwtSSUJJJJJJJJJJIAAAAAAAAAAAAAB46k0lNb1btJpB5B5NJtte96SW5mZmbSwCZmR2y2223bWSZMaySSYD0SYHnZdW+W2haAdW9+yTMyT7WpMDAAAAAAAAAAAAAAAAAAAAAAAkgJtpL99v/BJLWlrjqFVBgCbdOwSf6V+wQGMYxAUIChATaEBJzPd9nvdAXkgHeRIDuiA27r2U752kYzukRbpgYCdPbixjZGcZHTTe7LYrGDqigp2hJCBt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e9pWwXWl3vaxjYn3va75C972JrNezLbRNUAAbV1q2221NAAAmt3T1JwaYHyaPgAATRkm7u8TQvt+85+mZ5IePun9+ArQD9+/ALS22yTd3dtAEAAAASSTWnfdskv1SYAAJoArTttTX7MznUnltzyai0s3mZmZU1iy222pMAAE0AVp22zJbXkmLa9mR0fBMnns617eZM89s5e6tEY0/D4D4fxBeYk/j97hb231J821N2/fXtvz+W7+3d33QAAA40wP3EHm83beW7S7fprv1lvwmgAD9daTetK23MmBjMC2rMlteSYHkyI6ATVAAEmAY07bU12222lTVtttJkrb7u+6PL98/fwB02By22+20EMGnDGmAdtttttwAMk2SR7AJ32SSSxJ7u99Scknqa+kkGmAJqSQC1J2220TVVtttqTAzqTtt6mrJINMATRJN3ZEnJJJNTU7+8q/fpb53uTvZ6HBB+AkkkkJOgAW2kkkkkAAAAkkk3SXz685y2JPd7+Se7unyaADjTk9UaWLHiWJZiTJJpAG1JyWgnVbbmZUmGcSZJxNVoNgAmvZpq3aMtra81oOIqbtuLG1nemZ2zv71sn7c3n1Nh2gAEkkkhJJJIAGzJJJIAAABJJJukqTaf36/fW6k95H31JySepoQEABNSbybutr9m7om5JqaPAAJMlWdSdtvU1hrM5czMxNS2gCTkmJsATV/Xnp+FtJJt+0k0lzSbBVUOsQFiWCUAQHKyr97mm13t394Q+b7iHvzn3ze9IdxZD7qV7iHHl4qEA2gQGPt5UeVR6uc3uX7z4aICCAaQGJAOxsx+qVsOvMjbSAbEBXd33s6IDgutHOeQVbJztBnddWyNA3xqnjG02nUQkIjEAxAV285kms1k1NXX03z620IAPK17z7f3zvdgA++5n40J6av33rTae42kvsaTa8xtpbUNllqGlZQc5ScRXGFcaVam0bFsK2UNZNYtja2WZTYyhtDUNQcLlQ4xGiaRkMZQ1lG1JbENYxYKy1Q+ahz5yR3rp84gcxsItVWaahqGVD5851i2EZ5XIr9pL3E7xJ+5xUyGoLxj3UySb1MmR5yZOSSTIG7b3s971QCPdIPvh4ABbbbbQBbbbbQB2XJlAfUA8fTM5999z0VAA8tt8ttABgB6HgBz77553vfAAJ37J33etZN6mtZiCOAwjbFG009cGwY0xlADaHFAbAhE2QbnKKTQx0RoTUkikYDIxttqDbSjg2RDabJKu+c973veAzuZJN6ne9737rgHwICB5JgPRDzve8737ugD4cttvLbT4AAN3d3d0/AEa9w984Tn262ktTaWOZndb31aPQ8FttttABbbbbQALbbbaA9NyYckzcmbkzkmW22+W+0+egH33d773vegyZiZNZMzNADTeh6HiTJACtG5MLbfrbQXMkiTJNAbtmSSzGk8TSWPFjaSzJJyQAADwDxEnJOW0ABbbdZmZMttA1kwAAAAAAAAAAAAAVoA0QCq0AADWTJBzzzzwHhuTBwAAAACz7Jnq853N5rMyTc0KspblZyFskrGq0JzEkmpJpQU5s4vsWJPq8fMS7zb+t73tAC2221fwD9+/FttttdakxqAASABPZiT5OrraaW+Nte9jT/NL5JYMEgEgY0h95+teaFrSXu12wXe97YkICQATU2SbupPebo05JDMxJZpoFkSS9eeSZbb5MiC2iZLe9799MUzM3dGnJNTUey/vP3nhiTDwOnq/Ct8uJP62y3laUv2O407b8M1yd/Jsrbu+Xve3nbfU6BbbJ+uX9L8rn4qlvFGmYGcofXq51Lf2vfeh8JMn7iTAOpqzVtttTUmAAkwCtO21NX1tttTVQZ1JySepoQAACakm7u6k93dE3JImvO77e8k3PNa1r3nJrz+57vPj7VffxzAPiBAH6UeAfuAW22tM8AANAAO227TwJI5Ka0+77u7tsbU3zqmeJOZMX6XiazuszO5mZiatoAJMAxp22pq+t73venmNptJec7CMOyAuvr73KG0egwPQD0aUkkk1J7u6JuSRNdxNJeVtJeLqxNJe+e9+bfe9w73yH1ouegekknQH79P378ALbbbaAAAtti279ZJLE1OyeepOZJ5MTQgAAE1LQASeW222poAAE1Vd3VzaTzMzqTkkgAJoCSSRJySSSRtSfadxNJeffc/c99vt+t70AAMkrTSQAQpJpJJQpJJJKEMkkkkgBJJy8u7u2xZLbzP5uTDeNNZkACZBbbbmT3JJJJqa3dkkkTUySHqTAPU19mAfgAFxoAABJySSSRNbvc9838vfk2laGQVmlEzLZM1oxSbWbNWyKvmii4Ou/v3z9+/fH3779+/YA0w6l3Mx97zve979ZJBAHvbQ4B+klqSttQASSUrTdocaZxGJJPl3effrZktt/vZMDyZBQJkFttsmW2222ZLbbbbMl1bXkmB5MgoBNASSSJOSSSSJsxtZixtJfvG/FjtZtbS+6r705X3xwS5oTdD796u88Tfc7j/d+734+98/Mzn5p+AT0zraS0ACikibgn3MWXLfb3q4k87y1N278AjtLibv0k/SSQAkmT1uprLz7nLYmpJP72TA8mR8ATIttttky2222zJbbbbZktpr2TA8mR8AZItttgLMeYk8xoAQACS4eJPuJvx++JLxZ4mksS/fvFbyW+U7QAABAY0wA5LeW20MmEeA9K0tAO1+3+/Zbb2bu853upoUkPkmAepqLkkkkTUYAAkxAACayq222pqmzNpO23qaxS222prEAAJOQABNVNJb1vf31tKss7wD8AElQGAF0zQAC2yQAAttJJJJIASSTbtkklia3d76pltvkyJ8ATIttttky2222zJbbbbZktteyYHkyPgCZFtttsTkkkkhmYsS/eKE/Nvufvff33V9n3eXzvm92hAAkrSQABYgPyQB6Y2zLaAEALbbFJJJJQJJJqbu2SSWJqS/zXsmB5Mj4AmRbbbbJlttttmS2222zJba9kwPJkfAEyLbZJEnJJJJEn7m5vRppLEmksSbxJvH9Q1Dz546Q8Q6/b92o52h/PH8EBiQEYgKsElEgGeuqB52Gb6u7ffZxrzBBhnOFhWdq2vzthzxM+woKEAwQQQDPUqOjgOSHr7zXK3Ot7Mxzd+X2KfqrNlsNpqPlDayrUNlDFHJgLlFkU1DjkxaVVlOULrhHChijFXrXCrBgrFXO6KchynKqcMqHnu6ak0VYUaGuqC8cdUMR1DHzEp1Q0o6tyh/OCVd6JLqh9PIOjvKXe1jLYplVaJdHEqxGUGzLcobknHBOFbBwPhunXFDHvHVQzZmsViyHRHzojzUOzmXKhlDBlTucJXE5zmKsVczYmzGXNU4ae86lnUWxUbIZA4VauZsk7s5XRVzmTNbbJszKGUYRuucSyGzZUdUMo96FOo1vuS4/cRiQDSXrKEI44AlvnvokBiF3vKvnO+9Pd8ejrwg0+0BQEJMAAAttttoNnh97be++20HoeEmdvN53ve896tfAGu973vfug2AnQAAFyY73ve9+6Ae+++v376eYppoe7mMwnuJc5y1o8OgA873vO970AHy7tttoAFttttABbbbZrVoAwD3d3820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C9vJM3ky22/Fre8mHAdakxpbbXze5MNvQ8ADYDr5zJknh7DT7oLANhB0+HANyYA7orWTHvvu/ffR9AAAhoPTg+Hdm5M97Per3jOIQT37nbe1HSbHHQKfSc+BIdLSHhiXWFeEeuQnc5889fn3zb/M3bxtJpP3G0l76YfyzvO0XoAfSOgAFtkkkkhJu7tmShbbaAAmwCSTnK2m9/nQDW+98aZJJJIk5JJJInLbbbbMlttfSYOTI9AMyLbbbZkACZLbbbbJlttttmTzz+3RPvWnvD6d58gPzTDT3yOpfgALaK3Lcadtt/W7Pd3SS9t4k+pvverve9tAAGAXnOPnOWxNSRySSJroDAATUkdr7Jlu8yD5ATJ7b3vve7lmpZq20wTQBJEnJJJE1QC21NU19nOffH2/r72362HoSPoHoBbyUAC2+VphJOSn4C22gBDDwCScl5ec78k93v5NCHQJktW+23mZLbbbbMlttttky2222zJbbbbZkttr6TByZHoBGiSSSRtppdWJNJtYrfgD0m1SSSdjkkkgEkkkkJJJJJ1tJW2222gHwDj79Ovbbf1mS2222zJbbbbZk/gBMlttttmQAJkttttsyABMlttttka0AMmSZMayIftCuBkOaknvzz92I+MQDaQDYL5oR500gQud2u13u/fd+7XPxMkkkIpJQ9aYW7eeAABZN3d3bIAAFtv739999/fZM7/f3JkADMgLbZkttttsmW2222ZLbbbbMlttfZMHJkADMgLbZkAHgSO8hnYIBkG268rTBtZy/e53Pfu31SSTsUkkkAkkkkhJMTckkgQ600rbfbiTStt9TaVvlLl9SSaAOa0+6p0A72JqSSSSJOSSSSJqSSSSJ7kl3bbbZkACZLq217Jg5Jj0AAmiSSSRJySSSRtaXN1r38n95ZbPWn7b32STvrTCft1bu6QlA8aYHEFkEBJLJ7J3rTSt8SfLbe87221K22NO9zE0lc8AJ01NWSQNSYeNezJJIZiay2y21J22gCarVtvbbU1zqQHO97MlW1bZk+++SZ2/SZXrzMnOPgE13lXJh5995zG8xJLOfNP2l395+vaBs6ASSAAfT2ST2SA0wkk2ZJ1NpFttu9zE0l3xPve973jTS73p600gN9vOc5braE8ySSSRNRr7JJJImp2ST3iTk8bX4bcyZAATXJJskiTkkm7qaikkktbUns6k5N3SauvW22iawt0kl7S59376Hv8tt/g/gB+ttttq227zJbaBYm7f1xJpW2+q2mAfhMk9/dV3fd538NrrWpOYAJqq0AE1JWmGRt27bVvgC1PVoBa2stttE1ittttTRoNhnGnbtp22221Nc1zXMue9Dvp6AuTzzMWNHAk6e2SeqSd6gAALIpJJISbu/bvhIVppW22221ppaHh622nJLnmpue998JoC221J22221NW2221ZLbbf7smG5MACZGgW9mS2222pO2222pq2222pr8Th9v9tN7TSXvx57X4oQFS5FTip0qaQEG2ITbfnQ0KhiAZdez9f7N4kknIIBt5WVBjz9oIC7CCAbjSAjZnqJW1jOSXnr3EIMzucbqsC8RlSu1OEmQIYm/VBAMHncDuGyXyEEBkHXTtiAe5KEBuZlnSIbjn7vK3L+v7O7y8r67MAGmxJfG66JOrFa1QybbNFrPmLik1DIaUbJ3QzJXyWPznVDohfPzhx0vOlU+XHBU6hMVWzaiZPvI5EY2QbJGUZgmEzVW0LEahjSjEd0MJyZqGsbJW1LatpLYVYE5xxiHaOVDzKOsIxtIZtEtQ+5DlDEfzRzGoeHA+6i6sq0UaTaocxJwtPdQ5NFTM2qRkMqy1DY2m1ts1DT9z3dKmm1jbWgto2Zi2Jd2XNbTWlFsEgPVoCBxiCjktpCXLltL3vb5Ge7t73vvQAa5rpzg6+HOc4B3ttttdAFurbbaq3xzgdPNA+B6Hj733330UAVqW222mh4FfALQD43eW232gAATckUxtt5jTSeY2/2PzEl95JPYQABXltvlva+NyY0Di23220HAPrQbHTx0u33FFafB4UDa2y362hogJ23JktttDAF7dW22gA59bu322gA+9t5fLbQAIyYyYyYyYyYyZ5PPNyZ554C/AA73ne9750Nm5MB6ebt3Jlvtvt+0PAOAfAAN9Nh23MknZM1d223h5MyTzJknAq2t5MkW2362UABbbbLa0AUbt7dW/WjmTJAPhyZ26tvtteh4HwAtoABbq222q1JknMmSPhx8r1B4AAAxjLbbbaHMmSAfAAAAAAB6eTBpmp4uJvxY20ljaSzFqG1FkNFtRMhlsibFjxPd+3pvPGcnUkvd8SzeG3rDa5J0AmYABbbbattttAD+n79+/vcxNJdttCKZiaSD9y7vNSW5qT74u/m5vWa1mDwDMgtttmS2222yZbbbbZkttttsyW22/RqZhuZOADMkkkkBNAABE1vuSxe+Ylme5lTdXnPOXnrTtXavR4AfNMAOrltv5p2205QrTttt3ZJNmKWQAAO29SfetPvfO9oSNM53d3SRNSSSd1JmGJoDgACaAkkkSckkkkTUkkkkTUkkhqTNzIPgJkFttuf46yQAsya1kTSnflix4vp93nPRGfb/OCnWQ3Z38SSSAH4PpJ+kkjTBNySSKTrTSLbbbaEkm7u+9TSXY08/WSTvYmpJJLqTDxOPACZFy222yZbltttmS2W221NFttwSeZtNYs9mZmZiaoAAkwA3dTX3i+fWsF9mJY28ZKmy1U970i8kJkDamAABQkoAFN3d3bJUYkyq231O2nqaaRjAEgD9s5vu7tsSWxSSd1Jh+/N4SSSRNCkkkkSeySSSLJbbbbZktttdkw3MnABMltttG1dW220TU02xTi8eX7k9r0nO96rL+2095z9zOXaTknkySATZJJDZJJIEqtttttAAkk5eXd3bqa3d3d7qTmNruAFzJQL9LMlvLaEyFt793UxYtW220bQAAJoAAtSdttttTWe85vMf739907yLbPt3Enu7uybaAAFCSSSQm7u7pIICSSSVppBaAUN/bu7Ymt3d3e6k5iTEAAA2pJJN1paABlzSeczMzMqToAFqa1bbbamiySSRNBJJJE0Z+y4mkvBLyr6cR7mc8zS31p9nmmzY06B3631J5bfmnbYj6SDTAD6bu7ukrTSLbQCBjTSDt78k+22+tIzvOc5Yk+4mpJOSSJqSTd5puZAAmQAuZO973ve9mS2222xq2222poACNo0ABE1dT9rsvlvc4mkjnN+XVi2/W/E5J5zZvZJ3tttst8CSSSSNMJjTkkikrTSmNNK20AJp9bbb+ckkn5NSSSAk/2k1u220bUkkkTUkklEmAACaAABpaAALprQAFqaAALUk/flrXZ8op9mven7vs+3OXYdAAChN3d3Td3d3ZIVNpXPGnb+MSaRbfWmlS31ppWW35ppXO5iaS/fva5oOnpP1bVtoAmgAASYAAJoAAE0AAWptXdtttTVAAEmAACaAABNApxGm0lF3Xt9975J4lVn5Lcepv3e974Yp9ed3VuQnsknsgAbMkk3d3d3ZIFaaVoetNIAE2FowD1ppRN+dJ0DeypJKST6SRtSSbu6mgAASYAAJoAAE0AACattttqaAABNW2221NTnOh9DSh+1ptHP1UkBSQD4b8IClxnu3VczHOZey8uVrL2Ubf289Vu11MZ3s57JWZ7kqISaSR57nCj6i6Yjq0MXWtiXENtHCczaK5IxtcNMubi3OHNbZrc5UOVbCNCmQ1I2B3XFaho4fOVwWbbQyW7rLxXVnVyjlrhKwRkPPXTmui1DGFP2uvgF2Dh1qHXVD512od1K7kduolwRkfOXZHVQaJpG8ye8oe+PekHyiOiNmfHRHVDoK2UdYjn7hQ4k/OnSOt15Q8L3HnUrzUOUXJmmbMde++/O5qTGu9873v2+wDprdD56vjwAXVtltvfYHnoeLbbbaPPQ89e7t3fLb7Qtb2bdyZz3z3np0AHsnj232/e3y0egW2220AJ9999873YADvezPNTw88kmDzvegAnJ3ve+d73wHoHtu5MurbaAD7O673ve9APQBbaB8ON/Lu2/SQAFzAPQk1tKJtJYm1mSSQCMwHezve970ADsl1bbbVnrY9CZmWJpuTACXUNyYAyZe973ve0Aeh5kxb5bb5aABHkmSX3Mlt98toAAAAAAJkyYAAA4tt9tu5mSXw3Jg511xrjcmLeW8t8t3Jh145JkgH1oB03JkgDpu22363kAvW28mSC2/W20ABbbbbQ1N5MkeVoe9qtAAAD7M++++++jUmAbyZIUOmpvJklttv3ZGzAAAiMJ7JJF5ijT+8zMzM3zzW0rUnYjxzhaaKujhTmbebIFvG0gMTBB33a5ud8+b+7+ElENoznub07v15u7vSSSSQAJJJ7N3w9kk4AASStvttt+5mJpK97bb0Qiez5ST8+43mm0taS1p6Wknd2221NUAASYAAJoAAE0AAWptW3tttTVtABJgAAmgAATXz4jSW9bQuqzhvjT/ftjbnxl807fuAFadtzPZl207blzUvb6XX2rd8AAAX+P6TP311/Xe9979/MTattttqattto2gAASYAAJoAAE0AAWptXdtttTVAAEpps3JJG0E9+vPefFr3sNNvSWkk0u/tvZ9n307u82zd4VPoAFMltoAA2pKeNM+QAitNKW33uYmkrbfmml3vncSaXe9+++zMsyfST6JqSSSiaDgB+qbV3bbe9ODG+95znNOMbGxvod7O973nWNjY2aD72jve970bGMGaB3sO973p0aGNdoADT0a2tb21rZWnbbU1N7Tmk2k/d91u4mzFyyk79K093eyTs3d3d0gAAepMJPZJJJJUzPGmB+QeW39T4D9e5pNJfffe6p+5JP1bQAAJPwAAmpAAE14AC1No2AW1NboADakkgCTACRNCAAE1Ub3uat6jW+676eS08xZmYzxpcxpfvvg73FOc53ebez1SSeyAaAAG7JJJJJJW20wC220CtNK/fffY09fm/soT8fJtGwAE0SSSJOT4AE0AEiaAALU2jYGwE0dklBJgBImpJJImt92tb+/d+zPr9nUn99+/ZbVttAALbbe9W222gg6HWmlcbaXcxNJedxJ973ve9779n3330vWmrbfW3iqdtttE0AFtqattoCTAABNAAAmgAATVttttbQABY21+Rq9fqMV9CHY09vnudQBw40wPzkkg0wD0rVD1pkMPfNxWST6SSSSSgAAAemdzqTzPEvM3d3extTd3d3W0AACaAABJgAAmgAATQABam1be221NW0AEmAACa/G+6NaS/fvS4r3e9ydJoEAJJQADgI/dtAA3bJ+ackkz6SSTaAW4k0rbbbfn73ve+xNCAA/VNq29ttqaq1aARpSSSRXWtLS0gAIxaWtW220ugAKqABbpGjQBfNPRwb3vM7mZP3620urbaQA9AF71by20+G8mA9ZvM/L7777778v35bkkk/SSST5AAEkkkgjSACxJ6tttskkkqAAJJJIFtkk5GnefaGr31r33z7dvPvr3Dv6SVNnwB4CAAW222TLdjgeA2ADQACtNK2jT+W9n7d3u85xc5w9zd3QFJJJ73ve9ZJJIAAWSSSCAAJIABzvv37t97O8TSXfb33gfrz7yTS7DDGwOcEA5dzsebzvve56TcBB3CwYcfM8m+Z3pOauvZ8X77fy6mkvm0kcp0w61vS3ryam7vPdfas9t1MknOcyXz392nvaeA8HAOe/s5nOe858B4B8Zy/rbeWeW5j9Sfwz0jsjEcpU2EaI5ybY2yMhqG0jTMm2bazWbmc1bLZYqyVsW65zJWRlNqhkNGw2uztVxpTKBm6kcVNlK2feiLmSu3Z8+8vKHnMbEa0IchziyS0RtZXC3lqjm97SPcdh866Xhcz3dKn1qCe587SclXHfvJLnndZJn3D3aaZJO9753v3bs2CBry23z21wAttttoAAAPAe8stt9tocA+szPu673vZ1TYDpkzve973vQ2AO3Vt3aPTYJ3ve973oADvv2ZGpdZzU57zPJrJq4MKkI1GGllEKaKJAbY6RG0qqazfLffugAa1bbbbQALbbbaAF73ve96oALbUB6AG8mLbb9byj2XUb6ekLkmTGgC5JJMaA83Jne987127eA9DzMwHoeA9C22229NgD3kmd8kzyTEmPHQAAD7vsmfb53nne9AAeN6Ij4LHm9m5MHT4AAAADMySAAAAA3kyQB01kyQKKgUABbbbbQANZMkW229tAAbttt+tA3kyQAB6bkwvAAW2220ANTeaD76TMme+++jpMyQAFttttHczbTzN5tppZmZfJuTsF1J8adg04xaso2s1RqH6hqHDSOKuJRyisS8OKHjxu3tXnFevHDNO6aX2nmmk/tJNmmuc9wOfH0t7y231t/W2220W22zvVttoAAaakYAB999999tTS6saUkkk1TMxKSSSa1Wta0nbbbRqtattto7p2212jaABBuSSSKSSSqp22226NNLWRXR0n7jT7POoADrTtv4YAfNMCH3gAvWmB8fSeyShbbbaFtv60uW22l7zxp7sJ+kklAAANgB4NgB4NgB4NgB4NySdk3AD3QvEn3Sdt9Zbvf6a1vdDeSZPZ22kACSgAAIACfSSSQto4B8AAd++++++b/p3ve973PpJIKaX4AKg0k9tq2+ttAknu9vvbDQHg973vEDXNGkAdukmflr993n33332fvvrbbbattttoLbe971zJltp8eDM9mZmZmZmZh+AA+/EkkGpqSSET0bADyc1JJISSSxJldttoABVAAJJJII2Q33a5330klt/fsy22225bb9gfv379+ttsmW7tc8D18NtSYB8LMzMzMPiST71Uk5IJGn0APwmy222ySSVSpsNgcmpJIIAAnve96C0B33vbzJmpkk5NfqE6/v74cbAdtttkgASSbu6SdC223y0ANAAAJOAH6/fi20PSSSCAAPe973gWgAPe973ooNs4aAvUnS220gAWLST+/VZ9z9baTuJO59JP0gYkw8AD0wxJgfgD9MSck/bukk6W2220LbbbbaBOnctt/fKSQCST3oLQAHve973ve972DTAAJQAqAAJJJIe7rmt8TraS0m0m1QWoaAP7qlcoalRZkKWKtQNFWg94qvf4bgd73vSAATrbba7bbbbTAAk2bveqHB4D0AAv7Mz+mZJNaz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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })
    with open(filename, 'w') as file:
        file.write(j)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        load_snapshot(snapshot)
    else:
        bootstrap(stdlib)
        home = expanduser("~")

        try:
            src = home + "/.parable/on_startup.p"
            if os.path.exists(src):
                load_file(src)
            elif os.path.exists("on_startup.p"):
                load_file("on_startup.p")
        except:
            pass

    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)
    else:
        print('Initialized using embedded snapshot')
        bootstrap(stdlib)

        home = expanduser("~")

        try:
            src = home + "/.parable/on_startup.p"
            if os.path.exists(src):
                print('Loading on_startup.p...')
                load_file(src)
            elif os.path.exists("on_startup.p"):
                print('Loading on_startup.p...')
                load_file("on_startup.p")
        except:
            pass

        print('------------------------------------------------')


    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
