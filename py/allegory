#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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98883v8pSlKUpSlKUpSlKUpuHe973vec3zzzzzf2qUpSlKUpSlPsmSlKUpuG7u7u85znOc33qlKUpSlKUpSlKUpQvcO973ve85znOc771SlKUpSlKUpShLcEzMEwEENZRVvCVPmCl0861uK/sKiNjfMQQ3f3wQU2VQDsoKn6FZHMiOYSpzJE5lTmIjmBpQAjBJJK5JmVxRo4NAbD4HwNhoPeZu6u6/e8kn7970lV+BHM+U+BPEkm+97Tveu9nXe97dvMbbAADyglREJExEKEgPkAAVznOc533uyROSORkpQlmChmYJkpSlKUpuG7u7v78qb7nvvvz2983v8pQNCUJQlCXcEyUpSlM34bu7u7zn7zzzzzf2qUpSlKUew5KUpSlKUpuG7u7u85znOc33qlKUpSlKUpSlKUpSPcO973ve85znOc771SlKUpSlKUpShKNkyU3Dd3d3ec5znOb71SlKUpSlKUpSlKUoHth3vf7ve7/Km3t77nvue+YhvcUpSlKUpSlKUpSlKR3Dve973vOb55555v7VKUr2XJSlKUpSlKUpTcN3d3d5znOc5vvVKUpSlKUpSlKUpSke4d73ve95znOc533qlKV+hMlKUpCjYclKUpSQQ3nvzdMOCocz7z58SIfYnvulB/e/33REv7migc5zVMGaq2KoyofUDcYNST1VVVb1epPZ9Oe9o4NAbD4HwNhoN4hObqqHhj40AAA2yEoRMAfJE0xdO1VWxJO945zjvUiSSSSfXbFB822/RCiEobYeQABVVVVRhEKZiFMxBSlKUpSlKUpQPcO973ve71U9999/g999+bdlKUpSlKUpSlKUpSgDcO/O973vfOb55555ve+wGSlKUpSlKUpSlP2fsnyU3Dd3d/fuc5znOb71SlKUpSlKUpSlKUpHuHe973vec5znOd96pSlKUhWy5KUpSlKUpuG7u7u85znOc33qlKUpSlKUpSlKUpQPcO973ve71U9vfc9vvue+4f252UpSlKUpSlKUpCqdw3d3d3nN8888839tQAA5f2Lv9JJVVVVU7AAAMYmsSSST3Oc5znJ3zIAA77nf3fObeMpskzXvXvvv70pHvuhR7ioEeyMZ99AhBzSAAO6Eku7u7vLuhgAjBJJiVyTM2NHBoDYfA+AGpJJ6mLd5znklXVVc9dVave973vJJJJI4ZkkuquSqqr673v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c5znO3GOYZu7pi7qg+qMAFdMgODQGxqSSfSQDUkkm6nqzV1bNZ73V3Zlc/qno3ohIA4j5AnA2/vu6s+PvpJ4FBXfSuykSlCUIlGcDM75HH9CDweVxAkLmhCC3zdc93vV30/M5XgC+n74ru2ElD7xtt022m223cREQxHyAAKqq99772NqyqCnMwaOpvw3d3m73qp7777777vv6e5mGYqZllVRFwN+G7u83ec7znOcv2eLAAvWLu7u7qqre77DAABgxNY973pJVYxVVjGaVJj2GQA/T7EklSaqsYqqqdgAAE1j3veklzOc473GO973tzwAAF6xJJJKrGKvnOcv1gAAYvWLvtzUlViq3udgAAGOYT6JuTclViq3udgVVVVVKgNIIWYILnMyeRYQn3QpCWSTXo77wgAPRO0hAZv332+7ABAAKA971eex73veHTIDhmSSTch8D4JMSuXd1znE9MaABwAb0m8D4sDOs+SUBIZl3N1RXeuwoMgOhqqqwOe96ve973vc3ve9zsAAA9hi8DDN/sXu7u79id1rGM544xnHOcubAAA77F/sXd3d/vb/fr7YABgO4n1ruVJ7tVvc9wAADM11PeknN7/fp2AAATXU96Sc9zOMZ5yqnuAAAcl/o/SXd8nmc5wx3XXX7muXqAAAN4yYML+iSXd83KqqvtwTWgMAF6+frkk5ve97nYAAB5hPo+kknKqqqp2AAAb9+xn9h+x9yb+k333vDAN0K0o0BwoApGADpkBwzJA4cfA+Dc+k+1znveHhJJPakkm5Ikk736qq+YY52ruupqJqVJJIAAMHq972Pe897u973udgAAGcYmte1JJUYjOesYtlX2ZU9z3+wPc9+PsbJ37kZgUFBRJjubbu7u+c5+888838aUAx5ipYZRG227bu75z9znOb+3wBzLKJzHHMQd+dt3d3fPv379+7v42ibJUzLCO4IlIm/Nv7d3d8+/fv37vu6qZlhOVEWbnbd3d3noxjGeOOc1y51+AADGcXf1tXd3fNyqqr9eAAAL1F3JJze973OwAAD2GJ9H6SSc3ve9zswYAbbbY+u97cAQeMOm69u4s+3d2+7vu7mARQAKAYUjAQdmJJJJwzJJJuQ+B8E7MTtVV970FTkmZJImZJJOTtVVsSSXdSdfVV973XepCu0fawDYAB6ve9j3vec3ve/cnYAAB+T6JJJXcW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O4IvYAR7IiD2AOyivZAO9/fDp3AIUADazMzMzo8cvzbbdt8bbALA173hsPgfBGDqakh73f2qr2L/fsqNnd7vdlRC3Suwk5S+b+cw5Whj3UlHN/fvjnzO93QUI5hDSroOYH7oS+iD5oM++nmuaOYuYjWG2AoEa1rNZW73d0sahQohEwoglQohEwBLAD3ve6WTMgADs+iSTkuZznHOc93vbngEyMwKCgoKPN+Zbu7u+KnOc53zzf2kn3EHMsou7mW7u7v3+/vm+G6qZllEYww132r/Wvc5KxjGd3ve77awAA56/2ku7v9+x3e93yAAAcn0T973r9nOcVdb5cnQAAJf35OScm/366qr7YAAExf2l9u5N/v297nIAABnc+ifpJN/v305AAAOMTn2KutSsX9X3vve7PeDID7pg2jDskkkgU0BxGKAOmQHBoDYkxJznOsdr1EkkkqR973ve37HTIE8NA96q96Tvep30kk7jvc1VX3vp3fZ573ve9zOMZre9792AAATXnpJJu5nOccxjGee73tzoAAF64uSSft73dVfvWAAB7F/fl3cn79++lQAADrute/e/T76Tsr9+/fpyAAATU9qSSfq3ve5yAAATU9qSSfuY5cznOO95c2AABPYv9qauTkr9+/Xu+2AYMB7F/Xev13cr9++nIAABjifT2pJ2cxjGeb3vc7AAbbbbKic7vAIJHf4dUX7P3ve9+/Z+7u7oASM4AdlSSSQKAEYAOmQHBoDZ1j9ThJPcD9+8ABAa223mYZmZd3b3QDdW7uvMwf2d732PV7ve97znPc77Xte9JK/fvpyAAAcYzH09qSdneM2xjGaYzVV9u59iAAAP1X+3NXd8uvVVbvtgAATF/amvb965yt7/TvQAAJqe173pK+/f77H3vhtW0lLS2ZhmUb83c3d3fEUXVVVbmzqmOcXOc5HOJKOc9v27zd29u6qvb2xbQGGbSakl3Umc5xznKv2OOAAExf2pq7u/rqVW8UxjGavtgAAXq71NySOVve53oAAH7de/foufRChe976FC9L77wDSYHAAHbcttt+9FHq973mxQGBGBA6ZAcGgNieCSe94kngPEgGNvHmZhpYGgDu727u7u7azMzMwSiMZ9Pe1z3p9OYxjPKqtzsAAAzNe9r3vSc5VVudgAAHsT6TUk5K3vf6cgAAHsXf76akl3XpnOcc5yr9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G3mZmZN3Kkk+7KkAFODQRgJJyTMkPPZmfZmY35t4KW3d30eN+YgA6BIGue973fe9rwzd3RJJySR+97wEk8Hve973ve971ySakknOVve52AAAYmve16STnrz5rOc464z9zlzYAAG7+k1Lu75z3OZxjPOcv1gAAXq71JJPucqqqdgAAGZr3tekk5yt73OwAAD2J9JqbknOVve52AAAYjGve16STt+1jTPmmc5x1xzlz8AABnmL+k1Lu75z3OYxjPOcv1gAAXq71JJOfuVVVOwAADM1Pa9JJzlb3udgAAHuz7GMZxi8pQlKcpKEt76b++3L3db1B8DdxEKHqD2AnfdlSc/GgUyA7GNgOGZIHBoDYkk5ziSSPe973vc973ve973gBJJJJEne973vvHve973gD3puSTU3JOcre9zsAAAmve16SS+91M5zjrnOXNgAAXqTXrknOXzmMYzznL9YDHdY1powtd6u7u+cqqqr7jdVMywjLKIjc3c3d3fPOffv3fXbaqATF/Xer3d3zlb3u+wAACa97XpJ3jl6znOOVV/rmgAwYPl/Sa9clVdVjGM1Uv1gAAVf13qbkqt/v0nYAABma97XpJOb/fv05AATMzMzj52vNvYShKeLveVW+86MvW22/m2Bmd73rkmIAgAFBJJ0yNh0yA4T8J3viRV3VU8AklABJPu97r0kiSVJJIDlVV+9770kkkSSSpJNTclfvvpOQAACa7NekldzdaznONs7dvVzQAAF6la9ck5y+cxjGec5frAAAvV3qSSc5VVVTsAAAxzCfSakkr776brwAAHc49976fVJOc5ve52AAAe6ZxP0+n25J7vcdv9nOcc5z65oAADucX9Pp9ck5zF9qqv1gAAXf13Pv0k5X79+nIAABma7PfSSc5nm97nYAAB7H099jz337e8Y1USfyRhCfZJR/YTbCT3vRDzWirKnObRf2Ih/ZEf2QQ5KH4hoSJkIAVNgRTYfkE0wW4gIG/cEEXYAE2QQ2QV33FRUlR3fd3c3vfffee+3u/v379+RQkkklSEknZiSA6ZAcJM9mQlGZjp6HEtmZjd3d3dxboHobb6m2xt5mZnUkNtjbzMzMaUJIACkSAAGByEoUByIiIgmAA+ALu/e8YTMyAATXve+kk93l/ZznHOe725wAADd/X9f0knL5VVV9sAAC9S59JJyt73ucgAAGZr0n0knOY5VVU7AF6Y1rDGPXq/r+u7vnOVWMVV9sEWkZZVft+b835u7v73zvxU88PPN/cqqgAbxf0u/pUnL5W932wAAPYv6XPpUnOYxjPK3udgAAGOJ979770k5zlb3OwAAC3GNM4zrWM4zg8+NzE+EtNESzIzBfgTnP33+fiS4Ig79Pn377u971RR3cRU3d+CDv36XdVf13VV+/fv36fv37P4DpgBaKNsSZqquSSpCVJOzEklMUOmQHHHg21MOb+SUcz2ACup5EJLD4QAFptomIhTEbEolAfAuREKQrYShu+uFGPFH7Xvedcz3dVV933XdJBgCqomj1KIiA5EJIksD4Au7r3jCZmZlTKmYOP3vvT9JzlzOc47VXNgAAVf3pPpV3fe95vd+sAAD1/SYn0qTlb/fpyAAAZmuz33pJrHOcr9nGM1U7AAAJqSfSSa5zlVU7AAAJr3vfeknL4mc5xyqv2wAAJyaXu/1/Xzl33lfv19sAAC9dv33pJyt/v05AAAMzXZ770k5W95xjO9zkBVVVVUA/Ixth5HwvgCEHPvqfbRvt8PSett/MQAWBwaeJym7bltgihJJJKkARgA6ZAU3izM+i6p1lCfWClJQAAYB83ic1mcwWZhmZg22Zl3d3Zuhu7u7rbb8kofve/XJJPpJNcre9zkAAAmuz33pJznLmc5x3nLmwAAJxf67v6+cu+97ze79YAAF69733pJznK3udgAAGZr3vfeknOcqs4xmqnYAABNST6STnOVVVOwAAEST6d73z977vxU9883vOFGURkqZmYROYqjk73d37bvdzMv3tb3ilTC5PJneAfGlVXr3fYAABj8n3ve+9JVVvecYz6p2AAAXnGM4xc7W172599du3fpJJ7Xve95wZKB0wBwyoDYfUAIwAdMgOEknecSeM09QOh94fUDzputST7wekkmbu1mZjbtttttt+bb6AB8Dqq94owmZkAAmpJ9JJznLmc5x3nLmwAAJxf67v6+cnOcq936wAAL173vvT1VW5udgAAGZr3vfeknOcqs4xmqnYAYMBNST6STnObqqnYAABU+kn0qTnOXM5zjvOXNgAAVf0k+lXd973m936wAAL16Yk/T9JznKrOc4qp2AAAZmpJ9JJznN1VTsAAAx+eYxnGefuz8fubqtd7vfuenfAaA4MpJJyTEARQHTJQe973vPY97wOmQH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ABmakn0knOcqqqdgAAE1JPfpqTnOVvc7AAAJr3vfeknOcuZznHecubAAAmL+u7+lSc5y+VV+sTMzMquLkyucX0x3PEW++u9zavUAAAfHve84MpJJyTEARRQAoPe973nse974E4yA4T2BO985Jmekk1A22CMePXVX73hJJJ6MJyTMg2wADSkAdANAOnRu7r3vO9fI5yM5xrTWGMXeru/ru6qt9qr7awAAxS/ru/ru6qt+qr7AAANz6SfSpOc5VZznFVOwAADM1JPp71VV+znOOc1jk98AABL+u7+kl85yqq+2AABeve9v965O97W9zvgAAPYn0k+lSc5yt7nYAABma9733pJznKqqnYAABNST6STnOVVVOwAADs7j7X2H6fSpJPe9733ve971DKSSckxAEUjABQAjAB0yA4pJJ3nEnrHmKqrCSd8oA973ve2APCSSSSAAAAAAA+ALu3sxELMzNKmZmZmZmQF6u7+kk5zl85zl+sAAC9Xd/SSc5z3Oc5PUBgwBNST6VJO97yqqe8AABNST6STnOVVVOwAADM1JPpJOc5VVU7AAANz6SfSpOc5VVU7AAAJqSfSSc5y5nOcd73tygAAL1d39JJfe95znL9ZgAAL1JPpJOc57nOcnqAAAxr31d9nH377e5rbdVOSckkk+kknuDKSSckxA9Xveer3ve82H1ACMAHTIDhJJJwnjI973vve8bkkkknve94EkqeoSSSSQdqqs+MAAtJQB8gOAdALu6qqMczMzMyAE1JPpJOc5VVU7ABemNaxgxEbm7vzd3fPPOc5zfXuypmWE5ipmWbm7vzd3fPPOc5ze/ncVMywnMVLDNzd35u7vnnhznOb387ipmWURkR6W/N3783d3zz7ve75iLAAJi/rv99d3fOSZznHOc5fqAAAvUl/SSc5dVVX2wAAL1Je/0kne73vc50AACa96fSSc5ve9zkAAAxzmfMTc3vcknvB8DYaA4MgOmACAAUAIwAdSckzOJJJIAEkkmpJ45JJKr0k9WRJOSSQbbbbbbbYgA+ALv3veLJmZmZmZmZkPT6T99JJzm973OQAACT6T76Tkne/sVes5zjnOfYv2gAAMVf0l/Xd37ve45znL9YAAF6km/0knP379+lcAAA7j3cTf039JN/ffTcAAAz7Xu+n6SVVb3yp2GDBkJrck/STnOcqqnYAABjE1JJ+n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lhHNzd3f7fv3+8/fd33+o3Jppppppp3O9/t3734c5gD937u+/goHcwGDLKrc3f7d3m+effv9vm+/qoAAmpuJNyq3v9JyAAAZmvekm5Vb3+k5AAAPYn0n6Tcqt7/ScgAAE170k3Krf0lQAAC/X+ku63dVWMYzX675YAAmZRT6ee8+X3e9SUJCzK56s33aebpQAFFgfAA223mZjbAKBk/A+Num3y3sPumACADvfu97rveJJ+Hz083JJ4AaEm567q6qYu6uqnfSSeTMzMzMwbbbbewNJQSAAedJVVUl43Oc4u58AABi9Xd4u93qsYq63d9sAAMPXqS5W5WK339J9jgAA5j2J++ubl1e/2rvdgAATF/a7dy6uv37P13VgAAXrV+klTf799JXgAANz6XLvlXv9q73YAAH7F/X27l1v9+u92AAB6fa73vrre97zjGdycgAAG2J9JJyVqsVVVJ2AAAax57OJvUknU965JJKu5+/ftfv379+AB8DYaA4MgOmDplOypJJDve973vU730knp4kk8ABJJ3vqq7qpjNVVz31XdNsVdXVNn0QoSLRJ2IUJAB6IUJE7MpKEt3du7u7973fPe973vere97373LAAA9ifc+kn6Vve/0lQAAC7+uSXdVVVVXfbAAAmqkk/Sqqq3fs5zi798AABm9SSXdaqqvnLv1gAAXqfSeuc5VVVSd8AABNVJJ+lVVVuTkAAAzNe970lVVVuTkAAA9ifSSVKqqrcnIDNtAXqSS7qqqt+9nOcXfvgAAMbxr888nMJQlwr3u3e0JXd629A1bu71bubu6973nqur973ve973nwNhoDgyA6YAnZUkkh3veySRW6SSSd6kkkAAzVVYC6q+vXdXVGRq7qEm2zAXBwSAdiFCQBIAD0YAElTnOcqTtgAAXr3veuVVVW5OQAADM173vSViqqqqTsAAAmpJJKqqqqk7AAAJqSSSqqqqr9nOcXc+AAAxjN6u7u7qqq+c5d+sADBi9X9dyTnKqqqTvsgAE1JJJVVVVUnYAABmakkkqqqqqTsAAAmpJJKqqqq733tVVVVVR3sijfAEMvPp/fkEFrWT76zntaeuDB1DXvePZ8e4tGxNVrnrrsO980JB92dfx6qi59BW6/S+Oxo77EPCIHDRQkJXBaQAwBGdX1933y3qVNd40KN1JtlI3ZDC3lkIpgCFSGALk0Kjii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x23mjANjQB6qqqvmKxdVVXjnNZzznPfffd3d3d15qRbOalk5KoaKY2wmIIahrSiSCWiSIBtjkUNpTI1Ek1e7mYAKJc73ve9SAAkkkkgDbbm7tXd1b54APBgdTTSzO5mZmNt9DjiSSfVzF9z02Eq6q6p9kTcnbq6q6uYkgAJJqSSbD66urBsEQko6wAoDO02/n5tu32IhczMz2ZjbA+2drve72QADkmZJJAaISR3d1TqSNQLuQJgK377mHjG8+hK629qe9pRm7ugHZJJIu7ujIBd1V1QJdVcuqvVZ+z8+2ADerurqg2Lurqu973veyACj71VVVeefaq0oUCAC3d3bG22222285EKEstqrn3fu9QAAKrS6q5Uk3Jm7q6qQHQNh8Mmbu6cGt+uquq973ve973ijN3dAYrN4dBIzV3d1eQEiqu6oADhm7umAADF3V1QBAAAB6qqqvnq9733ve97UY5sfdcAB73ve973veBRm7unDp7s7u7u5927u7q0aYJA2mNJCBoI+iMiNGANKlqUVoVVYqru6rd4rOoOku7qqvLIEKoDbau7O5nzldo5Hc7mYFpzmXd3675eZmYwA2HwPgbDQHBkB0wAne9k5JltJJJJAAAEkk713ve9SAAAAoA6+r3qphMRAO0wKr3ejJULENh4Kr3a8MlQhu2BSVe70ZKhNDfwSFKvehKPeAULFMR+FMLfjd3d93Eu92u7KhNTszKW/G7m77v32vZUK1KWwpmVG6bt7vu/fa9lRGwp3Xpu773u917KUbMbobs7vve9CUe9r2VC5U+n7775IAoswpy2237M5d3dvMzGDYfA+BsNAcGQHTACbqqvvc+qST3vcqqszJJJW6qr8G8B9VVYNiSeJPeEjhr3ve973vebblsA+iIQD6oTJAA973elAoQAWHve70BQmmjgHg973emohbMQt0Dd2qqve3d1RzQNrebt3dVCUVW61C8gDxQXd17xY1CAOlhd3XvA1CaAPFBd3XvA1CG31gWZl1XhqENs8cC7uqhKKoGoXuivD3sSVdKuzMG2226zOZd3fbmqq+9zJJGw+B8DYabD7gy/e973vT3seAne9kkjYHwdcafA24NBuSane96xJ1JJJAAA21oAAVVV7xYKEAFhVVXvAKE0AHgrLu/qo3sRC2YSWgG7tVRdVu6oWgaSFVVVEQqlUAlAAMKqq94sF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Jkk/ffv298tttLbbbaW2220AABkkkyckzkmd5JmtdjvIfjroJu7d3hBXF4QVxeEFcXhBXF5DTqdBFxeENXF4Qt5bwgri8mTzJMmSb6ySTMkz773zfvv31pbbbb9Jj777777775ZMdAAALJlkzvJMyAaE6JJIC893eQ+OodBN3bu8IK4vCCuLwgri8zqAuYvJp1J0E3du7wgri8IK4vCCuLwhgEkkDvzcu8++tAAAAAAAZCBznPffefHU6CdE6Cbu3d4QVxeEFcXhBXF5A063dzd4Q0Ju7d3hBXF4QVxeEFcXgadSwCQD333yvnp79777sAAAAAADkmdSABmc9994Q+Cbu3d4QVxeEFcXhBXHoNOibu7d6IaEVr1A/bA50Q3du2iUJQlCUJQlCUJQlCfB73t9eEoShKEoShKEoShKE3d7tolAXxgGQlCUJQlTJ11MnXUyamSZkz773zfr79b+AAAAAAA7kzqZJM677Ovpk66iUJQlCUJQlCUJQmwO73bolCUJQlCUvzmCUJQlCe97vrRKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlCUu7vdveQyEoShKEoShKEoShPe931olCUJQlCUJQlCUJQmwO73bolCUJQ+shKEoShKEoT3vd9aJQlCUJQlCUJQlCUJu73bRKEoShKEoShKH2YJQnve760ShKEoShKEoShKEoTneVLBZFotEmwRhZJNqmFqnBZLjFd/z8LrC0Xaf4/933oLCMLsLlQ5qnBGFkDguBcC0IxLRVgsKtUMF/c+l/C7f2c588+efz+5+AAAAAAAAAAAAAAAAAAAAAAAAAAW2220AAAAAAttttoABbbbbQAC2222gAFttttAALbbbaAAW2220AW28nvXvq20AAAAAAttttoAAAAADJh1JgBQAAAAAAAAAAAAAD2yTOpBYWF9L6XpfS7C8F6LCPheF2F6I+C+lwuhHXnXXzz220AAAFttttADJJwU4OHh1LEtiW0LapWmhtRTYFtJVbUNkhsIzbEbNhNtgm0psqbNoqbBbIWykbEtoWylsqDYFEM0KjbZUm1bCa2stYjVgZqswKaUlkgmgFoogkCSIhiCIpBYqYjd+fnuksERLRWKV1k2TZNk2TZNk2TQlCYlNMgwEFMSkQUFFRCrQRBR72A+31wSk9GQlCUJQlCUJQlCe97vrRKEoShKEoShKEoShN3e79gPidYmybJtPdzJsmybJ77737tEoShKEoShKEoShKE3d7tolCUJQlCUJQlCUJQen3sB9vrglCUJQlCUJQlCUJQm7vdtEoShKEoShKEoShKE3d7tolCUJQejIShKEoShKE973fWiUJQlE2TZNk2TZNk6pE/fvfe/Pf6/n4AAABbUmAcAHxfi/F0inpYLzzn883qbJsmhKEoShKfmDIShPe9wHvrBKEoUoShKEoShKEoTd3u2iUJQlCUJQlCUJQlCbu936Z4Sn4nIShKEoShKEpNk99979954myd84mybJsmyUJQlCe93vrRKEoShKEo+JMhKEoShPe9wHvrBKEoShKEoShKEoShN3e7aJQlCUJQlCUJQlCUeg972+tEoShKEoShKEoShKE3d7tqbJsmybJsmybJsmydMzMzuZOskkyvfdb9fvwAAAC2222mTAD2TPMmeeV9MnXUyddTJ1fMOQlCUJQlCUJ73uA+3BKEoShKEoShKEoShITd3dVA9IO7u+0ShKEoShKEoShKEoTd3d0ShKEoShKEoShKEoTd3Ud0S9i5CUJQlCUJQlCUJ73uA9hKEoShKEoShKBKE9u70TSFaAo9DkJQlCUJu73olCUJQlCUJQlCUJQne98bolCUTZNk2TZNk2jecHf9P5/P3759/fz7+AAAAW2220ANyZwu++/z+JsmybJsmybJsmxKE73veg/YDmCUJQlCUJQlCUJQlCbu920ShKRL5xchShKEoShKE973fWilCUJQlCUJQlCUJQpu73bRKEoShKEoUoC9iGQlCe97vrRShKEoShKEoShKEoTd3u6DkJQlCUJQlCUJQlCUJu73bQL2AZCUJQlCUJQlCUJ73u+tEoShKEoShKEoShKE3d7tolCUJQlL7MGddTJ11MnXUyddTJrJM++t1y/vvwAAAC2222mTADkmeZM88OvpkoShKEoShKEoShKE3d7ug5CUJQlCUJQlCUJS2rj0ft4Bu7m9ELbl6IW3L0QtuVCcIK49ELbl6IW3L0Q5Anvu7Xf337333330AABbbbbQASZ55546mFty/BOAK49ELbl6IW3L0QtuXohbcqE5DoJ1BXHohbcvRC25eiHITM995zW+fffAAAALbbbUmAC/SYkxJnsmeyZ777971Mmta81ZM7mCuPRC25eiFty9BzoluZeuQnXR0BbmVCc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COhaFWiwvgsL4LpxU7qe+fOwj4L0RWFkSYWpLVDC1TVCMLVMLRUYWCLnf71vfOe3nwAAAAAAAAAAttttoAAAAABbbbbQAC2222gAFttttAALbbbaAAW2220AAtt6ky22igB7L1bbbQAAAAAC2222gAAAAD+AB8AAAAAAAAAAAAAAAA9kw7AAAAAAAAAAAAAAdReCxfS+i6FhYrC+l8Lgj8XwuF8LhcI4VYWCwsLCwvheF4XhJ8LwsXBeF9L6X7rhaqfBYWCMJm5M6ySTPe/dae2gAAAAAAB1Jn6Z/HUnXXXXXU6k666mTrqTqKCGYqEqIaCJImlQmWJB7iKrzvz89E8gpFQCqiVIrWRsJayGVhTNbZmVoGBiCguCYiZCe97faDgiuPRC25eiFty9ELbl6IW3KhOEN735vqZNa15rqZNa15rqZHkmHvuue/vwAAAAAAAJMSYkz4H6A/Hx8fHxGQHe853wOJyqqq3c5tlVVVVAx3vOdhO97zsJ3vedhO97zqE4QVx6IW3L1JbcvN83bu+ffe++++++++gAAAAAeyZ554a1rWvgnBXH4Iqtttttttt0IquhF3veta1rkkz9mZOpJnWSZ99bbfvvwAAAAAAA777Na1rX6TN72voRVdCKrbbbbahFV0IqvZve97fszJufW+W3998AAAAAAAPJM888Na1rX6TN73vaTN73vdttttttt0IqtttttqAQ/SQ6kJMzcmdTMzMkzvJMLu2/vvwAAAAAB1JgD9kkknnnnzWta0hFVttttttttttQiq222Ett1+zMnJMkzOskzrUmW26t/fvwAAAAAAFtkz2TPpMsmeyZ3CE+777+4W8tQiq2235VUIqttt5Jm973vWta5rWtakzX6SZf3nvvt/fvgAAAALbbbaW+yYyZ541rWta/Qiq223xVUIqttt0ICq223Xe973Jn7MycR3bb+/fAAAAAW2220t9kx541yb3ve/0mb3ve9a1rV2qoRVbbboRVdVVCKroE7879999+++AAAAAttttoe/AShLb99bbdCKrbbbbbbbbbahFVttttt4ATACdAToCWSHAJwWFhaphb6LQuBYLr3z4LsXwRov4EwtUNUTRaIwsEZDlQwuFyocFypWFhGFkqwnAsFkrC4C6FwXQuspVwWlSMLRJhHCXOBchbgsFqqcqcBcKMi2C0WJZKuCTgtFqmC4LSLCwjgsLgXCk4LRaqORdi5F7nx2XnvO/PPf5fgAFttttAAAAAALbbbaAAW2220AAttttoABbbbbQAC2222gAFttttAAPZerbbaAAAAAAW2220AAAAAAAAAAAAAfwAPgAAAAAAAAAAAAAAAAAABuTA0AALbbbaAAAAAAbkz2STPcouy0UuBYuCMX4R8F6LsLhfepL5F4KuEsVHfjzd99AAAAALbUBv3333wJoS2+ttt/BFVtttttttttttttttQmC8qgE2EoTzzzy9+ffe++++gAFttttLbbbaBJlkz6SdhPJ3339QltuZnlttvYRVdVVCLve9a1rWta1rkmb3ve/r9777779fgLbbbaW2220ttttoOSZ554fSZve971rWtIqqEVXQiq2222222222nvu7u8+++AttttpbbbbQAAWSZme34IqtttttttttttttttqEd73vWta177znOc+++AttttoAAAAPJM8yZ54a1rWta1rX0kze973uSYqqEVW22oRVbbbbbe+93d377730LbUBsAAAAO++zVzLbb8EttzG222223hby222oRXe+5M995znPvvrbS2222gAAAASZZM+kyyZznOfa1rWta1rWta1rWta10E+Fa9hFVQiq222228++3d3737y2lttttAAAAB332a1bbbbbbbbb8EVW2222222221DJP4kkmdSTOpJM6kmdSTLbfff379bb+AAAAAACyZZMsmfSEDd37u22222222238EVW222223Wta1rWtyZJzMydSTPvrbb99+AAAAAAAHffZ9JM3ve97kmbVUI21ttQltuNttttttttqEwqXYsLuFr+VNRdfPoukXQtEdiML0tVUnYuhHpfBcFdhcLALhWiNFktguCxRfS+l9L4XT+F/DEmefAAAC2222gDqTAW+222gAFttttAALbbbaAAW2220ABkxbbbbQAD2Xq222gAAAAAFttttAWTHQAyYAAAAAAAAAAAAAAAALJjoAP4AHwAAAAAAAAAAAAPZMOwBbbbbQAAAAAC2222gAFttttA5Jg8DyTPJM8kzyTEmJJnsl+L8XC/F4XheF0XheF4XRcpF+L8X4vxfi/F8F2XgF4WVDwXC6C6L6X0vC8I6L4L6Xz4LwI1LKL8LCOf1mSZkz6Pe+cW/fAAAAAAAD7MyTPOp5599qTMmZ/E6zJOc5zmrbbbbbbUJgvFttv4VW22+qr2TOSZqTOnvuvfb+/AAAAAAABJlkz6TPZM5znPta1rWta1rWtattt0Ju7u6hFVttpbbbba+bu7vn3wAAAAAAA7yZznvtttttttt+CKrbbbbbbbbbbbrWt5kmSSakz333z333774AAAAAAAakz6SZuTN7399yTN73vfoRVUVW225mZ2qttt7CKrl6tu5MkySfpJnUzMzMn4B7+/AAAAAAADkmWTLJm97b71rltttttvVty22222/vwTroJu7u7oTrqTOc5znOSZ11JnOc5zckmckmWffA+v4AAAAAAAckz9JJJbfvkJyEVx6P2hOugm7rvBCLi22222221CKrbbbbbwJ77u3d/ffvffQAAAAAAEmWTOwJ8ED8BO+++/1tttttttttttttt1+kz2TOc5zmta1rWta17Jmfv3vvvvv778AAAAAAtttv6SZ+kmdSSZq37622oRVbbbbbbbbbbbbbuhN3nObkze973+1Jh757777+/AAAALbbbaW2236SZrWtG973ve973ve973vfAm7u7qqqqqqqquhN3d3evvO++++e+/fAAAALbbbaW223UJ6E+Akm7u/fKqqqqq6E3d3dVVVVVVVV0Ju7u7+AnYEykJ1OkthZhZqhrC0wjMlmS39fuIuuC/gunUWapmF+FotCwj8VisRYX7cqakdBdFwXAJgsAwWBYWqapqphdC1TgsVgWJYL+iuAuBYRgsLCwWkpotKiwsFhaLoWFLgXAuIvnH9dc1rlUAAttttoABbbbbQAC2222gAFttttAAPZerbbaAAAAAAW2220AAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAPgAAAAAAW2220AAAAAAttttoABbbbbQAC2222gAFttttAAPJM9kkzkXguC+C+C6LC4L8LBfC8L8F+FgvC0XBYFhZJM/jJM898b9X74AAABbbbbQA+kmbkzqSZuTNyZ3mZP46meedznPn5+NaRaVFpVHpCZTVFVRNMFK0qlAglfHx8b8fG7u7u7u7u6sIugTd3d1VbbbbbUVXoJ4rXn79+AAAAW2oDYA9CehPQngT4J55554hFV8VVVVVVVVVV0Ju7u6qqqroBPe+++++33wAC2222lttttAD6ST8BFX9+VV7Cbu7uqqqqqqqq6E3d3dVVVVzzdzd39+/e+eeeeeeeee++eeW2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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
