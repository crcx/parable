#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        tos = stack_value_for(i)
        type = stack_type_for(i)
        if type == TYPE_NUMBER:
            r.append(format_item('#', tos))
        elif type == TYPE_BYTECODE:
            r.append(format_item('`', tos))
        elif type == TYPE_CHARACTER:
            r.append(format_item('$', chr(tos)))
        elif type == TYPE_STRING:
            r.append(format_item('\'', slice_to_string(tos) + '\''))
        elif type == TYPE_POINTER:
            r.append(format_item('&', tos))
        elif type == TYPE_FUNCALL:
            r.append(format_item('CALL &', tos))
        elif type == TYPE_REMARK:
            r.append(format_item('"', slice_to_string(tos) + '"'))
        elif type == TYPE_FLAG:
            if tos == -1:
                r.append(format_item("", "true"))
            elif tos == 0:
                r.append(format_item("", "false"))
            else:
                r.append(format_item("", "malformed flag"))
        else:
            r.append(format_item("", "unmatched type on the stack"))
        sys.stdout.write("\n")
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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k76SSenkkn2vPPvp3tTzXnmvJIkknvvvvsnIAABNxJJPc75ry7u8zvAAANZn4yST3333KzPsAAA7rP2MzJve5LgAAH2nzvvs3Ukr9+/ScgAAE3O7kku/ffak+gAAHnkbk3ySXzjzHmvOOPPOcz9q83AAAH7P2ZvMzLv67u8zuAAAZvM37JJznvvsnegAAd1qfpN+yS7qqqT6DbbbbbbbZri5kSA8c3GVTnLqozg+59zm/d94MgOmASdlSSQCgBGADpkByTMlSa16vvewomZk00ABBNkkmYeyszMyZ73ve3ZoaEzCSTQ8SSfSSTom0lbAOfAXfV3vSfQAADmtan6Tfsku61VVJ9AVRtWVububu73398j333u/g5LXkUZRhmZYTmG9c5m7u99/di9997v3m45itlZRRubub+3d887/fv278bxxshcyyi23d5mZd1VVmfTTzWNgeZvM3mZn67qqzPoAABN97uSS7qqqT6AAAZn7uZ+/ZmXf3fNeXd5ksAADmnmfpN5mZ3nKq7zO4AABd7/Zv337zXvQ72zgCQBwxAE9JUkkJMikkhJCgBGADpkByTMlSa17749709r2gd973ve94kB4JDzc3J9P00NkinczP2bJJJJ9JJO6BD9wC7+++D6AAAeTfe7kku/faqT6AAATcm/pJd+++yfQAADup+k37JLvO+a8u7zJYAAHM/SbzMz7nKqszuAAAZvv7v7JJy/ffZPugAATfe7kku/ffZPoAAB5N97uSS7qqqT6AAATcm5JLuqqpPoAABNybkku875rznNc5mTgAAGezz9nvvut1v1JJ79O97W+973vZ6e9j3ve9J2VJJO+Zq7FAYEYEDpkByTMlSa1776lqxV37QfTHZV0jCbwD80zXu8be7oHpWZxvM7mZPZazIpj97vvSrvlN6ZTMk9kCuTLVae173eSZlZ3fMkznLu7zO4AABm5NySXdVVSfQAADybk3JJd1VVJ9AAAJuTckl3VVUn0AAAm5NySXdVWqk+gAAFazPczeb5vff79/bvu1VW5GYFBQUFHDcOt3m77buY0/evdLVNe42+crlUq5vA4G7d977mfamea83ts01tppiTcmZd1XuZ9GAAB5m5NyZl3Ve5n0NHgBrn37jGM4xjOc1nma9j7bnvTwZMA6YgCKkkkkinBoIwAdMgODUik/fuHe/gD49+aYB4F6SAAFh8BJJJmZsJ6JOmnKPwCWlhkmZnczPxITve9kkklySbkku6qvPPKk+gAAEa3JuSRd595rznOZksAADNyb73JnOXdZncAAAms/SbkuXdV7J9AAAPJvvd97Jd1Xsn0AAAm+933sl3VVrzykn0AAd3sRrf6bk7F3n3mvOc5mSwAAM3Jvvcl5y7rM7gAAE1n7JuS5d1Xsn0AAA8m+933sl3Ve950ACqqqov9+xtt1TTR+5P3aacCHZJySSSX0xoBFSSSckyoARgA6ZAcGijWvV9N997733qr3ve9mveB0y8AngPeJJJXfSeE9Ye9i6uSfp377777776dkm5JLuqrzzyu86AAB1rfe773vbvPvNec5fJ+7YAAE3Jvt/du5d1PoAAB3U/Sb72+3dV7k+gAAHk33u+9ku6r2T6AAATfe772S7qq888qT6AAARrcm5JLvPvNec5efZOAAAZvM3J9LXWX7mdwAACaz9mbyXLuq9k+5VRtWUlLQbnOZzm733+/f27ujzMwzlcquKnzi5znK79+mcnyv93t9t7d/rNzYAH2vZ973venvY8AipJJJIoARgA6ZAcGijWtaZHSqyx173veCGAfgAACZKTckgAcadyafcinpNANnE3JJJPQJJJJJAOAF33vW3+5z03RcyyrMwqrs3Drdzd83vv71Hzzvfq75rjYBmfszeZ3LuqlZ9gAAHdT9JuS+/c5d13O/AAAeTfe772S7qvZPoAaAJvvd97Jd1VeeeVJ9AAAI1uTckl3n3mvOcvPsnAAAM3mbk+l3VZWZ3AAAJrP2ZvMuXdV7J9AAAPJvvd97Jd1+/uc95VVVVVV396fj+5/KgcIQR9wUN4SXM6yobqm6pqEutQJAZVzXvfZDuK9X3YkgIPQCQEdAkHaVipNc19rUlfYI1735dKGYgSArNjIJw5+7Pefs4EiRIDwkAxIByAgIWVI487uCaglCQFeq7eO8VPhIB7UCNuE3kuocS96ue69bC51t1XmI9MFkRb33pVMG16M2gASJYkA0IDjq+BAHTB9kKmhAG5VY837ez3j4AHOc5znAU5v7G5NzPrq7qqxeBXdjcOBAgPnc5ue++8khIXNJAS0hGspVjFDMmVihiqxENapNSpaYgtMgsLMjMVSC0ohBKTI0FNDECU1EsZSYoYrM5zm+c59zsRzOc5wJV1VWwAS6u6zVXiSSTsXd3VUxUMKMSMoMwoZZEZiKZkQyySwsJLFlUMznOcCXd1VKwAS6q7tgAjA4NJS8YvAB9Ku6qrYH2wVXMXd1V1eAYyZUMUMkjP8/fv3f7xznOyu6r7EkzPA6YBGLusYqqq6rFau83V3dZwihEu7uqpgKCVV0xdXd1WKwIwC7qrvF1dVWKq6q6vVYus4HTMRNNJSpJck/TE01KzPszM+1NJtyAfB73sVdKuqq7rmBo7PrqqupiSZkB0wARQAKAEYAOmQDpkJJJPVV1VUPY973ve0QcAAAwARQAKAEYJJJyTMA4NAbD76owPthrTmBp3o4MgOmACJJJJIoN7DbmBJJyTMgODQGw+B8DYA973vez73veOmACKSSSSSgBGA73fe573ocGgNh96lVdVVex73vve972w0AMySSOmACKABQAjAkk5JmQHBoDYfe973vfe973tgAAAYAFSSSSCgBGADpkBwaEqV9JJ96quqqj3vfe8B2ST9JJ73ru7kmZmZmDykm0lTTSSxwDfmIQEzCZ9CSEEfOav77777uOj3p9PLkn7J4wBAHQz9mdQ1VST6dAAAIs4szMzLySSSSS167u7k9kgAAAfiqu7vuKuruqvh8+4PACUxeO5xi6zgpUMsCDKhymb2woIgiOgCkscCgMMaMwsz7DoIIujJGczMcyafow6IqpypcsaMSmjKr7ethAb+Bd3VVzl85zmt84OASRL3ve973pJCgAAtXd3dksSqkk2lde9773ve97RJNySQAE+73uuXX2O46539999UPqhgWSmVV9mtfc5999199J9AAO973ve9AA9VKvFVdVVYq6xd3VVWKu6usYAPBoKOKu5JJPRh72Pe97wigfA2AG0mpJJFMXVlXd2q6xd3d3gBirvnOc473ibxJpJCbTbQkmlwALDjTKk973u7sa0Lu7u7tQkBwCB93dxYJAYJFViruqrFXdVWLxWLu6qsjewDNAMdd73vO96ADF3V3Vhe+e3VXVVWM4zvfve697NXYABznOc5wAAHe973vegABnOTANh9jk9dVaSRw+606A8HGn5KpmZmXeYcaTS/NP7Hva973p7lA2HzAMmbq0Gw0H11ZkAAAJJJJIeuqur3xqquqqvZ97fPe94AAABgCiAAUASSTt5vF3V1UrFVVmSjNGtBYiZiVGVgwK8YkCJVVdUwAS6qruqY6ZByjkHsGE+y+3UeyYyHCOQL4h3nfn350ver3777vX7wH8V5S3d5vy3d/LaWmBQHvCKkkkijNMBGAwAdMgODRRrXvu79z3veqvvJIkknhXve94IAABgBJJfq94zMAAADCZmZm67mtRqJmZvMyXdVWvPKSToAADx3u+9+79zmd81599yd7OAAAZvM3J9Luq9zM7gAAE1uTclS7qve9+6AAB5mt97vvZLuq9k+gAAD77f33e3dV73v3QAAOtb73fe327z7zXnOXJLAAA5n6TcmZd1Vea8pmfYAABNybk7F3VVJ9AAAPJvvd97Jd1Xsn0AABU5iSOH4LAEAcDp+A76SvSSRTv6ZK+1UnJN1JlTN1YNkYCMHTegvuzu6e47OqqlcMOjGhTfvH3V2Ug3ptkk7LXMwbcEkijpn0RX4sAPYHEEhvncStTnsXVmfEkmJPDOKsn1XbdCp7Lk3Jcu6r2T6AAATfe772S7zvmvOcvMlgAOba3vWjWs3JuTMu+3d+a8tmdzWjWjTWvmmmMzeZMXdVWZ9GAAB5m5NyZl++/szkAAA+6k/VJcv339JyAAANJ9Pe9kv7Naea8tbz9X2ZLAAAvJypMy7+u7815bM7gAAGZnsnYu6qpPoAAB5N97vvZL99/ScgAaNKxGtV3HNX2tXmsVWfvvb933EngyA6YAIqSSSSKAEYAOmQklyT9IpU/cF98gJ9mZn2Y2zCSIOBz4bD7wCSVVySfp4D03JNSTw73vfvvsnNakn7cly7qvZJroAA1zXk3r933feycx82+ebea85zerzJ6AAB5zX2vM9n7cmZd/Xd615bM7gAAGbzNydi/ffZOQAADyb+m+9ku/Kr2T6AAAd1P0m5Ll3VeyfQAACb73W+9kzjvmvLXWZ2gAAJn7b77O5lVWteUzPsAAA7n7EnY5777JyAAAeTf033sl3qq37znvKqqqqqvvPefwoHvuigedfxkLSW3mZ+nd7eTNk1B+ADEkmatm7W7u74igChTg0EYAOmQHBoo1rXfjU73veyex58cD3ve+ur94bASd73vHepI8Ae8BJPe9703Jcu6r2T6AAAcn7v7feyfcY815d1nud2AABrN9zfe5LyqrWvKZn2AAAZuZuTuqrzzz33ck+gDWVZQU/u83+5/Zzm/37+/vd3hvLGCMiMxPN7bDTSaz9M3mXVe+5mTuhp5rGzNybkyuefPNeVW/MYyT8AABm/033uSsqq815TM+wAACZ+3m5OxXvvsnIAAB5N/Pvu9qVXsn0AAYxjGGNvp+q7qqxWdZ+/ffft/nf34GgODIDpgAhkB0oARgA6ZKNa/ffe95J3sq7qqk9PBJAB6vAk73veO9SRJJFXY0973ve87feyeya3Ny5de/pPoAABNzu+9k+vL/ea8us/Z3YAAGb6++nalVWteUk+gAAGaz9n7cnYv332TkAAA1ek/fTfZK/a3JfQAAOXp337s/Xcq3nnl1r2T6aPAAm+97+7J9znM9815WZPQAAJrP0k/Vku85XmvKZncAAA9z9J39lxdfpPvoDm9gA1+T9779+kl1uTkAAA986xn2/uuv3hUf1QyQn2BU8wTohBNlV9PcVH7rEU2FADZUDYUDZQ+IaEiZCBBTZRU2A6maYLcUADf2AiLsoobKgbKo77giKSqbvu7ubu7999599gJJ2VJIAoARgkknJMxSfv37330n2fe3M4ltVTkmnE3u7i3QwtgHyABAAEn5JZmZ4zDMwG23JJJalQAAwpJtqTiSbcpgAfiy+8DxVVQAB3Unvfd/p3lzP3mvPczvoAAF533ubz2Vn37M+wAADus/dzfudqbk5AAAOCfvpuX2p7+k5AAAJv6d/d7VV7Kk+gAAK6fgPwd73Y07nt0uvcpc4lVJVSpri3m7n7Ll3dZWZ3rTTRgBm8zP2ZrLu6qsz6AAAeTck/TtVXsqT6AAqqnf7OvsP6UlQI/EOENNMbiGMpUwW/u/4QB/Z/f27v9u84iI7uLSa32/mm1v242mvmknu7u5u7zZJJPSUEk7Kkk6Zq7CgBGCSSckzMzkK/fTiCu/fvybmdxZnG0lefkYSS8KapFNOcb10ikB+KaYaNv9KlxSSSZ713fUn7tXZmSSSTdTDp9plh67qrszda1512+97+72qr2VJ9AAAJuSfpJd5x3zXnOczJYAAHM/ZmfsvM5zl1WZ3AAAM3JP3e1VSqk+gAAGrT9JP0lVX1VJ9AAAJuSfpJd3VVJ9AAAJuSfpJd3nfNec5zMlgAAcz9mZ+y8znOXVZncAAAzck/SS7uqqT6AAAeTck/SS9XdVUn0AAA81rz88z5Z+7zjXqfU2kqS97m+3Z9tJsk36ST9BHve933vZ8FHTABFAAoARgA6ZSZa00OOzvq38U4e99sA+kk7Mz8YszMJmEnEnJ4zLzMwN3N3f27u7JJOymnmc2SSfoF3fe9DCqqqpVQBNyT9JLv7mb815znMyWAABzP2Zn7LzOc5dVmdwAADNyT9JLu6qpPoAAB5NyT9JLu6qpPoAABNyT9JLu6qpPoAABNyT9JLu875rznOZksAADmfszP2Xmc5y6rM7gAAMST9JLu6qpPt0zLKJzEcywo3N3et3e++/379u+7bRNcrlVxNpLL/Tb39e7m6AB+ACZ6cnJIHTABFKACgBGADplJlrvxok8Zou7k8dMNeDdIeOjSSSTjvfSSeAAFbD6SST9JLu6qpPoAABNyT9JLu875rznOZksAADmfszP2Xmc5y6rM7gAAGbkn6SXVqqpPoAAB5NyT9JLu6qpPoAABNyT9JLu6qpPoAABNyT9JLu813zXnOfuZk4AABWfszP2Xmc5y6rM7gAAGbkn6SXd1VSfQAADybkn6SXd1VSfQAADXrrzzzzWptWMfYxicq7vfM553VXXt57z074DQFcGQHTABFAAoPe973nse94HTKTLWihJJ66qiTwlGbrw+Yqqq2GD2hT4kkk+nU+8HhJabkn6SpJJJMAA/AXd970MKqqqqoAJuSfpJd3nfNec5zMlgAAcz9mZ+y8znOXVZncAAAzck/SS7uqqT6AAAeTck/SS7uqqT6AAATck/SS7uqqT6AGjTTU3JP0ku7zvmvOc5mVAAAZvMz9MzOc5dVmdwAADNyT9JLu6qpPoAAB5NyT9JLu6qpPoAAqoO7zpAQ4CgSKyK8zsoUDFD3pJ+3mtKHbSh22I5tQ9z8odJU82A0oea1a1m9Nbata5GSzJx5cKiCEkBrjcka2Mkixjy6kqaiWr8ZeFeg2nqwSAaBBcoQEe+PvsqQ7d+iglo+tv53uej3ZUx0tNNKNAxMbTZO+hMJQAiQAG8vfs+++5LmtFJIp4qjMikqsiIwAmjJKmgrEqMqGmlmc51znfOc3JK5U9iR5qAaqGb5zrm/Oc54+5UNVWKRlQzXvOuc5zn1EnkDPvt/fZ9999IXlZgWSSuZx9DIrV1eA2G7q7pd1VjfM8G+KI8lDIkMRZckk8abqGVDdJkznOueZznOKqjlntQzXOdfc5znIj8wKltiqpeqHx+2H9IAOc/v3P3Oe87/RMUFApKIBKS4WlTBGVLShrTFmqhms/z9+7/ec5zYjtyalWYQ0k/GbSBSQJIBhD7q6c7uw5JIBpttsHKslihyoZnvOua5znPJVOsUOKmsr73r7O/vvvlQ7SYqZwwVGCrmYQABKiyqMZFAlEGLWVNGLOc645znPvFY5SzAkxiVYANVDJrLMRXjLRtQd9dSMwVQlESKBPsqB30otaZzrznz7nOFXFDMZkke1DEjWc51z7mc5yqjyMs+kMkWrm+dc9JydbTTaxtpKm21OSfS5J+1QVAHT3vKuqq63gPkku7q7+kk1AcGQ6Z6YAIoO1d1VGQoS6q6YCMAA0E3UkiO5fYfB9NMw4QAAGQHTABFAAokkk7MQB0yCbkmsySG3SOYyPgbDQHBkB0wARQaA5QkknZiQDpkDck1JJGw+AAGgODIDpgAgAFB3vedx3vQdMgODQGw+B8DYaA4MgOqkkkkigAUAIwAdMgm5Jr1Xd3cYPe373vfAAAAMgDEkkkRQAKAEYAOmRKlHBo6Nh8D6Se971nvESaSRU7JP0k4mU0mkpONtpK6f5U6o53oGB3+oz9lZmZ4Jk+7JJvVYkAGMOMAACJoCZeZzxmcwk/STxnkrGN73vbgAG/vVVXVUn3Jyanp5znOc5znx5ipkyHWNZMYJzKlrWbxVHx0gATN1eZJJO9AHCfpEqTcbeYSSZIAIAAD3ve973glJNJLvlxtNJHwdPASKqzMzMz2OpJJBd3dVRO973l33F1jHUBLuquqYCSdu7u93i6u6mJPoEuqXgD7ve673vSWwAb9V1dVSquqqsXV1VVis4U0CewA0qMaruO971JmrsAKKACSQDfe96kzdXJmhIzkCq5zkS973oLM4m02kJJN1SSTlHegApJ727u7vd093d5CELnnd3hLyS9okJK2N4vGKxWMStVd96k3y7u6quoBwaCZuquq73ve76gABWqm/p6qq6qu677s773tfA4NVVXVAVu6vmak+kk7AAB3ve97q7q6rvQ4MXVXVAH0pCCWgQSgQbtzmRnd73ued3T3wJAa22wD4AEsXve/e9735NJpTsklyT8nIHAAAAboPgbD4Kkk+ackn2ZmZmZkg2k0wAOgH0kkAAAMgjHQNh9zY+fbZurMypJJWFVd3WM3d3WLu8HwNKqlznOc85znZwqTKhwyUxaBSpqmkmvq5xpydklzFaqKQ6H7+r2dvfpPtufv0DQHBloCdYAwyigQFACMAHTKTLWtAXV8H6rv3gIwxfh9Rlg8CVQRi7s73vfSSeAAAPe973te97nObqpJ1o0/jtre9PNbYzM/ZmXd1VZk7ppmmttgG8/ZmfszLu6qsz7AAAI83JP0l5rPvvva815znM9pk2AABm8zP2ZlznLu8zuAAAZvJP0ku7qqk+gAAHk3JP0ku7qqk+gAAE3JP0ku7qqk+gAAE3JP0ku7zvmvOc5nuTYAAHPM/ZmdG7vvnnnffe79tVVVVVUQAHkqFTFaxT779rOvez73p47oDgyBh0wE96vee973vBkrN1YNiMAHTKTLWkYyxdX8k83niTwR7GGLqzg1HvaurGqBGCXdq4Ne15V37Hve994ALAAOAABgH5AXd970MKqqqqAB5NyT9qSXd1VSfQAACbkn7Uku7qqk+gAAE3JP2pJd3nfNec5zMlgAAZvMySVVZd3mdwAABrGfsySXVVVSd6AABNySSVVVVSfQAADybkkkqqqqk+gAAE3JJJVVVVJ9AAAPJvUkklVWd815znP2syfgFVVVVVVUl+zvP293fByQADPwAS5JySB0wB8Q2AKD3ve957HveB0yGte+7v2/e371Xfp1kkkkOsaxJJeZwI25JJJmZmX6veLzOZAAAA0tEk9kkySSftSTOc5d3mdwAAHd5+/T2SS7qqrWpPuvAAGokkkqqqqOc9N0oyiMkczMIi/FvW7vW77333+/bvu6jmZhEmWcN63d63fO++/37d95VVVAE33vf3eyq+xrzy7zO0AABM/bk/d7lVlVmfYAABm8k/d7lV9Vck7YAAE3Xe173s5zlVWvPJPugAATck/SS7uqqT6AAAxWZ4rG59vme++7PTwGgODIDpgDRBwAoARgA6ZG3332tDrc9YTFXc8STySSSPA7JJJJ71nve8ZkkkkgAAACAD8Bd3VVJ9AAAJuSfeyfqr32TkAAA7rU/b7393su7zvmvOczJQAAEhrPd5n6Tmc1zl3mdwAAD7Ws/b7393uXq7+u5O0AAB95qT332T2Tl6u6qT7oAAHs/d73925Ve+ycgAAGvtJ+kn6T69eeXdVJ9AAAJvve/u9l3dVUn0NAABNyT9JLu875rznOZksAADX36e89/Uffv33d727PBAAPwAS5JySSSekqSHq97z3q973gKAEYAOmQ1rWihJ4ySVXgnpJJJD3ve973vemYs96z3vemZJJ5NycgAGBwDd3d39u7d3VVmfYAABNzUn6SVXvvsnIAAB5NyT9JKr332TkAAA7qftyfpJVe++ycgAAE3JP0kqvffZOQBm2t70aebzeZn7Myq999zORppowAzeZn7Myq73zXl3eZ2w0ABm8zP0ku7y7vM7gAAGbzMr2Sc5yqqT7oAAE3JP0ku7qqk+gAAGr1P0k9przySTXve9733ve97XemgqkdyZAdMCSTskgJKkkkhGA1rWgduYkkklUBJJJJrVQ8d6DwxJKqSTsAABzXnne9/TUkk/SS7uqqT6AAATck/SS7uqqT6AAATck/ST7nN65efvNec5n7WTYAAGrz9mZ+zM+5zl3eZ3AAAM3JK9knOcqqk+6AABep+kn6Sqr32TkAAA87vvez2S7u6qT6AAATcknsl3d1Un0AAA81NySezka81x5xrXOZ+815zmfseQAABm8zM9kznOcu8zuAAAXXvGt/suTm6vv331/ffezveyXJPa973mXBk6aOmHEknZUk6Zq7JKkkkhGA1rXr9vF+97n1Xfj6bmJJVeJMWZSbzMzMxTJAA+aYACSQDbgSSQCT6SSSSSSXJPfAfAfBd3fehgAAB5NySeyXd61dVJ9AAAJuST2S7vWrqpPoAABNySeyXd6uqk+gAAHNZnuZWe5l3XvuZzAAAO6n6T2eyX3l5Neec5nO0AAB5m5Mz2S7rKrM+wavetmt4ZmYbc5/bv7d88/f39u+bxHMsJMsrc5zf21mc5XvuZz4AADNa1rWfpMz3M+5zerrdNZn2AAATXfpt9nP3t5mZne96ffve82GgODINHTDiSTsqSNgUJJCMBrWtHARgklUAB73nse973vAFRgSeBs970kk673ve9736SSSpUnOV77Jz4AACT9J+nsl3XvsnIBo8aa1N97J7Jd177JyNHga001p4d1P0ns9ku699k5AAAJvvZPZLu7zvmvOczJQAAFvGfszM9zLu7qsz7AAAJuST2S7u6qT6AAAeTcknsl3d1Un0AAAm5JPZLu7qpPoAABNySeybu7vO+a8++zJQAAVvpWCrZ10u/KgbvnO+XIOeqgZy50qBzmKgfwAHO+lQN3FQN3xVd+u7qq7+/fv2v379+8zwZHXx0xskk7KijISVJJuKM/TDIa1z7FfD6qou7STSiIoQfgD5yckkAAG2BrbSRtLd3d3d3M973veMySSSSSSRypU1tpLM3555rWtsz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Ek26baSppNopABFO9766R5N+3etPaTW7u6He973b3d1Nbu7une97vdhSaiA+A8e9d30ImiSSBd3d5Yfk0SSQLu7voDalAAeLu7voCaJJAou/yurvibV0AmvyaAAsu7u7s0ae02t3d3d27u77u7qaO5+VrVzfu/fJpt420lTXdvfm/lQIJUDZUDn38CcjhuCrnYoGAqO7vSqbCIbAIbXioGA7s3bTabtNppfbv5JpLd3d9un4kknZM1JJPpBsNAcGQHTBrOcBJJypmZmezJJ2SQTaS6BC023wACJO957sq7khtiVO973vUmgOeuruq9itF8ABZd3d93Sk0SfpIHvXd9CJokkCi7u7tt2A2vqAA8Xd3d2AmgAAu7u+gJqIACy8u76bbT2k0acA3b73v27uprZobtbfe9627vYUmuh74Dx713d2ETQAAXd3fQGlKTSSycSbWU1HXNKH7DM37579797f1QyqLmUI991dKrJSZiyoZ5iE8/tAP2CnaVlVWJMov79+f3VI7qGSZUMDFDFRkhmZJKgQEqBAi9bvQCIbIDsKimyHgoEobu/b+7FAkF3+3d33d3QA2pNSSRWzRsNAcGQHTBrOQCeq6AegB7wIwmru5J6ru6qpvvkk9JyXPSSSSVGBOQSaa1JtJU00m2t3j5RPST2X3vft3dSQlpwDdu7u+7omvJE5JAvmLy973UkvG409pNR7vN3d27/Vd8u93dTW7gG7fe9+0G1iogB4u03d3+6AmiXJAu7u+gJraaegBu3i973vNv27iaAAC7u7uzd1NVu6tm7zb73v2iTqpSTaVdXuJcpPepxVejWkgJePPbICDvpZjSQEkVd1SqL8z9m16/M0AWMSAnwIAz/4H+S/n80gbQgBCQFx38fcfzTy3X6FJKUfzBrOv8/0e/M339u0J2ofa1uoYoc4odVDr37fnTVJ2z7ihzFDPFDNKHXahvpQzNyHmdFDHmt73rpQzdQxlDXWrbJH3ettSOe63qRmunkhvahm/VDOlDepD3zXShnnNqG6hlre5TwprVQ6UMxQ01mFD7ihrJVrtnUq6lWuqVrGb6zVQ0oZ2obeSGudd8aiWtatqG25V6x1KeKBbEkRokBlCQHonfVSQljuZLqs2Nz7pp7rrWmdutCOlDeVT2oZVM97kO+qQzbShih26UNdyBGYJAXmTM7spIKY4QIl5YkB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EgIhtttttvbbblES/QZQfPnz58+fv379555555/FB7S0H4GIWg1B33tttbNtu+pB99qqec4qqheku1XXvf7999P37QACST7777y6ukkj0AAAAEkkkkAAASSSSQAAAkk7urqSSH3nnn379++0tKKv6Qn5VTQE0GlVagwSloNBoMVS9eu/7++f39++/fv374iSv6DQHXW222222223Kqn7JE9XqDig0GkJNBqC2KkNBpKLQYRXz58+fv3798+fPn2UVc5ttttttznNtuQheQaBgYGg1BoNUFgaD16/vfv+/v7++/fv375KKuc2222222224KR69eucqv7qqu61re9788AAA83vW973v8QsIrJEyDSqtA0GoLYoo0GpBgaSSQKqqr3ve73ve2SEgGBJJqQJCb3rW22222223FJHVBlIWgwg1BohbKqYG0RWgYGpVMDUFpVLUove9773vec5znSBJAtggJltttttttvboUqXSDUq1KsoMoVlCtEVpCtaBoNBokk0EkmiSTQQgVVVWZmeu7u8AhJL8DELQYA662275zbbbbbbpEDugxVLQaqC9+/fv3+/fv37zzzzz+IXObbbbbbbbbcUFfkhYBqCwMD379+/f79+/fvPPPPPwP1KtSrUHXW222222223VQdUFkGBoMqrQaQGpCSTVVVV73veu7u/BAAXWtaV1rWtAOvMz95rW9b1rW9/vM73ve9qqqqqoAAAAAAAAAAABJJJJAAAAAAJJLqru7ru6uuquru627u7v+63ve/2Z3ve9/v9qr+63ve9+eAAAea3vetb1vnOc53ve9qru9b3ve9a88AAG24qpfqDAwPfv379/v379+8888822AADMzMr9vW9VVewAAA/u973v+73ve/eZz+/3+/3+/f2oAAA/d1ve975znO973v3agAAH93ve98SSTQjAkYva/Oc5nPNa002222229xF53re2m963revfde++973vaqAAAM/fv1VfVQAABn79+qr6qNoRERxzLbbbcIREREN8xdJAhKqrnOfp+AAAAAAAAAAAAAAAkkkijsAAAAAEknLq661rW973+/efffe/VVQHd63rzzzzwAPNkPvvvvszMy7u71rIQVXWta1phBVda1rznOc53ve9qoAAAzMzKqqoADQGZmZVVVAB3zwA5zmZ3ve9qoAAA7vW9c5znO973tVAAAHec5zne972qgAADMzMqqqgAADMzMqqqv5vW9eeAAAefZrWt7urq7rMZwAAAAAAACSSSSAAAAAASSSSQAABJJJJADzzzyVT0lkhdpYJV33zzzzz755VQAAB3et65znOd73vaqAAAO65znOd73vaqAAAMzMyqqqAAAMzMyr777774AAAuc5zlV99998AAAd3reuc5zlXe1UAAAd5znOd73vaqAAAMzMyqqqAAAMzMyqqqAA754OuuvZy7u6u6r13VVVVd3d++7nuzQAAAAAABJJJJAAAAAAJJJJIAAAkkkkgAFXd3d1fffYAA0AAO71vXOc5zve97VQAAB3nOc53ve9qoAAAzMzKqqoAAAzMzKqqoAAAzMzKqqoAAA7vW9c5znO973tVAAAHec5zne97vWta023uI5KEMcy22NjHa0zznOc5rWtIAAMzMyqqqAAAdd3d3VVd3VdXV17dXXnY4kkkkgANurrd3d3d3Uurp0AAAAAAAAAAAAAAJJJJI+uro7APrq66qqurvW9c3rem971vetbzPK9r6qoAAA7vW9c5znO973tVAAAHec5zne972qgAADzM8zKqqoAAAzMzKqqoAD++eAc5zM73ve1UAAAf3et65znOd73vaqAAAO85znO973tVAAAGZmZVVVAAAGZmZVVVAAAHe/vs1zxve9b3rW/uquqq6u6rM5u/bskkkgAAAAAAAAAAAAAAAAAAkkkil5VVVWtb3vevPPKqqqgAADu9b1znOc73ve1UAB3et688888DzXOc5zve97VR3et688888AAOc5md73vaqAAAMzMyqqqG2mwGZmZVVVAAAHd63rnOc53tfffffAAAF333333ve9+++++AAAMzMz777777774AADbqqqs5znOc5y223tERAiIhLjEiZbbetaz4kkvQEkJyENQCQA+++z3Pd73ve9k/AAAAAAAAAABJJJJAAAAAAJJJJIABVXVVdd99gVVAAAHd63rnOc53ve9qoG2222222+cFe9735znOa1rWjYiIgQ2I1ogqQVIKkFSCpBUh99999mZmXd3etYQVIKkFSCpBUgqQVIKkFSH33332ZmZd3d61hBUgqQVntQ3tIKkFSCpBUgqQqq++973vXd3etYQVIKkFSCpBUgqQVIKkFZJPvvvvszMy7u71rCCpBUgqQVIKkFSCs9Nb2kFZCqr773v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AAEkkkkAAAAAAAAAAO7q6AfAAAkkkkgABJJJJAACSSSSAAA6uroAgAAAAACSSSSAAEkkkkAAAKu6AAAAAAAAAAAAAAA+urp1JJJJV3QAAAAAAAAAAAAAAkkkkhLq6dABJJJJAACSSSSAAAAAAAAAfXV0dgcurry6u6S6S8S7S8S8S8S6S4VVXiXiXiXiXiXiXpLiWS9qg9pakL1BxL2Uu0uJcku0vqX1L0l7KXSXqD5F2D3ELUqwqrwGkLn5QeXV11V3dXdX7MQ1oAAAAAAAAAAABJJJJAAAAAAJJJJIAG1VVVVWZ3WZu7u7ujaqqqr6q66/iuquq99999/fv378C7rMzMAC7rMzMAC7rMzMADbq66q665znObu7oLuszMwALuszMwALuszMwALuszMwANurrqrrrzy6uszd3d34AAAAAAAAAAAAPLq6kknIo7AAAAABJJJJAA+urrbq6y6uvbq6975u/bsk0u67zMwEgu6zMzAAu6zMzAAu62ruuc5zm7u6Dbq66q665znObu7oLuszMwALuszMwAKqszMwALuszMwALup3v2e9b7u+79ugAAABJJJJAAAAAAJJJJIAAAkkkkgAAAA7urrzrzwAF3WZmYAF3WZmYAF3WZmYAG3V11V11znOc3d3QXdZmZgAXdZmZgAXdZmZgAXdZmZgSSS7pznOcCSSXdebVXVXdVWfd1V3d3zlHG7ugAAAAkkkkgAAAAAEkkkkAAASSSSQAAAAbV3d7dXXKu65zmbu7JJF1ddVddc5znAkkl3WZmZJJoLuszMwALuszMwALuszMwALuszMwALuszMwANurr933V3XVV3pJDQaqqr73ve9d3d+14kNA6SQ0FVVfv379+/eeeeeft+i1c3IsvfElF0DVVVXd35+/fv36fv34AAAAAAAAAAAAAAAABJJJJAAAAB5554AD91+q7rq766r3333P379+/AAKoFWLNMSSZy7uAVQKoaMYsSSZ3d3AKoFURZpiSTOXdwCqBVDRjFiSTO7u6AKobMzAAu6zMzAAu6zMzAAu6zMzAAu62qu7v9d3d9/v379+/fv34AAAAAAAAAAAAAAAABJJJFHYAAABy6uvbq6/Vd1d1Xvvvu7saDbq66q665znObu7oLuszMwALuszMwALuszMwALuszMwALuszMwANurrqrrrnOc5u7ugu6zMzBJJ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Wrba2y1trVra2ttk2FTatjZtttrTq+vfffff379+/Au6zMzAAu6zMzAAu6zMzAA26uuquuuc5zm7u6C7rMzMAkl3TOszAJJd14zMAkl3XjMwCSbdXXVXXTE5nj66uuGuAAAAkkkkgAACSSSSAAAAAHl1dBOSSSQAAAAAl1dS6utuoVVVnOZmXd3Ye14kNQdJIVVV973veu7tVVmZmABd7dXX7vu+r9999z9+/fvwLuszMwANurrqrrrnOc5u7ugu6zMzAAu6zMzAAu6zMzAAu6zMzKqqregALv7uazzve972qqqAAAAAAASSSSQAAAAACSSSSAAAAAG1d3f6ru76qru75y3Oc5zmc55raERDbbbbbbbbcRa1rb3ve85+oAAAzM/VV999QAABmZ+qr776gAADMzMqqqgAADMzMqqqgAADMzMqqqu71vXngAAHnOc5zve97VQAABmZmVVVQAABmZmVVVQADrrrrrrrzauru673d3dm6AAAAAAAAEkkkUdgAAAAAkkkkgAAAABy6uuXV1+q7u/au69993d3dCAAAMzMyqqqAAAMzMyqqq/u9b154AAB5znOc73ve1UAAAZmZlVVUAAAZmZlVVUADWhmZmVV9998AAAWszMqr7774AAAszMqr7777u9b154AAB5zvvvvve97Wqrm9b154AAB5z3vwc56AJJJJIAAAAABJJJJAAAEkkkkAAAAAAkkkkg93reu61re975znO9793v333wAABZmZVX333wAABZmZVVVAAAGZmZVVVBoAAzMzKqqru9b154AAB5znOc73ve1UAAAZmZlVVUAAAZmZlVVUAAAZmZlVVUAAAZmZlVVV3et688AAA8+7/P55x3ne/z+d7VV99999999AAAAAAJJJJIAAAkkkkgAAAAAEkkkkEurraq7u/1Xd3y6uveufvf7/f7/fvv7QAAB5mZlVffVAAAGZ+/VV99UAAAZmazKqqoAAAzP36qvvqv7vW9eeAAAec5md73vfvu0AAAZmZlVVUAAAZmZlVVUAAAZmZlVVUAAAZmZlVVUAAND9edA+Ku6AAAAAAAAAAAAAEkkkkAJdXToAAAAkkk73t3fYQ7CFQhkIcOc5ne5mXd3eta1rWtAAZmZlVVUAAAZmZlVVUAAAZmZlVVV3et688AAA85znOd73vaqAAAMzMyqqqAAAMzMyqqqAAAMzMyqqqDRppsMzMyqqqAAAMzMyqqqAAALzy79+5ne873vaqAAAAAAAAAAAACSSSKOwAAAAASSSSQbV3d5mZu7u/ffffW9b154AAB5333333ve9+++++AAAMzMz7776qoAAAzMzKqqoAAAzMzKqqoAAAzMzKqqru9b154AAB5znOc73ve1UAAAZmZlVVUAAAZmZlVVUAAAZmZlVVUAAB115ldg+JJJAAAAASSSSQAAAAACSSSSAkkkkgSSSSQAAA5vW9Zre9ZmVX1VQAABmZmVVVQAABmZmVVVQAABmZmVVVXd63rzwABtrzmZne9737tTYAA/ZmZVX1UAAAZmZlVVVnngAAHmZmVVVQAABmszMqr7777u9b154AB/fPA/f333nP7/f7/f7VQAAB7zz1V7z2qqqqqqqAACSSSSAAAAAASSSSQAABJJJJAAAD26uuXV1tXd37777u63QdAAAMzMyqqqAA0bzMzKqqr+b1vXngAAHnOc5yv5VVd3revPAAAPOc5zne972qgAADMzMqqqgAADMzMqqqgAADMzMqqqv5vW9eeAAAec5znK/lVUAAAZmZlVVUAAAc/n3rr1379+ffu58969g5B8QaD2DkHrsHWg9Qevvzc599+7vzql1716g0Gg8lCtQaByDUGg1KrAwMDVVag0quIORC5Bwg5Amg1ImoJyQuVVMDVBzJV3dyquqrpnfWcz2SAAAAAAAAAACSSSSAAEkkkkAAJJJJIAAAAAAAASSSSQSSSSQAAkkkkgAAAAAAAAAAAAAAAAAAkkkkgAAAAAAAAD+AHdGh8AAEkkkkAAJJJJIAASSSSQAAAAAAAAAASSSSQAAkkkkgAAAAAAAAAAAAAAAAAAkkkkgAAAAAAAAAA7oB8AAEkkkkAAJJJJIAASSSSQAAAAAAAAAASSSSQAAkkkkgAAAAAAAAAAAAAAAAAAkkkkgAAAAAAAAAA7oB8AAEkkkkAEkn333ySQAAkkkkgAAAAAAAAAAkkkkgABJJJJAAAAAAAAAAAAAAAAAABJJJJAAAAAAAAAAB3Xl0vpQegfUviXxL4l4l7S9A9JdUH2D3QaD2l2l7kupC6g+JeoPdBeoPkGoLCq5SFyg1A1Bz55vfnn0AAAAAAAAAAAAAAAAAACSSSSAAAEurrMzLlVVQAABmZmVVVVvW9eeAAAec5znOV9999997vW9eeAAAeXvvvvtfX3333wAABmZmfffffffffAAAGZmZ999999998AAAZmZn331VUAAAZmZlVVV/N63rzwAADznOc5X8qqhrQAMzMyqqqAAAJre9Kqqqs3reqq5VVVQAAAAAAAAAAAAAPLq6AEkijsAABLq6l1dfrq69999377d2qgAADMzMqqqgAADMzMqqqv5vW9eeAAAec5znK/lVUAAAZmZlVVUAAAZmZlVVUAAGj9+/fqqqoAAAzMzKqqoAAA/fv36qqqAAAP379+qqqgAAC87+6371zzd3ft0AAAAAAAAAAJJJJIAAAAABJJJJAAAHd1vXmt63o8qqqqAAAMzMyqqqAAAGZn7Kqqru9b154AAB57777773ve1VAAAGZmZVVVAAAGZmZVVVAAAGZmZVVVAAAHOc5zlVVV3et688AAA899999973vaqgAADnOc5yqqqAAAOc5r3nKufffVVVUAAAAAAAAAkkkkgAAAAAEkkkkAAAZdXXlXdeeAgUAAAc5znOVVVQAABznOc5X333333wDQAOXvvvvtV999993et688AAA8999999q++++++AAAOc5znPvu6qqgAADnOc5yvvvvvvvgAADnOc5z777777774AAA5znOc++qqoAAA5znOcqqqgAA0c996zBz74AAASSSSQAAAAAAAAAAAAAAAAAAc3res3reszKr6qq002ABznOc5VVVd3revPAAAPPfffffe972qoAAA5znOcqqqgAADnOc5yqqqAAAOc5znKqqoAAA5777777V9VV7vW9eeAAAee+++++1VVXd63rzwAADz333333ve9qqAAAOa3vXOc5yqqqAAAP57/ga3ve+d99737ZugAAEkkkkAAAAAAAAAAAAAAAAAAHV63r+b1vX7z9XKqqgAAD3nOc5V9VV7vW9eeAAAec5znKvqq1AAAazMzKqqtQAAGZmZVVVAAAGZmZVVVf3et688AAA81/Pffffe9792qvd63rzwG2mx5znOcq+qqAAAPuc5zl7VVQAABmZmVVVQAABZ+13et6Zne9727VVBV3QBJJJJAAAAAAAAAAASSSSQCXV06AAAAD66uvrq6zMr32qqgAAD3nOc5V9VV7vW9eeAAAec5znKvqqu71vXngAAHnOc5zve97VQAABmZmVVVQaNdeAOc5md73vaqAAAPec5zl9/Pvvvvvvd63r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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
