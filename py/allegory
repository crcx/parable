#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "QlpoOTFBWSZTWdUcIUEGieZfgEAAcB//9f/v3qu////7YOveXRvOAJPsZNKRRSqINNRREoKSBEKUkKoSAhJAAUpSgB00lBVNmW2SOt2Ay7dGfUCgUAbKkGUEgKAVj1YO4QgBVBEEwUAUGcwAaLKMbs0AusASAB0uMAojmaAFG2AAAAdmDIAFyOD0dDswHVzkt3dhyD4dBCDofQB54vag+7AAMQYroNR3b7nsyJE9mezKIknutgaQD0KA+AHNDD1p89MFc+w8NUFFFUMQGrsNCgAcTwxPto27mGZh2Y2YfbDxwIADj6GgB5FVuztx648VO2vs1TQa07tXMbZtaseeom5oHoqoqb6pEFFJJUVQUoUD6CgAAAoAQtAkCtNDzwiEqn2bWRWmWZmzZ32qdz6B86rx9yuV7AsXz7zx82LrIofZhswl5sI25vPnUAo++U1oKUPdg4iXy0PZgIlDYxQ9wfWeen2zbLWlAe9xxJIobYAqnsWNjabwXgA+Xw+oUpQ33JxiVT62aitkbYm2InXmgDvSAUod3ddyvHkeQ2xI2yzJFs2xe54BOrmGqA+8z54rZtls0xc3e897zuPec+WdzxUUr2FGSaUU0yiSYb1BdmpGmRhkgNtUqQjQaU2RTSMTNIx6k9TNATxPUh6jZQaSE3t6qlKqgIwJgBGACGAAAABkJsSoqRTDJhopk0GQ0BoDJoADQBJpIEpJUA000AAAAaGgAAABNSlFPTyimqekPQRoADEGmyTRoAAAApKQhqUpUAMmCAAyNGmAQMgAD4+j5/ofT9r9H5pJQSvq1NoNhSJbQoUtgpVq1W/z+H2vvfV+lz/T/XfV+f8Of5f1f8P7v5fT/p/5f0L2P9v+r6fH+P/Tuq/1/y/s/o+i/kfL7Y0vyrPyz9v69ZrX44+O8P+Xv+f3etcr9nD82z+uy6v2Dv+23XvX+n6/eE7+XwytVz4Kyqr++tVv+r6f9s3X1r47++vu19/+XX91a7+FS9ffX0+3L+v47/j3f1pfmu65rXnWvr9sfLf35+l3n/D3zrH3cX6/u/X7vur5+9+Eyqr61/H576v2qc/D8/2x5Xznfz/w/y/0J/L7Km/++Wk/5qaSfKUpfl+9aqP9sTVoWtVrBfX9f2fllxC/4v3nbNkAf3055dXNpAHrZ1OCTTsgfwUqEBy3H+DM563n+fuz7sNJsIGWr4A5QIFUD8nvd1/Msiq9RIHloJ9i3mSfYL97w+WvSmroCwSBU3ALyYQRTu9qa1crWx8cBGdvtXP2yllXeB3gAAyWMDoeW3TteGaCAKBAFeytwKo7rhvkPNbnlVwd8wGqAAHvV8SrfAOyB5fLzfZYHe+ZoHrGigZElvtF+Fjnd+6uPqkO54YAuCyPMzLBmhV3nvWGrHhWdMp3Yu6ap+wVnsvPZypbVPB16992wrwVzFY3K9QQ3A/Claflvnx2iO2utVlYntV15q31VVVUu6qqqla285uu9K5aqq6+bir81X137777vFFVdXLmKquWqrvS7708qqq56qqqqqvVdbdX7Y9U1rLlV5+2qqqoep9u3dzMV2+V56n6Wt7vTa7cStZmP0QBGimv3bZu+951u+tqmoxRUG7Q4iEMZAN+zN4ZcIBzSQ2QDvCSarrnLvp92ue3TRSAa2SdkmEA8PkOpzzU9rrnNiwyzpAMqtMMPn26QBWfUQQOV0avpgtUBXqHrWrfLnyB26dAgBKD1EhAgBoAhbd3QIA71umATVz3uVbjIBwqzhkIGdGQDnPu65ygQzEVR3SQChA1kk7kw2dTcXLEn0kIcuiO5XfVD8xqvn7KHVhtmKLlMcd2VQWUYtCJoQoIICaIyUxKg8VJFLLswCgDIBZDrmsFNQ0i+PlVv0u7dq49vMYEItTuJAO+hAxkA0d4mdzIMPNYY7EbswZmG6e1rNlUCFoBwjt5juo/EeXPh32c6ofKHXzzyX4Pzz6HPKHPvO3COOMocSXdc02/UPqXWmqOuczUOHW8QgYZomxz6Jkkgc3MlM5j5ohpAQ8VcQ7Q27ofeci2nmVXb9UO+u2UNeEPiGbnnv7vVD58vgjBa7UPn4jvnJ1MrSHiELqP1CyczO6OsyccYYk3SrFZBIahpHyb5zUNIahtuednENUa2y+VS4ffnZ+8+46bqRqgFkAZIGQnNajHrPjPcGcDHAuznHLZifqHfXM50Q6QzfblBriF9SSm7M+vfASak2IsQGMJFRmGZrNtuSPq+PeTkyGsyGQ2qHvihzrSM24+Edk5Nk7ot8sdFO/084vMbNu97vkm+anO13dMu3OKyAWKPNd3o4goBwOJEZMZsQUvd6ZaVLrDOGQ7rtCB3RB0A6pklEU4yZdmEHlnE2kOMIV2aqyQ1DHRs5uuqVpluSZw2Ks0NGjA2amX7kxIxhjCxBd5S8KFyw6EunWK/euvZd+8sNUAnvJQwHebePLlzJtBrt8YWGMW+IUmtWSmzdFK0XrcuwDuBIkiKZPQgG5BvK5QwfaGB5Q1W8983XHzhZtttdvz5NuoQD0gHJIcCAYiB38Q4h8Q+odIeIc767ZkMhr595fHCXEvnvJHQ73HC+UOs4jzr5Q7XVDvyh51DO5fvPn3CTPuKeDE1YS5oIGU+9NyGMA3cIa4h12h33vyHSHJXz4h5vCdqfENzm5Q7OkNQ4hhPvOZDIeodq6un5DeKyh9x4gG7wgGqNvxJSTWXXs9uxPlGvO/UPk1kgF4w+125Icxu/HcOHTLQ3Tmd46y1wkZAM5r0kgYDJAzUIchyTcWyWZW0thbS3cjtQ4p7kd2pLdtqGQ1xxDGxiEJWfNBUkZiCzHGtGsFliHOcpoZzVOKHUTIbc8b4rrnWQ47Q1Dtshziuaw0uu7W+TNvyGIbPl4R0686m0jvqc58Ozhrt8ZVskZp8GSutTjbKOrnDqrLIaK5QyGoWckAQgfGVhLmjNElqBKy7Ljd1iOvJ7vM5K1JnOA2VbLabVK2h9faHr98oeV3j5mN0m6cwkmyYEBTQQMKiIW1iGIWYmZVS1bCwaECkhJZALIAkGobm+eUO1zopt12q7r9yXnPeyHaq+IZLlDnHNttyh0c/cfenSh05XSOtbO0fLqhuqTkTkjvjyG+0O5eWxVdIZW1R1fHfVD6doah7zIcE+Kt949081Q/ZRz7HxqHnp973dDqOHxJNllL6lMD7Nmm3DJc1aUbQZey4S4UtmOacywCaAkZIE+npWFgKSAM7AIwjJlmbsJgmOr9hpB533Pe1D6a+vW7ocQ4LIekNqfNVJ6++dROr77IfeOYriHw5Pnqh6qdnyVb4359/as1trJtU87vvUH3eFckr78MjmoLxezhjjfixkA5ohMc+hOdGSAaO/m7JdZujEahrYjUO9xkyhZdypznfecUO33dvJHLTrk19sk64O/rhb8Sd9IB9IB4fahHgQ+ZV91788/c51dv1+q60hyGoe3dD51+yhutU6oc7fH58+LSyTOpqFkA8yAbDRkyQDDWBTIRnnNwBJ9vTkzOppM0I3IoEDcyO4ERHH3yh5Q3SHIXNVzReZXc0POu+rlTirtuqL5gjzoT48u9d0MJtXNznKjuZqGfA46odvPc70jfBU54RyE+QySSgF5mw+O9mdTWzQpq1koyo1KfGqGIcoZ5Rfe65M6C4Qwffd9332oEJrUDtgQlNe+LECBvUkPmpWI02bJNtKyGefuPNn6+bHEl8wd4jmjzTud0O3UcZrG0c3NHeuKHVDwC2dXR8faH3sj59dfKHfYTRPnznn3e/e+7oEICQC2QBCR8e+rjQ6QDCAdIAkAsJgBXlt+3nukA71XbPkXnENTeRNWPlDhtjMbK2cyfNHXXCnNIcoa9vSfHfmmtrdccQ2zyUbkjJGSh4qzbzlwzuhzuc78fGrqhubuh5Mk7xyMWx8Y1m24ocqjX3lcgu6jlyXzi63RtmcuRmmIwjmQ4xGlPkhoTbIk0IKIEJkMBR5bNautKLYKIGKIizMYLKrEGMMgWVkxMjJI1MtiNZmMrGJZJbMtFirbEBtEwuQknYJJPUDrDHcFzrr7x0+edR5i5Q3CPyHhDtDm5fvhR8q+Ete5reUN3Q4QMGRhyhSB4ZAMkkhM92857v3vuhvdJCCkArISbyWK7RQ2mUgDRtLmjnXLnOU5uKHOKq++lPKHe975l4oZ7iHKHruS8wdivSuVK+1Dzv5dd/qHXCOwunufvqOHEO7jWWnlmzs6vLVG0vkltiVwuJ3rJpsX7UPvOSnR5wB73+UNqH7x8mvrR+xHweKHiHiHKHHcO62iOTfTjpdH7q/NQyh35aJbqfck+ucltKcocK+ZDiG3vWQ76VfUfXSllD2OsqdRPvV7Lh9zwMh92r5MhuPs/T3abvIeUM7vmTo3pHmEfaGu9zs9rN25x1zirGPuSO6GofKqrzJAO93t3IQUEQgd1/Bz89978+n8+s/sHOOXBGlR8R/ckeUOnPHJtVXyR8rmZO0vvzuT8F4TZjIB64SKbvcZCAjFwxRdm7NBvenPmnzqodOEekc77hbtycc/BqHVDUPvEOUN3+sZtMvKYMDcgGEgGQgYFDuc173PvfYcIfPvWQyGQyGQ94u865zzZDJOuuIZDy4h1Eco9oAySzL84EgHd3Nfc+997XpA0HjuE+OdHBGXJkjLXevKGK4vPNzNmI1Dr267Y6OyOGa81c3XVDqfVXXpK61RP3Xb7fcGvh0+UjqnVQ5Q4o5aga87yPpuRL6kcP3gq+BtMqNQ+aTkjdXU6p1jWrMSYukOcMh9j5WqD41dBXbmc2tol2hyNxUfNSdUMoru+Pl4oed+vfs+78p8C+Gkugjz3nv377+/e/T3whyB2hpQ76c66Q7uprKXrwHPN8qrOB12uJVwSyG78zSNePm5s3jYOdodIbEeLdTrTaahshpxDXiHAgWGNxLghSAOqyMJITlMTgxx2Ju3al186oeXgd3DqhiuqGVkN8Q025neO7vSOLmoNEOELuVGGDW4SgwDTIKYBGKqQDYJITRwOWNZgW6bQLqEGobx1LHA85RuIebmqN33OoTBXLOm6Gjr4ZsXhTaiyPGu5pqZsNZs9vm7W0ld0OZouriF0VUw5dukTJda5mNpxDJqy8S7EoT679eJzpxxF3QhOny71mBqd4UHrQzQqlIQmYQBSAIBFcgYmwo+1mvfc+/vfvnniHSH5WMhvit9ZF524oitXuaJMSS6SnNcS8IBXmc1bk5ud2Q78QyukO/fr91xso5uzpAMl8QDsgDnRAJ361B5rmYaKiqap3CAWQByQDLsgGq3A3D4FGmazHNcuaNG24VZapkpqW+jzlso5CXdc1y7cocsfrvro43NQ1DqhpZDIcoGnZIFBfuMVGPeLaixhApbFGZDLMdWqAyAJlJZakiBCMp+ic4RiNfLwdD7hHZ0HdqthrbW2trDaPFLzhLZGQgaMAhSAIw1Zd5ESXmYYepKJdIc458dyOnwjlZkp11ckY6o8UNxDqXPVqHff7nvW5PlzAozsv2LiZq1dyl7vNa1vWd5mNKV1hgTmQHU1reta3vsbNmzcaaHGyAZNSHlDt3Q7Q5e8uc3TpucUO6k8ocUPEPqHxD4htEdcv1i/UNqGU+BuPPXX3UOzbwCBRIAokAcra5ycmNgBAx+BAG6CDz3svqHdDvpD5QyHaHX1DeavHcgGbNpmFlNUKucIAkA7AO1KwrmyVg2RrW2zbFWmkNtmHbUNP0T9+bSPt5Xb6/VDx0xHLvENq+pP305Nc65UbKU5fXeqWxePKHnxDZ+EdKHql+aE+B7E9Lz8bbCd9ffij5HeG7+ModuenfHsjrlDuh6fevvvzz7999I+u1aofg/coed8tlzTBwR9ofOR2a64wAeExkhJyF2Cjw745zgqiQ4bKAVBIDIAIxZ8yFLv2u/c7997Wk604o/EbRH6vGn2dmkcLCQBNAIGDQCzhJDJAGgmgTVc/PYp993pSAetbstpbzb0gFmiAMPoTgq8ePGbasDWeyM5qVtMz1lAvbv73PffJAGQB2WSd6ZwIHIEOwEJAHO6J2QD05CZ9o6c4mS5TIegwbmu4TezZiZYxX6azUTZHecywIT3ea9AQfeifPuoLQQBQIAYsaCAPAQEAYDsW+qtV4hAASud+jUnMLuzvd3d1vL6788PR+DwHcyScnFyY93ztzqfmCXlECqFVsBKecCWr0UyTmdzUW9zGST9Mkm/uur573MknsySdP3780rqZgDTz952HuqABa66AABuTH7t1517e0/fvf29+++NpfOOB6AAvboGlu/rsySdTJJzuZJOv15x7Zkk5MknkyScl788783206yZY51OZ1wGnVcBoAFrroAAHOve1IMSGZMQzNGzPT3dV57V06XWdfcOHDhfXW1e3QNL1Mkm7mSTv9+68sySevO/NFPPMmd9b57e714688/e0ngPwABa66AABuTPUdvAAAAF7dA0u+TJJ7MknU8rv2d5M9TJJ5LznOc5ye++9/qtdZMAaAAAFrroBXADcmdnYe9+b5PRdWQZo2AZUfe8M6+cnPuaqOyCYpXLf27qusmc3o7DQAAAtddAAAuXnMmddTzknXHPApsOgAAW+O+w0/bmZ+6mST9Zf3Hfff5unWTLk6dApclddAOAFXeV112AAFuTOc3rr9052/GhidddALO/HYe6We5zMk3nOT2ZJPzt+9ar93kwPxp+DwAAWuugFcALcmOugCAC+Og9FvPHXYabPbeue/u75k/TJJ313vUd68zJUgGEA7TbOpxkWKEDffc3ec++7dBAFeQIAoJDcXY012W4cvbrHdKwQBLqCLPLLO1S8SAHKDqbM0EAdyAIFEgHraH3da650zu5UqQBSAbX4565ft7oKgqHliW+BAHvTwyj7Xw8Kyx7TQZGUBLblzKMwunRANawgDL8/d4k65ogGvtZ7598Hc9rhANkA19TAVXLOX2vVoKraAqgpmVV2SAOxdVvGN97NuZFMzzecCAGK7nUpyUCALvc2mCaoE9ZDWUN8K3pzV7eeXbqehyeYIAdAbdJe9k1qr8CAKrWvauCvfAgDNq217a2tCWYHmigCaQvqWVQoAZ4AAkgAnz3PcvTu5wjJkJ+yZ7354PdLHAC+Og9FvHOgHYHo3MyudPffd7/b7111vXJX7u+WrIL7d9w3d3Pdkncn3N+AlEF15Va3BWTx13qldZMAaAAAFrroAAG5MOgAAABe3QNLO7O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qp420bG1tZY2TbaNpmM1sTaay1kdchHnrqPEvkrWQCtpDa2puvb48gvNbZhaBFQfrCcTBCLPva1qE973tEPj7773gmS7bd3ZM33dTMttc5ySc1oLIkl155ky23yZEFtEyW7u++zJec5u7E3d31NYt9vJra1vOJTTkxc8aWYgwU09gWHBpWbplJsDcc67vDbuJJTmIGYHchpMAALvJRmzaKzBWHFabDAGdJJ4Z4C/lb81P4wC19wgtt+BEVSSSQEJc22wC23CTJICJskkkBEDfeINtvkyIAJktu7u7Jm7upmW2zJvF2+5SwtVVVzOVSWte1jD5JyrnJ4NMADgCBAGZI6kmeSQABNzEkkk7JJJPAHQMhJd3fE37mjvehbavuPK6w07q6ndvcyPODwEyW3d3dkzd3WZltsyXfve973j5FigHzfUqHrYTz597eCwdTg8Dxklttt2TFtttsyf3Jkk6+jSWF5UmktY0bbYFT3sXNhMySS7u/SSQ4IAACSXd3d32Xd3d3JJJJAJJFu/W7v2zIl/jr9kxw6cmS22gmQW22yZbbbbZkttttsyXl5XWTAfpMACZBbbbJlttttzJb+3++mSLea3jec8NnA93wAASTCbSUkkkJd9ltvx8ttu/W7eW0ACQNfW2279ZktvefzrJh1jjmZAAmQW225k/ctttuzJu7bbbMl5bXmTA8mT9zg7AnuQASZbbbbZk9/uc96neZkf1DIKzSiZlsma0YpN1Sp1TpKqabSRSSaTWG2a97vve370kkkibk8l6qp+9z3ve9u0SSbUkmlfjEnB2X7uSA4fffCn2TM++PZmPY5mZme/bvvv1syW2/37JgeTIKBMgtttky2222zJbbbbZkvLa8yYHkyCgTILbbZMttttszHMmczJJzM40zWzNH+Yf51cN/nIpsFblXvZXpht+r1PPt+PcObxlldym8AXoRjDaS7JJIRXdtu4n6qVFAZ95Yade2Dbk7+D+6+fczM+9F8AFt5fLOTPpk59vu7v1mS23+/ZMDyZHoBMi2222TLbbbbMlttttmS2nP2TA8mR6AZItttpOcznMmc5kCAST11Jn9yJFJ5e8JLCrCaSpLOsapZOWGCeJJJJBAgKTYAHZJmSSEkTcimpIG5LnBfgFfdfA/rv9d3f7ZkS2v2TA8CIFJJJARC222wCw222wR0EkkkBEdvrIMkn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p1M9t6tvtp+DwPTq2220ABd3m7u6quSZJ3kyR6O3p59Mkm7vczMxH7976ffAA88888AHeTJAPQAAAFvjz7z859Mz71Z+VxqhqGzUNkWQ0SyBBIAkUgQUYk93fffd5mT7nv0CWt4SrvJ085Oju79JAG2AAAASSS7svve972Xckkk8gPaqk0l73ve973hFUQD9frMAih1O91kUCLId7YSQ6moT9UAqAB+rIUgqCqKqjFiHOZmc5mZk5yTMyTg7AzILbbZkttttsmW2222ZLbbbbMlttvsczMOsncAEyW2222TLbbbbMm+S/Wd9ciqtUtibFruOndJssXvLY6ANpskAwuAGU2AE4SCbAA5fe9nbpWSAEkkg0wbYAAS02d73vel2mru7u/dac45Mg9AmQW22yZbbbbZkttttsyW22tyYdTIPQJkFttuf4fMkkkknU1FTSaV+2qVOlu9+5mKVrnPiRTz+fbr+7W22h2frb3bbZmGZlttst+aaUAAAkkgAAb8mkribrN3d37qybu7utyZeTJe7bbbMn8uW22yZtuW233LMls7tttmTbu7rcmXkyVzj8BCGkkkAUkkoGRFgR+kV4bVAUSaPfCcvyL5/XPidH84++36YAPi34D6d73ve97FdNO4pJNJgQ2mmkUwAAy4n5t/PkBFOCST7CD1Ai4222CO4VJJJACo222CG223BARLkknQg9QIvrbbSZOW222yZttttsydczMs/bPN/c59xbWq8zBNn2wS0sVL4+6KS5Uk7ujkktXd3d3d+geD7777774Bv27u7v2zJ9Lbbf65Mcky22225kttt1ZkttoJkBfbzMm7u7u2XMlttttmS2222gGSSSMEQeSarPZv3vq7hPnLZKIMkk5r4A+LbbbVttttttttB9kxIAADUnc973paa73ve991p3STu7u7u5xGXfd3dzYI6pJJECIG222AUkkowQ222gQkkkgRzbbchIuiQBTAuDmKaquYrvYG036Ys7O2m/QDGw006A2mwLU3d3E3JJN3d3d3djTSgAAdIFNNIA00wANpre9737rT9Sau7vl3dpy23d93kyW2222ZLbbbbmTd3d3dmS2SSSAiSSSSAhtttsAttttgiU/lOaWMbymkub5pCpcIG5fLvHO3313fvAAWGJLu7u7u21JJhNzbkkUGmldNNICSQCXd3d3d+fOc5zh5Nd73ve3dttYu7u7kJDbbbYIbbbbALbbbZEkkkkBFNttsERttuQENttuQgHfoqvL4EF86v373+8/Pt579tfwB8Xd3d1q2222/TMSlYTck1KSaUDLTSIGmmkAG2mkV9qgQB9+7QbxpL7CRJI22CG222wC2222CG222wQ2225CSJckkkBEbbbYBbbbbBDbbbYIbWB0SAEPbdX7fjTiQqtLtPrb133vYlK9nPd6u1cvV3d6u5JJ26u7vvZd3d3JJBppBgDLTSABtgEYAbaaUbePEkk76xpJXd3u7u2xJI22CG222wC2222CG222wQ2222CJJJJICG222yIJJJJARWP44qX68yB+rZAPdSAXx38IBhXyc9vM7d7cfvVnsvM+Wg/e1cLAAXe+BOkfhoUL+THFzrzvx/b2r9onPHUrRPuE39nCj1F0xHVoYutbEuIbaOCFYsCSwgILKDBJWkbQrFWtzlQ5VsI0KZDRGwO65VqGjh95XBZttVaTdmnh0104VxnKR05CrlDz+dHNdFqGMKf2uvALsH9+7PNQ88ofuu5DupXcjjtolwRkfuXZHQq0TSN5k+8oe+P3SD5RHRGzPjojqh0FbKOtQ5+4UOJPzp0jrdeUPC9x5/IdqvmodIuTNM2Y98/uf3zSppldtNJXtXd9xaAtNJBgsKxAOTr0898HYDhZbbv6B5+DxbbbbckJSUpKYw3mkrxDG+a2bxJi9Xd7skl3MYEkBab5ze9h0JJJJJtLU3d7vm71dw/BoAtACe++++/p9X337rvz77774Dd2Z5yeHnkkwebugAnc3d3zd3wH4D9b1ky8ttoAPc3m7u7oB757XH56LbQPR269Xq2+20E94PC3cySzMknJmTnLbaLjgN2bu7ugAbJ+l6t8ttfZkk/dJ9z7773775MzLE46yYAS8h1kwBMy7u7u7fweB+DzJlt8tt8oadBIo9JNKXd6u7vgu3ayk0lDXOcAAAgW2/AAW2ZMmW22gAO7bb+tvUzJHh1kwd612526yZbe7e7fLmGnJ2amUmkJpK6TSQZAAxd3d2djqTJAGrbbba7gF106yZIW2+22gALbbbaDk6yZI8rg/a+zMme5yTJJXHgffAA9/fv378RzJlB1kyQoacnWTJAG1cxw++++++8fN/Akne970qdJN1VX1vpAEJd1K2pllDi5Rc1t9Yj5vKptJbdJNILz3m7ld4emE28NVTW5znuX7rfW22/39bbbaC22+Xd6Ty230Aknm373ve9vlUmkve973vem6UUrDaVUqqqF8kqOr5gYqKRZBSQWEWBBtbWv3792gf5l5mxsbM1KbBbSZra1lttWzZma2yNqAKCkUBIJIrEVEFRYqm2m0xpsbbK2NqFbGw2qqFAUKEuSSSAiNttsAttttghtttsENttuQkiSekkgIkjbbALbbbYIbbbbBHw4HQF1YY8Isd4Cfv22AAvjX9My37vd3bMy2n4vUzLarnt8v6Xkt6oAAAPsmfc9vN3rrrd37+ZmS2SSSAiSSSMkNtttgFtttsENtttghtttyEkS5JJICI222wFRLtJJEhtb9v3gPe5UCaAoAED32zYxdOU+xp/L73gJ+kkkJVgEkknel4Td3d2VBppWBr1Umkve8baaXvY9STS97wABOne8S+IEJJJRkfZPSSOEGqNUKo1QlySSKGqFUaoSNtp0aqqNUKgElySOEVVUaFAoCpMEkkEAqqoVQQAksSSMENpJRkl0aoircBMkkBCuwVQJAOzdhPzkzPOT36/L/fvb9My2/w/ru7u7qgHmRyXeru7u5JBMrCbAygwBkm7u8nqpMAfPnzA20l8hIbbbbAOtttsEJNtIEPW23ISQrSTbBFtJRskJJNIApJboIQSSbYIgd3aqT7olaPVWrwDNUKqqZhpcppZ3sPepXznPd509eld3eruSdkkkkjTu8STMkmpJINtpgAAF2NNKd3dATX0n70bX1/CSHbbbYIaSSQBS+NtsENtttghtttyEkS5JckgImtttgFtttsENtttwUfUK+fc98+T587xB+fPq/nVq22gAFttu6tttAQkknmmkU20vVSaSx6mmAAa3W9732DJEkmySEiSRtsENtuSQESSRtgFtttsENtttghtttsESSSSQkNtt9u0k83Utbe1ul7WJLnrTdmNV5Ek5OJuHeW21MwPH2T48mYrjzreT6239fgABaD85Psmc5/Sdc3d3f65ku7u62SG222wQ2222AW222wQ2222CG223ISRJPSSQESRttgFtttsEfU8/c75OSd99eP7k+/v39/cv8uihbfgHpHf998Bu/W9zMtt+degaD77kmSHd3dp3d3egIYbbb+wkiSekkg2hVCqgqSSSMChQpttth1VVQDbbadVQkkkm7u7qEbbbkoOnTbc0E08YN33e7uXz+tt28ttpAD8ALure7bT0mE3JJNyYk8pJJ5Asc5znOHOc5znIu973raSSSTDoNtuIg1JJJEkklA2220kkk3JJJFAT9WvuY9niK9er5vvfPtT7kd4zMfg8BAALbbbky3odkmpJJieAAsCSQaaQETe131573vu8SCS71NttsJJJbu7uxJJJNttuJJJJhtsttJNht589e/fee7PYCAPbd+zn9mfNAIHk+fEgBsEAX71y68nO7n12tAIV7WkqS7XdxN5mtd5mrrcO2GDSaSG0lt39mmFS8uxMyzb8/G/eSAZqbfmAI92e/unmczk/X98+1tAD8HnfvXvvnvv4B+4CX6fuM+yZ6yRJknkmSckyTrJU2EaI5ybY2yMhqGaRjMm2azbNbmuY2m01DSNqbrnNI0rSpkNGw2uztVxpTSBm6kcVNpK2fP7si6yV48P3r+/kOd2+0PvWtiNZEOQ5xZJaI2srhb7ao5ve0j7p2HzrpeFzP7dKn1qCf2fO0nCrjv+/pdJ7eftF96/vv3X059Mk3d83fdvX3TsEU55bb5+td+A/FttttAAAeD685zq9d8ycVLFFm98N5il3e7uySQDCYBG3rt1ed2b9fnQDdJmW227tHQA28tvF3JNyYkki73vRNJcSaVcu9ZAAkkn33d8kPk8zEzeTQw0ioZaVlZw0YUxhhaCo5CrJmDLnvb537777777777755bbbbQALbbbaAF3d3d1YB19999980+iB+ADqZi39bd8vdH6XkdafiFyTJjgBckkmOAedZM3d83W3p4D8HmZgPwfTG1sANgGuXeL1d3fZMSSSSTeWnzu2nvJjJnfntttoAD1erbbaAEk1FioopOSSYOVEVQYaewsOSSSSQAAAZmSQAAAAOOZMkAacyZIFcKgAec/d/TMzPvvvvb98+AAAOZMkAKAAAAA6yZIA06H46yYXsAH2Zn333333333wAcnWcO+/OpMyZ54DSZkgAAAGnUzDp1kyQs7zM8+mSR7+92e5HrzHXXcezqzRWzWFYq9yrA4aRxVyorhRqTy4lXnm7v6Puo985X9r9o/te6HMP7FfdO+/3e739v3tvndtv62/W2220W22zdW22gABxzJgW+eePN+mbOZk/pzJJJJFKlVQEkkiIZFVQLbbaIZFNtyRmUZJJI8oENt63aSXkrSS8lBAfS7vV3ecVSS1Xb1LWq5q++4m/XiKSSTybAzHJJNpuSXN4kkWk3JNzd3q7skAACQAyEKAJc1Sb3jZzhjve97vvcd73vd9dttvW7bbbbLbbbSSSTBKSSWtJZznstpd73Xbu635XjOTU5y7q9X4CXJJLsgBAL+tttpbR2B6AHSLd3ku+htttpJJJh0PskkjdEGSekkkkbbW7u7bdNvW93d1pusp0G2/Sin3yrHjGQDZPdDEku7uy7u7u7uSSXd3u7ruZltp6eB5bbb8ffH1/t3f27/fb6kkyFSSSaBp2229BVJJJNJJREFwySSNttuBNttpJJJh20/ZVjPfN3dl3+/i2222rbfgfffffW23JlvVrvwTc5JMSmnJd3u7V3cl3w5s5w3a5zmec6l2j5tt/WSXJJJEkkoFCS3bbxUkkmG222t3d1MU23rcwE0CAMD+V3dwXffqHboBtttttBbbu7q3+PvvvvvuvvnSRSSTukb1Ln9nz65JG9SSSYbbbe7u7rYpttvd3d1BMAB46bc8QY5JJHzve97fO1hpnotnMgEv1NMrd3ebuSmnJiSSalSmnJMySZumnd3nvey7v0AAAsgAAdJJdl973pFznOd73nOc3vnVXe973u7u7u7u7v1gltttqNtuBtttpJJJ77dfeddr9Q1S2CjWimoYAf5qlcQ0qDWqomoYbSSpNpKk23um0kpydqT3ve9Lkkkvzkkmf333333333zgLdu7uqHY8AO+uuuuu+++++vcfEVbFWNahWKsQQfld3d3fUkkkm223zIMkkkjbbbgbbbaSSSYbbbaSSSZBdBttuX8gre/u+pJ5QxahjKGR/mlcmkqabbVNpKklvCaTwmcCw970TckgFttttBdv2TM6W2/YW/AFttttBfsyZP6223+3d3d3bu7u7uzd3W2kkk0klqpJJJtttvd3d1BJJJtbyR8+8of5850+befO72hpUNKxFstQxE0WFg1H+ao5QxNQwahkmQ2xNRarFWiDFWlesp69evf37+Pj49+uuru7sTUJJJLkgABd207u7tbvabkgm0lw4AASSSSSSSWNtrzaSppNoCSST6kklG222m2224222222222222222222222222AQPnywUMBqvX71e62QBtfqQDHP0Pfzxzu+EAbVzt0w3STyQDY5uSSZ/GkP7zP6TBR/k/zj+WX92jMu/VfrP8lft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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
