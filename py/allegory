#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "QlpoOTFBWSZTWf/6iacG3cSfgHAf//X/796rv///+mAj3uxvngAAAAoKAKU7NSPgMUEo9yhq5Zjbk52mBucaK0tiEtaClUoUJCtGGwYQENjNk5q6wAUMIeOgA0ABpoQJomTTJkJop6Gpp6Qaeo000B5TTNTBBIQmiUqmiYID1MhgTIGmIA0A0AKnqZTI9TTEabUaAZA0BoaGRkB6RoZBJ6pSUUaAAAAAAAAAAABNSlVGR+hQA0BoAA0AAAAAApKSE0pigAAAAA0GgAAAO1EUqB5FibJsElLWr9Bio2KQSFgyyHgh+HVjbzCDbqL50EAHj+M9QRTGGwA1Bm7EETFay08H/ysKrSEloLXn8VSJV1ofJBdFUSn9bhi5rO1gT9HWHrv/xpnE2y6C3v7G+BeO2e59pv5yxzftjXEjQNBaocdYXQ2tfSbW3XwHLjyvvN1mM1BI+yrwHIyjtz5LKHa7fk/96/t12eVZ+vfC72RV29Uu93LVK/bRNYLYT3/f9/m8qiCUd8qpCp21fJ35NHgm/NnphdvG4nPg47aRtH9DtCMjk52q3Z/S1Tvjyu5VbV37mbuU/NUJD96TpZLguzzjzncnnm72b7O+wvHs6dmCC2TeXoI1uiYhEq6O7H67y+cyr5NPS6cEbKo9ztDZhhCCEhIEYCGCBUwRnarKKlAjlsRgI3gBcd8vfe2nfdhZARewEdPQOPNcZt665g2FRaCKjcKIefWCMbXmkjz85xxgipoI7YrbtgjtzRJ+7dJJCVybTy68TulatBEBHQQwRKJsjm8BDSKsEY5gI2WSO++BEVAhoxCMkyeeMEcBEQjJy9BFuVXedBFAh0CJuP3QRoIsEd454EdQiXyc4CL7KoEUCJl9rhWgitu7kjmxJdyLPMEVxblPlWU+PjTbdtsoEVx0Z2ZUd8fH2jARUpm7EkqBDKZbLYDYkX31vO36gQ8BGYXnpedziuXHWR9gI5N7XKvjMb5SEblcroI93xrBFUCOt+d1DzL9L868avJnmCH3nrQiNtvOSeZZMvrSmXd4CLvlovO9LGzVhqKYRypVQdTjsEWQEMPP24xcdWCL9db59oOVt2CPAi4IbWTa1pedsbWdqnGhHq75za0y7rJ2u87RV7teBGj97X173rBEmVjPMOZTLsffd9vJks567zcN729BGsMj5yp29yWCG83nOeMl2CK3TeXbzOcujaxiXDExnrQkhABjPWUQbmLlXt0+zOe2PuG2rqBrK26fJC3FVVG6HVUOpXtzH7rYg6Pz3mc5r8WzLiEScfcEZTSRlZRpgIifgRyqOO3QFNN9YId8m3TOAjYXcOXPcg+wtqgRYI9VAjgIgCOE705vRyNuhOdydydJ6k8k5XARAjoccQKmZVPRB3CjAQxIbgIY8hgIASEgLqDqpwk77DmZXBkdTbxq7g89VU5u73OemXCXu+hUe3ffAjAR6elHXkAINvxoCKbMBDg+16UsL3gIvrWAi4Z6a167q+giI5natOcecp3Jq69fBOrevJOxPBPSEZZlgi6gIuFAigRJ4EO+83dsEAHto5Vcuu3VTlVUMqgpVVZZjzMLcdOPp2uKW72ynGuSLgIYWCLcOWQ70iXO7QIbLBDgIubeSuYXYIh0EUCNqcBDBE8CO5q899DNyU2M5yu7kZTbrJtcy4bpT4z09fQRWsDARdoEX25rHyFdNVHgEUCJoI4x6AjAREIsEYCHfQQ5oJCXe85m1uznS8PPr64+lQqZ7nOgieBHgRo3wESdzed8ePPfjx6cMTE4TPPqTxJ6k4TjugiAI8COiXvbBAhd9Yd5Xrqt0qrmXMK2vXl5OUJYCLBEodGXY7hYI8TzJ2E6V4J4J2Jznh6KkXjt66vjzMynfN2vVtD77ARTvj93H4EX2wQwQxLoIorz4eu+yXy7v4QkJAifn6Fr5uHCBfp6OnUiD8W4fAxHb5Q7CPZJTRqWNLtu4Z7k5aurXTnAe5eO3yaEQRbJfLz8HnlV2y6yr0apzBjNuvXv11vocJ1vAUrFH+n8/vUFgh0yMNflQQY5JGJD6S623bv10Ymd9XGU55SkDHXS59X1tkQmkHEgASEgGjXmZQkYkAA15oRTDW8JL57v7trwJCWh+P6hBLhzipFz10848+vC9aXd38zeBJ4l1Orm1rbGmMZtua85c71CVcdsdN27kl3ouveqCKW1W22qp6exs3t7hyvMLdI5t4k3nXJkc3YmudmRjO6ubURXBKC869vkXeuxlS89veed6u7t25Lg67dy43jvF3OoBHK8Vy57NVXqqi1G2IbVbrwYqQsizUNqUWiKKNSlmgEaNRrTY0ZBuQiiCRJhUJJbhCyUix0XVotxUxphVY7zMVNy22qabbI3RFKg1UsqqkVNFSU6JTRJJKqkMdVd3YVT16vE8556vLqaDAVmpF53Ea5JjRMcDkkkIwG2cINsZcI21ZGNjiWWVBmU5dPKVZAbkjZdA6qNqQbENxpS4iEGIdBQ6hKgUN3LdODiBsbbVkTjurtxuqjKkHUhYx1MyDG2XcbC5BFpu22hQaCpPOk7d2CUuXqHeuvF1POub162rW83rzrzu9BXXtreNNPWhRMwjYxwhJCBBwYQZE0BFkB1yuu8deXezvIJN4ktdmN3cWTSOdiwEajGLMKEtd3akYa5el3deNYIK9i23pzC5rmK5oGxDYS2qpzRDpjrnLrRTc4Tahda2qUObm2c5xKjvpONUXZkttqDhtbWSHLa1JOYWrW3M4oxNqhzUbVVLjQ2dtHJmXXOUbJMJspdYnMCbBVnORcNjmG5wzVMGxNHflQOuddBpszrtx1Y2k7aqvK01VFtFVePF6jtLux3JuZxu2q76hzSTxqq7Wl0Y243jdtWstvGiLt7HCd3S7uWiMRJCJtgMbcgRMdNmOSS6r3Ptw61zsHN3d34w/BjGm2A2m2kAhCJmBLYtFq0aq1u17iLe8+f2dux1jnjcFKJ7ciOY2k9fHOhPeaTkez0+DsTr3d/GJ53f2ch52z3e3v0NNj620kvOmCGx/kI65lffTH99Nfz477Gw8CGvn6nL+hGj5iFTMzKR+P8+/K1B+SDBDfzp8ZwaqYCOloRg/e9S/vtare/m1tpNrSJGIg1e42D1yr0xPXF7Mgvb45IPbie3IXhdOUdMl07OVzC2R4Pa5dOrhLqxep3OLp18h01OvRLmF2ddLcF2aurCXbSm0PdrxpV1qNiNm09M79cecjtpLr05T3aKdaMTUXV3QoxAK1IkBAQwGmIWM+fL7SEHaqhX9FYIYkXctnzbY2MG20hs0bQW2jWK2NbRVG2NpsUbBUlmkzSbMzYmlJViLImK0RJUMpKsYxYwla1mjNpZUYxiExjaDGeZj6xBX0EZ6C+Zn3a/Q11nWceP8dtRn1QeQOMjpyRHzVMSVTn1oppJa67GwXAQ2CGCOZKBHIFMEqbYIw2LjBIjEK2lHGA5O/QBPg3EAgjOPWgReQQJe77M7xffQ+fz1oF8w+a1oFAQwSOciEY/e720517OqqNg2NiLaqbKNgm0m1I2iNlLZJslbQraJbAW1JNrbak2DatY2La0bRWxtRoxWNqLa0ao1RVjWiqxZI2xWxWijY2qMaiqJFbWyW1LaK2g22hNghtVorForY1tYqyG2sbVWI2i1G2sbWQ1aLRtUVGtRpNtFWjazNETZRsQ2KZlLYW0bEaLVi2xbFjURVUW0sk2UbKTZE2jYTWqmKtGxaorWKxtWMa2wm1RaLUUY1rFjbWLCLaGyVbFbA2VbUrYpZibVbBshtVW0NmaoNqjbairFW0aKtjWLURtG21jVGirG2tRqNtFRtYtsVrRtijVaKbVRtUbBbImxbbKbETbMTZRNsw2htCm1G1KbRsWwrYjYU2orapGxsqZhVpMS2ljQ0moiI1StKqxbVjaDUaIrVoqy2VtG2jZm0MTBYmRMTVVsK2rWDUsGpYJqWpFtbG20LEwpiZViamJqytK1qVpasWjEmLGMpiZUxNSYmpViaEMy2Nk2oLE0qxNFtRbUM1bLExNaDE0TYDZK2W0bNhbTNSLEwxVlRiYUyaDa2BK022sbVkjYxpKoNFtsNtltFlqpYmSLEyCYsTapsTE1BsVmWNixtGg1atK0qNVSpoLIYkxMS2KbJGWlbWiKIMmqNtqpWkxNIMrQMTRZWJhMDEysTAYmYmQsU21ajFAaNtFogjWaqGJopYmkliZDKwmJiWJlYmJiYmJiMTEjEwMTYmgYmlRialiZDZtVtNs1sEVGkiDJiojUVm0raUsTJJiYpiaQyyRsbSYmJtUhiYqxMK0TFYmVWJkLYltqMBiaIxNJialaVpaojZKjWNgpNFYyFqICjRaZbSaq1bFLEyCxMksTFJtKm0mExRs1pMTE2EzbEs22Eyq22kWJqVYmSMTUtojM2jMbNo2jGjW0bUbaWFqLMtpLaSWJiTE1QrEyompZDUshtBsSyWU0mBiZhNiZTE0jNKYzJsTRMTExNFLExMJirExWhiayBpWmVpaKoqyZhk0YSKNRYjRRURjaKKo2iwY0gUZskyLGkZqKa0UVYraVpalbQGLCK1LRDUtUsTSgxMqLSZtSNEwmJlNpMJlMmJiYmJlKaJibCZNExNVYTSYTVVtSxMhhMRYmpLEyjYWoymyZsbSGTYsVJjFYgNRrSYNJVRJrERYYhRUIag2MbQQ0EySYosxkqBiSzJiG2zArE1JMTE2CGVhAxNSpiYibJJiaS2lFiYGJpFiaFiaIMTUxNFWJiYmotkjExVhMJhMTExViYmJoGJqmE0TE1I1qZlsTM2TMCAI1mbRBotBrRFWNYmbUjJSSZYwVpKxjYKiNQltG0bFiNGxaSMG0RbWKarIbEtS0BlqWaltBG1UsTKKMTKgzVSMTUKbIgxMTE0SWJqqxQyg2bTaq2JsItoqsCw2itjWjViQTaKNoNGoqiNG22mLYW0ga1E2FtVU2koMTENpUMTJQyNKlbVLExEsTRSZmZtUtJalotksGxbBtbQ2tozSGzbYjYbTr26uXNY0ivuU35pe37LbS/GB5+fKmNW0utd/IvmLzXX5oR0mFIRT4wFaYqBDARvq50TKtJ6bilznG77lDZd9TtkhB3YFDEklrQLOAiAIlUCK4/V59O0nUnn06Ote9qezNm221jbRtGMsotBUaSk2sWTRqWJLUljbWk1ZtjWOvTaAx/fkDvog6+sR1nWjvYH40uZBETE96wRjpgiwjBInYhW1TGMtiR5qmCOc8UklYIaEcW+o5yCEZW0JJdY2j89ykm1GLmwRrPhm83tkfmvei+Z8y2H3IJHNIeYwQxVlUhH29oEX9XSwR7n33QR3u5u0B16dZBDPmfOZzn3333wImEBHkIaEe99c+3gIxqtjqvrQCH9z7O8ARmVQkZ6CEhfgxIlxH3vyj7s49YOfUFMb6MjXGfbCyTrXWCHc1gjjQijYITaFBJ7+Qt3wgIbBE9VAjv0SRGCKn1IRrSSXzBE5BBuve8enXe7+nsF1ptbC2BbBM2STYkhsSQDa59Iz5g2L89DGHWTk/NhX35+X5neQnXWWW0lPqvmAI4hH30oeTkiKYMHy85313m56e5nd+98hF/H3qLQI++gItgjmbQliYCL2vrSRx/jBDeIqLQRo2jajaK1RjM2qojFCW1ottG1JjM0GxEkwtoixZU1hkzSMENGlNGDWMSSE2A22xgxr3j8KCvodrKrv5RgzzjfO0E7O97Ro2Jkz8O4Z10MEPbqzuuUixkfagIYkPbcQh+73veCA/PezfHARTxvPUVkDDkXHkkbhJyE+4Tm+YR2onaU6SgJB7eQ4BclDMrsrr2EdD5/UvWo6py+MFDD1RnGFS8uqyI8kC1tJTFl7R64zlbB17B3d38f33i72H1/z4N3/7UjwcRnVvbKhhd7Z2+73nvPgtt11WH5USxsFXxjPxX4Xf4vxvuBAn5sEvy87/k6oHWNkQABASAAA3V6E8rI3X1t5WV/VBPQPMJ+MvYnygBIWFYTqjef9vmUtsD+l6wAcdpSqQwgTJu75fPY8wPSVSCeLCXpH44vQB3jJkgVyRg7LriqechzY4mjsgfVmAxjf3XUBpA0n/SMMKuyRKSanqvzzy3K7ttXWYWS5zUcZZRMpUFQpkllBVZtnraLIKtg4u99zwQbAlKWVxjYMZhhaGuFjhZlOjC4mg+ggJik7hHbKjHBWtSAMRuKcxhfbHDY2m+fFIQAdDxBzKREWaKE6SIII4FoMwhEEKN2/AlSpJRQozWkUGhEVeO7biSSRuQbk1FiF2fDCmct0wH0vyMBaSYpXVaiUUFEGtM73kO+uOSTiCJWHIXXJpcoVLguVy6YqIsaRjoLRG4BotZQykgskrwKKLN4aukYCBzCS+g4TseXNJ1HNYtOGYXaW/pwwZ+osY6Pv7VFYbWHd9xi2EkuQiiIZyObREQVEVDJGLlk10Jw3Qz3bGIdOnfJLhIMJrwtsKawUpYkuFyPZyDU4rgDdQ8wlB0vXKW6FcbxLhtGYsxYksGUkrYMeQGwEWaUnnswBgXB4MLdz7HAmRhHCFQYOqkAgLLAKwD1MEG4FBgDI5pIMqfgQKONU2pJkFaqf1ImjCLBNh1wjFXXIiRQOIStiDEhTKSVHAPaUDEiHTv27CuyIsFFSAIyLlAa3SrGecOMnlCG9aIqMow6rJStUHaJA3FOBnQZTtIfW0KqtWCCTzcWghCAdpg1zUUwxD5HOWl+KV0GnCQxTQJvtEq8wRg92ePOgjEYbxnAs6JsQ31ijJmVy30CutLp3sEvqjhMpjYCOz3KP/MUFZJlNZZqdnMgN/X1+AQABQB3/wAAEACqoP3yJggn72g0r6zU1szZQtbJU1VttbFigrWTbSxapAW2VIhVa1YFYpUmKkaVXvQAAAOgAANhyAFUFUHAAAACm863OSgAFu1ohoENlK2xs1e43UhLgcI3mz3ne++VttlKVTdrb7fA9zoADvnpgI9IOvUAKDIA9AAG9vDR0ASdmdGT3oQA3hyaTreyRRezpdvtbKW2Pvsp8AK9p9snbK7p3bTtmu6OvgLD4hnb30lJW3vd73s2zSln18AC+AEvvpKnbXWWu7dfekHB6DGeqpfbSqUqfHvKAb4fQ89z6petSqWvds8+tLfAGPn3WWvdql2NredfCYfQZ1vvlWtQvb3T23nufevMLZZktIAUBRng0TEeJUpRpkBg0MoRANvVUlUIABo0DDSPyUptFVJoAyA0DCTSQTUpUAAAhiCJJimUlJQE0NGBNMFJSCFFKABkaAH3ffvhABVUR/3EZ/3ev/w9e9p5/pBFUgQhT+t/t/sxuQzv9t5/drKGc9mw1TYk++5zuXg5Y4P7e5yxw+9CqxQHUO0fVVVwQe9hX7PU2mD7teWlrzbzWDq6zWe482vcPrvu9a7N4bvc9TeOk4bw7oeXnd8392YhdaWt++qiXNa0qrtqqqKmru6rrS5aoqvN9daX6+wq57v3c1rfG62qrq8uOVVcu8qqusy/fW1fObrqt7v7u+99z3c8bJnbvKmVUhU537dqq78dvJu97zfTtznfVuZvXdfe9zVBxErW/XmuxhB2zhkIZ0YQ37ma3QJlRVCQSQzllNHk7FymD1FKeClq3wU6R78IlMWSEFFyld2VQUoxbIOCFBBASZzOYyNe9uqmk65haT17D33nDvviSTENqEOEIU74zuZBh5rDHISsOEecMo275hUgDopmBip4U1rQukTUTefMRLuvihSiiCJQAd1zTb5J8F1potttpOjyU4XaV51VKZlT0ogOgEBOAknET3B8wPtJ3zpkmuxPSZuefvvepPHhTE10k+qde8nUytE7AhdD6lk5ncOs3OOMMYbtWKoEaTVPTe80miaTbdOieci5IQdRAoM4Hb2BwnAUiDmcYwPF9wZsMcl2FpYok7CGsqXAIYEEfpQhriF+Tbkzfs79Am5OosQEUtkZqzNZtuVPs9fuTjVMTE2pPvqTnWqZtx6p2HJsC0Sax4C3cG4yHInO+c2plXGivRSAVR53WG0FANh1IjJjNiS9zYil1hwsO52hA7og6AdUySiKdi8rDiE2jYZBWSzlAmhyWYblSG3etXJM0bFWI6GBs1MvuTEjEMYWILvHmhv1+ONat+t5rmChzu/b6Rr3eXMmmNTq0sOasrnSFhvVhTZuilaL1uX6BDIQWENwhokNe05TdKE+qpk7PQyWAnUTUNATkIaCQF6T4ToncnO+u2YmJ571ZTDnqVOAfSigdROQoQzmolpxEvIQ3gB157czuwgn3pmUIMoQwIZhvhOicq/eE83i7HwnHJO10TScJkvnOYmJ+J787dvpNSaR0ENZ0Iao243Nc1zlifKNb2/Qhfs3X7vXu+FtmqbznXWWpIXmb8QJoELvyTknEnZP2KnfbYmk1woQYsQAKzzQVJGYwxHC1g65Y5zlNDOZHEnQmJtx+757usTt4TSfmxOcVzWGl15a3yQk8CQBJDXBThlJIqctKrQh33ReDSXNTjbC2OKaVyJASKU4iREyvV7dhIJsalRUnp7v2cqyTOci2VbLabBWxfHhTpiJa8gZCBOCXRnADE4KKaJDCoiFtYhiFmJmVUtWw5NxTiq5JyTE0m5vvkna6oecsAte17nPN8ASCB8CQGkSqKVLCGwvqdwwhDMIFYpogdmEg8ESlGlTKMeolIkdzUT4LBIp9k5yp6HzP2nepPuFz5XrSeBhBhoxni8pgOjTb4yXNW0bQZfS5C4UtmOacywk0EiEk+n1YWApCDOgAkGGWYwlErl9hpA5rUOknpnr636ThOJifor3EX4+zijz7yCfUVBaBIGeETyKYA906fdiwjJGCSKmY/cAD6YpSiH2lUiVsnzrU8RiJvAeTnkc+Ionb59d1OnDKaTWymk7ycpBBtQaq7hQiW8LVKY7LJz1cOfF1aJaJ8TpYCcqu5l6/CyAJ8xE1+RN56CJORDiphhpaAaUlon0ROFNInb4FDF9VNbxrhCUR21IKUZaJQJoJUrLDjkeIWrZxENii87F68upMltO9zC7S2dScL9C4qYqrMFKRH6KAzcDp98c6mumhdNkoyracGQggQyEE2ED61pIcBKB+qu+7773bVW7A+pVfeVOu0jxTTalqsTd53vl4dAeYO9VfcdzqTt1HGaxsOaotxoROImCo8eB1E3gpmnMROIjaj9tZ7773ffWEFICVSpBZNkVS5AjIhokLFQRihFKyeYHXXJDSafL6H554Y6zhNs8g0tIpFFTJGcRJzMNIuIkqWi8mi7xyMWx7jG3EnKprTEuouXE05yc5ZZmUxTmQlCtisoH6MGyBJEV4HAmVTd3WgsUQMFFmYwWURBjDAKVkxwZJGplsRqYCxjhIzMosVbYgNo4XCSdggHqB1hjuQy9po2kLgmIkaVOgmAJYJUpxVMV4LTqTdScUxqx3w49aTpBA5u1u9+73138okgJUADOUyTITHmYnXFOaOtLrbgm4ofP0rES561wRIitUidsFtEOi0ohqiXdc+RNoUsE4/aAUFInGiOmnebOFfdL2DbCOFwuoxsDzVXDvlB+/fEm0n3x7a+NH3KejxJ34TE5Jx27raU5N8OOl0fevrSZJ2ByfMk+OcpsVyTivMThNv3XXCd9h766UyT9HWB0J71Y9zsNJ7XkxNxz18Py3mJ3JncuG+qd4k1Ejcq3wwllUcqlGBA2KjaIwh3iqrkIcNe2ElYqkh3X9fvvvffvfP4+385cKZRfEd8F5J08abUGqmpUMB+3gB0EwaxE7R9cRSEZNOSEmGUxQnpsC1ErRTwpdqN05OOKck0nvCck3Xyxm71W0cIhiJwROKnAoN5t/d33fcKAT5865JiYmJiZdZznO9iYrrrhMTu5J1Kco+yarl1z7uiR7K5ft933b6FhtDOh4FINMBSDG4YiRRocyVCQgpETnnlkDhYpQRlYicT4A54RDkVB7yz750OGtTpOqTknKnGSmdeQ1VeqnD73A8si0n3E4puro6p1mtWwrom2J8j1aC5ROzbVVuiatyI81R1JpB3ee3giZfdT5EtFsIiHAFL7X3fu977gJ8kdE0U63TronQNDcmg+6lIJSCxEmZIiEcPpUhMlWC4TZTydR1utOSbE04TXhFJCwxuJcEKEHVSMhJOUxODDjtLt2pz3qTx1Y5JivJMrCTQSBJULjy1SgqKGiS0pMJVdLo0O9TdJyzYnhqnb095bmeNVcgEtUiJSOImWCZKiDLtKYuWeN0NHX4ZsXhdqLI8a7mmubDWbPt8V3SV3Q5mi6uIXRVTDlMSx26eUlmWXaXQlCeu/rN/bcRdUCcPLvWYH3OIhcFUoAFCGIQQgmEx0FH7Wa77nfezAh0CfBBAimCI3mZtC6wIZbm9atyOCEM0EMCGvfH3KJFSreABE50E1EnxYJ96nb3eGios1TuBCwg5CGbCGauBuHiGmszVszSaZNE0t8HnGyjgF3XNcu3JOWPt310cbmk0nUmliYnJNz5Fx+922a3z3a1FYEUZkMpjpqAwgmUAlQjbPtLrimU17eDofMU7Oqu2G0s22tVsrqjvSWytlO3QEKEEYMd7iMLzMz6wpIYEEeHdTp6pxKctUxxHiTckyi3t+xs3MBGcn1Wpm7Tct1b3eZ3eY0pXWGSFgZM1zM1vsbNmzcaaHGwhqTyTp1J5J9626dNziTuU8k4k+ekxPSek26xTfbovsm0SJoBRni/oCWEmCkRIie2vt993vvi+gnfrBMwGvfAnETATUSAnATPgTOXWzETDNo5GF01NqwSgT79KaLmxGlbFZm2bSbREZIRbIiROqPekip84tnVEsplOXWSbL2V4ZnMLaqX11omxdu5O/CbPhTpJ+CvsX0TmhJII/c3VTULiy9IIlldCHVSqROIng+5vtz773hT4sWKJ0A7SJl0yCVQKfIm0hYR5UUJWqIchdgo8O/G9iqJDZooBUEEASHvu397fve7dwORKAeikiKdXCB8FhEQoHiJ3EThinzwE+RPfc377n3vd6+YqCQDJIysIKRiBH1173ve9ASIk+PdO/Cnyj1CCifdFPTmYbLpMlymQ7BBuuWGGypuxT3MDlgAXUrwOc3ue973L2AkBJgJnQa3WOTW+97XsVWPPa4npF1424CSec5wupLEkrSSVAQJE85XSLFcybk3wcwGrm+8l+uZAI4DoevxvjoABI1oAAGe7mka5XL93vde8WV0OAACbaBZJG97Alazus4ZBcajILAAka0AADfJ3s72kJV7uu62u863zsuFbzspSla1pLJtoFmQCM93mJnTVa1vhcaAWABI1oAAHtDgQAAATbQLNcZznOc5vRt1YAAAABI1oAAGgXvnubrVZreK1npy3ttSCzIBEnG9hYAAASNaAABMTNVzNYZ2Fl0aAABNtAs8NgTFbaBZMUyAABI1oAAFXjNGwGFa1oATbQLJvbYJAAAAAEjWgAAAAAAATbQLM63JFb3s9cZujQIAAAJGtAAAui7uu37Ps5pzXd6u+cVznLXtoFlaqXvs7Xa1nFea3ZJAAAAAEjWgAAAAAAATbQLJXZWqqNb26GqnWWM77W7zWu82XcB8APgJGtAAA1ecmgsxdMMarLWnzevc05mu3m9/JfdL99mfb4cXZvL7usNbzVb1dd93i4AASNaAABo5rQJAAABNtAskje9gXRoB7Q4EABI1oAAEy0AAAAE20CzIBM+zis+ve+73Wa3mZrXXOc4SEjWgAAAAAAATbQLJjdTVRrexZyY60PeAAABI1oAAF8zvxxxaAAACbaBZcrbWwRZoAMMK5WtAGtAAAyARZoAAE20Czw2AvevNZddIAAAJGtAAAzkAAAACbaBZN7bBIAAHvdTl8zvtb1nT3eZNVfu67x3m3Ha7zfruQAATbQLJfPOOurAAAAAJGtAAAAAAAAm2gWS2mwAAAAAJGtAAAwwwwpU331blZNJYq9wpJeSkGeYYi55eXc3HB2auxyeGfax3rcFTeG8DDaVvI5X3KH31x+GNGW95i+ebMwK5vVp8bwIDjhvWNTVBjAFgHcKGU9h7c4Z9eMTOvroHMqOrdcwptM2ZOS73dNzLqGjJMYT7va7LbJ8Z8mm8wqUH3NrhYm1ws84V9d7nfcu8nI9ON+tO5aPJDMN3hVuYNO8qHWBmiaNdpjpU5aHMd8ebT3eTX3LorvD4MpqM3LdY9zGLmkoZlN/S4KM075R8dO7vJxdNrTO9O6h03ES85cNCXlG71VeI7ud5nmeD7eckOpCVOKRchZ7WsDmUB3XMPaKixO8HKw8wqg9N2I2rcGUHPi4DkFPqb7abL8kpzuCPOHkw3z1uGOHbvadQ3dYx+TNFMmrjEQ1k3mtc2Ae5ZPnrEgp3G9NVQ20+yyRXfrzO70hzVMu/ZMxHQZ7XV5fuHK3hvYpmNOFlEuS8zeVzd0wC49O4b9zLN60GRm5vbK5jCR2Zq6ly6rDLmDvNa1bbTpow5dZvtnI2PLouHxl3JVWfO3y83CPDYUbvCRMNLnNXtmGxzNsN/DeGav2t6uqFkitoz2iSaFhqno2tKXWFEfjlPXWQuBdhv4OIOp777LBJp30sw1AMMo13Sl3AuI7p4w957vXrrvc2LBNAutHxruy/JpODzWXiuYa0nDxyd1mJZ2Gr98X048y+GGW1HlRKyL9w5wuZZ7u4FmwsDtydfg5K3LrvOCJ8/cS+z7zrV1ndmFzLu7zI4wnKJC7tpThJkeXDZWZGbYWtFoKiY3ibR5vHKbbTbvVKNtPsrZC8UuTbzcsVaJQeO3SdzN6FMSpzh3EE0m+hrOpvrNZ22NMRN6aqqKqqcujA0Jo5vNHrvn2GG7BY9+y0ShnU+cnEuuTxohpJ51DdYzqrrXavnd833OtzOa77fXfXIAAAAAka0AAAAAAACbaBZ7eRsWAAAAfAka0+AAAAAB73pyXupdzmc1vPbU5WcVikne3WZLua5erzdVnWa57zoAHhsAALo0AAAAAAoAPYruaG3QvRsEAAAGsgIABrocLAAAAAN62BLjDDDCvd5zgtAAAAAAAnWh0AAyARNtAsjIBZoAAGlAWAAAAAABezYWc8NugAe9rG943nPJns7Xd5jWlveABPNHAAA3kCwAJue3VVjucVjFUzw8kTLQAAHNg8sAAAJ5o4AAG8gWABzXsVVSqxnOMYrCstvETLQAAHNg8sYYYATzRwAAN5AsACey1iXM8a9ic1z13aJloAADmweWAAAE80cAADeQLAA1dZzK32o53Z6Ey0AAA3kCwAO7ze5tyvd33jwAAADdYrFXs2LReTYAAO7rNBwsAAAL8bcAAGrrOc5rnFOC5FmgEmdlm+Heay6Nrrnilyto5Tg7c1y3nu8yzvKzytbxnVdr3eb770LybAABwHQB8APgvxtwMMrybPe7773q973ve9SJaJETqJSJ1E7EWJpNJ89NzzpjdMcbNPZOB+k9k8tJ7JyTSduZnvDa5gxUJW4QhYQ1CHC6IQ0httxzx7J8ieSb5J1J72De6fM5zSeImInAaPJfHm8OyVSHlbZndRKPkPSIvJsAAHp3NSvN76XYAAAX424AAJxoOe973ve973ve4fPeVM5mssNKq7LCqJiLo8EhOHp8J3N5id1ZpxczCUND76X7d9u4vJsAAAAAAAF+NuAAO0vedzWpJLjfdfUce60RuY6rtqblbU57mvfe7997r72AAAAAAAAvxtwAAAAADl3nZvjwvJsAAAAAAAF+NuAADIBCta0nO+5nNY5VerWNt1ymauX7nUReTYAAAAAAAL8bcAAAAAB6uTWdZrE3Xt81rtOzXL47IXk2AAAAAAAC/G3AAAAABKxju7qsVvOM1vVUvM56936d7fSAAAAAAL8bcAAAAABvNXXMLy44lgAABcZ0AADQCwAAA1sD1gAeGwAMDR7ndaxusNfOVzfc49Pt8mrWKIgqG1QTlO8++zNq/eq8+71VJ315yr58iX3Dn751c0niTSfiet0LoTSfiWEGwhwySR5zDF+77uu848TWJu557yiZuyeExOycJ+JwnwmCaAXJppZkrGyVA2IkRO3gJgTfPSdk9J2TE9J0TsnhNJ9J6TE6J8id/CeificJ4TonfhPSdE7J4Tzwnzz5hLBMkJfO9+3GsYUUVznc53nNMOYCcAToCaCVWHrv6XCCJYD8qeAaAYqQZ3O39deo1Uu3nunGwGHw2qeVPq5733blVip1vx3OyTYc53fk71UqSGUUUhBCFnLnvvudJBgO8uqpky+9v2maSAkBPu/KkM36uLg4NKmKlZXtvwZ0+5pfe2Zqp9zTMFPrVPAOVz6AOqmKlFfSvuWg9VIKkVOF39edzl1z777IiZxpU4qV1BsnK5z33halp0ye4Vw+m2FjqpRxUpUzO1WiAWOtl1naQ1UvxCQEgJ5UzG2BOATh0zbfqLDDp7DXpIc5b8H1T7A3ma0gS+99rXZeELWW4xShloIVlG5rP707zX3LfaD5Kh1ky2X9luTbrR3f7R7nOZ9aXua4csX3MN83numGXr5Pc9NlPilymvLyTn657GKZ4kx9QYkTyJRQREiCNfAqfBG8tKp9RxQSroqKJvypBV+aFS6bU0dSdn7tz53dM62Dp3TyTySMgCWlimRQDOPYlh3zBNVLBPgnM7TGSSIkoF5qJ2gxE+IZfEnWSczE77ajVTZV3cmOtQWo8YbSWcRPqFOnC59gVygeB1IanSfaUUUafGgJmumQhYQw6witiX6da63TuVj0uPVsvGk0poAZ8cslUbOFmojEgbWkJ5GIFqldgiWwVORb4uq6iUNvM+vbyoKdROl059udiDT80yqOReRVKK0IIgJCHyDSmFY0+O3WpCzd645xqTutJyTyjFNT1u5pNGmS8k01+3EeSbxTwmlF2i2iNDFVviRE4ilHTG0DPI8fbGyTtnUmN24dinaV8UaRdeVn27ZPIkHf8EUUE/0BQHESpA4qoJHb93dr2cmQOYksHZlGqB5ySILUH4++0H2zjD71hm/WXFbGX7uubKJy8PJdFmdz3zwzz7vt+2699s3PVeGDaKeQkIXpTSetNCatYTnD7X27vvvsPcpXUYkgsGZQjUJBJBjHvv5KilX/7UiCUf8fP21vWc5xylSpx5LPX7/K/z+7tdT073/EShQPRkVkbS2g0mkNNhaTFPmHvQeY6K0222zYDZT/AcpVoifcAVZBQvluRU3KkIQYzlAlIkwBpqqBGMfvihSRWGYKbMv5E7piJOKp8ZBSwH7DoIcBeERMmVVhNUIFAMRPX5E1Ve4HxJqLpptmrpkn80I+2p4k+cTpmaQ60I/PlVc+nM0TnFFOb01E/fdfm5xE5+++/SpJ/Ue+73ueKPObvclyIct8bnGxiXs6l5d6njbbxtzdiCfGcw+4BciJkt03yA5gefG2rUpJWkm8Zb48bbuApACSVpJPHIh5xt031xdzIkQO95Xed66ctt23xt03yApUpJLFMBXwNum3545DbpJJYlxJ0228ctugpj3uen3vOy23jltu23FEgzIEic5HFitZ8yYox42CMQ0oNtJQVZFFkUZAWSCIoCqiJWySIKDGLEjGjatrCIhFEjFBYMGSMViCiIqM0NRv3fud/ft/m28bbWABTAJJJaTSSSSShJJa29293d3etpJgzEySTYiAIMktvG27iAAHLbcWklb7wOW3ncbbvHxtu0kSSU0vfvOyST9P379n73vlEPkSHUSKREhM6yoPq++lY+znPwPqGarIHwAfSsUyA+lYpkAlVWOz7JwPvgSSSSSQcBTERqVOZ8gICEQJmBAkCBdKrUocP6j3VTvvs+VK9zQGIP0eQZFDs5LvqJoKp9Eh46bGkCc+wiPY0ne/vfR/M2zT/k5M24uH95VOs/MxD9YQIjIAMGewqzrQFD+JkAyyqLFREg/tsFP6PZIECKYAiADMCBfn3vw6USSSTECIgpJJJJG6xWKZZqgPVjGMa0D3veuuc5ze975zMXa7VQGKoAqoC6yZmecCOpkfIFcvPjRUEQk+3fV7e+9z0N73ve995UAD1d73ve9TvaQPQVX0F9FPer093pJMzMze+9VUAVViqAKqKpd3d3d3Yiq9iCPwlUIChu7vt93yigOlVVYwAkky3jFYoD0XkmTJhvvWKoAAKqx0qgulVW7u7u7VV+H6lAS4sgqm7w373ve95fKNjyqxiqJJJDFNxzFdzisVvOGad33zh3u8yZk5qSZgdrFUAYqiqgMVQBVVXFyDuSZP2Sa2bySTMzeuvVlIJJJczKqsYgAHuVWKoc7zve9zJJJ+yaySZIFzrFY6AIAgb3sgCA5FVgDGZmZDUzMy73kzJmTGO5xVY1x7PhEkknZMQCSqmaxWKmXek73ve95kzJMm9+AdWZHSqAxVAGKrmRVAF0rWTJ+Nx1JkdizJk97vSyMySSQakkkkgAZ1zWcVrMzWtne73tdK73tdKsVQDe9rJpVlb3vjbet73WKxiq97vveQZAJiiSSeeeedMh3c73ve393eTJpMm+9JgFAFViqxVYqsVd72M0q5JmZnNTJkmTkRQJFRUyC5zd971+773u973vVHvfGCSSkqFSIEBLiSXUvRERHZAgQOLKqqACqqqqqqqqqqqq7zJkNCIFVwQBAiOcv2BI2kj73ve9ECB5IwSSe9r10qvoCj73vb73x74+4gg5meu7u7VVVVVVVVVVVAFmTDUkzuI/r/Ac25tzcJtryr+dE6zMSgToJWcBKrfTa593RO9RP6/2AnvgTn7eOb7+/nu+4/xkbTaGMKw1lmkKmMuWL9lkwQaULylVUF2zTMRElGSVVdt/me7s4btYddsMQ60STYQwIVdfUNJpijPqV4lGFbvMmMmrUQV1ZQgxEv2QNupsZ+amgNNxk8moEFgQSmBDCSY/fns+FOmcCkEDgkQJ4J5E1Wd4600Ufe75JJeuuH1Pzb1TkmlaTSZVtVOMLj7y63VQwWKtzvpTqalpM3w9SJhag0ajfbAVskVIKQISExNsT3ipzKjMUzNTWMVj2p+6dE1sptmybJpTaTKLQxTJNVm22tpszJrLFlWDWSbSYrabJNpMmk2zbSHzTtLZI65xTcgzUmROc5VWIP3JcxTGTUmagy0htrNtpttLVVkTbENpmI2amam2sWbNiwyTQp85VypiYWSbZrVibbBlVotKrvBX3UuiazJpNpdatJoHIhrbNmybUlg1J+zhNU2Mo/Mpfd0U1RuuAkKQRFB80kkO299msDH2fHe9934kj2tIyKVnhQ30MvAWa5vWvXn180ubmb6bPdN5y5JJ7kkO2zTLZVcPu331VzvkUkp4M7aXOSrqskIUpjo5mZVa7Xfe96WzGtKAt041l08N2crYt5nHhzhJ10OBSd1zkk9PevYe9z3vX3vTfeySiEXbKrBZICqSoEeSgqiyKGFGjatQ2FKGIUgoMigsnnC0kCsCGMCsgpAFiwrAG0pZtDBiCiLlFsFgyq1rCKEiwwyzGVWIyQolYUSoHcoCgYOokqDBQVBMYURiQURGAVKyQb8633vve98oO9zXc5r2t7zn3vDocAwAHAdeG2cAeNAAUBQAVQN1JBXhzzeu6plbecUzVYVr7Mvved6CJgiQRIiSHffe93bz3vehM4xnOdaqrrTjhzwrFb5nVXWnHAdoOCVypJOSQrtBwM8kk5Jc7/D6/n2d/fv373unzJ5PDOfOk+7xExEihESIm0iUht+rc9JqKVABKBIIkgqZ9e17vvae0lt57pz2cmleD1+oJMrk59k5sh9R0FH3sOVETqkVEpBfuH/L/Nn+eoCo3/n+cD/IX/lGnD3v4QAP8iIoAVW/N3flpI+973vCBAEeSMEkknghSIEQe7S+leoT0E9AH3qUR7tIIp/nCFR/iTTNQtJlpMmk1VHIqUqsSKrFE3aEV/oqjcIZmqUbKpNJkJ5qRc2JqqUaTQmqaV55yoDzRJO2UUZJqFkmoNJi0mvMjkmmtRG2k1VaTzedVS80nWk9ZRyTYmU2MzaIaTCHuLkmlNJ771VHuB7lI8ZmVOYoOSbJMqPdIe+8qXuoV5VMrFtZNabIJqqwqNJpKMTUWlWimk85KReeccgKqZBJCSKRVJlUjFTMzbGeNsUvdKe9e9Hur3SdmBaTSNJiovdxTGpNU0mSzJRpMkaTSV77xL3VVO8q9xTZVDkmSnuoPfeJPckXkmSzKaTBTxC9mIAuYiBECeciIAEREH3vdXt3bTYJJJ8ZcwBEBcSUJJJa5Dm4iIiXIch2HIch6/n8+uktkr7VF/ZMjNETSYW2htrSatJlOZy1RLKao0mpLzzkRf3FdmJtTaxYNtiqMphKvNyTVFpNUpMTUmwK2FUxNbRE0mql5vNFPNBdtQf3OaijGLSYGkwtJvcpc1axmaTFaaKYWB7z3pXuqrpqTWYzbZa2zMFRRYyEJDdoEUCE3veairygS4kxaTIsk1pNgbJMk0mpWk1VSaTQvcih77yoPdS9ypeyaQjSZpNUU0mUjaTRNVS91HJZbGkxtWbaWSalpMaTKo0yDSbSZpNpPfeoJ7qd2ixmba01s1oe6SkcJtiCyT3ctVWorSbJNI0TKbRS0m2UaTQtJinu91Je4qvckryTIm2JhJWUxpMoXuFyTSqnvPfffFCdlLSjSY0Nj3c2xmMzasvffe+8M022bJtW2HuOTUlkmqViNStJlWk1D3XvvCe+8AZu8jnDQiBECAZEQCdTSvSpKSSSMRClmqAN1VVVUzVVjg5imaZrzWKxWcxH9Kv6TbRcyd98v7pP7ki8wju0bER2DsBVMESIMQN2t3NgO4Vu7tqYiTd3mzYJm1ETd3cUckUIkm1vNhu4cCEd3m7vNkZJN3d3HSBu7u7qGiqH9AVO6UoAd7z3r/fuCXd3d2iSSek1uqmaoHfE5VYrB+l3+3BM/t292kdzd3dE3czMBzMzMEzMzMEza3admwU3N3d0TdzMwHMzMwTnc5vTajlXm+tURGoiCj9dIvO9GbpZR973veEARHlyBAKJsnhPBBmBAKXve33mkEfffcQAD9N3f2Cf2yjZu1sU/1A0Iffc+++0TdzMwHMzMwTMzMwHI7A2Du1sVMN3ebtbIBHd3dzRN3d3BMVFKgKxiiCpmZf+fv3+f573e9+7O96ACd973e97172lOwVO9oH0Ar1Poej7xQqB+nOfv2A5/VsNm7QBuZu7om7uZgOZmZgmZmZgmbvN2tgm5m7uibuuZgOZjmY1FxFP6ApeUyI5AqKA8TkviKqdioqD9ETd3f7+/f36e/H822yVOzECBD4kSwpCkKRIXFUBSBECFMORDbduRAgRFXPIiAAB9N5mxu4IGfO9jd0Tcw3d0S92jMwHMu7EwzMzBL3MzBskI5nMzDkJAkHM03c2JcN3m7hPCr3JV/dF+1T405jNNlTqQIEAD5IiIiIELEs7pXxvjdpJewks+973vZ5YViWLkCIA2abzBAze13vAI7k97Xe9EzLuwbvczBMzMzBcl7u3sRNvMzBNN3MwG7u7EsE9NqpEVDsARNhiqrGc4qsYvNd3f79PyAAEu77d63iqT6Hu+4Hoeie2hVD9+q/37BL/szMQNIG5u7iH9/V99377AczMzBMzMzBM7vN3eGQkQkkd3b3dOBDd3dwHMzMwT15/fZIyRA7IrO9sQIEAbdnx3UUkkkklAgJeSRJJ94lJJZhuBAc47eCBm973vRA7mZu6Ju7uYDmZmYJmZmYJm7u7om5mbuibu7mA5mZmCZWenaRKRIkBILCPKQJlpIba7YErAA32khU/NEynmSebrC/mSdsLomFmdfwz4ZqIba1MM5r7crjpxOnuZpObmV46+azQwhj3Ahy0IZMxseGOnq7MTMdn3dzrvZZ1zVlVA0wJV1rugYwRz3euvvu8zbgAifQjUbLPuBIdx5C8yncm4g7Sd80One2KOFqTjlK7ksNomFo6k3nUnTpJyTVkmhZJncOHBT3R20y00myjTqTXK4RycL3kvmh1o2VYyTvSHJGyWS0mXHFOc1jSNsYy1pOVOCcd650bUWDZrnJcXGuS93LIZunORkmqs1nA5w193WMtlTRJ1MX7rlUXSmlpM2FWU1GU5y+8FSk+pUAobFInoNMFRuIPvt7iqquUzTupd3ddu9IbFle7lQ94cjJoBckkkkMgLkkkkFAXUgD0FJJO073vQZoAOSSckGgAwA88ccAa73vOdvve973t+972veO9kOiAYyp9BklYoRRiQiCFQlSP3333ffe5v3va9v3vR6d9ebv1vVjg4eBQAAGjV3e7u7APYxXs4rY4LA4CgXf333333ve97L8e97Pbfe/InRSKqREgdzVVrPe8kjqYqsMgSSSSQ9ZrYO3VZq9TOtySR7ErLTYEoAQHve9fvfcvp3ZT35E7yKk4qQex+i/RMVI8ul2HouKkipHIHIC+he9rvcvqTS4JYObYWk1S2naJKJIhyIolBFG4IJ3tP7s/fv3BnOKqsVus1WKq7vl5vNG/giwqgCSSVQICSSR8jR9UPvevMgRk6O973BA7mZu6Ju7uYDmZmYJmZmYJm7u7oYQCTd3c3RqMYm7u7ugbu7uCYCeuhTod3dgTAiBAc8mDZz3N2ukJuajmCs3NvaUuLo8TnkgQI6xQ2Xxu3PgW+VfHLfA+0fv379eD+pACiNBZSnDlV+/fsEz+3d3RNzM3dE3d3MBzMzMEzMzMEzd3d0TczN3RN3dzAczMzBMBT9VADJD6P0igOXyIgQOZ73N7r1E896Pe09aTbRJJw97v7u+q/Z/Xd/v2A/wbCtqnYbNihebu3uiZu7mA5mZmCZmZmCbu847W7QlyRjJIbu7e6BUN3d3TWSR3d3cNhCH9zCRMVV+GQZun3um9KSJBJJJSRJPjJP3ve97v7M/ft7P4IjJxA4wxhx481RSESEN3dvdE3d3MBzMzMEzMzMEzK3a2bFN3M3dE3d3MBzMzMEwl+2wT9z0xOX6+83vs/L/fBL96ve8tANged+5z9+/YpmV/bu2pZN3d3dE3d3cBzMzMEzMzMEyZu7uKbuZm6Ju7u4DmZdiZ7c1n6qre/qUzWMUnvw0g5Jr3veXIBJJJJeR48zLsQLvc3IHZsTESJETFd73uZo1u7u6DmZmYJMzMwS73MwTMvc3RnHnOWTAVmS5kyBua3uu96rf337777vPfNDzfMWnw8qquSVZ1+1c6qSS1dSDmbzgV++uTB+Lq+bmS8t5Zk5ktrmTmtKsyVbsOxcz7dwW+cvMExz7bEySY5mWJcfByZkDneNEnTvfSkkfZPR6ve8iktbbxt036kqVjaim7iB0YN73vRAzuZnezMyAJdMzN02IZmcEwu7tTLu7U3TMzdEu773IgcnMzLEDayZ5uevz9726MSSPve973kUkkipSSSSt027ECxI7Mb3tdmAPT3MzcE+zM3AbzMtfo6bmWJpPjKzKE0u22ZFayYquZObu9gG75399983ve973s6SSSSUupKkkkksdNuxA6M3ve9EDLu8xIQzd3cE2EhGEhkm7u7shCJmZmYEkjm83d0uBm7u7omZmbgOZmWJn798Kf0BIAn8CUVIVWe4iWCfd/p7oq8KsTrhOE7/hOicxV++kpIuypVFjNfsxUjxufS6e7727CG7jwE04CSXmBXZuEs++BOC20CVSnIJKGoSZYJwc/Y84CRrASAlDCGjRk4UtTtNffZdLmwEGEigAcXClHkVeRKPSV37AedoodXa3ZdV9YUAz0K9QgGh1pEr2AI1fSj3te93ptfZfbu+2d1t0WzwoZeygQAkkkkgAkkkkgAkkkkgAPXnma97fvEgAXd3d3YNAKsAABF3d3frAAqSYxhWaqs5xiqxnGbrJsWCSScpd63d3YCgSSSSQAF3271d2HhsJySTmKkhwHRyt3d8vrEmtArBZlJdVKxisyXKglUqsgpJiSSXMnQ4s1KkkgbA6HAcC3mwD13XMVip3WMYrecVmqxWqrAlCJzPhhJ7677T4dgqX7tKn32/b9urqqxjXp6fXPt3VbnJJ89eZ8BLu7u7ISSSUkkjyqVuIF7mZggZ0Zmd6IHe973AOXd2JhmZmCXuZmCZuZm6Ju7u4Dl3diBjOcW4BwRnMpUFy17DI2QVwGYhSFKlSZn3q8NNEvzXOqSSWkj5cjZECZunlmR+ttmS8tvOTJy2smcttyzIqxkmyR05t7uo8hMM3dzWEd3d3Q0DMzLEB5kiUIqxAgACLmBAiIgXL8jOnFraSS6jwtLghJOwAEkliSpzDkat3lxEQP6Kn0BFG7v+/jBMrO7uibl3mCabu7gN3d2Jd3eYJmc3d0Tdu8wTTd3cDHOc5ysVr9neVe9vl+/ffgEZF0zUku7tEElJLyY7UdrMePBAzM3veiB3vc7ggdud3cB5zLsS7u8wSZmbuiZmXmCabu7pohGGZmZhJJJJmUCXlbmcu7vt7n9/Y9SSWJJC1rbbdLW0upLWkszHmN2NkZDMzjeUBUJAJmZzMEyZl8Eu7uwxVZkVWZFbbMlttsyXVqZk97uTnve/Xf334AAfffAJH333333e+73vzJiqzIqsyK/WzJual3bbMlVZMVWZFVmRW2zJS2/cmTvVNhfP2+nOZum14IKUkkT4jhPLktbr75tvMWpZkk+qSQf4nP36wP6SOZmWpjDMzMxDMzGZFbbMlLbZkqrJiqzIquZFbmRAb9s7V0kWe+OpIqUl4ySSSiSSSe9753X3vyj9Zkto6mR0qTIqsmKrMiqzIrbZktttmS2rJihMjP3Im9Vd33n6v378eoboOVUmpNVJEn4UG210HrzLoQKqm8AGjvc7eACRIkCYkTFtbZJu1GSXJbWZHWsmlFmTeRdrJi1ZkRspLmSkt2A906W/u/e/e+neh4AbkxJOyQHuer6sYqsd799yqxxFmTSrJgfLMittmTdu1zJvSpMnOc4Dzl5mCczKzME/vq/f38KgegJUBFSBERUiIAjaqulrosmjqgQPSAIHsqrP3rBNUgCeipzbeAkiAlz6yePewEgJETgJCzneX3PuWCn33egn2KZ2t7Kft7wPRC97x9yj3KSoqDICQrFautY5nNa1is61NVt3nrgUAIz5L+9svfTld92LyCj2IlQVKiDIiSWWk1WKMkwjjJcZUybLZNqlsqtZNamxtbLMTbJNtJhOFyk4ympapiYyTWFsI2qNaxZBlqT3bvknWqdO+OnfEpzWxVYM00mkyh5951o2KZ4uJP2UfdDvCv3OExMoP2gTYgnr4hxUCQV973vvr333Pvr973veGZ4bEQa1ozkLu7u7sAEkkkkAAABxv1Dfk13vd9SwAXd3d3dmgCSSSSoAErve13rwAEkvFT2s5xWs5zjGKrWdAlVJVjHrVBGImSRYNlBQKWKUW/YZEEcKhGW2y1kaiLKKyVopYLFLc1r73ve973ve97v30IMgXNgeCSSVJIAKACMoyDwnMySbkm4bALu7u7sExXMstJ277isVeKxWcYxedatIOhwSSSSQAEkkkkKAEkkne9973ve973vefvvrBAtEiCQFYCRhES7+Ks+RAvOEnvFcxU77KttgD41JqW4bhW1UaYainnvv2/vr+3VT9WsczVOYEy/e/fN4A8ASQ0kkk20svRsAQBmbtwIuruxAuruwI4ttyTetLa2SakttbMlqTJYqyYGXYgXdXYgFWTHsqz3vO85a3brxVhOXLtttYoAKAUpJNho63sb7m7u49kR6hIkbl1vRt9JMBWZFVkxX62ZLa2zJbazI6mlWZFVkxW2zJbW2ZHTd+6jhnJkVwTfKz25u60kkkiQSCSSmElS73ve+++y/X2375kxVZkVWTFeWzJu22zIq261mprLbW6zWrbWZFbbMlttwREcMgQJ4NkCB73ied171pJSkkkkrbbb6kiCTRLSruPMZsCLu7sQLu7uIF3z6XVM3qZNW0tmS2rJiqzIquTHVvByQM5lARwZmVmRAzLgQCu5nec9a3ea2q2BZ9WKqqAc+SQJ8S6nOPuVWFVmRVZkfraXMm7bbMitZMVXMySGZmYmGTJmZwHMy8wT1kpEtEiJZqCzLam1owhs1taqznFYrFezjFVjFe778a/ffvgAAJCSwklbbNgA5yBEDMbsCLu7sQLu7sQFTH7eZltbZktqyYqsyKrMjpW2pmZeYj+quQSQiJFhEkVkd5fERAr3IAAHPe4OngQnkxq12hMKVXEkrMsAAeSSSaMklAbMy5bt643PVUiMrlbtyYqsyKrMir5ZktrbMltWTFVEu7stchIVlZmPGYZmXglwKBIvpgRUVyApihMCyKoc94vZO+bSSSRIJMkkonxJJKSFbI2xe1ECpkVVCBQqqEDWLyzJdqzJYBMl1rQbmTewmRW3VkCbu7EDBvYEAwOTXiTvp3epeS4klZOhLJSSaPkgkkm2rxVbqgI7d3YgXd3YgKv1mS7ttmSqsmKrMiqzIu1pgEzOTmZgsCYF5yyKu+c6e83d3rSKSSSTgANttt4QjwCiTZky08vsTdt2BF3dsyKrMir9Zku7bZkqrJiqzIq2Jd3eYJlZmYj+9WV8AkASCwWH4EiCUCb7P7e3/Z0B6CcmAnEE7wAKEHjUHjv9T31PJ1hDvV+T7fc4H39VnMOBgJBSgSbXeGlJJUrO1l/v1/t3378vil9RltW013JoaTZJlTk0VckylaTjkpNJ1lOiTSTVNJqrUWk87kXA596Sp25r1pPEmk1rtIbkmU5j5kl1JoXVuSfeSqHJPxwrm2MtimUNVXfJJlNEbMbkm4TjiXFbL8dddcSY/cdUmbM1lYsTpTzqk87nKTVJ3cSbcwMVzNibMZc1Thp+51TOhVslgTkmOZtU7a4dSc5izW21MyTC1RuucLE2bIupEAfcBXiEZ9EKPUJiJ66VLpB6z5rFYpPTl3dgAzvNmhaAC7u7u7ABJJJJBZoBwHQdDiuc5zgAAkkkkMjgOySSSQAJNySTsAAKkl4xjGN5qsYqZxVVjOcZzJIsAJd3d3aAB5NSSSQACSSSSAAkkklZzIAwF3d4xWKu7saJWGcVnItJdYxipmZkkZLqsepo4iXVVMZkkkPDYLxMySSR2UycBO5knJJIyB0K4J2S91WMYx7GM5zK1kRPKnoqnyqSKnVTADgIx73bv3fEEuykBCInEoBGJFH6jhN1d8u5+/g5mT8/fXn7vPwQSfsVgDT6JMwekkvyZ9PczG7gRd3diBd3diBd38ycmS7ttmSqsmKrMiqzIhWZLS2gCpAgDleoRgq+qyKzFh2torsJLnUl4y/JWkk31KQG+NtttGRtdmLm53bsdmZmakpbZZltrMiFZkslLbMlkulcyGTTtWZECZBVmS222ZH9vNZl1Dh3q0bx62kkl5STJJJKRJJJJK2RMcnYffEZMtLbMjVZMAWZFSZGK25AkXN3YgXVUBFVVCBWXdiB4y55Pve9vtJ1JJJIkknhJSRj0mSSSU5MCuOtwQMzMzAkkSTMzLwhCGZmYYQgZmZznOfrLbeWXdttVVVh9fuZ3Wi85xefr3n33qxIJWkSSSSViRokkkp+5yuN1VVVVWqoAqrbbQBiqAch5Lu37n33n2u9DhDQCybkknZmPt53nf2vv2q7rvbaqAMVQBx1kjqR1jd5Lu2oFl3diTo5XF3vMzM3myd4ZcT5t3AqbbdrOmwZJ5BaQNHpJwlee8HZjM3aqq7d3dVVX+lttttqqgDFUA89+3kmtc593zz3zvP3PvvjoBoBYD99999XO13XOfffq7NW2gFiqAAFiqAWKoA5mWCJEDKESlYiZm7/f39+vP7+8Z7fe9neupJcSTb6TJJJK2BA3y97BAgZ72+wXd2AWKoAAVVbbaAMVWyZPtyZXfamt85u7+7+/bfp8oLZmPsAPvvrNHe971739z2ct9APlVbq2gDFUAAN6da1rMzeU1xCGACEFVTH8MIef3aoEgJ9P768L+37N/u/eENvnMqVpKcgaRFFM+wzEurQgh9zmc5zJxlywhUSodcYLgQ3Qy5T7VVFkTSWIJ0EiCchy8nHrCHvpXsqrzu9+973veK5zvdPevktFK6IHoCCHIibFAkVFSoqjwiIDZTQA782ce81VfSpBc+1EUmtHfUqCn0AT0EHYAL1Uip2dSKh66AQPe97fVnPvuXftXRsunnuM642yadTjht0OemqzqDw3N2ZPLOFS5mSSCuA633cubqtcnp2FluZbbpm5Wu+zeec5u8292DkDh6pzVeW717u2aQdGhJPSZkgIpZq81qSSV6XpAjIL7eQBAMiIgYAAJgQDJNleXVKXEkksuZ56+X27sFGwtn2ZJJPQ3kGR7GZNy+yHGdh0bZSTkk3MwOmqZZEklztzMc65lMUz0tJeMVisarOcTU7JNo7iYzimjhur9iu5vN95dgAckk5JI3QHgAHa0HcjsJK7nmdkyq8Cjz6hVeqniqvgDv21noqZXmq5w7bcnMMZaptd/t2XdTjISqr3pn6pIS6qxALCII+gpt0RXJ7gIBpHc+TyIiIMxAgQOTAge8Pa1ta3iSVpEw0kkk2ySSSSmOyAAKpu7u7qqr5c2tqtVQCxVAwAwvk3rWm/uX5+5z45cEmiTWmNApJJJttN02220d5dXWx8Bhyy0sulKzSu97IAgb3usUfe9O8u7N+0k0dalEklkakrSSb6Wkkku+zs3v31iqAMVQAA+dKoFiqVVXAEREXIAFyBAkDKXe7t7vkSSTpBJJJSRJkkklEbAgWM5mN7d3dVVXd3dVQqoAqoA2222ZJmZrWZJMjqTMzjE5pF5inT3hOYmyPuq5oREReDnGT6mn5EnUj73mTZLXi/VSSSXff1vZb76AMVQAA+ttttttVardVVWpAgYN4JkCBXo5MRfvPVzm6ySCdSSJJJJKJPSeElbECIi94Lvdqqqqqsu7dl2tZd21AsVQAAutTWplbrnOfTG+uySdtJKySSSUS0klgSc+3ABHLE2a1kyadn3yBYqgG97KrvexjtTe8wRN3b4/DlVXZEyABPs7eonS0iQSdJJSSSwkEkklDYAjZkCBIi5ERAqbgc3eAF1curq6AsVQBCluy2ze7dZNFXnt8bmKuoFTGSO963B8o76faSWhrbbbbaRKSSSYgRomq2ZWYBd1YqrGVViqriG7qRVVd73W6fdc/c3p47k1q3W+fuTd1yRIFe3dG6tgk6kktDbbpttleSSSR9mZk5rJkk5rIvfQAA+sttrbagMVQAAqo84a81Jk/TzXP3hJkHUkzWtzEIUVCfy1X+Zze9/UIWv7d1CCwh2lAgghC9vNUkFTN5X51nXBHMzToILrKoUnbfqPL/Ew1eFLl1kqb3sPWelwgJDu39YJCAnbTf7e9qv07+v96/fye6p3pPjfzsV1ZEybbMLM80cpNJ5wnKptHkmaqNKRKFV2vcDhwb4KuNUqrxEYRbbKWT5wcpMbQbSmFtJZLMLahlNJjQtJ3JkuTNRbBskaIc5Sdq6hOYpjZTNqq0n7E5JlP2jmNJ2cScRWJtUe6i4mn7ScmorM2hMTBlpNrabW2zSY+fuulWGtsxLYNZNpXbHM2WYR7xCHs4Eg1MO3SSHEgaT3texfjed7vt9tkbBkabklzttAEgBYAGQCI9oc3KkqTskABLzes3d3q0G1h5EkkkuBsOAUJuB1k8Kkkl3cAAux6RAETMQAImREGeSAM4SbKKSSSSSmru75frPDYNpJOyZkAgl3d3erQLLNJJJmSQIAklSSSHQ4FPDGNgDAHL9ed3d2ACjlmjoADsk3JJAAe3fr++1EoBpU+ipf3M9qL73ub6ClCpZw5733trve7PJDqlEUSIkhEW0ddcpdE1NqliZbQtmtA7fu73gQmJB0ZIE4yD1nrj3vdZ2kSSaJJS6ek8JJ89mQIEiZkCBfaHMe3d3di1QAAZzU1baAWKoAAW7nZ5nck1giPGQ1gPu41REk6ZwpLRiSVJJNdfe973ve6nPr1vt+VLFUAAKqKpY3d1VV9Lu77dn0CIFKuVnM94T8z3zeHvq9PfntZ6TwriStI+JJJGxEC9AgcF8t7dRVYLcUIGwKx2pvdgFA2QL58X3Rts8znH2qxjWH331P33V3d3f0isfgD4kDve+yZM1r4+7YBYKgABYqgFirVVVVVZkVmOxVXdrxHu93N33vZ33iSWkku973vfPPPPPPPPc3vvv1ttAKq2KqqgFi7u6qqqqrMHssTzw957ve96e+9pJbbbbbaRJJJPmAIqk9zMzLu7uqqrF3d1VVVBVUAVV1Ozm9b1Jk98fJOTs1vzUvb+XPTpnp0rbSSVpJqcPve93ziICkARtwATT79zltqq1VqqqoBYqgABgy84OiquwIF8HhN4K8t7tbIPd8/eHpW6sSVrG3xdSJBJIYiIHeh7Bn3t1Xd3VVTFUAAKqgDZbbbbb36+mtj5PH2ek+9167u/z8UB8E1JJPZfVjFYx+zmTIa/cPveRVAADjpVAsVQAAuIZmZlX7Ib2Ck5Au+ZeaEd9n97n9/buave9u+973veRSRJJLAEAXzaum6qqsXd3QABVUAVUAbMu7bPu7Dsz3WTI9BPtubugllQ5m/syt3dLnPjOXf2TOSQlaXd3e5f38rFHsFIRVMEWmIGLmbFcJtq5XM2S5Uxtwxpjc4c1rbmKcVXOcJiaplyEGBQ3LJZEVYAyOgbuYUkrOVTKJ8+fe5PPLiaTWFftfAo8EK5XOeRK4iZYLxRDipw4rXCm+8u1OgveudYrUtJqffkn79xR4JeqbM9dKdSdKGwPIKV6kQaBfHDhzmImA+gXxXJCFJCwRBFENa973dF73Oc3w94973vDXXeydnb9IALu7u7sAPZ4wdPAALvlXd7uwa94c4xete973eoA0E7d3d2gASSSSQMgFVd3d3dwAGNKklY9n3XOVWKHLuwA4SckknIF+NjHZJuSSABLu7u70gLMiSS5UkA8U27JNy5mQCvZs1xJLxiqlYrFZrGKz7Um4Ep7Q4u61d3d9DYHiVTegLSmtAJjGJTIBKZB73vc5NminsVXp3AHZSpzvFThFT7pSpPYdgWqfYUqd+8hXObIifIhiql1QkGCJwaVKjJ4gN4iYzAgJGvWeJ09AAqBMwKR325m9fvee+973veRSRJJPXomZAgTI7mN9i7u6qqqqrt3YqliqAAFVU9PDZud8nne/vPL7zfZV3f6dk+3d3d3aAEZzVeqn7dazzX37nOLFUAAK6VQKoOldb1tJnN7ec0IiYmAAB6Ree3c3ZHve9p75MRqwJJWm5SRSSSQYAjZkCBIiIHV7vd03N3d1w2AqsmlHUkDYG6aFQK4q/amSSa7eMfe1WM5xiZqfcT8/ffXdySSAcB0m/PPPPPsx/b+1qTI637x7vYaApoGIUBTWtaMzLbvHMv85d7pbrXNyxRVnqTjALDsl71Kz4mySdBJJJJSRJJOgREDcwOsD1AACulUCxV2aAAqqm9zwkCqsldW+09JJJJJKJJJJKSJJ8857JJn2tSZNL76AVVsVQAAqrbu7zM5mZmXd8fKiKnlH0eHpHenTvtfBoSKlLqSpSkkkkepOA222HI6xwbzg4AuX74AYqgABVRVLFUwAgFe+vNZ9it9Z9y32Z+3Y/V977777gAChIkkkLYiB2nu+Hcy+c5QqquqrnOUMu7zJFzd8yZGZmVVVhoYeZta9Jokk4SWQSSkkrSJokkMe0cu2aqqqxci7wZl3VVWBVAFttHSqBLrm/d5nOfoA3x88uvvP370mrkkknygABQd59jGK39Wu7PYBve/gBVoAxVAVVcyWayS3MbHJyi+d3x4BArNklYb6OgQPdS9YEBTv20Cczrf218KdnO8L0p5KvPbypn05f7UTUTndvoVPpyWCft4/oVmfZthjB511Wd71qs7rGs49e/lznYN8BzwdV51U8Z+nPfsj8BwUoUgpSqMgKRFOcNsbYxNJtUxmTbNZjmrmm00mqbFtU1WRYmG1PD92HTVWlJt2pyU2pG3JDj33l3J3S5ZKnHOLARFIrSk2INfrBT6O1ikh+lgvxFAH9DbBaUSr9QHm5FMr3vZmZmETQDXCT3Pemp3sM5M5Bd3d3dgAoACgCSSSSDw2MX73verxAAkkkkgACgHMg8BJd3d2kABhPXjFbzXzMTN4aENIhlpWVnDRhTGGCFc1ndY1jG91nGtyd9YASpdXd3aQAGJJJJIeGwl3ckkPDQoMG5FDzpkHibkkkgs7TNc0OuyaxjGMTMkkEqsYrDIEkkkkOA6FcB0OA6F3d3d3sDw97Nu6toRPs+VK+VOZ7ip7O/APtPsnxjIIBipSpU7OfY+IxUkBYifZNJw1TKhgtK+XAnvnd1D0UO3S+j2Afog/oI7Euv19/b73bnxJJJJAAAkk39+znNVzn33KruJrWpltrJcmrbWXWW2uSKoAAWzMzMzMzMu7u+TzRXKOXd7un2rjCSSTbdEkkklJJEk9amN9zvcd3d3d3d3d3d3d3QAqnNZLa1UsVe7121vff3333vve973qJZJJJIKSSJJ7PV3LS0XO5mXeZlZmZU3tdK73t7bo1dS65Lbag9nrLynPJ+/fv33wAJJIDgbkk87uq4v7lYyqzANofNiqrYKgDANobdOtaHPK773ZenUsPjRJ6SqSSbbbbbZJKv2R1j778ttoFhYu4aBiqb2M0q2czMzLzMwCBs06fvZ7N9upEkkklJJJJJJJIknXlW30Xd3znLsTd3znKFXF1c7l5l3V3guqsVVWzV8kcpdJ73fajr4kkkupKiSSSSkkiSdD293Oibu+c5znMu7u6y2xVAGKoB515M/ZMmpmTWpMkkmskwKfsSckyqU0mlJkIEgAAyIECyd1bu7qSSSR2BECBqSS973Z+973ve+7sv8D/CJIiRYRQGImsySXT77aqqtiqAMVQAYra3d3d3j/T0AX5EgVFpEgQRIryK5xEoUCoqlIkA+lIkH6/vf39X9+/fpPSSSAHjbgL79jGC7rGuYrGP1Pf1iqAKqxVVUAYqgABbe5xU2InpESs4GokFAYrAUNJklqaX9yXJMjSYNJksTbE0mGk1JGk0C5iBfSNbe67JJvxksQE2228bS9iVLvfPO+zJkn2TJqZJmRfvqq1VVVVVVVVVbbaVtr8ckzDvmT03o9Z5ZIYm+0Ib/ld7XO/zewg75+7mwqbvihD3FA/5P/0f5/qIBICqIJZX+v4+/1J7f9Q5z+OKTEmJcrsIbtQh/RwIchDP6QhxJvSbhO/Cddk3Pv254T5uCbEzrb0nfUnZOdk3WJuic4Tmdu9BMBK2kSkSVc4icBIQE5yTiCZ0EqC1fKsWhasGoVXvqRNBJ8CfdBJy9KUqBICSxfu0Kd+BL2u5hwurur5nwOe+2clwU0E6iVJQnXhOE6dcJzom8cJ34Tn3wnl4EM5rsIXR41zDEVF1aEOBC8w1pE4CQqS25JJZnD6aicwEroJdgns1E4Cffc7l/FAmdBMrgJd3zd4KXvjoQ1jozmnqW+dLu+1rk57m/rR+8EfpPNifSc8+E96J2NmJvpPnRPnvZPCdSd/JOycxN1wnWEyAn2QSZ0E3fffQE3AT7ASHQT71PASugn3QTdBN+NO+Oe3dObnZsCd+pOnpN+JsTr0m+E3pPCc7Jzsn3kndJ14TonXmU4T58w0EzQSYCZwEkBJoJdAko7yqN+ze/Xmq7vu9xwzLvfc2Kiq93bbhn3rzICdgJPYJdUaCXQJPsAKhPrBJ98CXQJKw+Fz494EpAyBvQT677PPHF9a7F1TXczXLvXTFzdTrvPJ7t1b1+b3RhzXNOsXd0fFKmezFmzQ7065ihdnC8T5Nvzjj3M3muW6d9KF+7dajl6NRTWZ3VdO+1TuXacbluUMYs5eYdeHGw0re8xcV7l33Zm3zNrrdv1dKcem/jucd9Su8ucLjcftTWd7a5v16nHrp5fs4SDXz+y/u3mBC1uv2b/c9roQ32/vsN9FVf2cY64qfOBDSmvt7N65h18EO3zrt6EGrlPud5za/Uq9ylfrrFu/sOMXO/c1x6rp5u9dOt9wvLx5yEPBB6CbgJkBNBN78CYifWCc+BJ8817pq717x19u95fsX1t5lwn1wM50ylmbTZTKDvXb7f3OBvIQvMvuZq57pxutA87eZgQvGu82b0U7m+Y70+7rqd7vOLjrLe7ehB6EM2ucfzmLf7uX2+ry6uOfEmVXmfNOaX+GftH33Fe2vL6284G3N7MY/y8r8EOc3x2Z3Oc3g504dL77ngh93VXludeDPsznO53lpU048SGyLjiHE+7ZJkdhOzmgneSWE7svvj7veae9KzwJ4yI5vt5m7wlgVQeK7hDmOa3mzNGN00cpRLb7fRwrUm+9uTqZ9a4rj4IPHd1mBDrzYQwIa2gQToQtCDvCddE9c4Tm63pPOiddk2J1wm98E523pPiudk3qc4TrhOMQLAgdgQKwCBXgIFeAgSpy4t/f9B9B/Q+/+B+n1v+vv9R3/n8fabP0tYOj6j7D59p+/v5/+LuSKcKEhMqTo+g=="
extensions = []
extensions.append(""" [ "-"   `2000 "Turn on reporting of redefinitions" ] '+warnings' : """)
extensions.append(""" [ "-"   `2001 "Turn off reporting of redefinitions" ] '-warnings' : """)
extensions.append(""" [ "-"   `9000 "Display the stack" ] '.s' : """)
extensions.append(""" [ "-"   `9001 "Exit Allegory" ] 'bye' : """)
extensions.append(""" [ "-"   `9002 "Display a list of all named functions" ] 'words' : """)
extensions.append(""" [ "s-"  `9003 "Evaluate the contents of a file as Parable source" ] 'include' : """)
extensions.append(""" [ "s-"  `9004 "Save the current session to a snapshot file" ] 'save-snapshot' : """)
extensions.append(""" [ "s-"  `9005 "Replace the current session with the one stored in the specified snapshot file" ] 'reload-snapshot' : """)
extensions.append(""" [ "...-" `9006 "Soft restart from the basic snapshot and Allegory extensions" ] 'restart' : """)
extensions.append(""" "File Operations" """)
extensions.append(""" [ "string:name string:mode - number:file-id"  `201 "Open a file. Valid modes include R, W, and A" ] 'open-file' : """)
extensions.append(""" [ "number:file-id -"  `202 "Close an open file" ] 'close-file' : """)
extensions.append(""" [ "number:file-id - character"  `203 :c "Read a character from a file" ] 'read-file' : """)
extensions.append(""" [ "character number:file-id -"  `204 "Write a character to a file" ] 'write-file' : """)
extensions.append(""" [ "number:file-id - number:position"  `205 "Return the current value of the index pointer into the file" ] 'file-position' : """)
extensions.append(""" [ "number:offset number:file-id -"  `206 "Move the index pointer into a file to a new position" ] 'file-seek' : """)
extensions.append(""" [ "number:file-id - number:length"  `207 "Return the size of an open file" ] 'file-size' : """)
extensions.append(""" [ "string:name -"  `208 "Delete a file" ] 'delete-file' : """)
extensions.append(""" [ "string:name - flag"  `209 "True if the file exists, otherwise false" ] 'file-exists?' : """)
extensions.append(""" [ 'slurp-file' ] { """)
extensions.append(""" [ 'FID' 'S' ] :: """)
extensions.append(""" [ "string:name - string:contents" dup file-exists? [ 'r' open-file !FID request !S @S pop drop @FID file-size [ @FID read-file @S push ] times @FID close-file @S :s ] [ drop '' duplicate-slice :s 'Unable to to locate file' abort<with-error> ] if "Read a file into a new slice"   ] 'slurp-file' : """)
extensions.append(""" } """)
extensions.append(""" "Command Line Arguments and System Integration" """)
extensions.append(""" [ "- pointer"        `226 "Return an array of all command line arguments. Typically the first two items will be the scripting engine name and the source file being run." ] 'sys.args' : """)
extensions.append(""" [ "string - number"  `227 "Run an external program. Returns the execution status." ] 'sys.run' : """)
extensions.append(""" [ "- number"  `4000 "Deprecated" ] 'arg-count' : """)
extensions.append(""" [ "number - string"  `4001 "Deprecated" ] 'get-arg' : """)
extensions.append(""" [ "s-s"  `5000 ] 'value-for-key' : """)
extensions.append(""" [ "s-s"  `5001 "Return the value of an environment variable" ] 'get-environment-value' : """)
extensions.append(""" "Terminal I/O" """)
extensions.append(""" [ "v-"  `6000    "Display a value to the screen" ] 'display' : """)
extensions.append(""" [ #10 :c display "Display a newline on the screen" ] 'tty.cr' : """)
extensions.append(""" [ "-n" `300 "Return a Unix timestamp" ] 'time' : """)
extensions.append(""" [ "p-n" time [ invoke ] dip time swap - "Invoke a function and return the running time" ] 'invoke<time>' : """)
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_NUMBER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
        parse_bootstrap(extensions)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)
#    parse_bootstrap(stdlib)
    parse_bootstrap(extensions)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
