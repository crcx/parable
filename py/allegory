#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack
    if type:
        return stack.pop()
    else:
        return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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9+/fvfO1VW5GYFBREbm27u7vnOc5zm+mxFpGWVVw/H753z94CbCD9lVfsPkHkqA7H69kQ2F7IC9lBHsCPYUM7gi9gBHsiImUkkU022U0kgn5COBIAfkCkkhOzEkkk5JkPe97vve173hsmpA2XJKmSsz9meaakD2/ktp7SZQkbv20m1uh7rS/HEg4Uylu7NE2to3d1FFIufhHMPqhL5nzA1pdEJGbs7sLWj5i5nUkiki02uJoplFFLoAARJtNopvzyNea881HkkSSSXVVVVOQAACbiSST9eTzXmuc5zmSwAAM3Hckkuqqsu87gAAGb7m89zva+/Z99OQAADXye9dkkr792qqcgAAE3L3Nzva+/T76cgAAE312SSXk815rl3znMnAAAM3ickkuvvsqs7gAAE1nuM/Zkl1r7776cgAAHk312SSXX33305AAqqqqqmVip88q+nQsCSTkkUknpKkz2Yk7JJJFBQJJ2YAOmQHEzJJJuAbJz4xr1D7var0+lSanve9496T9+kkk9AOSSTMwzMzAAAAJUk/JtSSTo02mBQAHr71d6YVVVVVVVVAfanvXZKkusnmvNXVZPgAAO6z2JkqS6qsqs7gAA7vbus9/JMkr779+lwAADzu+TfeyS7qvvpyAAATfe772SXdV99OQAAVVNlck5AoPZlPaaayspvG2sz8r3hVUAAHue5m8zMzd327u87gAAGbk3+73JOcqvp3oABo71P0m/vs+33sy/vubbbPzbhtDadZICD7umQMc++3z9ve9+nf34MjYTbBJJjna73vedkkqSSSTswAdMgOJmSYkm4MEASSJtABu7u6lu7q3QAAkkyVmZmZ70zM2mntJINADJP00APEkkkkgm0kAcAD3rvoJytpVS5VLi5zlcVOYZm5+/Z+3t3fPOc4Kcubv53FSysoqKzc3c3e7ueefuonvvvu/ekTeQpmWUWmbk3JmZdy7qsyeatsAms9zN5WXmc5dffZ3oAAE33u+9kl3VffTkAAA8m+932RJd1VeeeaqpyAAATcm5JJd1X31TkAAAzPczeZ3Mu+zzXmucu+/AAAVru8a3n2ZvMrMznLuq5AAAOtv3s/d73tX3JpAHAQBPSVJJIGRSZmeMzFl5nMzM9MeAdMgODQGwe973h5JmZkiQAACUgCAACQOhJfZNk0kn6T8AAUP3ve9n3ve93vOb31jGMAAHnd85vneu9u6qvPPNVU5AAAJuTckku6r76pyAAATcm5OSXeTzXmucu8lAAATjP2ZvMrM7zl3VZ3AAAM333vve5Jy6r76c6AABN97vsiS7qq8881VTkAAA+E9k3K72q+n31TkAAArfe77fe1X1/fd50AADseybn7varO+a81eau8lAAAd/ZPP37X73X59+32b+MJJfJJJAwKAAnsWZmZJOJtSRMySSc7MAHTIDg0BsHvCGKk2p+kJ9lexNPMxQ3m7v5prY93jbWpboHpOScbkkknm2pPlJOral5abX0xN/TPpnyMgVyZarXWve7v3v33pn3h7nLuqnYAABm+933Iku6qvPPNVU5AAAPJuTfe97WqlffVOQAAC57JuckquV99J1hret614a0aNBbzd4dC72+93Et1trnK5VKnzjTVb+DgZmXdV99nIw01tppo3jW5NzMZl3O+a81znNeea45ksAADme5m8yZl3VffVnMAAAkn6Tkl3VffTkAAA13e9yT6SpLuq++nIAABq+T6+Jh022xiEVVEoR9cZPzEj3vvuvu7IDpgB2VJJJAoARgA6ZAcGgNgntT33tG9ve9vZQr3vvBtT4GxJPw8xdXTB+k3MzM2SAABJIAAWSAAe9d96YVQAARrfe772SXed815rnLvJQAAEz3M3JUmc5d1WdwAADN97vvcku6qvNeUqcgAAHk3JuTsm7uqqpyAAATfe772SXdV99OQAADupvXsm5Lku875rzXOXeSgAAM3JvvckvOXdVncAAAzfHOZ3uXVV5rylTkAAA11PYk7Jvt1VVOQAAD9v7T31Pe97c57wZAdMAOypJJJ0yoARgA6ZAcGgNieo+JPgZoPHTOR4dST0k8JPHe+73ve+9Z7bF1dDSSeA97zAPd5ze/T2MYAAHdTevZNyXJd53zXmucu89lO72AAM37N9rJLvLuqzuAAAZuTfe5Jd1Vea8pU5AAAPJuTcnZN3dVVTkAAAm+933sku6r76cgAAHdTevZNyXJd53zXmucu8mrq8pKWlszDMt+d7ne7u+ec/ec5v77aTmFmWYKZm52/ft73m85wHlzfdq3MKqHjrPcZkzN12qqszJrbYABr7feToq5frT9Xvd/Pe8+7me3QA+/HAAFgUSQdlSSSQKAEYAOmQHBoDYkkneyYknjZ590aPAYSk2pJxpqAEntDkUmyS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1d1VVOQAADzutT3cnskl6u6qqnIAAB3zU93J7JJeruqqpyAAAeTck9kkqsnmvNXd+6vO+tXvQuVSpcpprnOcVKv3H9zq5z9vd3d0AAD8HvecGQHTAHxFNgCg973veex73gdMgOE8+D6OJmST0zO5eVn3JmXmcJI21AAMz3vX6vTPZOOcgABgG+PIPj4A0APwBuJtZnve9v4/aiZmYRJm5u/d/t3d9985znN9/VVVQBNyT2SS7uqqpyAAAeTck9kku7qqqcgAAE3NSeySVX3330uAAATck9kkqu4155q7u87QAAE1nu8z2SSqyqqs5gAAGbzM9kkqu1VVOUAABNyT79JJd/fffS+AAATck9k799+/T6XAAANfvkvX7fv7f0k5Vyd73vfe9704MgOmANEUcAKAEYAOmRsO7SSSd7J6wM1d0SZmXmEkk+kALEiwJJJ73jMzMIlJJJJAAAJFJJP0hd33pZhVVVVVVVAJuSeydqq++lTkAAAm5J7JJd3k815rnOcyUAABm8zPZO5d3VZedwAADNyT2TtVXKqXO0AABN7kn6SS7vWqqqnOgAaNfT2SeypLu9aqqqcgAAHk3JPZJLu9VVVOQAAC9T2T97JJd/fffS4aAADup7J+9kku8nmvNXd3naAAA13dSc5vlXX6/sUr6pfe3JAPwAS5JySSSekqSSCAghAEkkUAIwAdMgOEkkqd7J4yHgkk9JJJPHvV73vJ2u973vpAUpJJ5NqRcgAB5NoOKaAH4Dfe73vcvAAAJvvZ7JJd/fffS4AzbW96NPGs3JnuZmXf3332XjTTRgBm5M9zMy7++++y4AAB2eyfvZJLv7776XAAAMzP2Z77mZl39999l4AABN97PZJLvJ5rzV3d52gAAJrPcz97JJd5VVWcwAADNyZ9+kk5zlVVTnQAAJuSeySXd1VVOQAADXuvq01qfSSq1OTve97393o2GgR3JkB0wAQACgBGAknJ3vUk6u7oAkkkkiSTUk9PCd93temZJ4EqpJJB3ve973vJrve9773vZd3VVU5AAAJuSeySXd1VVOQAACbknsknec3rl575rzXOc91k2AABqs9zM9zM5nOcu7rO4AABm5J9+kk5zlVVTnQAAK1PZJ7JKqvvvpcAAA87vvez9JLu7qqnIAABNySfpJd3dVU5AAANam5JP0uI81rjzjWucz3zXmuc57rH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ALnsmfaz7MznLuqrOYAABeeyftT9JLu7qqnIAABq0k/alSS7u6qpyAAAOVyvfZ977nnceZ/e973vN+z7zYaB84M7AMSSSRFBsPigBGADqTMxZnsySLQAwA5IAT0kUzLw4sJMnfSd76SeJJJ2ScGh2rujPvCnve9d3dVU5AAAJJNSpJd3dVU5AAAMz3WZms/ZmXd3VVnMAAAkk1Kkl3d5Neea5zmfoAAAzMzWVJLznOXd53AAAM3kmp+kl3d9u7nfgAAI3JNT9JLu7qqnOgAATck1P0ku7uqqcgAAHk3JNT9JLu7qqnIAABN97rvve9l3dVU5AAAOvPPPPNa159TbbSfaaScpJNN/vxd2HSmmsN/SSSbw95sNChwZBrIYnJ2SIoASpJJJEYAOpICBJJAAkkkkiST9dVdVJ33e993vpPLu6Al3dMAODXvelTMk97v711dd7383jAAAcmftuc5k5lVWcwAACtZ7uaz3ve/TWrvt3c78GjQBWpv3pUbu/YH3szPt78ogYQ3AkRDgeoP0c+79uh79+/d82tFMywjKwUzLCjc7ufv377ob4c5z5vu1opmWEZWCkZWFtu+fO97zhvnOc33a0UzLCMrBTMsL8e783+37/bu+eHneonnnm/jkXAbKwnMBstzve7/bu/vfPv37vmk+4DZWE5ill035353f7d3znBT79+75pO4pZWE5illgAINIR/ZSkaJYI/siU/f2qIWmwaQILh5KCJjZmXP6ZYNiG0oZ9i7urur3zs799r7v79+kkk+k/Gw0BwZBoMTckkRQAlSSSSIwAdT6HDhOMySePGxoeBOzHpJO945zjvUgAGACer3ve977weu+96eFT3iTrlVxU+cbVcreG7v27vr+++3mk7gNZlhGRH4353d+/27vnP7+/t4dtoADee9yZ+zMu/PPNX999l4AABc9772fpJd3999LgAAGZ7JM/ZmXX79+vLwAACb792fpJdV999LgAAHcZ+z3M/ZmXVfffZeAAATfZJ+kl1X330uAAAZnszN/t3fPBTzznOb7tVVVVVWQCH2P73iSaX35Lmpb79vt02NJe0Pkgv8HFYbu7/fve0DDgyIOncmgRQAlSSSSIwAdSSQQCSD973vASZmZmZSbRUTakkyxtNLJMyu8pNNLCT5ptLKwz8m00spPMzCQCSSaG7mZmfsyXd3k155q7yfgAAJnuZrM/VJdVn32cwAADN9z9J9knKr999L4AAB3U9nsn7sl1X330uABzewPJv2SfpJdV+/S4AABzzXZ+nsn6pLqvvvpcAAA+1qe9kn6pLqsmvPNXd534NGjwms9z3M/SS6rPvs5gAAGb7n6T7JOcu61rylTnQAAJuTMz6Zm+cu6rOYAAB9XUXv793V98utc77d35qfvpJvTdz7Q6BDoAfAAWAfgJJcnv0+n0kmekqSSSSSchqruhsoASSfYkk39V3Urvdd73uqu6Sg933vZq7o5QdMeSXJd1Oym1gNppW2vwfNNBYFkvM5mYZNqkk9amZmZmczJmZmfsz7JOcu6qpzoAAE3JJ+kl3d1VTkAAA8m5ck+/SXd399OQAACT2ST99Jd3f305AAAJvve9/SS7v66qcgAAGZ7mZP2Zl3d1VZzGsG/NGttbNb34llw35u7v9u9888879RPPN/f19zKKqJjc9zMyvsyc5zlVnNcYAAZuSTPsy7u/vsuAAAeTfe97PpLu7++lwAADtp9lP36r81Paz362u5kfeTM981rzKTe7v5/bu+3dze7oHwEnZJP0klyen04A6YGw+VJJJIKAEk1JMzue8ve970xTQACTMxZmYZmZ4abSzxmZe1SSaU4nobu22mlpJ82mlJJJ7Se973ve973ve9+727u/vu3AAAJvve9n0l3d3k815rnMn4AADN5mZn0mc5znLvO4AABm5JJ9Jd3d1U5AAAPJuSSfSXd3dVOQAACbkkn0l3d3VTkAAAm5JJ9Jd3d1U5AAAMz3MzM+zLu7uqzmAAATckk+ku7u8nmvNc5k/AAAazeZmZ9Jec5zl3ncAAKqq5+U5XFzfyXd3fk1u7gcthJPuqSTsD3vnbq6YYbDQHCmQHTA/e973vUJJJ4oASSSSSd76SSe90B5JJJyezJO9932burqu9776pPHqEknOTve973NSSSSSfd7d3d1XeYAGjR5NyST6S7u7qpyAAATckk+ku7u6qcgAAE3JJPpLznOc/TzXmucyfgAANfaz3MzM+zLu7uqzmAAATckk+ku7u6qcgAAHk3JJPpLu7uqnIAABNyST6S7u7qpyAAATckk+kvvOc5n3mvNc5vJsAADX2e5mZn2Zd3d1WcwAADM3X7d9z6taPMHh5XOZrWtaXWVCXfb96zZq193fwHrLDv6lSZZu7v27psNAcKZAdMAEUACgBJJJJJJP1A969enve9z2PEzMzMMJJmdbTS8fvexprCWDaaXJ7kTanXKTbaclwACSQYAAB2T3ve9d/ve1rmBRJlhubu7v3d888885zfemwpmWE5gpmWEbbu7v3d888885zfd0UzLCecTa5yuKltbu7vd30zMw6knmad6m1znOKsxEzLCczfm7u793fPO++++eb+8tXIRrMsIysVzLC23d3fu755555zm+7bkLmWE2SpmWFG5u7u/d3zzzzznN9N0UzMwiczIpE3N3d3d5znOc5vuxEVtVUYzMzMyu2u7n7Xnmuc3k2AAB5m8zMySqqqy+czeAAAY+V55rXjRHVv9/NxH9p1nW9DLqqZre4jb+iKIAA1y7aBBDiiBClgIH83+e+/TeIEHhxGNQpEiINqabbAEDCggBB6CJBoEEOBpuR8/UxuFNx2k1G14mYLrJHjAQU2y36ZmNjzMYYK2mvADv17lmCRdzV03TYXNnoz1WZACBohw6vZNcjgBBkR70ghJ0DgBBQz333cIQ6o1m+v9369cZxd/b+upnar78xAJ302imFeC4bgREQOIkFfvuSEGCllmKl77v7733z9++4kYzfATdlUwgyoEJVEgwR/SC4oKxI5znOffc+4IwhZlMznOc5znEiVi6qqtkAutVQUxdXTgl1V1WLuqqqvTSUOixruzRu64BkSr3kgcsaYEm1UZFVmMyqjFbznPue85cT6SMMykMwUYxilcznOc5z7mfqF3iFpUcYqzFZjMiMKMhMSPyRioxKQQkBigBKRKChUKURgTWfv3739+9/cuZlUwI7E0qXffOc5757zmqRmEjFmSRjMpQmgQdHd3d19yBBqBAxCDoru7uruJ8wxEdmqkbyqG7ElgSxTMJVrATRZOa55zn3N84kfTKlTGMykTBGIMWRBtNobTbY0CBi6G+7O7o7kgXACiK/YiJJQQVEqq0AUzKUgJ4SZFDECC/M/1O9573t3p+ELqvs+qrq6rGNAlF1V3KYAUAIxoDjpVVVWxVVrMkk3JV1dTQGw+B8DYaA4Mgs6YAI0BygpsPgACKwd737ve66DYfA+BsNAcGQHTABFACVJJJIjGQHen323BvvemWANh8D4Gw0BwZNSpUnZzEgEUACgBKYABJJIGgNh8Sakkm4NAcGXZiSckxAEUACgBGPvvvvsAHYyA4NAbD4H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+97JPr+/fpKgAAHk3OTvfp99rzzX30lwAFVV5e/2X3AEO59s53+7zUB3++m73fu+uz7972/e974CgBpJJuSZk/B0w94EUOmQU6Zq7oEkkqpJG02pAOLp1poA6m12TPiST8m19mZnc/LMtysrvhtNLMwikgQRTaaQeBdaaPgADClJJJJJJJOz602ru+uTCqqgACb72SfSqqqzvmvNXm8QAABnfcz3M+mvv37My8AAAms9339klZ+r779JfAAAJud/SSp+r779JfAAAJudkn0qvvpLgAAHXd7n6T6T7n3797JUAAA7Pd9kn0+/fvZKgAAE3OyT6ffv3slQAADJrP25mZ9n379mVgACqqq9zgvc/bzjw++STS+8verv27n1zN0sA97nu+97Xve94AH08+OHvd+14ODJsPumACABJJJNyH3D9778ASXmZmYZmZnMzJmX4bTSym00swkkAmZizMzMkkkkk1kTaKAAOy7u77M815rMnoAAGs3mZmfZVVl3WZ3AAAM3mZJ999999fe89AAAmp7mZmZX33333MzmAAAZuTMzKqvvvszOYANQb8MbzMzPsqqqszvnRG5ZWWZhmYd3P7d3d57znOc+7vu9syyym2222/tZ7mVmZVV999mXju9t72Ntlz2T9JlVVVWZeMbbbbG229xn7MzM5VVVVe7hW1yuc46XOVzi+29/Ul++5u7uZs0AC9/T9+/a/e96SST8HwNhoDgyA6YOmRFACSSSSA973ve973ifNNSSTuZmZmZMzMSeZzBJtKVxNoCvmIQfb9KQg+7pSEHZx3TaQg5/mwTSDd3d3dkmSpJJJLu7u7kJvKTa5znNNPDW283mZmZVVVVmXAAAO5n7MzM5VVVVWZzAAAJuSSSqqqqs75rzWZPQAAPM3mZmZVVWXd5ncAAAzee5kku6qqkvoAAHZ7JJLqqqqqTkAAA8m5JJKqqqqk5AAAJuSSSqqqqS4AAB2eySS6qqqqzvmvNZk9ANtttts/ZddFn37JQIJ+9c+z258Hve/d3aBq3d35bubu/iTIknJJIAT6SSdkk0BwZAdMAEUAJNzM+m5JTiSSSQAJJJJM1d0knd9762mkTkk/NppABgcRGUAfNppAFEkk7k7JJJJUu7u5OYAABM9kkl1VVVVJyAAAeTckklVVVUlwAADs9kkl1VVVVJyAAAfp7JJLqqqqzvmvNZ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NAaAE3JJJVVVVUnIAABqe71542nXNa+3d+3d/aH5soA+TKPH4Ob3d3d33vwNm9BsNAcGSSR0wbBFACTwO0e1mQHT3vAiopJJJMzMxJ5nME5XE2gAwSMFKaalxSfjapJNLd01JPd3dkgHDd3d3d2qqqqsnIAABNySSVVVVVJyAAATckklVVVVZ3zXmsyegAAZvMzMysu7u7zO4AADEkklVVVVck7rH4AAzeZmZlVVVVZnIAAB5NySSVVVVVJyAAATckklVVVVScgAAE3JJJVVVVWd815rMnoAAGbzMzMrLu7u8zuAAAftP3cyfu526188+t7++q/fX5K7vH9Sqqp+2Bu7u62B+R4DrS3v79+/fv3vSSST78Gw0BwZJJOSYkAigBJuSam6kCqEkgCSZn7MzM7xNqZme770Gkk3JICANJraaQABNJJJrZCk2gAmd73pd6E/AAAVPZJJ9999dVJyAAAeTck737776VUnIAABNySSVVVVV2+gAASeySSVVVVVk815rO7AAAm5JJKl6u7u5yAAATfe973tVVV7VZOQAADybuSSVVVVVJyAAATckklVVVVScgAAE3JJJVVVVWd815rMnoBo0azXuu691719mV99mSTNVmZmZlZnfeg7MZkkk58DYaA4MkknJMSARQAkkkkhJVSfSSAkkSSSSJJ3vepJEn6qq7qv2MVVXVEk/Gc5ne973t97vve973val3d3cmQAAGbkkkqqqqqTkAAA8m5JJKqqqqk5AAAJuSSSqqq1qql9AAAk9kkkqqqtVWTzXms7sAACtT2SfSVVVKqXAAAO6ns/SV3t3Vffdy+gAATfe9klVVZVZnMAAAzckySqqvvpLgAAHk33vZJVffv0leZp4YBNfXfNV9++347e8v2Yv29/aw+ANXt4t34AAttqRK2gfHve9z3ve17wcGQHTABFACcq7qT1aB73Ku6SsyST6rujMz7BqT9DibQAdkmZhMzMM7OTADgTMwkzMBpoAC9S3d3d3d2Xfettd7JeAAATfZJJXtfffVJyAAAZnsuZmVVV99mXgAAHdb33vfu9uqr77Oa881J30AADWbkmZlZdffZl4AABPNb5v3k727uq155qq73nQAAOa8z2e/pJLv9eqqpOdAAAvzU9nvZJVVqvvpLgAAGu6T2SVJVffv0lQAACb5OySqryvvpLgAAHvv7v77V5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AGZmZWYSH5poCfJoAAKXe978210N1pC2t3d3a73ve7omgkkC7u76ahrabQt3d3b2/e9717u6moB8G773rvukTRJPpA9713bbVhE0AfAHue9d2ETQSfSB73rvoRNRAHQ8e9676ETRJPpA97130ImvvhX+/fpJd/HgnZAdMgOMVd0ZA2HwPgbDTYfcGX7z2Pe9Pex4AkkkkCSSA+AEkkOEc2BJAkzMzPTMyKST6SRaAAF3d3bbVgJoAALu7u7ATQAAXnve99Zv5praTZTrd3d29u7Pevd1NaBJpd3d9ASZJJAu7u7basBNAABd3d3YCfaaACwvHuZmd9vPU01tJoW7u7t7d2e9e7qa0D4/e73vOb95V12vsS617Oh6ensAHTL3ve973vY94DcHwPjWhod0BwZe973venvY8ATck39JGxTkmZJKqQAkkA2VVgxmruhqmEzO+3JNenlJNXV1Kk8cAHOc5zl3dcPJMAALu77dgJroAFl3d30BNE5JIHver1er1n7aaa2k1obu7+0973veTa9u60tA+APe9fbsNElu7um7d3d93RNSqoADxd3d9ATRJJAu7u+gJokkgXee96zbaa2k0VMhXeL799N73vd97cKkkkOmQAAbD4HwNhoDgyA6YAE3NSfYkjujvfu99JKrzvve14SSSTVXdSE3JJJEnZMXVrMzJl5nver0zMxSZJJLu7vs01NaG7u/tu/yurvibV1sKTX5NAHQ8e967uwiaA/AB713fQiaiAAsu7u+gJMkkgXd3fQE0SAH4u7u7bdgJSk+0fuMA8emPMz8szDetNSknu7u7u3d3fd3dTQt3d3b27u77sKTX77Wk0p75PlLa7VVX1fvg3v939P2ADpkBwaA2HwPgbDQHBkB0wCSd73vWqkBO973vaqQA0q7oHB+94CpmGZ7973vfTMkmZmZmZkkAA967voRNEgB+Lu7u23YDa+oADxd3d3YCaAAC7u76AmoqQAHi7u7yzfybW0mtADdu7uy93U1ofgNPc9d38knYRNAABd/ru7IUmigkgXd3fQiaiAAsu7u+gNqe+1Yfd7+W+aa5t+3mbJveSfpLnSbZ2P3ve97Xve95xsPgfA2GgODIoOmASTfcXV13ma7lIcYaak38AB0ppoSJ+kkn0ppqZn7MzMyNyTUkkeFAeBJiSSSe8973ve5y7voC2ktADdu7u7b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/fffffffffewJ7LiXEVH7ao/hZGk1CtSYmSYitCsksqMS+cfnz8/PzrxFTMzNtrZTuWBXMoo0mhVWU0lEyWqDzzzrzzuilc5jS2xhKnhLKjGWJZUZUZEAhH3vfe94EfAjKh2lkapouFJkQ0WJaLzzzrzzyoHNaW2ZQeKjAPPPOvPOxUeKjJZL5OJbY1SjiUYIaTUktSaTUTQrBMCjzzzrzzuiLnaMS8S1R5733vfsj4R6VI1BI1WQIJsArzjzrzztUcppE9SwrJagGgNSyWKjRZUaLIrzzzrzziXdJWphEeJYS8886887SV4llRksS+JlF3599NJquJppptLrT/Wdm7+/fbu7u7u7vszMt5vnnidgACqYD7ub93N8zc3NvwVP0iYKmSwrUWVIZLJZLJD9fr5+vPO1KrxLRL4miDpylwJZLSSmSyo2hRaLQoyWQPPOvPOklcthoqO0sSyWpZLEslioyWS7786887pK5TEF3338777IuU0JeKjIGkpiWksSyWVG0gWS0JZLCg8886887VK8ospT4mUFxRaKjRYJYllUbImS2gMSyWQmSyoyQ0rzzzrzzulJ5S+DipQcEsqyrRLIGQMgagZiWSyWSxLRZB5551553IR4llRkspL5bVoSXFFkhktFR+Pffe/ffFRymiD0qMUsqMlkvPPOvPPEvFWVYl8TgS4lGJYjCMowjCMAje973tER8pnM+/fW5ubm7z1m7u5mfq+d+XL8ACqqoAABVVV83N73c3N3m5ub+3Fz+fnX352S/EyinfffffRKu7asIeEtSyXnnnXnnCdddc9dcJ4l4lmYZlJqJNOSdkpNYmniafGnmYZlJSGFEt3ebuCfffc++1Hl6xJGp973MylGnznG66k0kn+zLMn79+3d3d3d3fe97UDoAACqqr3ub3mbmbXur8o8oJGoJHd3u7gbfrEYsS973fZSaAsKTQFhSaAsKTUack7JSWcTzMzuZSaoDvSk0BYU36uptttNL9mfO/O/P34AFVVQAAAPffffffkpcTUK9TKR77z333kv5OSdkpzjfJJ2Sk0BYUmgLCk1SbD7vfowS1Hd377c2qEo/ULg3ve772DQFhSaAsKTXtE0m21GnxpNNNLPefffv5155+vwAKqqgAAN3d3d3d2NptNeafG0+er3vUmvmnJOyUvy4kszM7mUmgrvaTQFhSa72u9pNRphOyVFxpcknZKTQFhSaAsKTQCT3NzMzP3z58+99/v34ADm5vOc5znOc4tzXoAAAB93N+7m97m5mbmfNzfWJNpr3q9JTS+XONOSdkpNSSdkpXxJBdhSSAsKTQFhTcXHxpyTslJqSTslJoCwpNAWFJqVWdG0k2mvveuGfcAAAAAAAAft+2iofj8Z+Px+MfyjVEyNUju73dwTZJ2Sk0BYUmgLCk0BYUlFxPjTknZKTUknZKTQFhSaAsKTVtpNJr7vv59775zgAAAAAAN3d3d3etOJppL3q931L5cSXGnJOyUmpJOyUmgLCk0BYUmopJ2Sk1GnJO7uCbv3PvsT9aBkCUCRCe97vvaCchKEoShKEoShKE++599nwlCUJQlCUJQlIUekyE78m5ubv7y+d9X79+AAABVVUAAD3ub3m5ubXur3zNz16zc9es3PXrEoShKEoShKE2R3e7ufCUJQlCUJQlCUJQlKbu93c0ShKP1JkJQlCUJQlCUJ73u+9miUJQlCUJQlCUJQlCbu93c0ShKEoShKEoPRkJQlCe97vvfhHnhKEoShKEoShKEoShM9iPvfe9nwlCUJQlCUJQlCUJSm7vd3NT8RkJQlCUJQlCUJQlCe97vvZolCUJQlCUJQlCUJQm7vd3NEoShKEpb2IZCUJQnOJr32eM9XO39+/Z3tHlyvdnja3vu95VblxcLnffvPf33737zvz595cRqTRMTFJaTVC2U0mU8k1HvVyH7nz79k80nfCaX+X/h96pNCtJ3ScRW5xTkK0moq5Jyk5SaVGFYgxLIGlGS42bm+bmt45z92gAAqqqAAKqqgACqqoAAAAAAAAAAAAAAVVVAAFVVQABVVUAAAAAAAAAAAAAAAAAAAAqqqCqqoAAqqqAAPMvVVUAAAAAAAAAAAAAAKqqgACqqoAAqqqAAAAAA9997T4nib7Jqk0mk6T4nKT2T5JoV2nvqeUn2FfJPU97m/N3dzOvPXz534QAAAHnnnnnnngAAPe5veZubbmtzfX8n8nrM3PW7i2JbQtqlZpC2pLZIW1VslWwGbYGzYjbYRtE2SbNok2KbJTZIbSptsFs2ItiBsJShmoTZtJZs1misakzATKLTSkNEQTQo0USSBJMQTBEUqMVMR+vv1+v19pLBEQ0TCovYShKEoShKEoShKEoTEpplGQgpiAiSgoqIBaCqIgo97FedeefZc9JsmybJsmybJsmw3vCc+++9++8eJsmybJsmybCUJQlCbu93c0ShKEoShKEoShKEoTd3u7miUJQFH4hyEoShKEoShPe933s0ShKEoShKEoShKEoTdxHe7udEoShKEoShKEr0OQlKe97vvZolCUJQlCUJQlCUJQm7vd3NEoShKEoShKEoShKE3d7u5olPpyEoShKEoYSGEhhIYra1rDDXQMwMRjGGGFKXrWteAAAeeeW5tVOwABzV1LqXgF8liX37x97748TZNk0JQlCUJQlANCbu8R7u5wShKEoShKD9TkJQlAle97vvaCchKEoShKE7mCUJQm73u7miUJQlCUJQlCUJQlD73vfe9nhKEoShKEoShKEoShN3e7uaJQlCUJQlCUJQlCUJu7xHu7nBKEoSl9mCUJQlCUJSnve772aJQlCUJQlCUJQlCUJu73dzRKEoShKEoShKQvYuQnve772aJQlCUJQlCUJQlCUpn4599O7mZnt6zc97mbm+/x97v3iqAAAKqqgAAs3a88uZuevWbnr1mlCUJQlCUJQlCffYj999wShL9YuQlCUJQlCUJSnsE973tBB73vfvhKEoShKEoSj0GQlCUJ73ve3RKEoShKEoShKEoShN3d3dEoShKEoShKEoShKE/Hve6j72o+6/iDImybJsmybJsmybJzvfffffNEoShKEoShKEoShKE3d3d0ShKEoSk/FkJQlCUJQnve97dEoShKEoShKEoT16zc9es3O373VfvP1VwAABVVUAAHrc2qr3zNz16zc9es3PXrNyhKEoShKH9WQnve775H3MEoShKEoShKEoShKU3d7u5olCUJQlCUJQlCUJQm7vd3NEoSgL2AZCUJQlCUJQnve772aJQlCUJQlCUJQlCUJu73dzRKEoShKEoSkL2AZAl73ue+R9AnCFaEoShKEpTd3u7miUJQlCUJQlCUJQlCbu93c1Cj0mQlCUJQlCUJQlCe97vvZolCUJQtk2TZNk2TZPXRL9e+89++/r39fQAAAVVVAAB81e++++9cfibJsmybJs/WnGTZKEoT3vd97UeQlCUJQlCUJQlCUJSm7vd3NEoShKEoShKEoShKD0e9773s0ShKEoShKEoShKEoTd3u7miUJQlCUJQlCUJQlCbu93c0ShKEpPRkJQlCUJQlCe97vvajyEoShKEoShKEoShKU3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AAARNySSZBp19edzzznAAAAAAAA3d3Rp9afzTjTGnqb3cMtBQAAAAGJuSSQACJvFmZmYAAAdAArzzvzru50deecAAAAABu7u7u7u7u7u+972d73vgAAAAAD5NySSAAAAAAAARJNfwSTT4mnxZub6zc31m5t+A/fgAAAAAAAB73N5m7uYB11111110AAAAAfk3JJIABEm5JJIk3JJJE3JJJE37zSdJp/ffv379+/fv27u7u7u6AAFVVQAA+7m+tza948AAABskkgAHybkkkAAAAAAAAibr3A+793b8obG203xNPiadUmrtTROf2+SdJPJMFeQrSfUxAu5OoV/J5Jyh3ScTVUnIYKxNRtSckyE+p9TJ/Jv7r4nE/h6nXXXXXCAAAAHrc0AgAAABVVUAAVVVAAFVVQGboAAAAAAAAAAAAAAFua9ADN0AAAAKqqgACqqoAA8y9VVQAC3NegA/gAcAAAAAAAAFVVQABd7m17qoAAqqqAAAAAAAAAAAO9zR8AAFVVQABVVUAAe9zfe5vvc1ua3Nbm+bmtzWzieJ6n1OJ9T6nafU+p9TpOET1PU9T1PU9TyT5VJ8TUnqfk7TtO4p9k4n6kyZOk9T4mT4nwVxPJPU7k+UK0NCfpNCuf4BI++f3z5+9/f39776AAACqqoAAZu60/m20+r6l99998NNpv+C42lmZmYIO9AA73vexNgSQAAABAAWgoCJty83N9/Pl9rn6qq4AABVVUAAOtzfu5vW5vNzW5vW5vo8788zdkkk6cAAAAAIm5JJAAAAAOuuuuuuuut+dd+dd9/Od135zlVUAAAqmA6AALN2qs666666z51176BAAfJvkkkEAAgAEAAgAEdddddZ13u7u7mZ3m75z78q5yqq4AABVVUAAOZubbm83N575znPE3ySSCoCwXADpE3xNySQiTckkkSbkAEm5JJIkkAAgkk+aeLk9z5m5m5uZ+zc31m7u5m8+865zj9X7AdAAAVVVAACqrmd999999ySSAAcTYB0AAAAAAAAAOuvWbveZub+zc2/Bfv1VV+AAAAAAAe9zW5v7NzMzOc5znO03JJIAAAAAAAAABGn1ckud99dddddc777777m9bm8+V9rxVVAAAAAAAHW5vW5vW5v3c3mNO2nxp/k0/vvvTwAAAAAAAAAGSSSRNySSAAAAcV1fs8m3v777ffc/fgAAAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
