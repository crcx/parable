#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

MAX_SLICES = 100000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_FLOOR = 8
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_floor(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom.random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_FLOOR:          bytecode_floor,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [float('nan')]
            memory_types[i] = [TYPE_NUMBER]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        collect_garbage()
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map
    memory_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_values, memory_map, memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, MAX_SLICES
    memory_map = [0 for x in range(MAX_SLICES)]
    memory_values = [0 for x in range(MAX_SLICES)]
    memory_types = [0 for x in range(MAX_SLICES)]
    memory_size = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            t, v = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    global MAX_SLICES, memory_map
    i = 0
    refs = seek_all_references()
    while i < MAX_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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iJJJICbckgjskkghttsE222I3h4573vfvbz9n4kkkkiSSSfjwEnuR67vl9qsd7399CCJckkERttgm22xDbbYJtySCJHJJZQFFFBSkkihBEkkISqRrP3u3fNa33Pddz3vZdZ/T9+x4ACSSSTN3d3d3d6fCQK7v6xHxQ2/0YiSSSCG3dgru7gxD422Cd3GxEJI5BDbdgru7jEfVn35CEjlISWUhAub2Zs3rXXc/ORGesR172EdkURrv2EdqJHc9fkwRVJAj097vtp+zdrPesEUCKhDAgzONrIQvM+9j133tCHvYEtvHTOsIruw88Q6l7SQJUIIQe84WuyqzWcY1nGa1qs57y779yub2+gKAUZtbvve8/c9327u62y37mzmoSWUhEoSRzSm21lpNVijJMI4yXGVOcTmWybVLaVaya1NjZbLMTbJNtJqjhcpOMpqWqYmNSa1TYRtUa1iyDLAb57zqLPORTmtiqwZppNJppNA6+c60bFM9XEn7KPuDvCv3OExKSB6oRyoR7WQwhPe96ub97zPvuy82jvAffJ37Um+SpUgAXV3d3dgAw+GwAAAAAfSs/ffffOWh3QCMySSQAoJJJJIACV999998sAEql6zmVFUkCtBKqSqDHzVBGImSRYNlBQKWKUW/YZEEcKyDLbZayNRFlFZK0UsFilmr9998uAExWKZcbu+Xu+3Z8AJJJJIFAEuZkkkPhsDckk7JAAXd3d2xXMzJOySYrFSsVis4xiZ1pJJOyRwASSSSQACSSSSAAANALANd3vGMYrecYw/SaJirE1mk+evm8kNYXmqeN9553y7sLjUmS3DcK2qQGCAhIFZIE+33n73G/M/hmkPe979l737wAEkknh73ve94cr9Wf2KzmhAN/T80Ju/NiISRyCG27BXd3GIbbbBNuRiISRyCG27BXd3GiVVVVaqXV3q/32f378uk9qtBwMVT1fc9n3de+++t7++Pvy/V73331l1X0dFhKDe733n8iA27bEQkjkENt2Cu7uxF3d2Iuirt2zJy22zIqsmKrJnHmfMB9Oj3rz7z7okkn0moBx72fe9v73hGeP37Wa/ffc/MyK9WzJbbbMltWTFVmRVcyLy48zmzJttLZkUrJiizMz3rJk5MyB199O/vsufvxJd3d294bB75JJJas/e++5+0E0/26VB1arEY7UN7zbuKbJvdrmTmTVF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aSRdJIlUgKoSpCMNJr32JeY0B0bqM4kk+7JOcUAEk7JNycGTtBxztJufV3cnIKdoOCMdoODczTIZwPi/pquVnrjnx2eRte173NK29xIQulUt5rzM93GvKhZzN58L219mqzlk1zeVn2kcb0I7l84a4HVcps0fHYzpQylSSS5AKbu7t2Oojou9VnaOO68CQt3DohFZXAhDmckgy+zdfgJyj73vGe4xQh1Na6vdePOyRq/nK/Mvm/s+lNdQOFCJlJIZS+SV+6CAwOU89+n8r7+fNJJfqSFWK7nFYr3vTx+94SYzJJ4eY973vAJ3337MkgHiqgH8FUAbLS1QsVTe98rnOc/ft1nXe873n79+n72PvPZ0UIqrPex7777757z333ffffP3nfn2q+AFXiqFiqAcrnOc3ve973vvM85wmK1+lyT9b897xLu7/SHfvk99996/eeevvvvvnnnm+ddcrfGKoAAfKoAqoAqoA3MyZmftyebM5uZM8nGSTy/fvB2Xq7u7aSST6fQ3JJf7FYr2bb6AfW22220AYqgABbbbbbb2irzKpZid6E9xPfOSn99cAgqwNuJPJBZHTQkked7rM9/b/u/c378KRmSSSeeHRs97wfe9++++/d5xQBiqAAFVSq1l5bUC5Mn7ZjFZ+xqaqqu7q/0/fv3gJd3d2tJJIDzzz7MmZl+5Lb8AAFdV46FiqAAFVxAwf3fwST3fRad7kPfdfe/fPv3Xfv769oOfTWr9uSeniVB7Xve+r3ve/dxVYznOKyao54phYrHQCFXl1XnOMqvOcDt3b6Avp07zve84coAqR3P1e/fv37777N3RJJNy7TskgBn9iqx+zmqxWax9nGMYrXW/AFiqAAFsltaqWKoAK8e6qs/XrOtVVXmru/379+e8CST8Hgkk9888877/ezJn03636220AYqgABbLbbVaAwB+666+vXOj4/eP793ZrvNmyPl68j9+/CMySfqDXgn0ngk9jGKvNVjGJuyer7znPmYouS2vOcI4666AAMqO973bc2beIQ/u7P53/UIe0waXbQgioRFf1KEGVsILCCP7sIWBDAQgqkgp/M57mY9y88v33zsIb3fbzDU0ze/tmrRq2bpzuZ41vAgi61eas26wuBB166Qg1oQ0ekWF/v1937m/a9z535Oap3pOm50K6siZNtmizP2jlJpMTVTaO5MxTzXr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"
extensions = []
extensions.append(""" [ "-"   `2000 ] '+warnings' : """)
extensions.append(""" [ "-"   `2001 ] '-warnings' : """)
extensions.append(""" [ "-"   `9000 ] '.s' : """)
extensions.append(""" [ "-"   `9001 ] 'bye' : """)
extensions.append(""" [ "-"   `9002 ] 'words' : """)
extensions.append(""" [ "s-"  `9003 ] 'include' : """)
extensions.append(""" [ "s-"  `9004 ] 'save-snapshot' : """)
extensions.append(""" [ "s-"  `9005 ] 'reload-snapshot' : """)
extensions.append(""" [ "...-" `9006 ] 'restart' : """)
extensions.append(""" "File Operations" """)
extensions.append(""" [ "string:name string:mode - number:file-id"  `201 ] 'open-file' : """)
extensions.append(""" [ "number:file-id -"  `202 ] 'close-file' : """)
extensions.append(""" [ "number:file-id - character"  `203 :c ] 'read-file' : """)
extensions.append(""" [ "character number:file-id -"  `204 ] 'write-file' : """)
extensions.append(""" [ "number:file-id - number:position"  `205 ] 'file-position' : """)
extensions.append(""" [ "number:offset number:file-id -"  `206 ] 'file-seek' : """)
extensions.append(""" [ "number:file-id - number:length"  `207 ] 'file-size' : """)
extensions.append(""" [ "string:name -"  `208 ] 'delete-file' : """)
extensions.append(""" [ "string:name - flag"  `209 ] 'file-exists?' : """)
extensions.append(""" [ 'slurp-file' ] { """)
extensions.append(""" [ 'FID' 'S' ] :: """)
extensions.append(""" [ "string:name - string:contents" dup file-exists? [ 'r' open-file !FID request !S @S pop drop @FID file-size [ @FID read-file @S push ] times @FID close-file @S :s ] [ drop '' duplicate-slice :s 'Unable to to locate file' abort<with-error> ] if   ] 'slurp-file' : """)
extensions.append(""" } """)
extensions.append(""" "Command Line Arguments and System Integration" """)
extensions.append(""" [ "- pointer"        `226 "Return an array of all command line arguments. Typically the first two items will be the scripting engine name and the source file being run." ] 'sys.args' : """)
extensions.append(""" [ "string - number"  `227 "Run an external program. Returns the execution status." ] 'sys.run' : """)
extensions.append(""" [ "- number"  `4000 ] 'arg-count' : """)
extensions.append(""" [ "number - string"  `4001 ] 'get-arg' : """)
extensions.append(""" [ "s-s"  `5000 ] 'value-for-key' : """)
extensions.append(""" [ "s-s"  `5001 ] 'get-environment-value' : """)
extensions.append(""" "Terminal I/O" """)
extensions.append(""" [ "v-"  `6000 ] 'display' : """)
extensions.append(""" [ #10 :c display ] 'tty.cr' : """)
extensions.append(""" [ "-n" `300 "Return a Unix timestamp" ] 'time' : """)
extensions.append(""" [ "p-n" time [ invoke ] dip time swap - "Invoke a function and return the running time" ] 'invoke<time>' : """)
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    collect_garbage()
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size})
    with open(filename, 'w') as file:
        file.write(j)

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size

    try:
        raw = base64.b64decode(s)
    except:
        raw = base64.b64decode(bytes(s, 'utf-8'))

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_NUMBER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
        parse_bootstrap(extensions)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')

    snapshot = expanduser("~") + "/.parable/default.j"
    if os.path.exists(snapshot):
        print('Initialized using ' + snapshot)
        print('------------------------------------------------')
        load_snapshot(snapshot)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()
    bootstrap(stdlib)
#    parse_bootstrap(stdlib)
    parse_bootstrap(extensions)

    home = expanduser("~")

    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
