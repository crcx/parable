#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        tos = stack_value_for(i)
        type = stack_type_for(i)
        if type == TYPE_NUMBER:
            r.append(format_item('#', tos))
        elif type == TYPE_BYTECODE:
            r.append(format_item('`', tos))
        elif type == TYPE_CHARACTER:
            r.append(format_item('$', chr(tos)))
        elif type == TYPE_STRING:
            r.append(format_item('\'', slice_to_string(tos) + '\''))
        elif type == TYPE_POINTER:
            r.append(format_item('&', tos))
        elif type == TYPE_FUNCALL:
            r.append(format_item('CALL &', tos))
        elif type == TYPE_REMARK:
            r.append(format_item('"', slice_to_string(tos) + '"'))
        elif type == TYPE_FLAG:
            if tos == -1:
                r.append(format_item("", "true"))
            elif tos == 0:
                r.append(format_item("", "false"))
            else:
                r.append(format_item("", "malformed flag"))
        else:
            r.append(format_item("", "unmatched type on the stack"))
        sys.stdout.write("\n")
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=0):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
#    print('OOM: GC & Increase')
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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ZSL3HPdRHv39tFPsiD9hFOYiRzFDmUqnMoTmVQ1MTMRDUDgFV6tVVUa+97fvd8eaqve96vNvrbb63mdzM4fSkoiN6EybvDd3QKwGUyQEAAS23mZ7M955nveeZnn73ve88xsAAKUExChIlQlCQHyBt+SfPN++o+295ilKUpSlKUpSlKUpQO9G9959nQuryPN+9eyG950pSlKUpQck1KUpSlKULzRvec3339z3znM4pSlKUpSlKUpSlKUps50c5nmd97873v7alKUpSlKUpSlKUhXGAOdG95zf4HzznvnOZ8iUhy1KUpSlKUpSlKUpzRvec3+F88576D7c5mKUpSlKUpSlKUpSlKb0b3n2fhdeeb7D33W7eaUpSlKUoErkK6kDmje85vvv7nvnOZxSlKUpSlKUpSlL9pSNaB2c6Oc35vvvnnfOfbBoShKEoS5oTUOojWhLWhNQPNG95zfffPM85zOKUpSlKUpSlKUpSlKSIHe9ajpRHro52ogtKgchOc0VX977+6lC/c0AnOc25nOaLmHOKEw27DfTmrd3W/AAAD093d19vs8t3d2u0PgfA6N7yeazMzF+q93d3mAOTETCtyzORH2pm7u73MTd3smZKCLvu7Xu7u66J5Dm3UNElpt4SQAC3me9hve9777+88B8t7+2pSlKUpSlKUpSlKUDvRvefZ+F15ry3c/a/R1zXN6Na5vYAAazepO5Par7PbzJ0AAOc/fprP2sztfc5K52fQAADU3rvfp33WvKqXUnfgAAJvvfp33WvKqXeteWk70AABEnfu+6883VS7k70AADU33v07zWuZl+3mfsAAAhn7M7Xea5K5J9ANAAa+1vbWo/d+/TvvnnlS+SfegAAd1vV85333LUK51z33r97EjPvd1Q6wgRmbI96AAQGiACSW4ABDbbeAd3d3OvVqqqit6qqqvUeaqqqq7Q+B8DpvgvpO84ANvISSSbhKHSiG2deeuIj2qrLtd3d3drTMTD4zEfd0s+TeAG222226SUKE+tkFgB8d7Cja5uvZmQABm9a1rMn3fdeeb5lVJ34AAAm9Tv07+zK5mdwAADus/Zna7+nP09iAAAam536dvkrkn3YAAAadfu/TvvnmuSq1ryknfgNAAd08n79O9vzzzuVl3mToAAHWfvNa1k739+zKrM+gAA17n5nNffe9M/dd/fd8sgIwjCEJCI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5aoqqqqrw4B0PhveRzMzUzGZ6F9u93d5eZEzmVnomc5MzmozO4FGzMzAaqqw01BgF4A4B7JmYg0hV67zl5kZ2AAAfpXOu9nP3vJPYAAB9N7nIna5+nJPehoA0a7v5973me688zV5v3MuAAA+z9E+zlysvM+7gAAH2fsc5O+3+nJO9AAA+1P3Unbr9OSfQAADyb+Tv0rmta1xKqT6AAAez9H6d7+rkqpPoAABN9Sd7Wfa88u899zJ8GhVVVXffQKBqCjfc99dHQadc11re97Mo0I+8OOtQCqmZqoqqo77Xve9435e973vett9622I9FgHQMX33F9LmIEcURMn3CVBKON2oh3D5MRDeMDIY5OfBwo+JDipv5tt1URGZn3ULM5nSSIgLJLVgFAfJy2/kB8FABWByQb2+7Vb+5mcjWgoKCiTXNec1rm9+dc775z44ULHNC2jVERzXOa1ze/Oud9859ziutWqJiDBiAT9Pl99711X13998x8kEVCBMQoCHyxmJK5nOZn2Zrzze29PNtDRm8ze8kr9nOZn0YH7ewAxrcZkld9155WXeZPTQAATXc5jmSV+znMz7AAAJvqTva/TnJPoAAB5N9Sd7+qAO9+eb39uqqqqqqUpByBNe9ciec1HeREZru8zLy8o0AWgu/e96PKo77Xve94VFVVVVeHAOh8N71tuTind9u678u92fszGb3n2ZmO2A/Rg223g27bfzD4OEqIAOgAAAGBxJ3tc5KqT6AAARreu9++me688u899zJ8AABM/ak73PeZVZ7ncAAA/Z+1vv30/TnJPoAaADyb13Une8/TnJPoAAB3U/a3376fpzkBzCRK4h5hvlEVt3u2oW6To3W92q3dULdJ0br470BKHkt5ld66ptqEX9P08+DeZ7MxRoAtBd+970eVR32ve97zxcXd3dV4cA64Oje+ZP15mZ6ruIuzbO5nve955mNttsDgREAAAHQB013d3gABiGi779870TEmi77vlEXZ7wYsSUqYUyvuciICQbrvqLtlijd2d0K73ard3YhbuzuhXe7VbpEcmAJBuu9KpgoRKCQbrfKIu997d8oW7sg3Xe7t3u7ELd2d1uu9KoBKAJBuu9KoCZh21959vua9vuVWZlGgC0F373vR5VHfa9972/Coqqqqrw4B0PhveTwA4ogIiBtpP1NtjAG31RDBsvd3f379+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GbzMzkn13dVJ98AABNySckqq5yT2AAAeTcknJKquck9gAAE3JJySqrnJPYAAB37XNuMzMz4HPgd8OPc99732/Xfvve15VFR73ve8H0TKA6FtDe8z7WZGZmZhkwNzMhRnLzMzMzMB4ZmZn0TOREDbAMzMzMzBpt/Ntu35voAB0Kqs7rzy7zO0AABm8zM5Jl377d5ncSS8YgIiIBMR0/VP331ffYCczLv77vBH6ATEKAjAgExH0ffffV99d3Vffb8EfoBMQoCMQCUBCgfT9999X32EnMy7++7wR+gExCgIxCiOcN+5u73dqq73d9qmN4ojnJ4pjk7O7u93bu2GgAMWd997cAKhKAjEAFQlAQj6M++zmYqq/czPZmteNm9PN78802b01NZveZnMy7uq++374kKEoCMQSFCUBBD6Pvvvq++u7qt326lE8meKY5yIUrnEYaFV7l733vbu0AZ9mZh7Q497nve3679972vKoqPe966pwQALaG97ABH4AYzMzMzMzC7i7y7u8DBd3d3d2XrUTLTRtLbbpgAHQtJK7uqDN1REzzk8UxyZU6N5vMzOZlVd97rzz17mTgAAGb7mZyTLu6r3M7gAAGbqSckqq5yT2AAAdE/fpJySqrnJPYAABNySckqq5yT2AAATcknJL1d3ndeee+5koAACaz9vMzkmXd1WZ9gAAGbySckqq5yT2AAAeTcknJL888u7qpPoABVUAADWpRAfZVAOtdazM83ve82gA6BI6bb+d39d3y8b+9XvT33vN+V3d+8CABbQ3v7jYfAAAAAu4u6/RMxEXd5MyGYXcxEXd5mY2222222zA4B0Kqu9DxMzMzMzMgJuSTklVWd155d/ZksAADN1mZyTLu6rM+wAACaz9uSckqq1rnJPYAAB5NySckqq1zknsAAAvU/SSuSXrWtXfOSewAADup+klcku7zuvPLvM7QAAGbkmcky75zM9wAACaz9vvc5JVfv0lwAADybnezklV+/SXAAqqoVUE8hFQ4gMiiP0Ap7m2JDvNMK+1qkZhFO/O/2/P395uP37YPgdDj119VVulOV2q5v6qoxWe973mAJtttv5RDxy2+c5ZU77d3e+39+/Xf4DzM5mgC2Bd1VVVLu0TI2222NttttsQHwAHQuIi7uIiqD6AAATcknJP13ed15577mSgAALz9JM5mVX79mXgAAHek5+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nmR9rmv379+/fv379+/fgBhd3d3d2AiJC7qqqqXGRESl7iiGHQHmNRDbbYA28zM7m3d2z0ncAag34a0azeZmcku7usz7WY2bb3vW978beZ+kk5Mu7usz7GNjbbbbZm5JOTLu7rM+xg22Ntjebkk5Mu7v7uvPPcycU222Nttt5uSTky++++3md9Y3vfjW9t78ba88z9uSSpl3d1mfZN6aeGttmb73v7uZfffbzO4AAB3P07393Pbu6k+gAAHk3999++ku7qT6AAJJJZUZcUgCAJqqHs97z+JJG37vvvrrT9O6FAHczMTu+Xd382/d973Pe9oXmZme8DIABARM857n2tjh2ZkzM3GVmZz6ZkM6u+xer1eruwLu8iImIXdZd3VxmoiJiEQxnYmdxmYC7u8AuLu/r7d3dd79AAAJv77799Jd3Un0AAAzP3e9/dzLu6zPsAAAm9973tdl3d595557mTgAAGs3JJzsz33328zuAAAZ3fe9vs9u7qT7oAGjSd/d72+z27upO9AABO972+y7u6k+gAAHk73vb7Lu7qT6AAATfe97zsu7upPoAAkkklqj6IaDqiCAJ4jPrr7rrvu776MHveAs8B8AHbvl3dvrZWVmZU/Zgd973vZmOBoAsN66Hxaj9m8zMzFYXd3d3dgXd5MzEQ1ERMRd3F4Osvl3d555mZmY3sAA233B+97xqiM9p2ZmZmZkAZuSTncz33328zuAAAZvve953Lu7qT6AAAeTfe97zsu7upPoAABN973vOy7u6k+gAAE33ve87Lu7rO688zJ+AAAzcknJme+++3rWZ3AAAOeaz93ne9rLqqk9+AAzze9aNaNam+973K1l3d3rWZglMqZlLeKI5yeTKlTvAApbd3dpbuClTMqVKmN4ojnPuLZ3d3d9r4AAXu5upJfT99999WZGZmOm9nd3Z3W63dgk7u629bTAWkb0AsYRADC7u7u7vMzSuZn333vyu0EP2azNblQN730AhsaT6koSACklCROzMKEkAkkAat2G+ab7u7nd3dhvvgj8kIhFIpFIpFC1vAC9qqrdwiZiZiZSlSoiUtJnfgC9qqrM+wAADs/fu9732tRq7u8rzzzMn4AADnmfu973MqqrM+wAAB77773tVVd966AABqN/fffSVVVXnnkn3QDQA8+++++7VVVd790AACa33ve9r3Ua9917fuXr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uqAIAfakkk5IAA5znOc4AAAABVXQAAAAAJJJJIAASSSSQAAAAAqroAAAAJJJJIABN3d3dQAAAAAE27qp8kkkAAAAAAAAAAAAABG0o2lG0o2l82lG0tKGlDShoRU2KLCCkosqi7VV2oW1D8odqL0IsIsIsorCLKLKFKLKiyiyCu1CQRfRFgEX1Q2oflCUNgnaq6UNKL6odqG1DxRF7RFm2k0omkml/z002200953MzMwAAAG7u7u6AD5dUAQAAAAAAAAAc5znvokkAAAAANNtppfNpaTTfG0tNpJAP+ZVE/klFlFlVEhRYACRFlFpAFJAUkQAkBSBF9zzv3777f32ta38qqsREVTSi5yqqqrMyqxAFOoEVVhFgARCEWRVFSEWURD7333377777WtcQUEC3VVVVVViioj8KLICkEMiLACkAKQiISi/e+++/ffc/fv3AReAiwi5uqqqqqrBEX7sRUxFRCUWFFhF+/fv3777779+/cVQQtVVVVVVYoiHFUSRFlFlUTnvvvvOc++1rXFVRPkBSUWUXOVVVVVVdKqidKokoKAQiyqqkKLKLACsAKQopCgCn3vvvv33332ta4oKjbqqqqqqwUX5RYVD7333377777WtcUW3VVVVVVgoiHPPPPOc5zmta4AKW6qqqqrMzFQU+UWUVhFlURCBBCBWEWRUSUWFRIRZRV+9999+++++1rXBBALdVVVVVWICInyiyAr6ffv3799999vWtcRQA+EWAFJRZEXOVVVVVVYgi+a9RFO+fNttttNcbS42lqqzmZ7MAAADvec5Zvl3VakjgAAJJJJIAAAAAAHOc5znAATWtYoa1rWt7kUAOCqD8oKSACMIsIrAiyiihKLCLKLAKh5535v77777WtcQBQPhFkBXOVVVVVVYAIh2diLiiLKLCACMosqiUqoiwiwqgkIsCCH3vvv3333379tFAC1VVVVVVggCnFFhRYRZRYRZEWUWFUSEWUXznv3799999vWtcQEAt1VVVVVYCij5z3333nOc3rWuKItuoKqqsFEX5VElQQkFBkRYRWBFlFlUSkFVGUWREWUWBFUPfv379+++++3rWuKCAfAiwig5yqqqqqrBBUekRZVUSEWREWFFhAUoEUlFpEEJEWUWQRSUWVRIAUJVffv379+++++3rWuKAA/AAZyusyqqqqsBAFDoUWAAhVhQQgQQkQQgQQlAQiBFhFhFhFhRYRZBA9+/fv377777eta4qICfCLCokIsqoucqqqqqqwVFF6FFgBQhFhVRPfv379+++++3rWuKoluqqqqqrBBEPlVEgBWFRIRYRdfvta1r77X29a14CfKL8ABKrCi9cqqqqqq77QRewBSRFhFlFkVhFgVkEW/fa1rX33Pt61r5AVt4oZmH3XVVVdKFZjqt/fNpvvM20mm0nmr7VZ3PAAAAHe85znCQAAAEkkkkAA9u6oMAAABznOc5wAAAAAA00k0ksTab8mm9NLnOXz3vffb1rXERd5VihmZmVVVWCKA+c99995znN61rgIiFvFDMzMqqxQzMzKrBQU+RFlFhF9+/fv377777etaNUAB/h8+H7739++/e93tu77znnGgAqqs4IvwiyH77Wta++59vWtGqqqqqqvgRflD379+/fvvvvt61o1VVVVVVxRfhFlD379+/fvvvvt61o1VVVVA75znnnnPe/fv373ve27vNAAAy9999qrd33nPONAAA+e3379+1tbuvyhaqqqqqq51rwAFMkUAPPfHp3oAG7u7u6AAAAJJJJIAAAAAAHOc5znAAAAS7qvt3V1d+++/3t9qt3eaAAB3zznPe/fv373ve2/ufgAAO3vfv99+973tv7n4AAD3L2+/a2t/ZznnH4AAD53znPe/e/v3e3bf3PwAAHfOczvvfe973f37vNAAAd885z3v37973vd/fu80AADvvfv37973vbd3mgDjvz4H7739++/e93tu77znnGgAAfO+ec597+/fv3e3bdaNVVVVVVc3h2ICKhkgiBvz3MOO9AA3d3d3QAA5dpAbAAJJJJJjaWZmZmZmBbaQAAkkAAOc5znOAAABuRFPyhCqJ6qEKgB77717vet73u7zQAAO+ec57379+/e9723d5oAAHfe/fv373ve27vNAAA++3379+1tbu+855xoAAHz2+/fv2trd3QAA78+fPOc979+/fve97bu80AADvnnOe9+/fv3ve9t3eaAAB33v379+973tu7zQAAPvt9+/ftbW7vvOecaAAB875zn3v79+/d7dt3eaCqqqq11+/aufvFUAPZRfcUMESrurt8yZOTe9AA3d3d3QAAAB8qroAgAAJJJJIAAc5znOcAAAB8tAEeKHnnnfnOc5zetaNVVVVVVcDznvfv37973vbd3mnz58AAO+9+/fv3ve9t3eaAd+fAD3v37773ve27vvOecaAAB89vv379ra3d5oAAGXvvvtVbu80AADvnnOe9+/fv3ve9t3eaAAB33v379+973tu7zQAFxQzMzPOe++ec5zm9a0aq4oVYTVWIec99995znN61o1VVVfZlVXnYCiETaTaSSW20ta2AdzAAAAO973vm0pJ3ve971LuqfAAkkkkgAAAJJJJIAAc5znOcAAAAAdbSDSaSbe20tNtNN9bS022iBxD9+879/c5vm9a0aqqqqqq94ofe/v3793t23d5oAAHfe/fv373ve27vNAAAy9999qrd3mgACrih5z3333nN6/fvx+qqqqKN895+/fv3Oc39+/efvAAC755zn3v79+/d73f379z8AF8+AfPb79+/at/fv3PwAAGb7777u9rd3mgAAZe+++1Vu7zQVVVVXLP3meIgA9wCAIZm9+73wAJOc5zjdAAAJJJJIAAACSSSKPoADnOc5zgAAAAAAAabbTWNK7urzMzDd3mgAAfe+ec597+/fv3e3bd3mgAAd979+/fve97bu80AADL3332qt3eaAAHfnz555685zv379+973vNa0a4JmY/SJ11VVVVXvSh9+/e+/fff4d3d5oAAH3vOec+9/fv37vbtu7zQAAO+9+/fv3ve9t3eaAABl7777VW7vNAAAy9999qrd3m1VVVVVYovUIgKdda1rWt73ve9hJznOcboAABJJJJAAAASSSSQAA5znOc4AAAAAABG0vkmqbS0kk2lf17s5Vbu80AAD773zznO/v3793t3u7vN/wMzPl66wTMwTMwTMwTMwTMwTMwTMxT379+99++++3rWjXBMzBMzBMzBMzBMzBMhMzBKEoTznvvnvOc5vWtGuCZmCZmCZmCZmCZmH0HXWCZmCZmCZmCeyH379779999zWtGuCZmCZmCZmCZmCZmCZmCZmCZmCZmCecxD3333nOc5rWjWxMzBMzBMzBMzBMzBMzBMzBMzBMzE+nX7FD7Wta++39zWtGuCZmCZmCZmCZmCZmCZmCZmCZmCZmKec99995znN61o1wTMwTMwTMwTMwTMwTMwTMwTMwTMwTznvvvvOc5vWtGuCZmCZmCZmAO+YAiHGHdxh3cYd3GHdxiuXZgtatfvvvua1o1sTMwShMzBKEoTMwTMxNfffJr775tbM+aSTSSu6zMyYAAABu7u7ugAAEkkkkAACSSTdSSSAAHOc5znAAAAAAU2lG0ttJNv673ZwAkimJrMwTMwTMwTMwfuuuhMzBMzBMzBMxxi9GYLZlmC82tnOM6WsWwMO7jDu4w7uJmYJmYJmYJmYJmYJmYp0785nXvvOc5v9+P3BMzBMzBMzBMzBMzBMzBMzBh3dgd8wwUzm1rZznOLWLaDDu4w7uMO7iZmCZmCZmCZmCZmCZmCd85777znOb0a0a4JmYJmYJmYJmYJmYJmYJmYJmYJmYJ5zEPfffec5zn78ftiZmCZmCZmH0HXWCZmCZmCZmCZmCZmCfvfulD7X7999v7n78ftiZmCZmCZmCZmCZmCZmCZmCZmCZmKdKHfOe+85zmv29GuCZmCZmCZmCZmCZmCZmCZmJ9ddYJmYJ2e/fvffvvvtft6NcEzMEzMEzMEzMEyUMlMzBMzBMzBMzBPOe9Ieec5zm9c0a2JmYJmYJmYJmYJmYJmYJmYJmYK+++TRzLvWuXOclVQuXL7L13ebh377iv6j473b66zzqVWRFhRYRakBAKERYRZRFlFgUWhFhFlF6UXMRXqCwwVf3X7vz3ediL+hFzEV8U/l/odd9oiyqJCLgouACmQi4gKQiyqIYIuCi4KLIApCKyIIQosCCEqifKu6u9+eb3Pz9+AAEkkkkAAAAAAAAAAAAAAAAAAkkkkgAAAAAAAAABu7u7ugABJJJJAACSSSSAAAAAAAAAASSSSQAAkkkkgAAAJJJJIAAAABJJJJAAAAAASSSSQAAAAAAAAAASSSSQAEkkkkAAAAAAAAAAEkkkkAAAAAAAAAAAAAAAAAAkkkkgAH27qgGgAAAAAAsAAAEkkkkAAJJJJIAAAAAAAAAAAAABJJJJAAAAAAAAAABJJJJAAHOc5znAAAkkkkgAAAAAAAAAAkkkkgAJJJJIAAAAAAAAAAJJJJIAAAAACSSSSAAAAAAAAAAEkkknW0p8mm9NppvSab0mm+tD1QxEX0RcEWEXYJCL6oQi4oYaUNKHoouhUT8IuCK1zhOAADd3d3dAEkkkkAAAAEk9u6qSeSAAADnOc5zgAAAP4u6+3V1b6oe+/yeNBM0UNUDQNCU0ANFCJQA0gFUIUFKFIAFCKirEqVFEIzKMQzKNFIQUE0A1RBIxMkESjTR+lD99999zmvtb5DE1VKiGcwTMwDrrroTMwTMwTMwTMwTMwTMwTMxTXeTTAkBRIURINFETR++10oa1r77n3N60a2JmYJmYJmYJmYJmYJmYJmYJmYJmYp5z3333nOc3rWjXBMzBMzBMzBMzBMzMyqrpQ859/vfe9723d5oAAHzL3+99qrd3mqqqqr75eusEzME9+/fvffvvvt61o1wTMwTMwTMwTMwTMwTMwTMwTMwTMwTznvSh777znOc3rRrYmZgmZgmZgmZgmZgmZgmZgmZgmQmXnPfffec5zetaOCW8PoeusEzMEzMEzMEzMEzMEzMEzME9+/fvffvvvt61o1wTMwTMwTMwTMwTMwTMwTMwTMwTMwTznvSHvvvOc5zetGtiZmCZmCZmCZmCZmJ9ddYJmYJn3ya+++TXZxtNpJ3eZfM94AAADve973dAEkXdVJJPZIAAADt3VADoAABznOc5wAAAAAADaXybaaXW0tJtJpc5zfMQ/c5vnN72a2JmYJmYJmYJmYJmYJmYJmYJmYJmYJ0oec967UPfec5zm96NbEzMEzMEzMEzMEzMEzMEzMEzMEd3YIppWK10000xe9y+cgRDjDu4w7uMO7iZmCZmCZmCZmCZmCe/fv3vv33329a0a4JmYJmYJmYJmYJQmZgmZgmZgmZgnnPfffFD3nOc5vezWxMzBMzBMzBMzPpeusEzMEzMEzMEzMU9+/fvffvvvt61o1wTMwTMwTMwTMwTMwTMwTMwTMwTMwTpQ85712oe+85znN70a2JmYJmYJmYJmYBmYfQ9dYJmYJmYJmYp379+699++++3rWjXBMzBMzBMzBMzBMzBMzBMzBMzBMzBPOe+++85zm9a0a4JmYJmYJmYJmYJmYJmYJmYJmYJmY/T79+/fv333329a0a4JmYJmYJmYJmYJmYJmYJmYJmYJmYpfuuxQUzFMURbre/Nu9AA3d3d3QBJN3d1JAAAASSSKHgAABznOc5wAAAMqrrKq6zMkkk3RrgmZgmZgmZgmZgmZgmZgmZgmZgmZgnnPfe1DznOc3rXDWxMzBMzBMzB+jrrBMzBMzBMzBMzBMzFMU9+/fvfvvvtfv37glCUJQlCUJQlCUJQne/PPN73vWta4b4JmYJmYJmYJmYI7uMO7jDu7A75hmiHGLWtaWCmdNL3vfBfAmZgmZgmZgmZgmZgmZgmZgmZgmZgn379+/e+oc5zWta4b2JmYJmYJmYJmYJmYJmYJmYJmYJmYJ77772oeb3vWta2a2JmYJmYfQddYJmYJmYJmYJmYJmYJmYp+/fv3nPj77Wta4b4JmYJmYJmYJ1110JmYJmYJmYJmYJmYJ77775ze/379+2a2JmYJmYJmZ9L11gmZgmZgmZgmZgmZgn79+/ec9UOc1rWtm9CZmCZmCZmCZmCZmCZmCZmCZmCZmKfv3h55v93d70ADd3d3dAEk3d3UkAAABJJJJAAABu7u7ugAAA27qvtVdZd1Xvz3zze/2973vezfBMzBMzBMzBMzBMzBMzBh3cMoiHGHdxi1rWrWrMGc5zppppoYGNHwShKEwzBKEoShKEpT3333z3nOc3ve9nBKEoShKEoShKEoShPPPPPOc5zm973s4JS32IZCUJQlCUJQl9gn79+/e+/fffb3vezfBMhKEoShKEoShKEoT3333z3nOc3ve9nBKEoShKEoS+wDIShKE99998+9UPvvvuc5zhsShKEoShKEoShKEpTzzzzznOc5ve97OCUJQlCUJQJQJEJ55555znOc3ve98fpHIShKEoShKEoShPffffPvUPvvvuc5zhsShKEoShKEoShKEoVzvWIq/dgmeffe/ffc+3ve9gN3d3d0ASLqkkk5JAAAkkk3UkkgAAA3d3d3QAAAAAAA8r9znN817Xvfe17WZm81ihKPoMhKEoShKEoShKE99998++/KH333Oc5w0JQlCUJQlCUJQlCUp55555znOc3ve9nBKEoShKEpPpyEoShKE99998+++++3ve9nBKEoShKEoShKEoShPPPPPOc5pQ5znOc4fhKEoShKEoShKEoSkPPPPPOc5zm973s++AyEoShKEoShKEoShPffffPvvvvt74oc5w6EoShKEoShKEoShKU177777zn7nN73vfgJcEoShKEr6TIShKEoShOv379+9++++3ve97OCUJQlCUJQlCUJQlCeeeeec5znN73vZwShKEoShKEoShrWkvaS+02tbSTSWve973veAAAA73ve7ugCSSSSAOXVDwASSSSQAAAAN3d3d0AAAAADG0uNpDaXekUmdwDvVia1oShKEoShKEoShKE77771rm961zezglCUJQlCUJQlCUJQnnnffOc5zWub2cEoSlvsQyEoShKEoShPffO/vvvyh99vf3OH4ShKEoShKEoShKEpTzzvvm97/ft60bEoShKH7MEoShKEoShPv373z77779++1o4JQlCUJQlCUJQlCUJ5533vnOc1rm9nBKEoShKEoShKQvsQyE9987+++++1r7e9qFwShKEoShKEoShKEoTPffPO+c5zWub2cEoShKEoShKEoShKE88775znNKHN75zh6JQlH0GQlCUJQlCUJSnXNddAIHf739+39+/AAbu7u7oAkkkkXdU+AAAJJJJIAAACSTnON3dADt3Vd73ve96kku6rl2Hqhz9777veta1vezglCUJQlCUJQlCUJQnnnffOc5zWub2cEoShWhKFaEpPrIShKE9987+++++1r7ezgCUK0JQlCUJQr5533znOc1rm9nBKEoShKEoVoShKEoTzzvvnOc5rXN7OKP1kJQlCUJQlCUJQlCe++d/ffffa19vZwShKEoShKEoShKEoTzzvvnOc0oc3vnOHolLfYhkJQlCUJQlCUp775399999rX29nBKEoShKEoShKEoShPPO++c5zmtc3s4JQlCUJQlCX2DkJQlCe++d/ffffa19ve1C4JQlCUJQlCUJQlCUmvta7uWkmw+TSSVcy+d7mAAAAd73u7ugCSSSSAAAEkkih4AAAEknOcbu6AAABJIJNVvYASALE1rSa1pNa0mtaEoShKEoShPPO++c5zm1De+c4eP0mQlCUJQlCUJQlCUp775399999rX29nBKEoShKEoShKEoShPPO++c5zmtc3s4JQlCUJQ/ZglCUJQlCXvvnX33332tfb2cEoShKEoShKEoShKE88775znOa1zezglCUJQlCUJQlCUhfYvvvnn333321De/ucPBKEoShKEoShKEoSlPPO++c5zmtc3s4JQlCUJQlCUJQlCUB9775599999rX29nwlCUJQlCUJQlCUJQnnnffOc5zWub2cEoShKEoShKTWtJrWk1rSave8zMzuYAAAB3ve973oASSSSQAAAkkkkgAAAAbu7u7oAAGta1Am+863ve961vezglCUJSFH0mQlCUJQlCe++d/ffffa2ob+5w7EoShKEoShKEoShKVfPO++c5zmtc3s4JQlCUJQlCUJQlB9GQnvvnf3333377WuCUJQlCUJQlCUJQlCcPO++c5zn7mtHBKEoShKEoShKEoShOed985znP3NaOCUJS/WQlCUJQlCUJQn3vnf333321DX29nYlCUJQlCUJQlCUJSnPO++c5zmtc3s4JQlCUJQlCUBR9DkJQnvfX33333777ezglCUJQlCUJQlCUJQnfnffOc5z9rm9nBKEoShKEoShKGtaTWtJr5fZmZmZgBJJJDve973oAAJJJJIAB8u6oASSSSG3dUfQAAAbu7u7oAAAkk02kV9sAJAFmmld1vMzMkG0szinXnnffOc5zWub2H3w5CUJQlCUJQlCe++d/ffffa19vZwShKEoShKEoShKEoTzzvvnOc5rXN7OCUJQlCUJQlJ9ZCUJQnvvnf33332tfb2cEoShKEoShKEoShKE88775znOa1tQ5zh0JQlCUJQlCUJQlCUp5533znOc1rm9nAL7AMhKEoShKEoShKE9987+++++1r7ezglCUJQlCUJQlCUJQnnnffOc5zWub2cEoShKEoSvpchKE6zBKEzXW86/ddn3L31RZRZRZBENqLCLgIsAKSiyiyi/KLiCL0iLCL1IrqEXsRehF7EXvvXRgovwi+CLii4CL16ovaqJ2Iv7tRRDoRZUEZVpqkm382ljaXc5fcDnOd73uYAAAAJJJJIAAAAAAAAAAAAAAAAABJJJJAAAA5d1Q8AAAAAA3d3d3QAAAAAAkkkkgAAAAAAAAAAAAAEkkkkAAAB/KAHQAAAASSSSQAAAAAEkkkkAACSSSSAAAAAAJJJJIACSSSSAAAAAABYAAAJJJJIAASSSSQAAAAAAAAAAAAAMu6okySSQAAAAAAAAAAAAAAAAACSSSSAAEkkkkAAAAAAAAAAkkkkgABJJJJAAAAAAAAAADd3d3dAACSSSSAAAAAAAAAACSSSSAAkkkkgAAAAAAAAAAkkkkgAAAAAJJJJIAAAAAAAAAAKq6XYSIptQ7UO1DoRegTYJsE0ovaIv5RFhRdgnQJsE2qGKGAi4oSq7UMEXShtQ/Ii+KVPMHIBJJJG7u7ugACSSSSAAAAAAAABu7u7ugAAA27qsu6r9z755zn7nNa2fwJVQoAoKBBpVKUSlFKQaUFpUWkEpEaFCkUKFEpVUpURioEaFaBGhpUCkWgWkCkpKQoUpBShShWikQoChGIUoQpaWgChShSlpApCISlFppFKQoApGkVoUoRCkVCgSgChRCKkFoFaBpUWkiaGlRoEoEoCkKACgaUaGgRiFoFCCCkRoFpUCgQpFoQKRKQoKBaUKBSkKaVoClKEAqJVClEKFIgQSgpCgAoRGkKVWgWgUoFoSgSgFoVKiBClqhKVKEGkoRpWgKAApVClSlSJWhUaSmkKEBpAoGgaGIQoBClEpKUKApUAoFCqQSgoGIGhAJUlVoApEoGgKFaFAKQaUGgEKVAoKFiBVoCkRpEaUApBoQCqUApEQqJBpQKBUKiVShVaRWkQpaUAKESgQoQaABoFKBEoaFAaVpQiaAVlSFSSQpAKpFopFJEkQKAGlAoWgAoAKKURKQJWECgSgWkWIRhSBWFIQCFJRaUShVIUgFCVIBQpKVRhSRVlSBkSAQIUlUoqhSlBiEUhSRSFJQQlCWRIUQoWgKApRpQAJUhlEkApAIkoZUhEmAUpFaUSIoaUpBVhSWBSSVJAQhIAKaFSkWVIEJUhVmClaBAoKWkqlooFiRCilpQJZAVlSFJFJUZUlQQkYUpGkWFJRaUaQiChGgKFRCVJRWVIAAgVgVlSUBoEKEElSBEKKaCimYAIloAAJEgESVkEJUlGVlSVJUZUlYUhFkSQhShSFVlSFAkSFRaKAqgoCqBoqqFRSFSVBCAJRKgUgEIFIUhSFIUkFhSABJEgUIUhSVIFYUgESFJAlSFaoApaopSkiKKpiaECqEWgQpUCFIRSRIlSFAhSEQlgACmkGFJUpEUIUhAIUhFlSRJUlWFIQCRIFWgBKFIUhQpEkSQElSVJEgUSRIVooCJaAiSmgaYqEKaGlCiqCmhKAChoGJUJAkEBiRBJUgFGFJEWVIFKFQKBVoUgUhUIiBIBhSVKFWmYAJhUqoUkSVJRaoFKFVhSBAlSREhSAShBiKAooKaoEpRpAoKShaGZApKYgEiQiKKFCRIoAUhSQUlSRBSVIQBhSRSRIEBYUlAJUkRClAJUkGVJSlUhSgUiFJFIUgUiRCIlKFIFJEgGFJUUiUGFJUhSEAhSQSQZUIUglSShCgaUKaCkoaCgKKKoGhoRKYgaRaCJooKCGpiYoaaiglokhgRpACFIQWgQWBkVBlaWUBaAUloWBSRJBUJUkQAqkRIFJFJEhSVJUoBgUlSUgUhSBApUWhSUSVKBSUhSoUlAhUlSRSVQpFCUAgUhSBSRJFGFJQKRYUkGkqmhIqKYhaAYmiloQKIhaAapCilqaIoKAqKhGqKChoKKGqKqIiGSoaGaYlqKoiopKKIoBqgoaCqgFoARKUUSVgUUJUgAWVJQUoBBhSBWIFJUkAWFJUYUgVIUkEhSRQCRIGVJBAhSUSFIAaQUhSEAgUgUgUhSFJACRIUhSVWRIBgUgEpUhSAWqpSJKFoCJoSlKEaKQYgCokmoppBpAqapImJqGmIaaACgGhKaSIRpSkKAiGkpYhGmimJGZBaSgRKVJUgVIgUlCRKoBkSRJJUgkEFpBBGFIAUIlRBhSBRFlSRSFIBBYUgQIVCgEIFAqhoASihKqGpSgFoAoUoRoiqkaaU+++6oShKEoShKEoShKEpRO4QooaQBoQKQKEpABChUglRAoBFApVKQIUlWFIFClQRJEkQAKFSVJEFZUgFCkBGJoVJFKlSAaAYBqJmRpQKQFpqhEiKKVpRKVpfffPPvvvvta+4oc4YJQlCUJQlCUJQlCUH0+e3nn33332tfb2cEoShKEoShKEoShKE88775znOa1zezglCUJQlCUJQlCUJQnnnffOc5zWub2cfpyEoShKEoShKEoShPffO/vvvvta+3s4JQlCUJQlCUJQlCUJ5533znOc1rnFDnDBKEoShKH6MhKEoShKU9987+++++1r7ezgJQJEK0JQlCeed985znNa5vZwShKEoShKEoShKQvsX33zz77777Wvt7OCUJQlCUJQlCUJQlCa898BPOc95z9rgSSSRu7u7oAAkkknl3VSBwAAAAAAAG7u7u6ACSSSSC7qu3dVLuq3ec5zn7mtc3vglCUJQlCUJQlCUJQl5531znOc1rm+KHIShKEo+gyEoShKEoSlPffO/vvvvta+3vglCUJQlCUJQlCUJQnnnffOc5zWub3wShKEoShKEoSk+nIShI9986+++++1r7e+CUJQlCUJQlCUJQlCeed985znNa5vfBKEoShKEoShKEoPoyE99875znP37mtqG4ShKEoShKEoShKEpT733zznOc/fua1wShKEoShKEoShKEoTzzvve97/ft61sShKW+xDIShKEoShKE99875znP37mtbEoShKEoShKEoShKU+zrUZ1zvve96Ekkkbu7u6AAAAAAAAAAAADd3d3dABJJJJCXdVy7qpW7zjfd61re98EoShKEoShKEvsAyEoT33zv77777Wvt8UOQlCUJQlCUJQlCUJSnnnffOc5zWub3wShKEoShKEoShKEoTzzvvnOc5rWBia1p6Xtfaa5y9+973pPAmqrewAkASWJNaV3W8zMyTDG0sTWmmruqzM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AABJzit3fN0AAAACS20vwTXk031tLSab62lptrelz9n2tfffffc5vf3zQDQqlKA/CShhStIpSqBQHvvvvv33332973sTvvvMACrrMzMACrrMzMAHbtLE1rvOc5zMyYACaqqqgAABNVVVQAEkTRWqqgAJImrou7AgSUk1jaQmvvufcutJNWB2TMAAADnOc5zgAAASSSSQAAAAADy7qgOBJznOcboAAAF3VS7qu3dVu7u72d6kl1XjzwEgq6+5mYCQVdZmZgAVdc99999BAAtJrG0sTWvuc5zmZkwAE1VVVAAKuszMwAKuszMwAKuszMwALutdz37VXV399zvO973oAN3d3d0AACSSSSAAAAAAAAk5znON0AAAAAHW0sTTfk033ve99494A82lia1d3d5mZgAJqqqqAAAtJoTWru7sCAAJqqqqAAAEljTWld3dZmZgBG0hNau7u7AADG0sTWru7vMzMAFXWZmYAFXWZmYAFXW754e+gADd3d3dAAAkkkkgAAAAAAABu7u7ugAAA5VXXbuqu69u6rnznOd710FXWZmYAFXWZmYAO3aWJrV3d3mZmAAmqqqoAAAbqqqgAFXWZmYAFXWZmYAFXWZmZVVV3zznO+c58fPffffe973tVeAcBrXKxtN1Ws+aWZ3MM6AEknOcO970AAABJJJFH0AAAAAAABu7u7ugAJJJJu755zneec+/fv373ve7u7oAADvvvue1W7u6APOececzMzN3d3d3eeczMzN3ZJJE1VVVQAAMbSxNau7u8zMwAE6zMzAAq6zMzAAq6zMzAAE1VVVAAAY2lia0ZLvdZnM62lmfAJJOc43d0AACSSSSAAAAAAAAG7u7u6AAAASSSSTE03xtLTaXOVXOZmYG6q6zMzJJAKuszMwAKuszMwAACaqqqgAAMbSxNau7u8zMwAGl7Xmmuc5y/e97wAJqqqqAAAE1VVVAAADSqqqgAABJavPtJpvzab+Sus/fv36fv34CSTnON3dABJJJupJJAAAAAAAS7qnwBu7u7ugAAAXdV+u7qqr5znOc973vQVdZmZgAVdZmZgAAJqqqqAAAxtLE1q7u7zMzAATrMzMACrrMzMACrrMzMBJImhVVUAEkiaKqqACSRtT7PtJpvnmYOd70CSTnON3dABJJJJAAAAAAACSSSSDd3d3dAAAB2qurv33333ve5ggMbSxNau7u8zMySRNFVVABJInTMzAAq6zzzwECrrzMzAQY2lia1dVWZmZMATV3VUAdJImqqqqSQABP2vNNafOc5Xve94AEl7zTX1tpLuqcz9+99/fp+ABu7u7ugAkkkkgAAAJJJJIAAABu7u7ugAAA27qtqmsTSTS8mm42lWpJPe7ngATVVVUAAANZ5Jr7T0lznOV73veABNVVVQAAGNpYmtXd3eZmYACaqqqgAABNXd3dgAAUk0JrV3d2AAAJr6q+qgAAMbSxNau7u8zMwAE1Xe8+xNN7027vnO95zp0AG7u7u6ACSSRQ8AAACSSSSAAAAbu7u7oAAAJd1Xau7q65znOd3vegq6zMzAAq6zMzAABNVVVQAAGNpYmtXd3eZmYACarMzAAq6zMzAAq6zMzAkklNCu7uwCSQSaE1q7u7AAAE1FZvrrefj8ov5RehF66yzrN9d+nqi+CAj6iL4osIuCK4IsGAikoKyiwCvQiyi4IsosqsovQosqCEosAimKqJii9CLCL0AKdACuCLiqJIi2CLKokAiwi9CL0osKLgqJii99CLii9IqAQi2KLtQmmm9tpppfNpWdlXZzne9IAAAAAAAAAAAABJJu7qSQCSSSSAAEkkkkAACwAAAAAAASSSSQAA3d3d3QAAAAAAAAAAkkkkgAAAAAJJJJIAAAAAAAB/AA6EkkkkAAAAAAAAAAAAAAkkkkgAAAAAAAAAAAAAAAAAEkkkkAAAAAAAAAAH2pJJOSAAkkkkgABJJJJAAAAAAAAAABJJJJAASSSSQAAAAAAAAAASSSSQAAkkkkgAJJJJIAASSSSQAAAAAAAAAASSSSQkkkkhu7u7ugAAAAABJJJJAAAAAAAAAAAAAAAAAAJJJJIAAAAAAAAAAAAABJJJJAAAAAABV1dVXyrq79u6r4ou1DxQ6EXxQ7UOwTYJsE2CaVRNgmxUIRYRe1CEX8CQi6UJUA0oXah2ovqi9gChpNJtCTTfk03vOZeGZgAAAd73ve96ACSSSSAAAAAAAAADd3d3dAAG973ve9/wRF+UWgGqq996Xr333nOc5zm94nCKGgaEKUpVKQCgmFQKYkoKiRpASlBpQgkpIJKpCimImoE4JBlSzISytExUQxRVFEkVEEUUUUAUB9CiGQUtNWta0tJ6eu973vve9JJE1VVVSSSSRNVVVXkAAA0qqqqSSSSJKqqqkkkkiaqszAAq6zMzAAq6zMzAAq6zMzAAq6+efPoy7qhHoAbu7u7oAJJJJIAAAAAAAADy7qgzd3d3QAAACSSSRtKkmsbS59znOGZgANccZmZlVVVwAAMzMyqqrkAABmZmVVVcgAAMzMyqqrkAAB777777fec85V/VXIAAD3z33332qqrkAABmZmVVVcgAAMzMyqqrkAABmZmVVVXnnOAAAHn93+7fPf7ud727VVVX79u7u6AAAAAAAAAAAABu7u7ugAABJJJMTTfk03pJpvnOc5me94ARoAAGZmZVVVyAAAzMzKqqu+ec46AAB89999973ve1XIAADMzMqqq5AAAZmZlVVXIAADMzMqqqgAAGZn9lVVd885zvQAAPnvvvvve972qgHOAzMzKqqoAADvPPPOec/f393vfe972oPt3VBvu7u7oAAAAACSSSSAAAAkkkjd3d3QABJJJF3Vbd3Vbd1X6rq7m7ve1bu7zoAAHMzMqrd3eQAAGZmZVVVyAAAzMzKqqv8PPOcdAAA+e++++973varkAAB/f39/VVVcuHgAZmZlVVXIAAD+/v7+qqq5AAAZzMzKqquQAAH9/f39VVVyAAA9/fj7m/fl/eXVc5qOABu7u7ugAAAAAJJJJIAAACSSSN3d3dAAEkkkVLuq7V1V3f379+9+/u97VyAAAzMzKqqu+ec46AAB89999973ve1XIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq755zjoAAHz33333ve97VcgAAMzMyqqrkAAD5Pv14AHl1QHN3d3tSTve973oAAAqroAAAAAACSSSN3d3dAAEkkk7Qi/CL6oZe+++85999ve9m6qqqqqZmZlVVXIAADMzMqqq5AAODMzMqqq5AAAZmZlVVXIAADMzMqqq755zjoAAHznvvvvve972q5AAAZmZlVVXIAAP8Pnz333M73ve1XIAADMzMq3d3eaDS1rWta1rWi93z6wJyQEmgAADve973vQAAAAAAAAAAAkkkiqut3d3dAJJJO9JJI2lxJrzaXe973phJIprWta1rWtAGZmZu7u7u80AADMzM3d3d3bzznEAAB899999q72q5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAZmZlVVXIAADMzMqqq5AAAc9+Xf2599733f3e1VVV+/fv2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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        sys.exit('')
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
