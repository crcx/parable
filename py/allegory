#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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7kVL795Kj7lL7qpPv3i+oaUk2QGQzUNQhkNFVtQyGahlKMGkvuo5S0NjIabVm2VlDUbDUNMbUNKDUaqmobUM1DaJpffvKQmpHlkRgiKJhmIgqAdx+yFfv3HlWEJZDbWyBZQ/blolqKahsoaRpDEbSJoxQ1DbSWoaUZDSp+37VK/ZIv2Av2CX799odVVbZDRUpqG2JQJFXcKGKBAKgbze973vQC1fALRVqGNVbH7c2xmMRSw7t754gIkqihKAqA3G/37p5NEtYWUNVJgNKtQxTUMJlYja21DSTmEksOTDbUkk2k2l7ouVeTmmmmkvUkCEKGI+sEECAvO+++/a0R82PfIInu69VjbvvDAtt775tppmJJ8OHzR5ppYRS6SSSOSU2koAAdIZADIJvIe++6992IHigsCj8ECATIHWsHUoGta95AQTUKm5HcbhV3Im5RHcG94og6FAgFlXe83vre975BKtAAEbVbSWGBowA+TVNY2kgDe96QTVIBJW8xHduN73vfRokpHFjSQbAAFMTeY8xJIAAKY8xp5jQAAA2JtJfsSTSSX79+4mkv3dJpL3ve3tKBmSSSSEkckG0kAGUikgPHU2GpJJeJu5dpNpIPgCAAAAAGtekk72eqav7TTDQAcaZQAgaTQW221J22221NW2221NU0mw0zEYg0zGkjKAAVNBbbbUnbbbbUz7m9Xt3PU7UZtm7YkgEkW0JF33cIFJN6STXoXDABImm3Lw2kuyYUm5MQ0mYm0gAD3raJoImkj4xtJGJNpIAATSRYAASSSSHUm0k6qu973u+mE16VhtypJNKTDS+VJRqkGQAImgtttqTttttqattskTVxXGY0kYmGmYGmmorbu22rmZiSttoAkJI3ve9a8E8QQ+oQV9lFPqEVBDmGmimmHS+lFJpLdMhLu771NNNdLLuyRKTCTlJNpSk2imkGGCaSwimEDgXfLppNO40m344AQAAAttvG0l7PSTvok5+0m7iuW6A22y0AgaTQFttqTttttqattttqapppmBoA+TRaAAJoC221J222218xutJs9kB+SI6hNQgnuYvEgAT1ddghyqqKewIqJ35igca87EDv33fKlJuDbxJJJfW0lMFNtN00yg5KUpSlKU7SppyZazSabalMpMA1I405MQ1EkkncuJtJXE00l9baE+TYAcANpu229SbTT/9/2v1dtpU1f4NNMGAETRawABNAO221J21W22prtulbe26TVNNMtv1um4hBsADqxPMeY0lmJW222O4nbbbYmomk3/BjMTabcxNp5pNNLSy6w0mmknNBwCdpps+F+9jHl49nvEP3vBTmgC9Pc+94OCttkkLbQgaAAC22+6km3mejbkk9U12/ttMz4NoDaaoattoJoLbbG1cy2221NSSSSJuYY06Js2AfJtFoAAmvd7u7u5C7d3d3RHVwgIG3IBiKlJDSXk3ibbTZi71tJEgfuv2jwAT6Bo97oAAG2k0Y/e9tL2Ixojbkne9C2hgAABgbdt+buK9Tek00n6a9bb6pqftNO27Stu2kg1QAI0ta0rZJJE0ZmO222xNSW221tU00zA0YuAfL7G0B8AHDMaxIAABp3LbbbE1zNOy7+UMxiHAQxttN0JDyrMoEAO6bTSS3vc3ySPwYDckmkml2JJyQlySfSevuB0ySd70LbQAAAC228aSS9npJJ6tq/tNMAAjaLaAAmgC22pO2222tq2222tqmmmAARtFtAAbQB9bb8m7bbbamsueaZM1vKLmyGmQ0rvSP6xHTJLfuJLYjznLao2odaocxHM73bdIYj3Inmdao9+8JPGbGQBIAkgIt/DJkYAeW8TphzIQ1pMWxyVtfIfT5gtGkBdXIsdVYgPNzCAWZjSR5Ntw9rdT5N3bwXnMWPE8c4UPMoKuDCpWEJT+3/D+JnKT8c7IgT+v8FCj6MiIIJcS4f4T9mb38I35u389UfOZXcgAexuMvADjgw8RjIolDLl14I+9PFR5iO6G4I7UO+YnTttiV03RaTqrUNs4qO0TTMkyjR1Q3nUnTqk5UlowjEsoa7quTlSdfz3p/NHbTLTUNYrYTTyhjlcouTkjviv5/OKd6NpGMU8yo4K2UtVahlxxRzmsaRtljLWUcqXInHmudczkgJIlM5guDhOI6sYQInhzlMoaDMza4jnDT5nTGWyRq61Ummh71xCuiNLUMZqqsRlMRxy+8daodT44JxdEafsuWRXeqv3X8qPuyI5oQYfGfMa7xggOe7m6++er4CCvgAVrgpFO75JN7gG+4XOc4ZoLCVmy7vd9uAYANgXDgABYDTTcpppVTpSIn2S+SKHEoUoNFB6W8w4O/mMa9rnee8+3N3WpJJ4BbJSk1HldoXcc5wLcKAAASRJJJJFc2ZAOAMCSSSIAyAAO6DIXd2mk13mG1ymk12m02tUm8UuXrXOAWC4AaB31tdVJJZp5G0gTJoGiYRjZGBxIGQ25JZYJd4Bo2EvvO13vS+Jm4Gw4AAwAACFAABksIpySOEhkABptdVJ3TbbeE3V4T2Q7vjCwWySaAAVAASXJJJAA5nYhBwO2WklEmlSBQlAlQ0B6WAcXvHvu/ffdA+VJU1VDoo0AZkcknJIHOyYzJJN9SpdxdYzd3dziGnHMNJPCaSzSrRnegAllQoAAuSSSSGwE2NucO5A2Aaikw05AALu7u7u5DCbA2AF8MNMovN3d3u7Go6STVrho0HAM8kmZOSTizJFqBAraSMAADAAAp6PbTSz5ppYmBkDtnEqkmpJJDrYGQADqEGQAOJ4aaVOSZkkuC7O5bTV6WKa0KjO+AAwAADhVhjIAHGlhppSTUklw6AaoAKknZMSXKSaXJJmXKlySSSAdYGwAOtAjYAHns7t6ad1jzHr2GThYcQBoADiSkiWUolhN85pLnN54AHU0BsADrt1bbb0DYAHQNdnF/D1DSv3v8Vz57L1Q1XlEaHM2S1DAbTqhuNsnWAsJVlN02mUkm0WjLxKYXlCMNFYaSzjSTaCGAeAAAPmn73m/e90skk22kp6+Dp6235STqb942HgAAALbb57+KZEA0CgFK0rFEIVSxsLaLbZRbUthW1SbKtpW0GxBsiopsJbbUNtqGzNbIZjNUbNlqImhAooiQqpgiKBCJo+azWta8OlmKGogAX5I4NMDMVTELRVCJE0O7JG3ve973pJltAASYBbbWnbbbbW1bbbbW1TTTAPgNp1YwDgAN8xpZjzMxp5jAACsxMAAK2t1NJftaSaQ7zma03TaSaXqxSSWThYHYjBWUksYMmSmmaRkMQxiqabcXRt6WZjAZ4uyYeepveZSzeGnOYUoC9cRjLTzKa1Nydmmk05Sue1zPAQwq1l6mzYfCAttvF5LGk8z0kk9U1f2mmAARNFtAATQBbbUnbbbbU1bbbYmrTbTAA6mrJLbamrbZJE0YrbbbE1G00sxttLOa1upTulpKqaxitYykkms3zd3PdzPWbMmiyFe933ve9j3veALA2dANcwm5JJd3yyZACmAAAJfJsAPWySSJq4vyx4jFo1pJIxGGNmIxNdmqIOgdSqauGwtsSaVskkiauZbu228TRbveNPFdXLn1u0ntLMzHbb9bRI5mY2sD4ABt3I00Ab3rWta1pppG376cnzjh8+Z8+fOTX71+gffZi+CeHroAe8AAAAASSSSAAAAAAFttjb8XwAVL9jTopQ1Cak4lDVq1zhrNcIZEuta1zbRITQB9bb8k7bbbE1VbbbampNGNO5cuW6TVsltokJoAttqTttt7RHcRO6dYgLIBdMXZmKkY0scZkdt9f2AWu21W0C22/X62nTpG3JJJAAAAANGGgt7b6z1ttrak1+xp223ja6sttvbRITQBwtqT+ttttTUkkkiamQ007bfqJaTQW8oAmgCyakeb7u7u7hEXnVEKamlxDBBXffb73rfoEOFCCwwQJJJJJJJJO96Xd3YB42AABbZC33fSSSNqT9tp3GpJtcWJLFjeZfwBA0NPMTkgraNIGl3ACBamrbZ2RNVWnzTADia1bJbambu77dgNENm7vhLu7uEcgCGkBLh7MLukuLNStLOaTcz1SdV+wdUHqmmaWZfNLlVXeNPWddzSbyjVkXQxy03KkkkkQpJrLTqpMSThuSSHAOps3Na7JJqTAG36d1JJE15Y+/tJuZbb8mjlkttTXZJ3tEqk5bbZE1U5JJ1L9iYZmr7TTD3qEvgluZu7ojTd3M7QWZmZm6IiNaJ9Hzolo3JuaorIbCW40Ddk+pK8+dvz58+ROSTOr3ecc5ydvNzwGzoG+EmYm7u7vyknZTTDAEkil3dkkSkAtcS5znOcTReZrVf7bTADiaj73ttu6/szElpjbEAAxZicy223qai73velraMadttvU1cySS21NSSd71tGDbtttiai5rM1beW38L97vl72+36Sbnr71t1bbQgST1urbAAAAJAFJm6ad8uzvecO9vtprdKmnj/Y0w0AHGlrJJLZE1UJsAtramSSSdbzHU3JJJa2hY06aADiaFZIW1NCttkiTG3JJJG1q9Vu9a2vvlo9zgWcErwAS1xXd3dkCAG2noA17uj3vW22ye8AAAW22yF62/c5z3feia/Y07bJLE1620Ct7QgAATZizGKg1rWta1rRVKxOtm973rw1BQtFR980wA4l3FJJOyJqVN22lramW93bgiNzp4EDmBAQCAbEAxtn0I1D585+68UXSiyHr70h97Q77nUxAYAgLhggIBJ4RRLImIPkRGKqdZX6Je7fCAe84nOEA6aQBS+jBBqyRyAYIC5BKlIgJmUjzE3FzNunviHPvi+ee3RuIZDmQO/h4yj6yQLm5DTT1NCiQaNi5nmej21tGXwJHx88S0GgE2IQuSaBEMSRYlUIkvaQLBK9gjGIYvj+RtBEjX8zn84qHp8uIc++RHTRHX1WlG37tnF3W9cJv6tvlh2207rR4TSXqAFS0CA2mkjeAhg4AmkgLA0uWq7nve9CDaSAARJF2YlZkkAVtJrtuoQOp6kFyUTiDIydx7xx3775vzzve9LIMAMmkUhCbrOe95rfAAAAIfW2/W2gGwD4NO2222gAAAu97RNpVuqw0mm7u9HAAQAA76kkKm1VNNOnSu7u76QQEknVqlzhrvehEAAgw0wAYFgEkkkkggJJJJJAAAbSUu8pNtZTSVJNpIwb2gAjUgAAABbbbbQATAAtiVbaWW27klpDEsAAYCLVSSXOyCAAAttypJJJA7TXQN6AAWGnd3ckw0+yI+973ve973vG1TAAPeAAAAkkkkAI3JJJJLu7u+XeE2bpJpDaSAOAB0DIBwMNOVJJJJc2mkqSaVUk1iSTkktJtJRNpK6xMySSAACAJJJJAxMACmJumAAdA2m80gACB5NpIAAAmJJmSTUkkkkihlMAA6EkkkkkkkkkggAACSSSSTCaaUkkk7JhzWpJJy+znMDaSA5wAJJJIAFjczH3vpPXwe97GmkAAFLbbbaAAAARTNffaTd58k01L3V9fGyiPub7nm8770voLckl96K7u7IAAAAAcDDbu7u7uwACSSXd2Ykuya9bbbSqg2NiLaqbKNgWyWxFoUWqUShFpUKBEoFSlEGgAWiqVGkAoUaWhFKEoVoEpKaRpQpBShCkCkGhSkBoYilaRaRKClEpoChCJWmkGlGkFoSkSJVaUKQEoVWqjYW1UNqM21U2Gyo0ijQlFDS0ihSNCxUC0rSlAhS0AUg1QxKlCm0GsbJNimyhtVbQ1Qi0i0BQFJQo0oFI0W0bNhG0m2yRsU2pbEtkNkm1sKbUrNUWyopUoQpEpAoKUaUpApKFShUKiEaEpSkCgpoBtGyVsthbJbSlsjZbUjYlsSbCZibVbK2RpiUaBaBShCihAoFoU2tpNpLaFsmyVsW1NFCUqhQpStKFCFJSJSAVQAhQ0A0rTSrSCUhSiFK00KhQ0o0jSiFKoVQIUoJQNUiUjSRkU2zVNpC2zRbSbAWwbRtSraGxNkNkmybIVtbVtSmYBtTZsZiRqGKsjDNTZtLZbNishqpbRVlYNo2qbNk2RNgGwsVkGxNq2JsVkNVWQxFkNSm0m0ltM21KyGNkiyGqlbWxsW1tK2RZDJDalkNDIaqLIaqNrNZjaqTIaRkMUrIaTaqVtTNW0japmVSyGtoWwyGjKxLaSzJtWQ1DWkGxU2Tag2W1SFFDQBSBVJVKjCyCrIZJlFqZDUmshhoyGRNUzYlsbCGQxRGlSIoChpJgKGKpgmbFbW21bEsTRSamQ2rZRkMhiGgshkVMlkNqmyGQ0S2FszQ2GZsbWw2pbWNWwKaWkrIaqpkNUtLVU2qMCyk2G0zZJlRrItCAEIECo1ShRQU1TOtm2ZbDMRjK2SkyGRTSwhisk0shqplTIaNEyqZExMhlVkMSZlMhjIYpMhqQIQIBUIWQWmkqqSmqiKRqhKoSiqKJqUKAItqVYhqKm1KshqgxWIZDKLIYrIZDIZDIYlkMpmJVkMqZDUMhpUyGqqshlMhhGzYNk2WYm2zYSkiKKoWIKQopVoGlLYDaqrIYIzUMhpJkMCYmolstqqyGobFNtqBi0KZhKyGUWQxJqGZDCsqaRg1QyGQbKMYhsE2oaDFTIaAyGoZDCDIaKzbNqzRtRtNLEU01ElC0xUqUNNNWNmzYGsrYrMkVtANpmVK2RZDSkxhQyGoMagZDCGYkbSJrQshlZDQG1rJMhhNlDNsEzbUMQyU22pJkNAshkDIZRQKBURSEQU0UKUqtAlUDSDDCjSFFU0IJSDLIYKhlZQyGIZDIKZDKmVqRkNBbVK2qGoahqGVMhmIbIZQyGgZqVjMlbIaoshpFMhkMQyiyGqaqyGsqtqMhkYQJKUKBCmJiSmpgoQpaaSgoCiiqEKWhpCgKBoRqihCKqGgliJqmpKSKKZCSCYgFqECVJkNE2IDRYVUyGSVZDKGQ0lVkNQps2krUMhkMhkMRtQxDKGFkMhkMhlEaQyGxDC0hkNSsQ1DENSm0TIZVYhkkyGVRkMg2oNAgQpIhpSKmIChpQiaKBipShGKmqGIAaIgCigpKmipKAqKgWqBKaFqioIipJqaGhmmJoZqmiqGpIkiKWgqKFBMhlA1DNqkG1VMVpSDIakTIZSjaqqyGhNqGVlFlYJZDKpkNSTIaCyGpJZDRZDSiyGQyGgbIGQyixDEMQyGQyiyGQyGFMhpGQyshqLYlkNKmsrMtIkRSJEJSMyNDEtCVQDRQCUrTMCRTEEREy0xUlCBEg00hVIUUNVSjVCUhQ0UUNIUBERFtsWbYi2RqrVFsoyGVE0yGMii2KqyGSUMhqRWaqBkNRUbKqllVkMhiqTIapWVK0itm02obVWxGyFAJVQ1KUClANCNEVRUDQUh3333zr5ggeVNUKUgU7LYTaq2U2rYzGaNgbKVbIK2WhpSthQbUoqyGqMhqpbBAwNKqm0hsVkMoqZDUKytCTNZg2IaDZDK1kMRtQ1RtGy2Q2kAaSqUKBSgCh1mI61rXzfYoRbaAJq22yRJwbdtttTVttttTVNNO223qaEW2gCattskScE3bu7u011rl4V4TeTwdKRS2LHacpuGG3iikUIxFJmNuYnGnJ2Bm0DbJMyAEqpicu73q8BgACdnE3JpTUgtgBspqd13ve+9U1f2mnbbb1NCLbQBNW22SJOFtttTVkkkiatNtMBgSZiSVtqvbdVt5jzGnmIXQAKJY1VlAPe0Q91j+ourECEK2gSQK33en28/fQAm7smpmTCchqbTakk5tpSkpMFMpenvYnk3QAKVKUnspopIpspFNImGzGEU0hBkMMpopspFJISpIpNFMz2JNNN973vPeiak/badtt4mrZBt0ATR0AtqTskkkTVVtttqakNtO228TVsgm6AJoIBbUnbJJImrvmer2e316T5WA32K4SAAElRSS7sl3dkkgdkxLu7uySZAAAJJJAAA7jnOd771TUk/fNO235NW2CbtATUAAtSclskiaqttttTUkPmnbb8mrbBN2gJrgAFqFiTWY7bbbbixZizDPjs0mkpXk961vmtTe7O7uLwcANAB73ve9+95+8AB+8BbbbbQAAAAA97xxNgDu56yS/hN5izE8xW3b+xp3G7bvmLMTy27ttqaDQW29TUklTdtqTvLbbamrJJJE1VbTjTAPk1bbbbU1au+xN3d9TWuY7zGtaG3pKZ1Odk9AACFGJJJAuSSSXcACSS7kkA4AAB4AC23qb9370k96pOySSRNVW222pr9bd/NO235NcWK6tomwBNFtklqTtttsTVVtttqakh807bfk1e20bckiaqpV5vSbu7vhPWrEUm8GwNj3Li1jT4b+w94NtPnQbYc4e97j4rb9bb9QAttvE3bd9Qa0atu7iW55b9Od94qatttv65ibw0sAABjdtttiakl+adE2BxNEAtoJotttja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SW+rDbSNAdAu1VXZJJLjqSa73uW2kpJAArZjWYAFsSbSuW20CtpdWMwPgLGlXlttodA2AEdy222mxuJpKm0lSwYDQAXKkkkkuVJJJALbbbaBbq0AJyQt007bu4Baa0AAW2223yk0kml73uc973vIAu7bby0ACtJpmABbG0m+LFjWPMry360AbaSAAwDturLbdtNIADoAFu71q5Uk5vk5JM5GmkAAASSSckmUmkAB0LbbbaAAAAW223abStAOgY00gAtlxNpbxppbaaVttLKjGmfABwPJtLjTYB8BPe0mwAANpppHec5xPgFOgAABsNNMA+ADiAPgA4Bv7zbSAvt79tp3nlmk0tN3C9qzpki1Do1lyqTTUamFlVlHNTsO/KYS5SxqAF0e5wJmSSXfmmAAepgaYB8g17PeAArL4Apl8AAAW8uNO+76Sd9GnJJ/Bxp23aavLbbQTRbbbEnJJJImpJJJamrbbbamgAABp3BAb+aYBziTDYASJprFJpLlJRCzo1Wte4cKaZDs2wmJTTknYGcdDQAbtK6kqpTTkkC9TCuby05OycgEkggAImygEEkypRQrqSTvv1eYszMaeYYAARGJW22hU1d2nGmAfNriMAABNEkkkbVSy6tttqaiVxW221NRq4rTjTAPk0W27u7TV09EMVjOlub30965j3N794CAXd1dtur7k+m9SSFPA2w4AfeAApgEDQe94AyRd8m5Oz3qmrbbbak7bbbamrbbbak5bf3GmBtGJq9ttLU0YW2zqaqkkkiT73ve2RNSSTvU1vn5Nz8vfHp7XtwAOgeYAGk2B4CAfABzwAHQPe9fe14AAAASQAc9JN/sadv7aalttoCfMzGgD4A+MaeYsxp5hgABDGnmLMaeYAAFFjTzFmNsAAAWY08xfa00wAgAsxp5izE2Ac40wDnFmNPMWY0zQABB4saeLEEmpJJtp0qVU06VIqE0hU6pap43vW85zrK1YjB4AUknZVkkkkAu7u7u7kTcAAsMBJJJJJJJJLu7gV3Pe9709EnixZiTxYgAABJ4sWY08WJAAACTxYsxp4sQAACQ0AAFTQAAAmrbTjTAPk0AAANoAttqattttra/az7mt4Adhb+AAC2222gW2220vrbbb49sADoBbbJJvy4b73vvVNW2221NXLdK39tpgbSZwAAG0W222pr62221JySW21NW2221p3GlcSuO020wNts4AACa+3J7ea+397PpvSbnJ6D5whRndNPYTe7u7uyRXd0m7u7u52y7u9NO7JBthwgaAJLvve9Fud73vTyTttttqattttqattttqa/AAAJq22nU2Btv5YAHQBv7HixJ5mYwAAqQsYAAVNW2221tbXcmvy1NGwsD1GySakuTCbkzJJLnO5vN3d+hh4Lfuyb9b4AA973g4Ftvqm6p622+qattttqattv7rTA2mvsWAAAJq2222pO2222pq2222pq22nWmBtNfAAAJq2222trPnpJpDaS/aT0oEQoEq+4KBgrKB7yL7757ex7HaXpJpOSZu/SbUrCbky4Bjt8u74SCBt2/m0lTEB+979+/eAALlA0JAXFcf5tJfsbSWItvafqmrbbbamrbadaYG018AAAmrbbbak7bbbamrbbbamrbadaYG00AAANoALbU132BNJbwmktHZ1Nb1vW961Zw7N+1JIpuSSQYAABJJNNOSSbjbkkkkkkkAAAttttibuXyttt8X8sax42AAFabttttBox4Ad60wNpoAAAbQAW2pq2222pO2222pq2222pnd3d7EL3vSIjxo6YgPCSYAqiG2ze+4SEr+8QBgEx5S0AHW8reDQMS2oVKWre3mEAsxknUkxCOUgE7f3d7fvopjFrIaBsMoQG3QVcNOqKqlIyyIIQPBAlBOYvPU30by5c2RCI+G+qq+ejXl+BA/WSTpLnm6QxOxTvpF5v0sCrvUPcqtaVUdvOIGcuFH7rm96uOnfHiCPWlUu+uuqgWOPPEVOUYRTrz3vzvu8ff5yKD7aWyR/MhzGFgBmPJUA0iEKGrSQo7136CDbQkCxgg+Z756n7pQs2pndr56/fBAs0aado6a0VrmzUo5zLTnZmTszLTSXJpp5k3q8K5Jhp6kmZlbkqBlpnQKBEw07u+3c7FyxJysVUpYbVI408b5wMhJCrTT1r5N73DgEOEXzT5pXZry+n3sKtJvkzt1znN8ye7y+00w1TYHA00+4GgDcqdw07mZqSYkw05d3q7qyLLTgBg4I9CF7PIY49G3p8EBNkCAxIBpAdaT3L33jwVp6TZoDdvbjTa3iTT7mJpLGmrib7fqQ6YY0zAAne7uNPRjTw5sCSgCgfbAhncttt7RGw+AwObadZju9Xy10nNNOoBoOiGkkU65lp0BsC2NPXcaeXfgCGI+005gbOXlumnl1bQOFaNtPuzYcu7G0m1tYljx35p6t3aXZxKvGz5p7DnwfLVjXcvzT1e8vKYGmmAB0Vxp2222C55Pi980/e9PT215XTTtq3d22gTA0HABnONPjT40+NP69AA7hpph3YHwAHO7+1jT5VpbXC95LygcAPgAzANYAAeaaTXkkkmUAAG9tOSTUkl3i7kknbTaSlQAtiaaSuW20DTTSCBoxpkPjGnbavpIAAcAAu1ltt200u2gLoH08k0l72173Qh5p6TYAdC01pNhsAJ3GnctttvTWmmGjgB8Fttt1aAEOm2ml8HEGc7bbYqAAAgC+TfQNgHvaaYABMCmNM72pak+khTqAAAAAEGAHA2B0CaDTTDl1VV1ELXvUiHfvVrjLhosuEc9zOtego8pAq9sqnEqHaLCo8DveuO9eHn1eG00mk80k0s3Kni/c8Rakkm7tkkkkPettttpbJJ65fB73ve8AAmwC23fe/VQPPrD53ig73vgAH5CCfJXRIgAAVJ22221NW2221NW2060wNpo4AW1NGFttsTRbbbampJIW1J222SJrv13+0lv5AXnyb705f3eIDabJ2axbEsySSFgLJQUmwAyHbvd3ckA20xtgIACSSS7uzZx84HU13vX3ttqa/AMABNW12nU2BttB0QACcgB0A+SQsAAImpJJJEnJJJImru7u7u01a7tLCJrIWYs14Nhc1JdvwHwB73b4AAPdttvaG/B73veACmAFtt933e/uNOT9tNCCAAJq0t5bdtq2222pq2222pO2222pq2222pq22nWmBtNHAAATRbbba2tYk2kvyxtJNrF73wB8WeVttv6u222gW2220tkkk/NpLwe973veAA6BtIAJ5W2231TVttttTVttttTX4AABNW2221NAAACattttqaAAAG7bbbQSWAAAJNJpmNpNJXGkm9IaUX73z73UPGQ2obF/NJ+28bSacvbbz3u+m5+LlttpVbfB8mw96e7oAAPeTYAabQABAAAAAOAHy93ve9/dTc/ftpoAAAbQAW2pq2222pO2222pq2222pq22nU2BtNAAADaAC21NAAACTau9K4mksS1oeZmJZj+2AXh+vOVW/W/qrbbafveAALfWpJSSSFp5ppe94+zEmkAfJtINHvZ75JJoA32Jv9Ff3QP36pq2222pO2222pq2222pzErq222poAAATVy2nzTtu0mHQABNWSSFqTu7vl3dtrsPYvV0sp8x7CnvXtN6972pd3++TYXcikkKXwGk2B1B6BgFt8X67GmlKaeru7OSQBIAtNnqpNJFYkC/iN+att+CNMPtpLiRsDgAmi2ySJOSSpO3Vypq6tttqa33vZJE1S20ATX0kl606G20bOgAJr90zO3M++XFvFjeYklnBN/ePTet+/eAl/AFtoBPHJuSTUuzl3d3fbqWJtKAE56qTSRhMADjTSPemmmlJO6Oc5wOtqJ1V3fbtqaqdtskTVX6237rTt02tiSVy5bbU1ySSSJoxW222JqSS22tqTvTjT73EpNStySSS01d00lmljhAVhz3iSeAPAABTwABb62SSQt95t+9v2JNKQNIAMFgSd8vd73ne+9ba01Xe573vepqq2SSJrvam5DqSVuklbySS8qS1bbbEmSSSRNVW222pqZJqQ2m7dNO2222prebzZT7s2vuSRR53WsxY1mQhu38ettVt/fkAAFPAgAt8JsLb4kkh1ppASSSRppQDBtlJNpgG9td13nPeiaklttqTttttqattttqattt/RphpJgAACaMAC2Jq2222pO2222pq2222prv6z6+1+0m9JpKfn57nphAMu2ghkrIBRUhFWiSUYgGTPe+19vNBA4gQDLlQOvuYhAXYQIBuZhICWyfSROTbNiKv1bs7mpAPa225tTaKmJ2Y0iLgILTfpgQDB3th61kRTGICob3jpEA6cCAtnfPPHvpwwhDcOPvz05dfa+xOffmbt/dqBAP7F86DW1KfxvnRJ1YrTVDJts0Ws+4uKTSMhqRsndDMlfFY+nOqHRC9/jhx0vOoL2zjCp1CYqtm1EyfORyIxtA2SMozBN+IfOKOmVbQtmoZDWlGI9oYTkzUM1bSNibGyTaoZJzlyxD1HKh8yjrCMtpGbRLUPuQ5QxH80cxqHhwP2JdWVZKNJsI5pJwtP5qHJoqZmlRCECFYZQKaSmqJQJNZvhXIVJKYKiFUoApmVtSdtOZssyK94ofuvRG5jS2pr7Em3vN42FBNzvvj628vveAADN5A3sCHQN73sACTwAB6e8BgBbllttKeLpJNZjT002d9PvpPd96AHc7zUnJJA4AaOb3vewLkkkklyld3d3dhgHwBToABaAAHQ1d223yuAtJpKZN7ACSSRt3dq6SSSqm2k6pt5x6xJc1bfqUAAAp9bb9bKdDTTMADZbby20ANgAdtAC7NED4geTSXJ3aaSO+7v3rfX2HQD4KABotqt7bQDAQAKWtNW22gDAALLltt3JJJJJM8u8Xe7u4JtLgBoAObu83q7aAAAAhNibmINNPZ8AF6AAASTcknwAaDTTADgfG7jTt5byzyaSmtK/Hufd973jYBeW220ADUDQAFbSUaeXVtpsPk2l800tgFLaaaaVttvbUAAAAW221WhgAebSXcaTT9733vAS5bb4DbTSAA6Gk+26tvbQ4AfAHQ1bbbaAAAAWTJJIUpiTS200joGzofeTSUk2m2xHOd6HvAAABUqlznOHegAbaaQAHQAAAAAAAAt5v73PeyJv3U8VbellQ1DZqG0lkNFtRMgGJsQIbGmLtve9uTKvfoBNQDz57Tzk6O7v0kAbYAAABJJLuzt3d3dyXJJd+Uk9qqTSQB7wRSqTSQb1pJNB3HznnhoBpTzzFFPI5R+YgZIAfMUwSiaoqqJpgpWlUzE22lgGwAG0Bbbamrbbbak7bbbamrbbbamrbbeoxthpvYAAUSQAAVJ22221NRfX1W/t6SzNZ5N+WeVjhzabIL3lsdAG02SAYXADKbACcJBNgAcvvezt0rJBASSSDTBt+97wFibO+kk9amrbbf0aZhiaA6AAmgLbbUnbbbbU1bbbbU1bbaRphpNAdAATQFttr/hY0gAAqa5jDSaV+4qVOlvlb9zMUrXOfCRTzId7PZl220A2HLbu20rbk+km0XzTSPe973vBJJAJJDfk0lcTdZ1d3fvWmru7uzrTDSaPgAATRXbbbUna7bbamrVbbbU1LbaRphpNCOAACaskkkSckknW5s7tdW1n5rOeUzEsbeP3W2e8vH36v8C0H4w96eTAAA8FvgAPEkkhdilNOCANJgQ2mmkUwJJOdO973vv1SUqttkadxNaskkia/CtttqT7bbbeupq3dttqatkkI07iaN4AAAjd3d3dBbu7u7xyBcZxnWfZy3eRMye4ftJud7vud9AvbdXLaBZbbbU2Fttu7sQBoAAAku7vhw73vQtNVd3d362mYk7bbbamhYABYmpJIW1NW22dgtNq6tttraskklqay2221Jy2221NT7k5m9ffj94FfHeW407baEPAAB4LbbbSySSSW220APNNL3ve973vb+O633vfRNeVttv6tMxJ22221JW22wBpAABU1bbb1tXJJJKompJJJE1JJJbU0AARNXWszmJpLUS1VyeXdVXMV3tw2m/TFnZ2036AY2GmnQG0373qjltE2AHLJJJPNNKgAHvHvY00gDTTEAG2lK5znOettrve933vrTV3dk7DSawAAKJoAAKmhZbbbYmi2221NW2221NSSSSJOSSSRNXP1urm1jHMppLu+d2vKl3UDcvl3jnb767v3gPe9fe0FtttpbdJu22q+aaUxppAAHveLbbbb+fe973vvyakkktrbWrbbbW1JJJImpJJJEnJJJI3JJJLUlq222JqySSWpqSSSWtJ8/LM+75dXfGc5399w9M76U/AAB4LJJIQttttDybSKwmwNFJNIsy00iBpppABtppFfsxNJfvzkk73v6tq22SRNSSSSJOSSSRNSSSSJqSSSWttXVtttTVkkkgLd3d3dEbu7u7ojdyTWkBhVw4q/iEJeWVKY42/p+/ftGK8939IplL9bb9aAEuW21tWgcYAAeaaXjQG2ml73vebYBGAG2mlG3jxJJO+saSV3d7u7ttW2ySJqSSSRJySSSJqSSSRNSSSSJq2222pqSSSRu2222VJa+vjmX95pB9aQGpAPTPggJWs+7Uzt2426c1MTLsyfl542QDfX8N54viYzujeuJu/j/VfdE526laJ7om/mcKPqLpiOrQxda2JcQ20cJzWyC4iEFOBJDlg2YGTUTZiw5VsI0KZDJGwO65VqGjh85XIs22qtJuzTydNdOFcZykdOQq5Q8/jqc10WoaYU/a68Auwfz72eah55Q+9dyHdSu5HHbRLgjI+8uyOhVomkbzJ85Q/ePvSD2iOiNmeuiOqHQVso61Dn3hQ4k+unSOt15Q8L9jz+IHIr3KBwIOJEkUQa699475JH273S73vMdYS00kGCwrEAnJuXqakmZJAMCq22cQB9wA+LbbbaB4xIxmtJLNNXgrWzZvEmL1d3uySXcxgSQG7Tdd5znvT3gAAOJfHLeXvL9aBwAgAAFoAAAu973vF6mk0l73Nfc973vAASRP7F8H3ySYH0kAAABbUkn0k+ADgAHLdNO5bbQAAA65kkkgAAd+7TDh0C20ADoGzXS6tvbaAC7gHwWxtKptJYm1mW20CswAJFJJIAAABEuK6t+ttPNpLmhez3vd97wm3ULDTTAABXEGmmAAJvlmpJJQAAOAHzTtv1tv1AIGgAEfJNKXd6u7vgru1lJpKG+c4AABJJLu7IAAAGrammnbe2gAAAG9223vbdJtI+DTTA3CGzNmmnu2/W77fqaaZOzUyk0hNJXSaSDIGAMXd8uzsmEmkAAQ1bbb202gALDRpppBu22XtoAAABq223toAYtNNI+vTQfcmjzbT68SaSph8QPeAAADUHGpOSdFcaYAGmmkFAIGLTTSAAJStmAABUYb8m21zi7i6m7rMzMw1qNpMS7qVtTLKHFyi5rb80hjttIC0wQe+dO5fed/PvQJKENorvZ97f2p0ltv79bbbaAFtt+smhfW29ttt3dzzb973ve3yqTSXve973vTW8OKVhpqqVVFahyLnOpDiooaBpEpGkEKaZ1rXKIB8l6ikpoiUUoAaRImmYapaKIiahChAoKGhISFqYqIKimqKkpIJKaKFoKUBaCgMzMxYlixXVtttTVkkkiTkkkkTUkkkiakkklrbVt+ttqatskkSckkm6I3d3d3RHxSawhwaUdk7EiX37GgGeheJu325JKm7aHAuk3bSmdv14rit1QAAAAAAA80/Z25JrWpJ78NtW2221NW222NqSSSRJySSSJqSSSRNSSSS1tq6tttqaskkkS7jc13vcxI3cv7FFBUV7GJMGAgv7Cgm/d7O+93nS+94CfpJJCVYBJJJ3peE3d3dlQaaVga9VJpL3vG2ml72PUk0ve8AATvzdzM+YIzMzM7Ut2d3d+8hNjabG030dbbbMeYsx5lsknVMeZmPMVSt1bbVUm202Nt4D7pO7u05psY8A7oO7u1c2xsO7d3d1Ja02hxvCXd3cIyIBIf1++rfsTf2LvveL+52+Tdt/AfrJJJChJJJppyXeru7u5JBMrCbAygwBkm4B979mJpL9+/bUk73v6tqSSSRJ8kkkia72SSRNckkktbampJZE1d2SSNrnOXmYCzMzcwRpu7uYI4yIi3u0c6Jbq6DE2Ntr0IMaCbv3vv1nZmfdzfn3qO7urrknZJJJO9u7u7uSSQbbTAAAJINNIAIm682S+99wba5jnOX3qa7znOc4k+99JJE1JJJImpJJJa21dW3VtqavJJJEnJJJImpJJJE1vmlr37fveL4+afvfvxbS22gAAABbbbIW22gACkkknmmkU20vVSaSx6mmAAa3W9730808WJW28ttbVtskiakkltqattskSckkkiakkkkTUkkkiattttrakkklqSe/xrwuvq5i79oKfqm77X2fl4Dp1NgbdttE2AfHmvB8mymA0+bubzwfB0+AAAAAttt+uLzTzPyWskknq2rJJJG1JJJImpJJJEnJJJImpJJJE1JJJLW2rb9bbU1bZJIk5JJJE16a+yYsS3v49i9+n79l/FkDVALb4AA6CN/veAAk9btN22+NdAAgAe9iTSAAOPnOc4VNRSSSfq21bfrbamqstkk6rizFmSSSSJYsWYpJJOqZmZitttsuZikkkqskkluKZMkkvE3k3E9aD4Dvv1tsuW20EAAHAAALIW7ttDoGk2AHA0H5B73vfl+/LU73Mz7mZmZnw3d3d3MzMzM01m7u72IT7u7uve973vapJJJ3ve972S2229qbJO6CL7fzWfa5nfc3979l/bsuDbOAHwAIAAAC222QtttAA0fve973r71to00gKmrN+9O7vzczDMz1Pd3d3TMzMy7u7vszMzM3d3d3szMzM03d3d3Mzd3dmXX37W3fVIgKuPRtZNV96T5YIKzZ9vhAZkTuCAnKjoddve97fRGWkBD6yQYa9vwlPqrcl87983vnxoI+RQgPiQEO/UqRDIdDIyFbk0LduJpLfz5hjSWI7F3mttfT71PEoAABwA+33Xe/d7wADMA1M3sDMvlwfmvf0fiOyMRylTYRojnJtjbIyGoZpGMybZrFRNk5BSUAkoEUpcZkiFK0qZDRsNrs7VcaU0gZupHFTaStn86IuMlduz7+fz+Ic7t8ofOtbEayIcUHMGERkEKYXAbxlQy95UQ807D3rpeFzP5ulT4yofzPe0nCbeFoGnltR7vOGk+6DmBUJpd73Xe87ePGgAQBn1tv3LTfwAcC2222gAAAAAHwHrmZq63ifVi1nr7nO+5sRbeW3wB73tJ+97w29y5Z9FPXxoAAkBN222yUDQAAEuW3VoHA0ACkk8mkuJNKuXesgASSSTu+NqUrp5pZ3l6GGoqGWlZWdNMKYwwtBUchXG97WPW7edgAAAGZbbbbQAAALbbbaAAAWSSSFQAGve973iB5CAOAAAGk2W8ts+u6BxXEagcBBWk0zAAArSSTMAA+005J9IS6NSSTckmm3JJNySCba2AGwDXLvF6u2wNAAAc6m8TfU31tbiz776SAAAAAW2220AAAA+D528t5de7lRme9pp896+90AttttoAAABa20lbbbQAAAC2223TTSoAEDGmkAVWyq20AD7yaS137abb973u31Lbbb4AAADGmlbbbZQAAAC2222gAGmmkAB23Vt5bpp0uwAADzbAAA8AAAYtPA599zSTafOABATaQAABbbbbQCBpNho000gKuVevRA47980do98i716L46JhQpiqNQ/lDUOGkcVcqK4UEonTgivXVy+oeShvrF9nUh7O5pLWJL2JNzGvt83Jv09bu228tvrbbbaBbbapC220AAAAAxN2223nOXavfiA+jQd3dx3bL5th3d3dnDDkN4nbbb24lWsttt65jkkk62u972yd73uZkZmZWZxwq7u6u7phtBvT7in1dvzBL7dCAA/Jv3vbGAHE2BTmgBfJsDhGnyYm5mQDYABIAZCFAAQ3Sb5rve99qSSck1JJOSakknJNSSTkmpJJybG7u7u6szMzL3MyczV9pChjEMO7r7uf5TWvbvLPZfr+9Pe1QAt8AAAgALy222hbQNgAdAAAACd73vD8u972yd73ve9imL9bbbJjTtv1tttsknec5zmpMknJOc5zk7Jm8mKST6405+Wa/e1v3ve54/T3tAW231ttttAC22SQ2m7bQ6GpJJuSSQAAL93ve9747znOc61yuc5zneJ5NSSTifc73ve9ne9729acrtttkkklXZJJO973vexcm5PtfaW8+9zn3LZ+/BbbbbS23wAe973rbZJDdtodA0Y0wAOggAAnp3ve+5V3vd97Epj+mpJP3G3Lbb3ZmZmcZyS3Y3dnHmZmabu7u7l3d3mj3ZOSXabxNJbU9gAun78AGgACW2220ALbZJC38Hve972veLb222gBb2ST9ffpbbJzve972KSSSc5znOSLJJJOc5znOrsSSm5kkvzTstttnZJJeqZpp+/C2cyAS/U0yt3d5u5KacmJJJqVKackzJJm6ad3dtPV4u5mSeNgABZJJJIAFvrJJ4Xe97JO973nOxZJJJznOc5znOc5+ibkkknbJJKpJJJ3ve972b5ub+TraSypbBRrRTUMAP61SuIaVBrAk1DFBlDG29Uk0lOztSe9z3vZuSSS/JpJPwAB7xgAWyySFANgfAAAW20AL5AfBQKUCWJVQlAkR9t73ve/3e973veySSQjTttttkkklUkkk73ve97FJJJO973vexpzFJJJdeqzC/baaa44YtQxlDUf1pXKGl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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
