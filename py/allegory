#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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2qSf2FS5WjEYJiMUsRv2pVcxmrWsRoqyxQ0GL9qH793313HeorthGbbYVmtqG022tZba2trZlfsR+xH79+6iV/Yti2LYti2LYJAERPVwwisgij73qqsZZISHvVRH79+/uy2LYti2LY97mLYti2JFwjWIwxGgqyRliNlTWI2iNEYjFlLVFiNUqyrR+yVUckZB1qCL9kq/fuudJF1lJ+0v2FK/fv3U/pGtI2xJP7FsWxbFsWxbFsWxbSRXNElpGsRoiftCpyRlUmxGkbEZSjKsKdZLhTI2rSMtjW2jRGK2qxGWrYjKjCsJLEsFWI1iNlKv3BX791zokusnbJTVrW1mma1okgAPognooKnvewbQSCHYpIWxbFsWxbFsW0tq5pKJ+wSOKptlLCsBNEdbjKi0hWI2iMlZI1DaqGpWSliNsisRkGkYqr9iP37rrrEOsiT9oqP2qov3799I7FTbSMiT+xbFsWxbFsWxbFsWyVJfsKK6I21YjRDrSrSixQBH3vVnGPe971oAPYpIpsWxbFsWxbFsWyKP2lF/VSWFGI1YTautctWoEISLA9D3sYxjOIBCJJISCSATar9r9+/dXi1+0DgrQaI1/Yti2VtzK5i2LYti2LaFV+3VUZDEaiYjVVaoQFZGSKLEVTFIFPveqsKmPe973pFX9i2LYti2LYti2LZSQH7edaKmtamsHZ7YoK+9Qq+v2AUG/UPIAAOYgIcicggB6DcQVVTulVV7dNhxKi0qqrAAG+hgDbfve53ry0qSwDlKqQI1CVJWgAPUFU97173ve3dl3hFULgjfKTnUVouN22wddqlVO3dUqprve9G+tgAFUkkgbKAAVKqML6Gll+pJJIwuiqSLqkgeEWJuKe96qwOIovvUqHvevKkxbFsWxbFsv7OYti2lVfsqk5iVfs7yj9+76utVV1qD9pRftQfv3P2VP7FsWxbFsWxbFsWxbKqX9EaD9iKVHB73qzjGve973dqSKSKSKSKSKSKSKSKSI+o6ez72Kr3ve92+xaimxbFsWxbFsWxbU4Rv3V73tYxWJ73vevakikikikikikikikikinaPezSi+9mq973vd6pIpItsf25i2LYti2LaVXNlGEnsHs5UD3s4xDHve97vykikikikikikikikgk7QIPsHvereMe973r8N91cxbS3OItuc5LmLYtnMuYSVQqewe96q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e53v33z73vettthoAB8W22231gBhu4AHS7u7Uu7y7SRZF9K96vYxl3FAzPQfe9jfqXuKoqll05d1d3d7e7e9787u7u5X7arlVdrFrA2929+eed3d3fc5WrANvdve9vd3d9gAAHJclzvbkknsAAAlyXO9uSSewAACXJc73fvOVVebu7s/ABRTjb3bne73d3d2oAANvdufPPOySTMAAA+fbV5qLA99AEgDAAH83b710231p/NttttN+/brfD0AADlUkm234CQAADYAAAaujbfqqn62AADbbbbbbfjbbbbElSptvDdwSAOl3d3d3d2A5Lkud7cqST2AAAfaknyd7ckn6AAAS27u/N735+5yqrzd3c+gAAfqcknyffPOySewAACXzMvO9vMzP2AAAczM8zvbzMz9gAAGZnmd7e8rlVJJ7AAAJclyeeb+5yqr5u7s+gAAbcl5PPO7u7uaAAB98r92635J97mTA2BmTM1gSdlTB03VXVCn48ttnouiLSpLADg310qSzx5y2gDPLuqr7uZdXVZnvuZme17QJJUkkgH1VdUOOtNB4D26QGVdVVeCe8eeXmZP3oAAGXmXne3mZn7AAAOZeZed7cquVUknsAAAlyXOzzsknsG2q7qiqKoqila2XN332qSXABr61atXf13d3cU2TJ9zmySdgAAEvMvO9vMzP2AAAcy8y8729quVUknsAAAlyXO9uSSewAACXJc728zM/YAGta1rWtZ+3zte1Ob/b/fvXf34GwHTSSSTsqABRrQmeZzMzPM7mZn2ZmHEknszwHqNVV1XhPz07VXVTU5j8Pv2AAAAANtj42/PO+97hu42z4u7u7uwAxV5l53u/Ocqq8kkz6UU44H6dkud7e1XKrd3fdAAA+zslzvbkk/QAADmXmXne3mZn7AAAJU7Jc725JP0AAAxV5l53u/Ocqq8kkz6AABLkvJ553arlVu7uaAABtyXO9uSSewAADkuS53t5mZPYAABP1e97d78zPe9zMDYDpoAigAUa1oZWZ3uZnmZmZgwDYZmZmALq6pmEkk7kmAy8zM+zV3VVmZzAnuc9xMzMv93t+++z9gAAEqXXZLne785yqrzd3dn4AADb3bnd87u7vsAAAm92XO9uST9AAAOS8y8728zM/YArRZVFbW93b3vb2q3dlbi+KpVqVd85VVdrClIq5Lm775VJLkiknor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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
