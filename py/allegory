#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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SyKwxiqsSsUxK01ZrnvXOb5znHMoS8iyCSUFQhJok3l7u1ftoXkxAluz95JJ+nqSSknnkkk97Wm3kAACNrzu2h8OTJmcjYC2oB8HugDhsAQVr9bfLd20OAHj0HNRJMzzm2w5XDQW3lltoCAW8urbaOGwno4feAfg9B6Httvltp92ZMzve773ve97zwGvZ6uiDvvwH78dD99q9999EHQmc+M73v7v3QgAeASHogAOgJJJqZmNpvMeLGgf2tX3RV1qNkja2O9+5zqTZp5iucv721k6pkkklA8/Ek8/P99mflhufb998dRGcAAASXxNkkkingAHoD9A5JJIpIAAD7noeBJIm2397qT9xtt/Y20kvMTe4ve+ee+wOgvAAPX35tfMHWuZ+mk5rYtmsln5nDrSS3E8kk6dBL4DgBM7979n33p31MgeAAGgwAOgQwAAMOhFJOxwkOAANtJ/LE+4002tTed1MUPfPzABfiSeAAKGAEkkkkgB+3z6RbPZPuzrR+SspDRWlXf4ZuDrd9d9/u+zqT+zMazGswenDgByRySeyQPZJySbudBnZ30q7973t4fELVsSQEASpl/JngATpk+NDwA7JJJJD9+ASaQ00htJdJyTw90AkU+1tJSCADve93ve97Iak0ugAHwa2kjBR4NDxttxaaB3rz7sPD4fQTwCzJmNAAA79m8yZmvMyZmpnDfg5e/SDwDvIkBz8AH4+QHAAPWtbTeOSckkgve+8aSS+8W41F+nP3sgDAAAPTAPfAD8etLW03JPJJOwAhgSZ3vfe93p2Ymnnw8VpR6D8fYPAPshHhbevnf3HqaT+3HmLZk5PToeoA8AA9SU/R6efm8ySHJD94B9Mg8eyTLbfs/W+UHw8B+tvlttfQeAC223slkmZrMkz548873zve94A4/btvttoAAGzeZJAr7ZAC2/sl9RWq/kktDmbJaKwG07is0zMTeQLRmtfb++565lDnlMHgNfpkzJbXoPuzl1N27y6nZrusjXnkyTVvl1JkyW9dfTJkyB7JAfpEAFaID777777487O973vee5kk5MaBsD2d+++++40m/jpJ7CNOTZN/NPve/JNI9nJCSSSSQAAABAAAAkDvvx7sxstq2bSto2JtBtLZNqtiraBSZoZobMzYMxmJs2W2a2DZszDMZqmzrrnnnnn32tralTzznem2AB8stVUqlVRSl1dFVXeV3fPq7qqeed3d3bAAAFdlSHd3d3dAAAFdldxJJJNAAAXMqQkk3fQAAEnlSEkknoAADcrd77d1VeeSfJJ5WgFaMCZUh9kk7uqov3Mqy8XmZlZl3VVmMDsruO7um+qXUYBcypCSSb6AAA+ZVVd+ZlXV37X779fOpzGqTM55pz7n8OqV+5qqRznNhOY0m5JIvyixTJNbSUxNqSB+hgAE999999Iu94Z4m0t055wxtJHiOBsN3MaaWnfiEFlbJ8+Vw7uxV0EGVrK9AQlvNUwDvnqN2Y1yeSak2mu4vcNmTve/GTq3O+pNKck8ikkkkknRI0AA+bbQHKkJJJPYAABMqTvt3VV553d3dNAAA7KkO7u7u3gAAOyu4kkk9gAAFzKkJJJPYAABMqQkkk9gAAEypO+3dVXnnd3d00AADsqQnd3d28AAB2V3HSST2AAAXMqQkkk9gAACrqjaK5qo595zPvPNd69Vxz18557IZ+/r5kyZz+/v7r5oAoAEAffe+++6fCkk+nZlC227baAZ0A+APDVMkDnOfud1fLeigD2TJAfgbu7uySpCSST2AAAX1LV3ld3yvvmZV3VeK5y75Xd0+AAAbK75XV33u7u94AACpnO+eZ0kk3aKLAuZExJN39oAAEnkTPuSST38AABXTyJn36u6qleZEfJkmaAAA+3QVPImJ9k7u6fsZllllKrGVdXXZzsd3Sftou6qlTLuqplYUvMq7qp5ExJJP0QpeY9e62ks341eGe+fs/fjwLZJMkkn5ST95EePwfEAfffe7++vtr33PTnWb+B3oAAc5zn33xbaAAASZJqTSne97+G5Jk3AAOmYseXG0lu7jXOCedc3fE8096J1vN5648551ebzVT6yl4KUpUd5XfHfe7u7eAAA7KnO+ySTf4AAC5lSEkknsAAAmVsSSSewAACZWz5y7qq8c53d0+gAAdnJid3d3bwAAHZzsdJJPYAABd3UyJiSST2AAAamvbX6SZm/0ee/v332fd5znP3b3o0AVAB8R4D777775zQty22W0W232+218+cyZJznOZMk5zgAttu7q7vu7v7d93dzd9999/pu63EkknsAAAqZEz5y7qq87u7unoAAFbTvOdjv7u7u3gAAOznY6SSewAAC5kTEm7v7QAAJPImJJJ+gAAG5rfnnZd1VeSeSTfgBRRUyNxsnd3dAAAdnOx03d/aAABe5rcbu7v7QAAJ7v98X588uffkn9PZ7Nbu7v3deI2byTMB+IA+3999939rne9d+7rs7297vrvQAAuTLb0+Hfe968Fv6220AC229Gm9d73ve3uta1rWtABGRM75d1VeLqST5NxXowqi8rMu2ZndnOx/d3d3v913VVmMAKXETHV3d3e1zgACvXec7Hd3b3sAAAmRMSeyT2AAATImd9u6qvO7u7p6AAB97zkx3d3d7wAAEyJjd3d/aAABe5rcdVXVSST2AAALu6vmNJvzNxGIniXq8z9+WnrCQgZJJJJ2QDhuTJCAPvp992c5vnM73PdZkk7ZW+5Zxt94kBdX2mCCj5fvmnfnyc8CDdAE7LfIPpb93gd793v0mSPTv696HofAB+AJAA6G4d5oAdMzMzMzMwBGbvlZ2VV1Xju7u6fgAAHPehO7u7eAAA7JHZ0n9JkAAAuZNmZJJPYAAAuo3czN3d39oGZgASpnkjvl3VV53d8rlduAAATIqrqtxskk9gAACoiYm7u/tAAAvc3Td3d/VoAAUqvV3i+V89hTSXeVRjd3QkNoE7nKbCJToHelHfu7kyS6+72+9urbb0qAAgD733333fZJs873fPffZ93nZQPx9wD0k+iTS73vau9773G0kTnJCT3skkgHQAAAJN3d/buatJJJK1YAKmZIvvl3VV53d3dPQAAOzotJ3d3bwP7GZZZS+curquynd3d3bSnUrGAFR3njq7u7u/QAADanmSpJJPagAAEyT5y7qqzu7u6egAADnSpO7u7eAAA7O6u6ST2AAAVqeeLq6qVJJJ+gAAC/799+bdXXz5l1dRP3z7JN39rd071UABAH333333Zzv3e98+vvOc85297bd2204c5zt1znO9Dve9AS3vpd1Vbu789999/fv37Z7rdqTyST2oAAB/TK88i7qq8vl3VV52d3d0r+AADzM7OlSd3Tt4AABXO5VXVO6ST2AAAVqeeSpJJPYAB5mBMiLuqpJJs99gAAEzyfOpd1VZ8zu7u79+AAAld5kqTu7u3gAAFc7q7pJPYAABcyRdXVJJJPYAABXu+H3vnnv73v79+73l5bq3nO28stfnDfohJJPfffffRL7QCdXq73ve9IEAPzaS8A7737bve223Jkl5zvQFttttADNau6qt3d37JJKk8kk9gAAEz9O+3dVWd3d3bNAAA7PEqTu7u94ABX8Su8x1d3d3fuLoqqdlF5lYViuznV3d3d+rurMzLzLq6phhS3bqy220izLurFjzcSaW7m4K5t/fm1VZ3d3dvtKUutYd3nV3fu7u94AADs52VV1Tukk9gAAFameSpJJP0AAA++/s+VdXZVVdqqrTGZj9vRH7rpK66ivvda7CvsFbEmCvvtiut9Cvt7/dYK7BXc7ABKhAnxz4+FMlSHyRNNts81H1MnJd34BL2VyFAQRQCWEASbo8wd4YJ48ds2o8FebRdWxW97o1iHBRjdgJX6xd8+KgcASYCWVAEnh861B+aElKq7RCzjLCDEODibqu89NnN735zxz2X8EAcevm733ffPnzUoGszMkmtAKSZkyeZmgOAFtskklttDTJkkBDeZJL0HB0AGTeh6HoPQfvu5kmT2ZnftrQ94HoZ+bTTxPP472SBDD6TJJOzszsgCRmTM1JoQCNacurbbJMmQgUoAlH7293Z72+QhLRpJIqTd5uzt+lu7+tPWv2SZA+/B+DwD15F822+K9cS+22y2oACA4bVoAAtttsusySUeh6Dy22/ra8A+GwPHDR8CgLbZbbQrQbmw4btB8PAPw53ve9873sn6xJNmBwACSd6sXnervT8kmz9oQ09ASTYHQPF71Z9z7774INJsABEkX02ZySQBdSSSmZiSb8x+Ykk1uNJJcxLcW45iOcA+n33333x0gwA4eGIXUJNLfPO9+8/enQAACTzve9873vZJPA9N5bbbbQAT7769kzM1+1reZIkn3vfD0AEAAPvySQsbWY008eLve9734ggJJPl5i99PPvvgiAPQQa2kvABgdAJJJJJBASSSSSAAA0m/vtSTcxNpPEk3iTSbNP35ABGpJJIAW2220EwC3klySTNW20nUhiWgAaEXmSSdn0ggAAOtNKZJJJIH2NAeAAC1tJd73sk1tJfSI8AAACSNNKNNKNNKNrq8/Z+/fpIAAHOc5znOAzAA3JM35qTJD3E03+STf5AHwfB8BwA9DW0lMkkCv0kzNTJma1MmTYfCyZJmJkmZdbeA6BB0ANTAK1JklaA+HkmSa3AHL2ZJmAHetjwPQAjvkzve973vO9AW2220dne973ve96AG5mTMAcN5Mx77oF4/ft9yTM6ffO970AAA73ve973ve6zJmAt5bbaAAW2220AAttt9trXj9+Dn6hrSJbbbfbd5kkHgAtltttBAACSSSb0Pnp7T4BLbQP3bzfOdnffs7+88z9r3nO8053rRb9byy0AKSSST7fvvvvl++knfvhd73vSAAAAAHoak0pk1pyTkkh+ACSSSSQ0AAO973ve970CB/H5ttpZiSWYlmJNJ5jbbZRsC2S2JWylbRNpLaRsqNlJtVU2JLZtsS2qtiW1bKTZNpW1G02ti2o2Um0NobC2k2C2WZtVsFsbRNrYbQzK2thbJbVLZNiZpVsjaqNkq2kbC2KjNtJbRG0S2jZsbVtEbJZtqLZDatpG0zKbKNitY2ibSNoG1JtsS2i2Gw2mwW1VtLZbRs2qrYm2YhsEbRNgm0lmINibVGwbIbK2hW2YGybBsbCtq2JbTZTYmwLYNlsVbBbRLNRsraWxbWYm0q2hs2qW0RtU2FNltRbFsrZtGwVtDabE2UjabSbQ2U2BtSNlbW1SbJsobKraVtEbS2RtTapG2Ym0E2zKbBTZW0bJTYNqLao2myqm1tNqqmzYzVSwYDNG20tqmDCm0qbKttkRtU0YG0NpsTZWDVGDVRgxLao2MxTBqqsGVDbY2lsqYMC1WVg1KsGpNrZmbSLBkYNSGDURtGabRRg0jBltS2VZq2WDBrUjaS2SbK2bUbVBgymCw1WlMGpMaVtbKjBpVZmw2bTMWbYzJbbW0myRarBqrSmq1VTVg2k2qwZFspmltWY22W0W0JYMVMGhNE0lg0TaRsK1WSGzY2bbWtW1bRUwYQ0aowYNVlo1VgaWDCwZFg2DImq0bKMGUptbTbbabbE2TZts2LaUrVWSLBhNGBgxTBowYMGDBqrBlKwaLBoYMpYMVWDEwZQoqqoq1KuwoqqLpSigtS7bbRNqRg1SYNQwaobKTabIwYG1KWDBYNVMDUYNCwZE2ibQytJYMKwaGDCGDKbNq2jYtq22s02LazbI22bbG1sVrVZiqMwVg1RMGkmDUhtUNgwMBs1oYMGwM20TNtDAyLbaEwaharRWDE2kszaM1tbNqbUWyNiZbaq2Ws2U2SWDKKsGBg0VGDQsGktkW1DQwaGSwZgbBkMGKzKMZpNg0LBqSYMGBgsGkxYNYrZgzBjYCqqylLUqixSiqsqyi6KoqqKKC7osu7LqirqwLUCmaszNtstptjRstRoahg0m0SstBGDSSwYGDSS1WSTZsVaGDBgwZG0MDIaYMGDBoRoMGwNNBgymBoYGJbKYNFgYJg1EwYLKyNjNbUzbWatlsM1s2TNtG1ClhdKXVVRSl1ZRZYsoUVVChd1YXRZVUFC1KFUsUVRVrLUu1FlBVi6KuyqDaqrVapWhkBoxVLBiRgwBgyTaRMGqMGCYMlYNVUwZYNBYMGDFNhWDBYGBgYMGCwYMGhYNRgaqYNUa1MyWZsmaNi1qbW1sm20mzaLYtrWhm1mMzNY2ttoXVVSlXRZVBVUUXQF3dF3TVsbDaNqzNraW20TZi0LajBoo0wYyom0kwaKqwYosxKsGiRtQlgwYNCTBqLBWItm1DYmyGyptltqbStibC2Zts0bG0c88889908uAAAKu6gq6Kq6KurutqbC2VUbRUbUiWDSYNUtqFWlilNomDBJg1EMYGgysjaGJtSbCjZtsjZRtVsvPPjvv27qqzu7u7fQAAJXeYlSd3d3vAAAdnOrukk/QAAC5kTLq6pJJJ7AAAJkTEkknsAAAmRO+3dVWd3d3b6AABK7zEqTu7u94AADs51d0kn6AAAXMiZVXVJJJPYAABt1PMkkm+++vff36e+++vfQBNm8ySA5rfPnNTmp+7N81dRrM2a00twxGCNik5GmlNnraSk+gc6gcyTp4d73rWm31575zfe7DvXH0mSHseSC/BoHAO9PZycck4p0J+w3AAOmYAAEyJ327qqzu7u7fQAAJXeYlSd3d3vAAAdnOrukk/QAAC5kTEkknsAAAmRKkkk/QAACTwnfbuqrO6+7u3dZlllllFOc6u6u97u9+ddXVGKXmXdVWYwle988dXd3dP1cpSjAK6nec7Hd3d+0AADPPPaVm53nXYcyqeZKrzFzDmIL9j9n7EX7ArmBLmEuZQ1zQrmQ2ml3EkuzUk2zEkkE4g06AACkgffd59zXOd73vnVvXzw3MO+v0zIH37IpiXknDGYrb2VJpYBF3O4u9vE1MSmN+TVMSVmtm6jGl8HA1mNGJmIxJGJGJoxmGGIkkknUm2mpjacxNNoXJExN3d/aAABua3O+3dVXkkk38AABMjcb11dVO7u3gAAOznTzO6SewAAC5mtxu7u/tAAAlTyJiSSfoAABua3O+3dVXkkk38AABMjcb1VdVO7u3gAAOznZM7pJ7AAALmRuN3d39oAGZmZh++N97F8+J/vd3p7+nYQANJJO+/d6C3lttp99PvvvvgLddgtvVtvQD6TZ3ve/He94SSABJJIAAAd73ve999nzd1uN3d39AAANzW477d1VSSTf4AACZExvVV1U7u7eAAA2u847ukn6AAAXubMzJu7v7QAAJU8kzMkkn6AAAbm7mZ327qqkkm/wAAEyTMzeqrqp3d28AAB+7zuzM7pJ+grhhdF2XbMueSZmSST9UjG4NSEkh9Tle+WAl8fvDFzM536zMzfrv1uja22/ct04bt+sttp999999/Tne973ve9AtttoMJJJKST77775ppfffSSd73ve972SAB6k0gDwk2SSSfH4A3dAD62quqZlMysFGI8kzM8v6u6qou5J59mVtV4wAMnkmZnydd1Vd3edvAAAdndnzzyfpJN0AACZJmZN3dnsAAAuZJmZJJP2gAASp5JmZJJP0AAA3N3Mzvt3VVJJN/gAAJkmZknXV1Xd3nbwAAHZ3Z8/vnySSboADMzMnd9+3zw9N5iTSP2fdAS+A2ABPuyBbyy3nF/fn333ed73veu66B3vQFrvZ3vbby85zvXyzoF6AAHsq6rd3d+yqu6uSTMybu7+0AACoTyTMySSfoAABubuZm7u7+0AADp5JmZ8+3dVU66uq7u86fgAAPaX3ndn7++fO7u7eAAA7N3Mzd3d/aAABXE8kzMkkn6AAAbm7mZu7u/tAAA3N3Mzvt3VVOurqu7vOn4AABJk88n6SeTYAAB37PnnySe+ybu7uwO9rve9726vahec5d5kk++c5ztsvYYk0tPwH4f6di3G0l+nPMgScbSX72RrJD9+d739n6c55zn3nxbxbakyQefQ3tsPSvcaiv2w/dmZJB5554tt5da1oAA2s3czN3d390ZlllllLxldkmZkkk/SlEAAbuZm9dXVSTye6AUUU3czJ8u6qpJJP6AAA7O7O887u6ewAADq7yTMySSfoAABe5u5mbu7v7QAANzdzM2XV1Uk8nsAAAmSZmSSSewAADnvj1nvZ3fZ+/d26bAcNAt5Zbzi/vz7752773vfe973vfu973vfFtv6329H5JklyZJbf623p5e4UD4DsAAAAmSQACegG7pJJ9oAAEqZXkmZnfLuqru7u3+AAA/TyTMySSfoAABubuZm9dXVSTyewAADxU8kzMkk2ewAACZJmZJJv7QAAJUyvJMzO+XdVXd3dv8AABMkyeeSST2AAATN3MzeurqpJ5PYAABcyTMySST2AAA139ve9vPe+dveuhsBw0C3llq14+3979973ned73zvegDo2B3verbb1tJEkAJO973vekgwA9QB5Jskkk/SSTMybu7+0AACVMryTM75d1Vd3d3b+AAAned5md3d3fq/hClmJbua8SxbixbraSOQ3StNK32+XtyhSlKFFdne5md3d3e1XOADs7szO7un7QAAOqZXkmZ3y7qq7u7vf4AAKbdTJ5mZJJJK1YAe1c8nmZlbu7v7QAAK726yfJ8zMqSSdXsAAAp9+/t3f3lXX5v39+9+po+339T7sADzhoAHQwkkknYpO9739+nvvp8AAHe973vene9JJICA+7ne9O96STpJJJIBJJJJIAAAAAboNskn6AAARWbM3zy++3dVXd3dP4AADskzM2SSewAADq7zuz750+yT30AACvrfN+Zm7u7/aAABue7mbLu5JP0AAAis2Zvnld9u6qu7u6fwAAHveTzMzZJJ7AAAO13zvmZ0kn9AAAL3PdzN3d3+0AAD3zN9x41ELmBW96Emb0/YK52QwQQAEu1lX83vOV71381Al1gCW5OefNiuqpgJzErzr7u6FZkFd568qPKo2u957L3X0EHAEoAlfLtAlwBJ8DHHLh17kbaBJsBKu85u54BLovNHeymc9NrKbT9x1rIwwaI/NXkXGtkTyCEgIwEmAll+z4Al3L8XTQZl14SazWTU19r7fi1egAen7z7f333skkk9/bJPefhtN/niecSTTXub78fAdTpH7RXWqVzIWwraZaK1FlUucpOEpxhLjUTFtGxbVLaoayaxbG1sswmZYisxGRWKzOdc5znOefJXMALMyZGgtvMzJNyZd22lMyTL80VqqxVhWMitYq2UjMhWWJMLJUYsorM5znOccyTMs1beXVqySTGgCtD4eLjND8HvtyTMyND39bbJ+1MmZMmsmTMWNYkm8aTeNJt5/Ek/QA/NNpmSTZB4cNPhWsya1JkzNTzM3mZkm9KgqyZkjS2W28kyXUkkk1qlaFjWSpgrCKbYaznOe8z372FfZ99959znJ1NNTJJ+kk8qTSADwAMTUTbT4szJkyfaHhyv2ZJI0urbbbw0AVDwD4gfDwC2363doAC+22+9kmYO9973ve/g8BXNmwHDQLeWW20CAHitD4OGwHxu2239ae+wHv4Asv7Vnez30A/AHUmlEk2YABJJJJIEkgtttto7GpJJNZJmXW8mtZJmXWZmZ55uaa3JMk1Hd+/vv1iTJHQPqDve9/d1+mtTmTJN+85zzne9IAHttvttoAMAPwegHn333ZkyZ+1mZmZ+++8AAkkki+9X2PP25jW4sxtpbmpYlu2XNrW+bjYzWZ0G03LhsOImyQcc7RSYMdEaE1JIpGm11kKY221G2lHE2RDabJLy87u7u7u7u6uZJmb1Oc5zn3HgHwICB7mSQH4d1rvf1t8t+5rvQPuzU1MmZJO976Dy23r4A5znOc5x4Fye6e7+X79zmSZnJJJmpMmc1vfFo/B6LbbbaAC2222uyM1mSZmszM13fe973verbbbaA/HXuZJO7A95y9fgAfW7tttDMkxMmskyZoAMmSMmSGml4uJJsTaaX5pN7+/AB0yTW0lJIOC228yTMsyZmrQEkzEkyZNSTM1mprJMzWgFttt3a3A4cBbbbbQGskmZABOSTM75qeZkkegdAAW2220AAW2220AAtttttaANEFvP3O5JMyvN+ne96AGsyZlttt5QD03mSQeAAAALbbbb4B8rUmSAA9/X75z05+tvuq+HF/fv15777zi2AALbbbaD7wenPec5zn1qwq4yisqrNGtWEMypJJNZmpJqSSZrQFWZMxoOG+ZI233O97JJPDvdXc+Efvv3meffvPvz1tJHQP4X32K27fFbeK4qe9DDwCSdik73vf3fZ99zt53ve9722223vWgHe9d6D62941jSUxSHZkkkkgAemNpIDhJJJKi1XK5VX8UUBaqF1RZZarVRZttW0zGYWyzG1LzzzzntKnXRHtHnlXnnqKfTbWo1Zth3eQAABv2+8r5yZ/f327qq7u7p/AAAe95Dzdkk9gAAHV3nOzukn6AAAXue7mZu7u/tdjMsspVYiTMnVd93dPaUo4AOVkbnf327qq7u7p/AAAdkmZm7sk9gAAHV3ndmd3Sf0AAA9G+b8zN3d3+0AADPb9zf3nvjvne9dl72773ve9cNAFQA5ptJffb99994uRBpjaS/AdD0aXT9jMSaQH6OfPvdaaXYm0pkDh0A8TAkk++5MnA/IzkF0PV1JpBp8HnJJJ7J1T7vMmcyZ5JIHp3dBNgHxmZizHmMxbDZy/m0lbbfya9pLugAJqokN3QA+FmJqbJu7JJImpJN3YJsAE1DA2c5fW0lbbfyatDd0AATVVtu7oACTk3ZJu7u6I6zvvlBC22+1Qwv5Wc+Z83fk0bAcNDkaaKgD799r777vO99zoHofB+BAHJI8knPZOw7wODaSkknbbbbX93ve873vnegAVp+kyQPf7oG7oNsAG0AbOfqv2a2krlxctvia8tDd3wABNVW27ugEbRkkm7sknU13ve7u9E3JIrizHmJtIA2fvf2rcS/braSMMC++LMaxWhu74AeRpVAG7oHzQXve9JPe9760RrASr6AShYwErlz4BbeySTZJJWk0HQwAJJ2KSSSe/fuc3znCgtt/gd+7O973ve96ALb3ve97JJJJJAAAAkk8kkn4AN3QbYAJoA2XzzfW0lctt8TVobugACaqtt3dAASckm7skkiagBu6AAmiSb5zOXW0kAeGJqrLbd3bbbRNAG7soAJMA3dAAG1J70qSb+577v33vv9+/vv7+A8A+GwHDQHPvvvvv7ne973ve2pmSQB1bxbb06tvOd5z37Pp3skkkkkkkkgaAGgdAO7ugACaAN3fHbraSt13LlxNW27u2222pq23d0AAbXuAG7oARNSSbugACaAN85wvjaStt8uNL3Mtt3d8tttq+att3dtttqTAN3QCRNHxM7zfzbQ8itJV5lC+YnTEPeJeavvnKjzIl3kV5orzE/MtkzWjSK8yg8y61raxvOJB575IjzKq80V5lU8ypX8iW9tu22yT6TJPpNn3vvvvvskkkkSaVDUrmY7fbbb+6iST8pJPFQk9knG0pIcSUkkySBJOyCTTAD35JpHUYefgA6GpJNBqaSZjAN3QCRNSSbuy+tpIA8TQBu7AAE1bbd3QAEnJJu7JIAmgDd0AATWgG/ucL42kraX8mttt3dLbbU1VbeXnNAASZJN3f37u774p32nLX3eaWitWaZrZmj1h51cN576pR66eevPPPPP1JPN3qbSA420jwrSa8TSttvbbtkkk+kySSSLv7Wml9n2Pn37476e/t4zPuJNLQO+CN1tJfSSSEXe9aaXYncxYYBy1a2ks/v3e5MkOfuG5/K1kyR0PQAGkk6lMcnZBtpBqaRgBu6ASJqSTd2X1tJAHiaANnOAFtTVobugACTAN3QABNBMNAAE10DObbnraSttv5NWmS8tttrStDd0AC1ZjzG0lmNWmXarQBJe04k/2JvX+1Jas1JN4lzL5b20pJJOQQAfAaSSSfSZIHPfvt/ffAPjs773vdSZJ3ve97weBPib3q73p3p36TZCT6SSTsLy2222ySSSSUJhsne9TQpJN3b62kgDxNSSbHnh/d72ZHdG5vZbZMtt3N7ttsyfwmrdkAE1ADP23W0lbbfyaiuAboACaqtDMAASckmYAAJqpJvnOZttt8tvYegHAAnsk2SSSfSZJJJ9+9WvvvvgDpuDQdpfAfo73vcmSd7297sttt7b0AABWhw33vUGYAAJoAzC+tpK22/k0K5abttttTVobugACTAN3QABNAG7oAAmgDd0vraSttv5NW26c5bbbU1aG7oAAkwDd0JJLmYsSv7imJNIb/tee+/r9r9+/vv5f6g8A18NhThoDn7nO+W369753ot7kkAdsHkgetZMka7rvdg/W9tt60O973ve9C2973vez9MbSUmzAA3dCSRNSSbu0z1tJGgfk0Ab3nAttqatDd0JJEnJJu7JJImpJN3ZAATQBu6X1tJW238mrbdOctttqatDd0AASYBu6AHfcve+d9yVhXvCuIsi33dCsiv35oV2K+8znUVroV1+FdCCMBLbAQoAkzbqgeehnNrrXWISdS+dnL9Zte9FGu2ZXsIFAJMQlAEmd+HmcZ8aXTpg4OM5vbfz5UxvypNF/N3ZckG5LM7+595z3n7VcysxmWE9BbVGJaK2RWqVyaUjSRklWRWmlhGfb+++++9gL6T2UPNVJais3znXPN85zxyKyqylWRWc571znOuc+ih6S6oc3zfoLMkmT7M1MzMmRo5r8erltttr9lHBOc51znOc4leIrKqGVGXCoeVNNxWJW0ZM5zrn3vNc4qU8isirlmorNc51zznOb4VfslUm8lJPYr4/bOsUWv3Xf7vnvO+ssMtimUlqSfxVxUyVlWzLcitzf0/fvf7553336R8dqriLaVqHhmxN6RWGs5zrm/Oc7fUVjMYwxFhYK+iszz7r7X333PKqdZFcE1i0is5z7rmec5ziK7hipw5QOVOc5hLQmqM5mxNjDFrKmjFnOdcc5zn3kscizKqW1E0iXIrHNbFHxrh0K5zS1rbZNmZFYq0Ezfv3rnjnOfcCwVmMxKvYrCrWc51z5998QdxlnuEmr7f3X3vOa52qV9E8aTU2TyeyTlgsAPwBEk0l5+2STz2CSTJ+W7ttt+Gw4b4atttvLA5kmYbAXMyRoAAEC39bfLaPweg9B+DwD4bC363VtoVAb82W2fcv62vVaAOGwHw82B+cAe2y1p9oCgIZkkVoArQL+vJJmXXlvewDX3Gmm5NbXuPmLMN/fg+k73ve9JJAeuzuZJK8z3z3UDz77q9+ANc5znOfWtjYcNzgAACyZI5zn78JpvvfO/gAkkki735L9iTaxrEkpi3MmpqSZGszJm97zWj04AD3nOec5zgAPl3bbb13ve973ve970C29BCYkm/3y1ptngHwHerM70kknY8knn33PMyTM5znAXMaya0C3kkzMurbaLmZM+mszJGj0XmSXNW22nw8BzLq222v3cxJMzWSZmpu987573ve9rQBWgA+nmTPMmeZMZMv62232l93aDn77mlu8ySW3y6FrewC+cmScmZzJkm/PvtOdnebySSTkySc++++O3sA9B+LbbzMmTJdWgWZkzJ9NTWTWa0zR6BmSZgGh8PFDzMmYLf1ttoP3r7Q+/fPh553MmZ3ve97zve+AfDyZMwtv622gAAAB5JmYB8NZkzFttvLqTMzzWZMzzMmZQXljWZJHoPyuyZmfSZM73vfe97zvdyZIAPJmTMttv62+TAPgCIeG8ySB6D9A9D223220AA8Hg87Jkyd73ve/u9730FrQCgAPj7779Jklv79+v609AABNckkybyTJuTPtb3mSQ/PR4xznOec50+oRkV8ZUYtSoZMIAfvX7d3a8cHp5BrSC2BozWfGg5jb/nj7jSa4l7nO+d8X7tt/SSckklPgNPu974cNAc/fa++++ALe5MAdrRvA9hvuu9AkkuDve967oAEk8/dxtJd7vne97JJIAG7oAA0wDd0/l62krbb+TVtunOW221NWhu6AAJMA3dAAE0AbugACaAN3QABNW23d2222poxgbyrzy88bSVtv79cbVtu77y222pJt/YsxCq4s28NACT48A+G34PXDT4ed7e3WZJLbefsCbMbSUk+gc34PAA/dS7kmZMbSUkgd8mrs/cbSUn0nsAkkEABEmkYAgCcUyT2d/czp9JqkCBuAAWvMWZmNpLMMt5dy220VxKlu5bb7aJoPxu6X1tJW2+XE16rbd85y222pq0NwAAbUSwOG7oAAmupBpurQABNdaDTdWl9bSVtt/Jq23cttttTUx/rc3m+eWnwAAHAAnsk2SSSfSZPpNk+305vnP37ne9673vLq223d7+vvPN85zg10yZILb2229rQ4bO973oP78H9z7ve+/3eh5ziTS4ABE0AbugACTAN3QABNAG7oAAkwEbhfW0lbeK3U1S3Tbb7bamrfTzmgAdTUQabgAAkyBuAACaCGAACa7v329Pxz338k0u969DwDX2hsOHDQHPfvt/effB8O4BuTJB0cHoPzJkne973v4DhvoABbbela73ve9707o/XG0lbbfyatLu2222p+5mNW27u39e7u+8u6qii7qqOk75553d3d7y7qqKG0lmULu222lxtJZjzEmlixW27u293dK5VXVKUVV1T67u7Mzu/d3dXKq6ozYjPPPPOc557+UPPPPPPb5iNtmw0sVtu+c5bbbXMSaWLFltu7t9ttt9dWpRdWpXJ0+V1LK+Lyvv359++effnd3dJ3ve+d73vXw2A4aB2dv7k5vnLzvfIHGr0B3vbbbbavQtvVtvQJJJJJJP0gH4AAkA5ugAUaeLFmJPFitt3dttttSeLFmJPFiVtu7tt7u7rq1KKq1K7u7Mzu7u7uurUpVO7ru7bbaJq227u2221NAG7pfW0lbbfyatt3dttttTVtvnOcoARNAG7p3ve97mTW9e/t+a73ve8vQD0H4PAPhsHOfffffAFttttFtttteS9tv6Zlt674B8AB+D0AQYBu6AAJoA3dAAE0Ab5zmoLxtJW3lxtW27OctttqatDznOAARNfgDd0ABJySbuwABNAG7oAA0wDfGlzEuYwvG0lbeK407bdnOW221Nfvf31zMXnOU/e+nwSSSeSSB6AcAI+Gwc4kyTnOc53Pvuu675+1mST93r9+ttt6S26kyS221y3oe5kkO973Jkne+kDwAAkkkkkkkkkkADd0AASYBu6AAJoA3dAAE0AbugACattu7ttttTQBu6F+SaVtvjatt3dttttX5Y3mPMbWZbb5znLbbaZidtvnOctttqG7bd3bbbRtee5228vvbnbeU73ve+973r8HgHw2DnPvvvvtPwelrW5MkAcfPL5bb3jTs2C29ttskkAAPQCSSd73pPUml3uikk3dkABNAG7oAAmgDd0L82krbfE1+xZbbu7bbbU0AbugACTAN3QABNAG7oAAmgDd0L82krbfE1+tt3dtttqaAN3QABte/vN89WZ+bSYa2VpN3vx29uXEvI0m9uXjSbt1pN+NNO+8aTdutJu35Jp3xpN/W28vzaSufreTj5sHOfa+199v7UD2YPLf4/RrcmSHHAN+773vfSQGmkDTSArSbGAAHf4AAtttvLqxr7Uur/ZJmf37eSZmoA3dJbaJoA3dAAE0Abuhfm0lbb4mv1tu7ttttTQBu6AAJMA3dAAE0AbugACaAN3QvzaStt8TVtu7ttttqatt85zloBE0ZUk3+1SZnf695Mn7397+/e++99/c7323+PQfg84bHw2DnPvvvvfhH4Dud73ve973oPcySA/Ae5bb7baAFtvP0mScz7J+7pBNo90k72STd2QAG6sazFbbu7bbbasxJpYsWYk0stt3dtttKsxIzvjmI3O++c5337+UO+++/ftsRm2JNLFbbu7b7bbV+WJpYsQHOc4AAF3alUXVqV3d2Znd3d05dXVKUVV1RY0Bu6AACTSxYsxZiTSwDd0ACCWYmkszMVtu7tv3zaStt/L80lvev8M4z11wV2SyqbNtnr93zpQddpz6AS5SEkN9kgkJ8cZ0mDgFMkjCQhG3OzKASiSCmkg5bgkHciE8gCW831rjOwWMpoGwuugJclheRrbbNtizm5ta2Kn4Voo9fzud7tepc8MfmyqpFfD13fMv5tfKqt78EJP1FFcKdR0AkxCLEJBtX6+74354BBet5kk1kzMyZPtZJmNXw4LMmTGuAFagPxZMzJJGvQFkyZmT2e7yTMk1N5uSZmJo/ea+L6cLbaSAMLjTwK18+zJkyaHpw33MmZNeed5rv791+799+76RYqOv3Ih1QyQt+edfvfc8/wO9dvTvndA9LfbbfLVkzMmTOZmSayY056bFmSTGjhofrJMzWs1rUoyCxGOZznX3HOc+VRylYVZoLLebl3ba401LJmSNApv379/SY2sA/H3voESbTa3zZJJ+nZxpNzJ3vedtt/B4B8atttvK0ICgAAAcN2363fltH3wuZJL+eeD96Pz5w+9B+DwW/rbu2hw0BeWW22ggArT4eDhvskxzmNpLTQA9IfNpL5T9PPJnnf08mT33jakceHHiyTM+e5kk8P3t3KN5kk9Hji/SZA42kj4DARNbSXe9+72fRe9EnMjesiQz5xICPOXz5z5nzvz29vxEgJLBBVd3N3e7m9tIDIerZXK3PgmwphvigQd8/dmZlY/fOZ75EgN2e2t3c3YkBx7sDxpzeZJK8ejZvMki2+26vU8zJJADT0RNbSU9jWLNm/fvkNNJc/LUk36gSaBL2JAV33Pnzfm75ICAg2bu173PZKbwl5mIZJ9hHn3X3PeeczmUGgc++8usySbazJJp+8HOUJw98HGvtW22/VHh6NH7zMkmvGW+36znX3uYksgHgfCG2mY8942ksCckne/NpLfczJJq+dDjUe7zJJzR4/X9bvMkmru2nO+fTm6Hm+b5zv7f3shNsEyyo+6SAnvV72+rcDyaW2kBW7l7tk91HH60pJu/fr+rRvMkgHyXWZJLbbbxP3Zkn6d9zJJ3ved53ydl3mSS2zy+W2jmjZ+DH7S22/au8ySV94PQHPPU1PJf1v7l/Ufg9Ay+/c57zncmZMk7JkkyfN/d9O97+/ZkkD9+A2W2/cmSZl1aBZkkzGgDeZMw4bazJI49N5kkCe26tFvvLbbfI2DzMmZwE+knnwkmkg4g9A6eNpLUmlJJPZO9m7Jkl3bbTm8ySNAX5veZJDb8HoAbAcfPMyZnr2W6v762lgAQDuSTOd73zve973eZJAHNFyZJb+t3bfAPoAAENB+PB8ObusySW+236/tDwH48zJmH4OX2adxNNnQ7nfPubnj1YsOaeemNpKSd7O8ttt1Xw82UeODvwB0AHOb45znypNTFVPajFVd5SuZ6/PlWJMmaAckkzJ+mSXdvto39I+5Pun3X3V3u27/rz+Z1ge4r31xFed7231pN3E02lJrbTgcTSbMaTaX4OGNJsPQDgEk9km+5JPJ9977777IvPJIfGd6B3vbbbbatttmZJetO973ve96BkyRbbznOLd3VPu5JmHfMmZLrE/wG/y/LzzWknbONJpXE2krdbbmNrMbxYk1bbu7bbaJMA3dAAE0AbugACaAN3QvzaStt8TVtuznLbbamrQ85zgAETQBec5bbbU1QN3QABJgG7oAAmv3283gCPAJ99O9873vZ+AANg55xJknF/W/foPJMkOTycjEvAADoC4YGJNIAOB93z72ffFv7MkncmSHZ3ve96Lbec5xbaW3obuuQAE0AbusAATVtt3ddtttTQBu6wvyTStt8bVtu7OK222pr6283Q9APE1EHDzmgARNEhugACTJDdAAE1AOboAAmp+JzThw/egUOdeh19oABsHPOb++9++fivS2T+Ad729AOy3nPnOdt6d6CtLQDgFt6G9n9zMkn9/f397MnZ/f39zdltttTVC7uh6AeJoNDm6ABE0AbugADVxW27u2222tK23d2220TQBu6F+bSVtviatt2c5bbbU1aG7oAAk00lixJpJJZiaTWMCSSdtv8ere+223oeht+HOffffEW21ctttottttpkyQt5zn9kmZbene96kknvO953vfe9knZkn6SQX4Dd0AATQBu6AAJoA3dAAE1bbd3bbbamgDd0AATVtuZbbbamvgMzgAAmrbcy2221NAG7oAAmrbcy2221KSfwygrmEppRkJP3vnOqK7YKzIrML7+GpP2dZUk+57zn3ff6+/Odt+/j8t57bbQBsHnOfeffVpbbVlt6eyZId7zv2wDttt5znbbaAFttttfLu223rvda73v9yTJP7+/r4mrbd3bbbbU1bb5znLQCJoA3dAAEmAbugACaAN3QABNAG7oX5JpW2+Jq23d22221NW2+c5y0AiaALznLbbaYk2xYjEk3iWcd855bbYm19aeJB7wNXpJb+tnf3e973pNkkn33vec49S22rLbba/u9AW9tmZJznMmRfffTvYNpsCH7cTTYB4k2w0hh4m02YmAAGTvO976k0u2cO23znOW2hE0AbugACTAN3QABNAG7oAAn3Eg4bugACattu7ttttTQBvnOBfzaStt8SdtuznLbaJq2hu6AAk5JN3ZJJG19bJzsxr39f188+8a++tLDAk/W1/fu9Pgfjve+fu9c4kyT77771bXsmSF85yc5zir0bkyQfQ7w0Lb1fbRtNya2kv0kh6AA0AdSaUwuYkm7QA9+DgW3d22gCaAN3SnzaSDU1QDZzgAJqTvd3e96SiTAN3ToAJoA3dJJImj9iQBmH4ATXb6kcDMP1ttTQBmEvzaSPg8bR4G73hWnbbU1+vaumZiXnnu/r557ive387bxNvuNO28flt+D48DveJNKyd8+O953ve++c+5nP3n6Tv3QAD+71+D1b367tvOfnOyZmUdD65iSbup222+tpu2h+bTYABkne9736QCboADaieGybuwABNRowN3QABNAdLzbfOtpK28b8ttvE2lublttK0r0N3S22iTAN3SAAmgDd0JJE0IA/bsvjaSDTupq56eBmAfiJqd8zNmPeQ8TVttPWAB+9Uk8k73kB+v1/X23285P77777vR0OgFdAnekaaUne/fffffA00pOGJpsA8QAaAEn0kn3c73tUkpbd3aSSJq561gBmfgCJrqmSZhJJE1JJnmiTSC/k2lbeNq23M6AW1NW39dwABJhJu7JJImhAG7oACakk3znNkvEmkGmJMA3dAAE15nnN8sPPu8Xn77vb77frO9lVVtvlt79fbf3MWJ320AO/fXved++999/d9kne2W1/QArpAW9ttu8yd1ben3MabkACSNpufSbPzmJtpqAAegcySDAD9Dm7JJOpqSTd0AASYBu6ASJoAN3QAE1JJu7JL1tJBqTAN3QAtqatt3znLaT5NSSbuySSJOSTd2SQC4laZdtttE139z3z67v18SaXgrvw7Z5v569OhXXPXOHfDj1I2iUG5roAVMcjTQoMBJmV859X3OdQJS5VQBJnuWU3YCZOfXbxpgCT1zgMBKSS3ECVSEK9RK7WM9Jeds92HG0CXPdvzcwpp4DQh3UrGgVPhJjgMxN7UASYPO4Hs5JbGAk774nnYIGwEnGOAJYz3zXx92uHCamDkpz6va5l/V9v526+q+vXAEn2Z7xYhDTaSQbOfXPPufuJXGb4A3YiyJlQxMzMZFljrAtKqZFZn3333vv3t8KwUZhZnOc5znOJXzAnNcc5qhzgyeSHIPhckzNTJMyTx96PXFtvLq2sgBhZnu8kzJjNTc1JJkk8yZViUsxmVVYm8+++8++fJ7JWGZKWYpWFWMUX2c5znOfcz8Fd6KvzKtqhs0VhWtFWSu4rKrkzRWqMg2JsbAbUVgObvvv53397/fmbYjBXspyVPfv+vffff8+/zvvlK2JWW1KzMpJkV+1znOc53zgr6KxK5rrnOc51zifYZFdmiq3lUt2ImIpkmYqjWANFk5rnnOfc3ziV9NURmbSBhWJZaK2tkNptsaBJo2N7vN3ZuoEahA9YINNrG2YE2Da1qbQPrRGNiYwQkVN3O7r3fCBK5oISbrdOS3JmTkurbRABXgHzlZkmTYD4mtZkjwD8HoPQfi7ttt+psBwHpvMkg8AAC23l1/Dve97zvdgv62+W2n4PQeg/B4B8Ngv1urbaKgAIAK1sBzgA1PNDY4o88880B9ztttve97BoLby22gndTbeY09bScPs5z8B8Hkkk/SSEPtO997yfv379+73vO92AJbbbfqa8PQfrbbb+tPQFvltt7Lom5JmV737793vz5u7u6hB73jzAAbSQJtJU1Gg2bo+oAVbbbeXb43mSRo4LbbbdUHhR9aC6bcPQ7JMz9z7ySZj7v3ne29vU+D0AbW3l19bQ0QE5bkmTmru20MAX9bfLbQAeW239bXZMzPu9733ve977bb7bb6D8BEmSJMkt283mSTx6ei8fDYFvOc5zga2bzJID9SbkyTd7JMy73Jkj2fd/e/d73oAEFtt+t3QGSZhmSTe9g8aeyZme5kzA45w3mTM4bDgLbbQ8ABoeHWk3zG000B4ABJJJJJxtNyd7393veTLQ+D8Hr0H4AAC2285ri22q1MmZ5mTMfDx78r7skzB5MmTPezv33v3e96AFttttADzMmYD39bfbbQAC2222gAAK1y97vzve977vvR8LbbbQAD43bbbaADhvMkgbszUbBwzMs1mSZmskzNamskzNayRsAkT+CtVNqqsKy2VVs1pNkkkkX3333wenOP93f4/eyeNJr6fUt8+dttvp9bb5aHe97992yeTvfffI/37vY5J5JAGmkAAAASSTvenfvvffZ99O9kkqJeZiSbAACiMxJN22222ySQaauJXzvdede+rZTannnCHm9UPOVcxV551TqjQ2VNhDeed7znrzzzzzzxPMtu7oAETQTDQABJhMNAAE0AbugACaAN3QPlcaaVt4mvLbd3bbbamgDd0AASYBu6AAJrv6E03zzEsz95vL7+/e+NO/W34yGaSfpJPJJJJJ3ve95377332JNL2i71fh4AfkmkSAavQDiTSACekgk0gAPe973rTSnZih3ve96F7mSQyZIB3qtSZINgk+kk3dkkkE0AbugXraSuW6mrbd3e2221NW27ugACTAN3QJImgA3dAATUkm7skvW0kGpoA3d+AttTVtu7oEkf97GkAbugBE1uLuNpN5PyxY8Vm/vx4fxZC0Ak/SSeSSSSBJDxeOTmv399eT+87na9474tAOH62+W977N600u9++/T4bTfZIAHekkADoASSTklbadyXG0lcvbd3bbJKmgDd0C9bSVt4mrbd7zltttTtDdegAWtq23de222iaAN1aAAJroabgF62krbxNCt273bbbamqU3AABJkDcAAE17xevo1ubV7mO3v1pext222/O+208AJ5MSaUknkkkzze99U+/fh+gtnWne87MAHS3oDJkne22229FMbSUEAeJk7PE2m5jTckkACSdmST6TfpNm5JJIJogbq0C9bSVt4mvLbdy222pqINNwAASZA3dCSRNABu6AAmpJN3ZL82kgOJrwA3dC22poA3dCSRJySbuySSJr3GmlZy7139+nfP37X779577737vegPwft/g+9Kfg8W/T779+3Jkl5959r5yr9bu6tovLbbV5z775znZ0773vegtt6D5s9JJ2STd2SSQTQBu6BetpK5bratt3dttttTVtvnOctoETQBu6Fttqatt3dtPgOJoA85zgAETQB5znAAJcStt3dtttEmAbugACanPfp9nN8Pv3ee87b38B+D0AA+enve2W8+++7rMkni219x0A6W222uW3nOLy2gDuZMzve973ve9A0AVve0kkE0AbugXraSt242rbd3bbbbU1bb5znLaBE0Aec5wACJoA3dAAEmAbugACaAN3QABNAG7oAAmrbbu7bbbU19N9xpN83jMR4e1TlkV/Wed3LeAfgDySSSSSSSckknt6d/JNL77YfT7qTSIBv4PG0lgH5JpAdU/d72JNKSSfu/ffvc9nw2m+ikAAgY2mwDxtJAAHqMMTMkkkkkk3dklraStvE1bbu7Zbbamrbd3aHwHE0Sl5ttttTUoXznLbbamrkhugARNAW85ttttTVkt5y222pqyG6AAJMA3dAAE1c2G7OeLd/cSTf371X975e+WzqpvoAHp8BwAJJJJJJ5IHv3e+99N/e/fTve2h4AB7J3ve973s7v2pNL7339PhtN/Y2myQAAne973ve9kkkkkrAAN3QJJU0AbugWxtJW6n5bbu7bbaVpW3l5zbbbYmgDd0AASYBu6AAJoA3dAAE1wA3dAATVAN3QLbU0AbugFjaSt1J/vvFmH3f18t77798um0AD23tt5bbZJJJJJ5JJ9vvnnve/Z7eXvQDpec5znOZMkW3nOc5x2TMxrcTSgeGJpsDjabIHjabAD82mzLmJJu228st2z1SSSTd2AAVNW3l5zaAETQBu6AAJMA3dAAE0AbugACaAN3QCxtJW62rbd+5y222pq0N3QABJgG7oAAmgDd0AATUU7xTGk31eftzfP3raSP1S999vb1U0KrbfFb228AINNnrTSAPAPxP0n7ff2+6j6/XnJzVX22320HLq23nOc5kyTnOXvZBtNmSTjabkkjTSgEYAfm02CbSPg4edDZTqAN3QAraSt1Jq23d29tttTVt5ec2gBE0AbugACTAN3QABNAG7oAAmgDd0AAuJZbbu7bbbU0AbugACattu7tttv0IrNMzNXPnsk84kFdiBL1NAlKO6AlR6pGfO5VTuY53l+qrzJXubl8H6X3OVx+wSDdEjvw5r4upjPenfO8rvz3c7O+49AnB9ktAb7dUWAfd9ed/v3P19wE57zgq6EdMldWhi61skcFbaOKnNbBOUrG1w0y5uLc4c1tmtzlI5E2JWqFn333n333wL4VlJZlTys1zOc751SQefskzNZIyaH7wD4B+uYzMyabbSWpN0aJ8nTXTiLjOVMzybySTMmj5wZJmANAFGo4ou8tFkVhkg5993978++u/iDXFzZJ7JI00/vT5IPx7+A6fmk3NaTfu+qg6qpdUrTplJNErKPNXiab4mm2sTbefyAkhAbTe+4mtySfofe5JmW+W/rb+YPQev0zMmMmTJm5isxjjM5vnnnOc35kVkVxFMwq40CUc3d5u7N0EADAAsopIKZu7qtXzJMzkmXVt/KiyNAH9JMz9rWYkwA/AdPzSbxNJPWsWNYsxY1JJ7I4bAfDwD8Hpb5bbf1HixofNZkkPGgPjxoH4BbbbLaBWgW/XV1baPh4B+D0HoPwePvwc/G1tHDQB5UD4CdSTM13fe973vb0Gt0r5+X16PO973ve913tltvP06PfwerbbbaOtSNY3vJPNZLqb7r3937v7Zu+239ei1vYE+pNL33330OpLoAAEn5Lyfu9/d9/d872R+DgAtACffffffp2t5Jmd7+37+73vegc5yZ7qenvskwe85wAE8nOc57znPQfgP1u8ySXVttAB9nNc5znOAH3v17O7793ne9tt6D4eN/Lu2/W0E+0PS3mZJZkmZqZk1q22i40DnJznOc4AByT9Lu32213Im/27EYB8AJNPqiya2kpJJJF3FJtDnOc5zhHkjyR5I8kfdddde++/AD8HsmSc55znOe8DhsCPZkx+tpLcEml3v5caabD9776AAAABJFttttASZkyAAAPAPhuTMx6bzJJbv6/Xy68u8ySB6eHqa2kpPp5OJpsSTfcaTYcA+A2SSScNzJmFtv1toB5ALxtvMmYA4AAttttoA1N5kzHtaH7ldmZJnM1mSZjuu+973vegBbbbbRGsySAbzJmFNS/W6m8yZlt5TlXMaALGgAAtvOc5xZ3JmSR5p3vfeu6vf0B+3sn44jWZJPwCgbEW/S/rb5QHhvRshx++6KyR+kltTLIri5VTmzWvpqSZJv4Oc+PDhsV+yTM1mth+kk8aTf32/fB6TPv37+PPZF9KUklSadatvnjV7beW22SSSSRTySe/r+/afT6d72He222gttvt5zb2234C23+yZJ/d73vf3uYkm7bbbbZQEAfKqlznjaWYszMbeeeec9V79c9aOts2mybBtTag2trXnnnpKvMvebW1tmUm1U2JmtrWm21bNmZrbBsKu7Kqq8WVZVqtd0LUKXS6ChNpjTZttTaBbWw22zGZbbv7nLbbamrQ3dAAEmAbugACaAN3QABNAG7oBY2krdTVtu7v1tttTVtu7oAAkwDd0AATQBu6AAJrw7i0wxLnm7554aj0D6ZO7JCd53vfO973oArXo+/JMk/ftpmSccX9JklrznOcsmSW0/F3JkltVr632XV1dcWi2222gO5kk73vfW+7ne673vez6Sc3dkktbSVupq23d22221NW27u229DU0AbugACTAN3QABNAG7oAAmgDd0AsbSVupq23fuctttqatDd0A6GvuNhw3QABtSLv3u+eJeeF+xN4ljSaX6/d5ZYXT4APUfAcACSdpoAHgS/d+99O/vZ9997KnZAAn7oBJJJ98c7xJpd++/HRtN/STy5iSbC382m7duJpu29AAkkkkkk7MADdAAEyQ3QD0LWlbft3bbZG0lbqatt37nLbbamrQ3QDoamokBzd0AAbXyWAebuoAATXySk3d1SSSRNAG6AWNpK3VMeY1kN95xJpAACa74cfmNppr7n7z9a1+/W+dvedpvGzADxow+OBt/W2222SSeyfp5Pvvf34BJpTvSSHfvua5znFAPcySDMh+P0yZbfLb2YzUmlJqk2ScnfxJPC5iSbtttst2SAaAG7oBaampJu7JJJEnJFuySSRNEhu6AAJoIZugFjaSt1NULv3Lb7bamrT5boB0NTRIboH4ASYH26AAJqIDm6AAJqqLd3uB4pni5mefr+S/fv3z8xZmY/b2y3bbWwOI+A/NK/v7+/v7+/v7+/gHo5z79+1HPvrz7lX2W2+2jgBzlt5zi229ySZkAHTuZMwAAaaR6E+8k5WyGAG6BCtpK3U1Qu/ctttqapLugACTJDd0AATQBu6AAJoA3dALG0lbvFiSxYknbbv7nLttt7W7Zd3bbbRJgG7oAAmgDd0AATX6at8PAPQ+6F8tttv39/PAPwehHo5y5kk5998tq22gAFttvOLbJkltAQB/Y02Y027mJJvbjaStttt7JJsmSST6Ts3dkkK2krdTVtu7t7bbamrby85tACJoA3dC221NW27u2gAkwDd0AATQBu6AAJoA3dAAE1bbd3bbbamg0OboBepNK3U1n4n27y8vlvv3xPuZWHACr66rc8AAOySSSeSHbbedkyS837rs6Pn0mSDzLbakyQPXcnT2TJFae75qdtt/XoAAJJJ5MknINpLTAD2pW2lu/c5bQKmrQ85zgAETQB5znAAImgDd0AASYBu6AAJoA3dAAE0AbugFjaSt1NW27u/W221NW27ugACTAzAAAdWdPx53P2LEuc8v33723t7LskEHe873vm+9BwA9HOa7bznOqttt6H4cfnn93oHOdvt9kyTnPe39bQAGJpsAAAkkkkkkkx5JJJBNAYsACxtJW6mi5bmfW221NCuXmUADqaAQAAJMAzAABNQwMwAATQBmAACait23MtttqaAPOYuZzAC/m0lcuJrgenv2tec8vvn62/TsySSQ4bAAB+Oc5zn3y3l1bbSAH4AXnFvnOcX9bdyZID8bP6AAVW2bJJO+9sADd0ACpoA3dAAEmAbugACaAN3QABNAG+LmLgBb82kria5bbu7bbbU0AbugACTAN3QABNaAbugAJqSTzl88AL9G0lcbWfe9D5c88WtZ5v72/v379frezJIDhsAAH45z9rnPPnNMmSPweggAFttvOLec45znNv4O9oEkg2mwAQa2kgJJPp6pJzbzgAFTVobuiAI2vxoBu6AdaQpJN3ZJJcaoBu6BATUkm7sk7ImqAbugEbXe97u73ve9uJoQBu6AQxNSSbugBDE17OL37zh5P3484km/P275z76d3h+TSWb309oCTBB2PoCWoVZk2PO+3273ZOYIS9hYMOvuT1VzKfXnvnfb8nywEviBKfOVV8+QxEY5MGTsWP4/hh7zASdV8zPtb1mZJqPv36ZNffb9yfue9465QA/B759v773778B4/aD6XvsyfmdzJIP32+99/fR8lcSsStKiZhKyStam2NsJhWis1KxmTbNZmzW5rmNpsqtFZtTVG33f2vvvvvfsylZRYUwjKKwVk1qTWprWSeSa3QUBbfpMmWazJJNKB9r777nOc4QfM5StKmYKma3vbQHhR8EkmABmZMyzUmZM8jy2368yau6A3P3ZJmbZpkmZ2ec7+d9/e+/5+tkrWFF+VE5xYpMaabzG2ljb1J5ufwAAY+tNsN2SSVeau7bbWZkzPtZLkk/eePXpwTJEmdZ2pt373vd8CAoYkCWOvbu8326VoBJuZJk3rYOG9gLUAD+mZ5Mlzvd973vO99ZmZGtD8HDYD4eAfg9LfLbb+o+9Hr9tsayZlvLbeUem8ySDyAAQAVoFv1u7bR8PAPweg9B+DXgX9eXdto4aAcstttoQAaoIOa9tt9/WvPQfi2222gAAPR261rd35qZ9NTep0799z9+8Rbf3e9JJIAB+UaaX3c73vV0icDQAD76JMkttt5yjYA5dW3do/GwT7774STfuLGk3nve+cAAkkkn371tTF3HTKylY0WxthUhGo1wsohTRRIDeprzJvWszzyazflv77gAGtW2220AC2222gBec5znOLAN973veuHYgfgA3Jki39bee3yj9LqN8PxC5kyZGgC5MkmRoD3eZJOc57zjl29B+D3JkgPwdmTM/d53vfP3e9779bu+228NgD99ya3znOcAAC2222gAevZkuTJLkyTfJzJkm+tTsvv3nlu8yScfcd+AALbbbaBmSZgBbbbbQAbzJmBb9brMmZbbWioAXzskzN/u+SZMzve9+veugALbbdZkzLaCgFttttAAbzJmFtv1u7X43mSQvgC29yZIB3vegBqbzS2285dzMyZKBwkzMBznOc5zgA4bkyQ23mTMAqjw3mSQPYNrbb92SZnz777x3uud9t1e7fg+5mJLvvvnPJxpqT76T36QAEY2kgAk8n7sPvwCNZkkALbeZZrNSZma1mprFWiv5FaK4YFxE5SU4kzM1kkk/ZrfltcLmZJk238PCwkAHOc85zrXu+c5zhb3QBw/eB+AA/HOc5z755bbf1tW2220W22y5Mt2PA9ttttoNNZkkAcF73ve972SbuySSDaf8LGlbbu7bbZcbVzMStt3dttsuJutZmJ227u222XE3Wstt3dttsuJO47bd3bbbLiTQBu6DABNAG7oIAE1+AN3QCoTuJqq23d2222pq/sxsxYucvLb+vb0+3JNBw2B8PAH45znOJMk5b52eA7Jkne98YD9Jkgr9sJ7Jkg/P3e+d70kJIASB8cCGAASSTpNk8bUhb2ueeeLerMge+eeAsyB7554JOpoAP3OcADqakk84Lzw400gOETQB5z3zwAI2gk3dkkkTtVtu7tttK2kAb5zhwCeNpIxNMA3d9K00rby1/ZmNNZiXv5+HOXltPr3sySSST6TZJPBw+8FafjnNc/rec6pbbeg+HgF/W3Vtr5b4tAOAAtt5zn078vp3u/c53vZKkwk3dkkkTQgDd0ABtSSecxXzwA++xtJGJoA3d9K00rby1NW2+c5w+AImgDcJJImY1kzQ8NwAImp2Tck8nepqSc9nOczmKDTSDzl1tJXE1n3ZcSU3Wnzz2+eeX69+md73tkcNu973ve873vgH45znbeW92Lbb22222gtt5znHkmSW2v1vltt/Ad73ve9F5znO3k4t/vPPAf0ydHvm1v85MnY1gcN3QJG16nne9zze973qa9b73uc3saaUhwE0Ezmz2SX5tJGJr0Ld17bbbU0Ew0A7MTUm9nNlbSQajCJqBpvXed73vZMer+PfvJ++6++++7z7jVtocNgPh4B+Oc5zn3y2222rbeg73ve2285zjy21+tu7rMkltp8QBbe/fffTvyOkm5O9JE0Igbq00AG1Jr+nOPnNkkv5tJGJasXQ03ACAmrS3ctthianZyc400tmjaQaETXoabunQASYBu6SSRNCANwA9BJyeKbk/SS+JNIxNZqSb/LpgH4Ppnfvr3vfe92SB8PAPxzk5zn3wbActtttoLbbky3drw/u9/d73vd96DgAtZJJJOzq73q7ud6klZOBU1S8vObegETQBm6STsxNCJwRzAA6mp2TckkkbXVknJuQSSDQE0QNw6ACTIG6m0t8MUkvjaSMTVVtu5ttttTQQ3d965dTJ3fJdP2ZJPPCn947zemr9bfrdklA+A4BJP0n33330+xtJd7vvO953smNpQ2D1prMkg8Dy6zJJbfOc4tv870AAkAAACTvV3ve972Tq73pOd2am1Hd8WZNm2/tvh5MirvVvRmS91rfe+m4EnU137vdzve96mu/d7udjTSgco2krjSpbuXtttu4nS05zltsuJok5Oc2SSdTQgDd0ABtYffpz8nWk3jTVxpVz151EPuPMijzH7V9qjSDRWRQ8yKv3nKE9CsQreUV+xUrmJXVRkEOZSicitR5oC4isB3neKd/z91Mkyb1Jk/u96Pv7vfAPxzmuc/rznVFtv9mSSZ/d73ve3vdgW285zi/DzwAAALZbbbTuZn9MkzNayTM1mal1NpJLWk3jaaVWW27u0CRNSSbuytNIDgJoA33954AX5tJXE1aG7pbbbU1b23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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
