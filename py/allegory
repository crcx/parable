#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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gr0z6oJbcQjzuoUDIiD0w4SIxsiVby1CbbgZAPHbpnpm6GyWQzMPSwZTL8FT5Pn5XnP3OcpycRL+eOAQAt9u+fJYSNUZc7Z057pkuENp70+mSIOpXXQU6XmRflhQimlzpFicHiLPVc1NtROuT7nnj7nbtuqkgDoAAAXbewAAdqpIbAAAAF+Ng6c5NTup9e2/fPjpuqkgDoAAYC7b2wAAdqpIbAAAHOcvz52eal77957vU91uLU4gSiGDzwIImpusJ9WNICqdg5erbcvve2Dg8AADsNgAA7VSQ2AACABzmpNc33UPPPvg7s8BYANVUkALbgDoAG/g9OgAfVUkD0AAfd7zdVJPuHvOr7YKUpSr888egBJUgAAAAF/Nj4AAAC57d8fe+nenPPqqSD586AAAF23sAAGt9qpIbDtgAAC/GwdO/fe+ec13ej7z37q3PJKkFd3e7u7MoKovel2SCDqK5w4ex725m7wa32qkhsO2AAAL8bDvd25O+0j0YAraQI53Xvdu9kgg7urudAAQAXbewAAa32qkhsO2AAAL8bB093ASrAEo9MmPYBCgbbw0BKMBBEGAJPJNqumPGYAlPmooBKpXnjWz0leASiWYqIvcEgTk1oAI6wEpT6EFdivQr3CunfrsV33wV1x0K6FcqPXXMK8FbhHrz567V8zt84uVU1qSVVSe3v32+XdueSVIPR0AAALtvZSlDW+1UkNh2wAABfjYOnJfdN1529elVJPPO03v7t327a3JUgDtgAAC7b2AADtVJDYAAAA74eB0352b1epq5v76ePvvDlnfKlSahsOgAAB2GwATeV7IG2y2CDOhICIgKmez29293d3c74eB08lSVXevtPfTq26qSaAWAAAHYbAAB3mqqSenj46dNgAA74eB0ud18as8b6pii2ys4giYcQOYMHbmsiM32S5nb6yMIpODKfoqb9nb0V0JAccRMz3Z3QAAA7DZgAwPe1UkRs+AUA74eB03UlVdVUmqo9RWivvUVg6ivvXWzmK2Vk5VzZxzm3NuK5Ucivns3O+mM4srVmWLtRqk6OxW1GlHZGivkVyK0V62czPnDa5jrbU5udIrkV3FfGhztFd49bnOs43dKPyo6UZqVflGKO+QpnvT5rnNFehXqK6LjyJqjvq576fd7itorCtFZOdc6YeUK02kglAjN8ACg3uzs7e3tlIDo7uO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d33QAAMvvbu+973v7oAAFdvvbu+7UqTMzme4AAB3Z5zkqEqb8vP27u5779u7vvXLvV3YbWgdOc5znM7nczPPszMrPszMzMDYGZmLu7vLvLu7vLvHJKkSckHoAAdJJPJO98JJN3YSB0zMzMAAxLzLu98qpJu7ubn4AAC5vN273m7u77onoskJLtdJEsjQ3QA/A2ks3UsWLFimHDzdAD9FlTFgbvM273d+bv7AAAOpfft3e+VUkzaqt3dz8AABt7t95zd3d3ugAAbeZd973vfvQAANdqLzzPl3eZmZs90AAD1fvfXzn33M998/X39+y7zzxsGXmawBaAOc5znM7mZmZmYAXd3gMzMxVSS2gqpMzAGhmZmYwPQfZm8ZrM73PckqpX6pmZy7uZ+73v7oAAH6p25zvl3c3yqkmbVVu7ufgAANvdvvM3d3fdAAA2+7fnOVne9776AABqM5mXd5mZn7AAAO33t33vne9/dAAA+duc75d75VSTNqq3d3v4AADbzb7zN3d33QAANvu3dzO97390AADXq88z5d3mZmfsAAA7++c5+TkupKklefOBXeEne70V0R9I4CvXXc17vme+dE9XIEsYAl1xkbHcWAlaSQyHfnCp3krvz3uXQraCu953t633u3eus5+BBiBKAEohAlYCT9mE3EDaASr1323wCXheaPeYELN2C614Es1MXqVXLnzSIiLGsmDPQEO2QxCJ8wrmFbCsK9f3z9/Cvnrr8760VV6trVayam97m61vW9d83zzwtevw3sBdnOc5znAGtG++ubyqlVytVV7uSVKl5r97v39775CVvFHGRGsQzKjMMtFaiyqXOUnCU4wlxqJi2jYtqlsoayaxbG1ssxNrIrZGitV55515559fSpVNAFyqlRoAuqqTclNhvfm9lG7FGAyhlRlZKMYVbKRtCtaYsqjLUVtfBfza6kqk0A9XVSqaPgXLu73dndXJ93X3d1VoCSOfRrrd3dDGISliTLFlRijFDL+N++9e++++9IlZobAdNAtqqmtSVKrU8qt1VVJvS0FrqVUl3dy7u7kqNSSSTWhbTu05oSQwEmCBIkYQ+3N2Pb5AJbqzg8XKlRofB6D0GpUSqr3VVKqq5oeOLfSVJLu93d3Z00AJd3d3diAA2BxoPQfAB8Hv6SVWZmZ7mZmfF7u7u75ZsB001d3d3y5YAQJ6BzQB02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vPQfBnWg085xcAAiaANwAASZA3UmloAAmgDd0AASYBu6X82krbxW6mrbd05bbbU1bUec0ADqaIG4B6AJMPxuAACaiDTcAAE170UzTh9mZgPAODZweOmnB47znOec4HAyszMzNyVJmZl/d73ver8YHPru8BgFyVI0ABmZmZeZvNYG9QuNpK0t9TVLdy2221JfszHS3cvtu7vytVUkIVUk3N2/Oc3d3d3sKqSEKqSbu7d3u7u7uwkqREJKkJu7t3dtttqzEmlixe7qTSy23d23ttKsxJyIhJUhu7t3e/ftVJN3d379hJUiIxJpZbbvnOW229rxY08WK23d2+222/mnixZjTxY4fQd9zff2ee/v3nn72/raABwzMxwbAdNOm2TL87O977zMz3QDMAx3ve973LKlSMzMzJVSZmZgEkn0mySSSSSB08OHADyQDm6ABSSkQkpE3d27vd3d3dkpEKlIk3bd3bbbbUnixZjTxYrbd3bbbalWrbd3bbbRNW23d2222poA3dL+bSVtt9TVtu7ttttqatt85zlACJoA3dAAG1PxoHvqTSAPJJJ5JJM9ySTkjpwbB33vN85wAAAA9B9eXd973Lzl3vAAADg8CQQBu6AAJoA3dAAE0Ab5zmoLxtJW3lxtW27OctttqatDznOAARNegG7oACTkk3dgACaAN3QABpgG+NLmJcxheNpK28Vxp227Octt/fv0qZ+63VZqt+b999z7MzAPQfB4BwbB33qSpO+d73K5jNZ57qqkmZea++u7u7wl3epKku7u7dvLvvlVJO9y7wxmZmZmZgB8HoAN72BklZmZvdAAE0AbugACaAN3QABNW23d2222poA3dC/JNK23xv1Zbbu7b9bbW/ceY2szMzFbb5znLbbYlViA5znAAImqB5znAAIms3Jnfy3c8w9PQ6RmZmZnuZmPg8D9mdzM3mZjvec5zgBd3e7u7s5293d3+GF37zm873zLscYST2SQACSSSSQkm7tAAE01bbu7zMzMyShvewEqDe9gJUzMze9hfm0lbb4mvcWW27u2221NAG7oAAkwDd0AATQBu6AAJoA3dC/NpK23xNHlkW831tJ891ujSbvfrPrlyvtqNfZ9wo++0o5Sfd8KPvtKPr8k0740m/rbeW2k/STZJJ99+z9n79v7FPw+lenl3+Po1uSpDymZnb5d3eGFSpLv9UlVdXd/j9UqTM/dNru73d3dnQJ2Y5kyVpN260m9y23d2y22poA3dAAEmAbugACaAN3QABNAG7oX5tJW2+Jr223d2222poA3dAAEmAbugACaAN3QABNAG7oX5tJW2+Nr1JN+6km4TzfM8Xl5y+dudt5JIeg+DwDg2Dvec5z3m3CO+lm5KkyszMzMvM3d3d3y9WSqkBdSpAAC7u7u7sBl57nmZ7mqqSZm2Abuhbbb6saxYsxJpYrbfec5bbbFckqREJKkTd3bu93d3dmpKkRMu5KkRN5u3d7u7u5qSpEREqRu7t3e7u2lWY28WJZjTy23d23982krbffXmNNREJKkbu7d3u/d3d82iSpERu75d7u7u72akqREhKkh7u6c3d3d3YiqltzLbbaNNK42sPMaXViab0SaepJt4K1mZrWrnV771vuKr3PqjELzu1LMeiQnThlkVZEksWRckREwpddM2OnBNzEgJQQxJBDhoGyJgBKKmPc7JYxQxxCBsKAS9UhlwxttjGkO+NXGYxmULyowF3kjvv989715vjrYNNDH73z437fnqrfTfwQlHsJJfNy4hyUZJcyK8458535577rypXOcFWIVKnNSpVXfl897d3KlSmvgAl6u7u/uyKrzNb3ve978pC5udKKy01UGg50AQJABcl3d329W5VRCH3dXd7uj4kJDmfnn8+T3X725QgTEkFXqBAUkA0IBTmVdUp+7vrvm/O75Px93HoPg8F1VSqkrtVUmqlNO+mxdAC593u593XoCTaaSBiATEDOfd7aC6lVUiqlVqSqrWl3dy77uXuw61MXUm0pkkm/d7vJUm2gPQ+/ARtNNr3QPh5UlU0D0HweADd3d3bpoTg8Xd3d3d2QADpsOm/AOcF1Uk9bu79u77f2w9B8N3d3d8u2wHTQBaAAgAtpweDpvJJVPNVUk3m8zM+8qpJ4X2VWE/MdYdHyelIDPdPd7p7QEs6kgOSe+dnFu97raS873vO8XvZkDjaSPgMBHQkBu77d73Gb8Bc4b5kJDPmJAReZ8jTgQbu74hID5M2CCp3rze93eykgNfRXTd/BNh5lMjiQQe176LxIDMrHvz32XuqkiN28HxuqknNOPD1401VSSx6Nm6qSFD40zOe1UkzMz7ecyY3VAdwvVE9Hs8fEICbIASxAk0CXrSAn258+d87tSAgEHR3dxV+aEjmCFjYgGhGsEF7W77s580gOfd3d2ZBMedVJPPPPfe97zoJ098HSb7oDhHh5JMk942ksm9753zq6T942ksgHgfCG2qzVa55VSTWY8F32qkm+aqpJq/MDrUewkB5909e3uwkBr3dnu7O1HVSQGV6e68nfIQCJGAhppINpICN2d3tnrDU0upICe667qI3yMe0kBG5e3vPuhIkA4l6qpJd3d3fU+yVJ9M9qpJmZ3O55Ml7qpIu55fl3d2d0bPgffVK+qV9Ur6pXt8A5puqkhzwegfc5795qpXLm55OO8+7f1j4PQV3zm/PZo9ypVSpNyVJKnmvM7mZmffVUkQfe1Uk+D4eg+uVJVNAFypJVNAXqqlVd3d3fXoPl3d2u78u7uxAeVUqgOD3uSSpJ5mbqpJ7ms7mZ3yqkhY4F3d3d3YAQHrpt8AbAdN1UqvO3q73f3vLsvjQB5d6u7+ypJQl5mZmbqpIA6eAcgPg9aOG6qSPZJRZ8W0PQ6fd9Pbu7u+Xbw8+Hr54jyqlU8qpIOl+dZepUqszxkvV+Tes9rebm7395zNVUk378dW68u7seFtbN8D5d3gGZmAto3d3d3cqqi0sgXYrWoHWEfs833vvfm/LdJWgEXJJVTkqRs9Om+97zMmf+3d+1I51qUcfv33n777xR9kiufdCe++8STZjSbS9DhjSbD8AcPzaSMJs/STUDvec5zgBd4AzM3d3d3y7Xfe97l6vDMzMwuwDoODw4ypKrM3SbXmNMA3xc5rSTA40mkYm0kGtv+RYk1bcy2/fNpK23xNW3O7bbbamrQ3dAAEmAbugACaAN3QABNAG7oX5tJW2+Jq23ZzltttTVoec5wACJoAvOctttqavn4+8TWe4l5nPBB+9/dzPQeg+DxbQ4Ng13qSpOrv7v71STiTSknJIJeAAHQFwwMSaR7VSTMzM+7d3fV3h9VSQZmZi7u7u7x1iTSmSZJJJJ0AN3QABJgG7oAAmgDd1gACaAN3WAAJq227uu222poA3dYX5JpW2+Nq23dnFbbbU19bebofgDxNRBw85oAETRIboGZmVURyTczzPMzmZgHoPg8A4OeD39l3rve95mT3LH13X4ehmcvADOXd391fmXYzBd3UqS7u7sAPJP0k/C9A3QABNQDm6AAJokN0L82krbfE0K283ZbbbUlQu7ofgCr1O3bebtttsTQBu6AAJMA3dAAE0AbugACaAN3QvzaStt8SabRjbbW4m000sV5baBKAB4AT2SQANhzfPvvPgDrV1d3d3YAHhd+95zn6pKrLvKlSGTMwAAkkkkkkgAbectttqatDd0AASYBu6AAJoA3dAAE0AbugACattu7ttttTQBu6AETRbbd3bbbU1JJu7JJImgA3dAC1ptNNXE0kq8xKcUaEn7zcorphW0TzEnfdSaMXmNtNNe+fv3OXzz6232SSeSQc0AF2Dm+ffefHwel3V3eHslSGZ3ObAMypUgNyVd3d3y7AEAAdNgZmZm97zMzEqfszM3dAATUkm7sh8k0gL4mrbd3bbbbU1bb5znLQCJoA3dAAEmAbugACaAN3QABNAG7oX5tJXLbx+4rbd3bfrbamvDi4km5iab1Z877y/rZYm19bb6lb9y3V+ttvtod73vfO/fdnsn797777ft3rV37drq7u7u37MAXeXdSpO672pUX33079BtNgQ93E02AeJNsNPgPU2m/MTAAPwcPJP0lJf1t85zltoRNAF5zltttTVA85zgAETQBu6AAJ9xMOG7oAAmgDd0AATQBu6SSRNFtt3dtttTUkm+c5DxtJBbfUnbbpzllttbXnJt298Xvvvtt8a736y8pctD0y3oXeBd5mZm+c5clSe85fu93d37JUl2T27l3di8G5KkHIZ00d73L773ptNk1tJeySH4ABIwCQuYkm7aW29tLbbu7SSRtVrADd0/AAmvUgDd09ABNAG7pT5tJAcTQBs5wrTttqa9tmcOAANr73Qme7ACJqTuTZAATQHTcAATUt2ly221NfojfKZiXF+9/eeee4i2+u28Tb7jTpr4B+Cbyl3939d33ttD7n7e+33vXrt3d5cu7v27t+ziSSTvT93ve9793J0SbcAA+uYkm7qdttv5tNlyh62mwAADkk+SaUmnxDAL1tJXtvjavlu73lLbamraZgSSNmRPdOBu6AFElGjA3dACJqSQ3S33raSpravltuptLc3KAJrv7vd3e2SRJySbuySUE0AbugEiasnmcw1+eZnsqH4+pd/nv0LfZmZd5Z8u+x8c5P3332ZgwvLu7u7y2ALvLvvec473MOGJpsA8QAABJOpNKZJJJJ9UHLbb5ugetpIyd1NXPTwMwC/qJqck3dlABtetYAZnoACaiMDMkkkTUkmYJNIL1NpW3jattzOgFtTVt9u4AAkwk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3ia8tt3dtttrban09nvqTRuxeTVam+fdfffffZ3rAHwegADwcnPfOIUu+9t4u7u7u7H13fl3d3UqQl6qpJd3d3fcmZngAwAHb1dyTrTSJ7Ju7JIAkwDd0AATQBu6AAJoA3dAvW0lct1tW27u2222pq23znOW0CJIA3dC2233E7bd3bb9beJoA85zgAETQB5znAAImv3F+eVNazM59mXgD4PQPqlSB6Le7M7PO/ffZmTZjTM7gAwu7u7u13d3d2DUlSAFsqpVZmZmZi7+vu+9z93ukA3dAAEmAbugACaAN3QABNAG7oF62krduNq23d22221NW2+c5y2gRNAHnOcAAiaAN3QABJgG7oAAmgDd0AATUn7izEk2b4luLwP1V7be37ct5Q9APJJJ5JJPZJPBfZ+svklSd8kqTa/O652SpFs16Xpt7JUmxkcvtpKkB9fe/c1x3KqVV4YAEDG02AeNpIAJ6pkxObve96Sdkk3dkkkE1bbd3bbbamgDd0C9bSVt4mrbd3bLbbU1bbu7Q+A4mgLec2222pqgXnOW221NU0OboAETQFvObbbbU1QLznLbbamjOfu9hn7s3nk4km/Pu/cl+7Onnssh7+AA/HwHAAkkgcPnvJzXM793M1VSTfbvq+/vwGZmy7u7u7Xd33vYvKqVTVVKoZmZmYu7u7u53ve97neysAIbugSSu4lbbu7bbaJoA3dAAE0AbugWxtJW6mvLbd3bbbamgOHOaABE0AbugADa5gBu6AETUkm7skAE0AbugACavqttsy/Xq9ugAH63tt5bbZJJJJJ5J7994dvne3d3mZ5VSTMzMzOl3d3d2u7vvezveiTbmQOGJpsDjabAPG02AHrabMuYkm6Ftttn0kkk3dkkkqaAN3QCxtJW6k7bd3b2221NW3l5zaAETQBu6AAJMA3dAAE0AbugACaAN3QCxtJW62rbd+5y222pq0N3QABtTYurxTGk3vvmZ5z09qX79+tvVTQqtt8VvbbwAg02AAATyTz33kdvne3d2ABd3d3d3VQNyVI+klRYsTSUk8n0g2mw0DjabAAAjAPG03JJ9snJCUltt3dttATQBu6AAJoA3dALG0lbqTVtu7t7bbamrby85tACNgG7oAFqatt3dtttE0AbugACaAN3QABNW23d222/X0IeSOYr5jBExCBL4Ak388AlPNXFZ0X6JzfZjj5mXu17DsbqJ96xIJ8xGfDijljZEIib2r+dk+7gEMKYoAA8SkLAd+vX71555+eAm7zgq8EdMldWhi61skcFbaOKnNbBOUrG1w0y5uLc4c1tmtzlFaUsykYKmb3vf7e97qpuowEJsBYk47uvu7ttAk0HIfbW7u7u92973vw2FlmZiTCWarFLpcWOKBAoGQkhKSAASG+7u7H646RCW3vLsABqEqpK+1W5K1UlVqpqpUkgcWhXySpJU8nmxwKlSu8zsmZ997ve/2+lHmlHfHIquQTkjVzYSWqRhXenMjiQsgz+W/vd737v3KqVW+alTeh9d/X7UlVd+3fw+UPQe76hNpJqRmWW7M3vvve98bxRiq8RTYq80Vzc8889+eec88IGAKJJSCWd27nte0gS8C173X28doc+kne9VSTfmY2k5JJ6B09aTeJpJ61i1U1NampPn3mxfV9NgODwD4PQeg+DxcaHLu7u7uwAG7u7u+XaAC3dngOvdtBw4PBd+3d37dj0HweeXd3fOXewHTQBaAAmJJVazeZmffffffaczM8+9Hr4eZmZmZDs73ve/Rh78Hq7u7u7sY1I1Te6k81UvNzzevfs5mbzNg+D15zujzzjJR3ve9y5JhmZmZg+kXfl3d+3223wdAFywAvupznPpjm6kqr9z35mZgF3dyvtT5z32SUPe96AHb3VST1oPXe+2HwH13uqkl6u7uwAcrxL8u75d2A57y8mbzmdzMu7vAcHjve9ne96BOaHpd9qpLlSVWpVTWru7sXTQF3Lu7u7AB8l6u73vne97BpN+7sRgHwAk0+qZNbUgBL1DdVJAHau7u7u7AHwe1Uku79u7v2w6bAeypVKlSKjSjTS9gk0uHy4003997+/fggAAAELu7u7uwCSqlQAAg8qpIeuG6qSL3rg3JVUX275d7ux7Dp57JJP2eST1NNiSb9xpNhwD4DYpNbUgdNypVdhqqkg+dPTUlSAPI6bkqR9d3uqlVd3dnQAAAADU3VSqHWr528lVJXK1VSVR41mZmYAPRDdVJPgOgG6qVQDpqbqpVAO2uqaBd9l+7vdVJLu/AAXe7u7u+EypVSTMzMzOZmeQX777d3fOcsAAfPrv2/b1d2De7u47O2N3Y0QlohBqEITaQxMQVW5W6qqqb1WteTVVUk5ryz7gAge1JVarQPgntSVXe986+e57/A9+u+3+ufv2yVJp1q2+eNXtt5bbZJJJJJ5J39P19z3peurZd3d3di+973vXV3d3YNSVISSVppW0t9/ZiSbtttodP1A8D98qt3d8+VUhAo3d2/Kr55fipOCFQlRg2psU2pbWv7+/u0q/svWbG1tmUm1U2JmtrWm21bNiIoSSbtyScQlFUlJKFIIppts2xtMabW21NoFmtiWZmYsSxYBu6ABE1QN3QCxJNW62gN/c4AAJq0N3QABJyTd2SSSJqSbuySSRNAG7oBY2krdTVtu7v1tttTVtu7oAA2vF3ONpIPA1Hx9MX5pexkzuZnmZmY+kqRoeD4+Nc94EE0yOWd7d3G0gNjp2t3dsEF7vdfO35JUm7vt6+6v6Xqd113veru7CpUgSSDaSATaR5DEHQ0BfgDzd0AATQBu6AAJoA3dALG0lbqatt3dttttTVtu7ttvQ1NAG7oAAkwDd0AATQBu6AAJoA3dALG0lbrmN28u/c5bbbZiR79v79OQ1Ziz79z376hibxLEk0v0+F222gAH5HwHAAknaaACPA9/e332ffvu9++/FTvJJJAyQCSSeT77Red++9MG033ve+XMSTdCetpsu3UqVX79+zMzMwBAW0G97DMzcqAG6AANqYB5ugACaJDdAPwCaA/bugFjaSt1NW279zltttTVoboB0NTUSA5u6AANr5LAPN3UAAKY8xrqSOHN3UAAJoeP3G000aYl5mVrzy3y/XlpxswA8aMPjgbfbbbbbILa9PvfPMKqSdWGX3ve971Yu7sX3zvfvvp98J9zpJIASSSFzEk3bbbctuSQDYEzJJO1tJBqattz7fEmlbbbU1aZgAdDU0AbugACTAN0AATRJmAAAmghm6AWNpK3U1Qu/ctv621NWny3QDoamiQ3QPQBtVbHrr5Zvx0qMdVefXgzM1Uxttev676759Rn19VsDiPgPWlfbbbbbJJJPJPfOc779+++++O973verF3d3fer3eqqSXd2+sZUkqoAHQCSDabAAAJJJWwFbbd22gCaiA5ugACaJDdALG0lbqaoXfuW221rqyhd2220bqxJPMaoXd2220TQBu6aAAmg6bugFjaSt1NW279zltttTVobugADa753i+88Dn4/H3wF8tttv62ckkkkkkk/Sezz9+98871SpO97d3a+973verAPaqSF37d3d2u+53G0l3urvd7Jytpsxpt3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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
