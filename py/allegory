#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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UVUHsUBHMRVNRRQw51ZkEBMxVC+UqqJfOYARL7QAJ3tKKnI8iKLzl97qdu7u8njPAOjQHA2G3A6GgOdGQHkwylSSSSrq7tJJIMmrqruqkknJIC6t4zuSTYNgJJJJMQHLu7qqohjmQO973vepVWwSSc473vUq66yBzk73vUq6Yqrskk5x3vepV0wA773ve956rpigHe973vUq6YYA93ve96lXTADve973qVVsAO973vepV0wA73ve96l3dXXsWoL2JmKBWLwCCmMUIJcVEu7wnZ2IoHe0hyIAryHOX3up27u7yDbxngHRoDgbBsB42CfK9KquseKAGhMkyIAAZF6wuKgHYd7QC97Xe9vuh7AUOTkEQm8kmZJs1BdVVVQAA4Kr7JMl0QxzIHe973vUu6YAd73ve9Srpi6uwHfe973vPVdMAO9773vecq6YYA93ve96lXTA0Hve73vUupi6YyaD3vd73qVdMAO973vepVWwA73vd73fRLl3d3d73ve97vqIHO0IB2B2KjUYy4qhmTWdTWgER1rOBBE1mrt7yHJMzJPRnchw5JmSB6HvBVV1ekDo0UHA2DYA1J7zkkyCq6xUAAJkzHd3d3Ue8yZJgAa73t90CI9iKHLUa7AUOwBQ5nnE1d1fZB0Zu6ti5iYkmpIDlXdXVVQMcurvIHe973vUq6YAd973ve89dsAO973vepVWwA73ve96lXTADve973qVdMVV2A73ve96lXTFAO973vepV0wA73ve96lVbADve973roly7u7u973ve931FVJVACGIEnOVqCoTcRoFEsijBGIIhdUKi73eDkEXsUQQuIIgpyKgL2Coh2ICLyCAIciIHIKicuuzNXd1eICMeMgOjQHA2DYOBoknJJmQHlBzF3VhwcN3d3dkeupJmSHE6gG+AIEgB1O+VVXdV5JO67IOgAMAcqqpnNMVV1VXVzFRnIh3ve971LumAHe973vUq6YAd73ve+8zV0xQDve973qVdMAO973vepd2xQDve973qVVsMAe73ve9SrpgB3ve971KumKq7AXd3d32gkcu7u7uvMzMzOwEagCQLQaAJAgAc47r6j3OtYAALW7uyCSBu920tBs8Z4B0aA4GwbBwXtQPQ5uoBpEeZkz0Ds04vMyZu7u/adcmTF6AACHSG77uyZmoKq9qnXjYGBgO1d1VImN5A73ve96lVbADve973qVdMAO973vepV0xTF3Vge73ve9SrumKAd73ve9SrpgB3ve971LqmAHfe973vPVdMUA73ve96lXTAJznKrnHUu60zQHOcqua7u+iZMXjd6NbQN7VUHV307e27oFKYoaYqqu2KuruqBzAB4yA6NAcDYNg4GgOmJJJDSDxAADIKqqPF7mZmAB6AhJM3V+mJuqu6rcG3QDgbAwGAnjME5zlc46l3XaZNh3vOc4l3UrDBsnOb24lXTEgnOb24lXTEgO95znus1dMVIDvec5xKumJAd7znOJV1MMGw5ve9pV1DWmg5ve9pd0wl3d3rOc71fROkFdRAS4krImARMQEUQ3AvdAoCXfcAADcbugQUNxESEBQu7wgIGYCqFxAG6ByqqsAHjIDo0BwNg2Dga4G7dMSSST0pgkknpJJIKqqr1HkyZkhwA8cyYr2G7u5qrqrvr3k7IAADmcBunKq6urokcrIHe85ziVdMXIDve973qVdMWA73ve96lVMVbF5kkjnOc4lXXpVNXkHJ3ve9SrqWzmSScp3ve9SquVTOQO13ve96lXUumayB2u973vUq6YoBznOc4lXTFAO3dX3ve96l3UmburquVSKHTFIoZkyZNDehEUTWtYAGujd0xbF1VXV0wZq7YYuwcwAeMgOjQHA2DYOBoD8vABVGeqAAEzMgkAADp5JkyZIAHoCH03jmTA3vdQBVVe8yWB0wByruqq7YuruqtI3WQO973vepdsUA73ve96lXTFA2d73vOJV0xRgHec5ziVdMUA5znOcSrqUzWQOc5znEq6YoBznOc4lXTFAOc5znEq6YoBznOc4lXTFAO973veugqSKobggh7hS1+T6cyA4BQwQmkQISsKIYhDGFRD5RDO8Aod3v3Ptc11ADqKGLoFDBegUKnOZA5ooahUkGpiOIYhNUGIbkmYmCBKKqJJISEmY4gYkINET6SGJJKpqBrcvBs9RUA3KYrIQagO8aUQyoQG0CWEL+ifL2OcJ1GFCSCQB1phlfVRHVH2KNKDnuMwkXMphVUSMRISprBQkkN5KxGobXEoCgRxABQo0YUQrAChONtFfZMJdUu9gkwYMwPapMfd7vOL73eOcObegIgSKqdiVAkRU6mQvRJ8bbKKK2tAqaIihBUIiJEACAoQFkFRk1vNBr3Pe6iCWZp4TFXd3y74It2AKwASQASAg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hKgMgkglQRqCSqWSoJIpICoCFCKH1KCBSjFiAkERIgoRFFgKEBgKEDERKBQgi1TSqiQFD7777777nOdQV7AUMwFDve9+0KGwUIRRCIoSHoDIJIJUEagkqlKgkikgMgkiKKUgqRD6IIJiKIEiIphFCAqEBQh9999999vfEROQUB5BBOQQEOc+wAiegnqoSoo1FJVCVFJFJFJAZBJEBUKBQ+qkFCCqmIIoSICfffffffb3xBeRRB5EAQ5AQXnPsCongRGIgRQCRiEgj6CSqZGoDIJIJUEaglVQkgMgkgCIP0AEMIgsRVAYChEVACCAEEFgCgRRBgiwgChigQBkFFQfoij999999zfHkRUOcoRQ5z7ACiNwT1UJKoSVQkgBIJUqKSCVBGoKSqBBPo1iqBAgjUFQ+++++++3vnOc5nn1CgXAZBJBPVSIUjVCSISVBKgkgMglRARPoCoYIoI/ffffffe5zodgq97QKHe/eypIDIJIJPUJKoSRSQSQSqoREaBQggpAUIAoP0AQWooAjiUCARioyQgChBEYChBBIQQSoiolIoRQEgKEAFT7777777e+KvIioc5QILzn2AREv1CUVQMgMgMgkgMglVSkikgggp9BEHAKEQQDBFQfvvvvvvt74inIiIhyHOc+yKJ4FCIIEIihAUIKg+gVGopIpIpIpIpIpIpIpIiqEAFOQXsREnKA1DUVBAiag6SAqYVRfoAqH0FEfoAC7+oABbggCfQV+gKFgKnqFQU9BREqAAh6IgvooiqYgiCHogonoggPogD6IOZJePGKqtkzMlreW22rq9KqvyvarZky3623y2r4qvq2SZI9qr6HRPXYLhuN3i/d971gqZrijFAfV4973veEBPe6o49OT0Mw0KC+o9gPQvJ5epXpW1zJMjq9SZkjJmKtdxVQADs4K2Zkv0ttvtvWSZMlszJJknyABFSEQPogggUChFECSIEkYChFgKERQzCkiCipBUICpIQIEkBQiqqfffffffb3xVR5FROhFEIQSRikBVkkER72hEF737AKIG0UIqqHopIpIpIpIpIpIpIpIpIoAjFJQKEBBPoCCUChEBEAgKEEFYowUFZAEFGAoQEAAgKERQT7777777fORQHkVReTkBQ5DkO/UgiVFRkFGQFQD0ERGggsBQiAhAUIqjAUJ9FQSosYEIQFCKiRIAqEVQiCnve9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UkUuTYV7J72T0+gj2dj993A9nY7hvdD9PRSRSRSRSRSRSRSRSRSRXx9g973333275zWvr+UkUkHlUpIpIpIpIpIpIp9V3f3332970jrX3fKT6lIVQMgMgMgMgkgiQISBFprz+++9nvXF3Ve93gQkCGGwQnQlRSRSSotRSRSRSIio8iCH0BQVJ6COMIIgH33sCgD6PpyAAB2Iod+oAuKogFwQVu6pVSTD8qqqpCAOpKqADrLAAb1vjo0dGgOBsfffc+++++598aA62TMyc5JbdXpUJkyZCqq22S3qTPQVQ9AAD0Q96n3gVKPQ0Iz3vev31vUkzHjzMyTMeZmZmYAB8Cqq9rbbxtttvqVVTfKqndBwAAzMzMw8UkikikikikikikikikinqPe977gj999jsOzvaOc5h+nopIpIpIpIpIpIpIpIpInofYPvr++r77fuc57nPvZUkUkUkUkUkUkUkUkUkU+o++972fe3ve9a93ykikikikikikikikikiPqLu7972973ve/d8pIpIJJ9AKikikikikikin1H3333332973ve/u+UkUkUkUkUkUkUkUkUkU9R73vfcEfvvu572u7397SkikikikikikgehUUkUkU8fYPvvvt/fb9znN7+v5SRSRSRSRSRSRSRSRSRT6j13f3vb3vete75SRSRSRSRSRSRSRSRSRT1F3d+97e971r3ffRCopIByNRSRSRSRSRSRSRT1CIIdgICGKiqn2FEFD76gQROQQUHfPsP314ABG7pEVAuKq3FVG4AAFy4qpfvYABX0BQnvAA35tttiqkkHmcD1h+A0D8ACVVSDAD4Bv5tt9bb/Ntt410qi6pUALQZu7u+8RUuvRRWCPpd7uFwuFwv0II+9rIZggIHo+g3e8d73vfXfRBELlwRQuAChYLd3d0avmFG7d9b/NiqkkfgADRtvHxvKSqlVLtpxRFv9ffZPvfffffb3vetfd8pIpIpIpIpIpIpIpIpIp6i7u/fnRH77ve97vf3rUkUkUkfRqKSKSKSKSKSKfUfffffffb9znOc59fykikikikikikikikikin1H3ve972973ve/d8pIpIpIpIpIpIB9VKSCkh9R9999999ve973v7wpcUkUkUkUkUkUkUkU9R73ve97e973fOevKkikikikikikikikikikLu7v7gj73e973nOe9k9AqKSKSKSKSKSKSKSKSKfUfffffffb37nOc59fykikikikikikikikgk7QlHve973t73ve9+77wlRSiNRGoVFqVBJVIJVUJUUkUkF+o+++++++3ve97393ykikgMgkgkgkgk+oSopIpEUQqAoCXEAXBu6wCv0EUWRRR+hvVAoffdwgj9EFA+iIA3EFULiKFwFELjdXV0xd3TFVV3VMUNKAEEYD0ZdUaOjQHA2DYOBo+ANFlVSpSRQAAbcbb8zgCOg394DwKqrAAAFVVVVW22232YWqSpF0qqkgPyAAMzMzMPFUruqV3SSKSKSKSCSH0SopIp9R999999diP3a73uOzvPvZUkUkUkUkUkUkVXdUruqV3VIn5SSSTMe7u7HKpXdUruqJFJFJFJFJFJFJFPqPvve972973ve/d8P0KikikikikikikikikiP1H3333332973ve/u+UkUkUkUkUkUkUkUkUkU9R73ve97e973vfu+UkUkUkQkPoNRSRSRSRSRH6j777X3315Efp2d7Xe13lIfepSS4JUUkUkUkUkUkUkUkR+ox73ve9vf3Oc5z6/lJFJFJFJFJFJFJE7GopIp9R9999999ve973v7vlJFJFJFJFJFJFJFJFJEfUe973ve3ve9737vlJFJFJFJFJFJFJFJFJFIoh3NGBEMdz7QioHoJrVAoHve7lRUfXRdVdXY1TBmqtiqKyoboHIA+qru6++j7P3vvvtHRoDgbBsHA0B1X1/ffAeMvgA+1dVdfYuvUjyHMh9mTA6KqqAAAqqqr9VO023822+qlSpU2xHUAAZmZmYeEJPotRSRSRSRSRSRSRSRT6j77777773hHvQ73Id73H09FJFJFJFJFJFJFJFJFJED6j2Pe973ubD7nOc597ykikikikgdgVFJFJFJHUdRMRT6j7777673sN73vf3fKSKSKSKSKSKSKSKSKSC+o973ve9vYb3ve+WpIpIpIpIpIpIpIBJ9AKin0PsH33333329m973vlqSKSKSKSKSKSKSKSKSKcLwXi7u7+8I9nTtdmp3vcGZcUkUkUkUkUkUkUkUkUkB9R73ve97ft73vf1/KSPYlRSQUkFIRAPH2D7H333329a1rX3fKSKT6oQSoLIDIJIJIJIJVUD9R7777776+b3ve/r6J8VQkqhKikiySSSST3u47r2DEUwAJNb1rc+2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YqriD9mggjqUoA/Zo+n0BD0F9ABeRVB9AR9EQrtIL4iqD6CoKi0ki6SqqLSSQP8hHAAQAJttsRgA8ZD750aE+cDYNjb61xt+5+3u6dz34tUNgYqpAG9pItL4PxdKBvg4EE7dp42kl8qTtL66r58UtJD5VHOIuktD8HKLpFqi0Wki0jKRoT0fT09DXve9676gClxFuIKXKbdjbeJVRmZmHi7VqWrVq75dzksAK97X2vs73ve5OgAAZvEkknOc5lVncAAAms/bZmZJznOc5LgAAH03EkknOc5zkuAAATcSSSX99r6qqqqdgAAE3Ekkl5Nfa+73ve9ydAAAzeJJJOc5zKrO4AABNZ+2zMyTnOc5yXAAAPpuJJJOc5znJcAAA1XZWr1q/ufd+599PgyA34wc8VkgAFACMUCTsjQcOjQq+qvjHigac2WKgAQDry23y3oHpVQqvarbbaqrbbbbbXiveZr7ve9/u96773veuqqqr3YAABNxJJJzJr7X13d3nrADRozPxkkk5znMqszXgAB7WfsZmSf39/f39KgAAHdNe/fpuSSVznOclwAACbk3JJLuqqqnYAABNybkkl3k19r7ve97ksAADN5m5JJd1VZd57AAAM3mbzMku6qqqdgAAH03JuSSXdVVVOwAADW8785d1dUYrP6vc32ev93ve8/e+/BkB4wcFNooAFACMAk7JkAV+V7VV9XV97n6W1Yqq/r+tktty1f1ttQAN1Dd1ABVW3u222XPe973ve96SSbkkl3VVVTsAGsGyB8n7z973vZmn5Ag6tQO7sX5g/IlIlQ2G00mEWwvR7z973vZnZmZnuzzLZILaY22ZvM3nMzM726qqz3jT7WNhm8zeZmZd1VVWdgAAH03JuSSXdVVVOwAACbk3JJLuqqqnYAABN+e973peTX2vu973uSwAAJn7Ekk7eXd3eewAADNx7+973s7dVVT3gAALq/39W/39zf0qTnKnpJLberbbXV4quKjFVVVi/K98VHioh8HRuoegdqq+qvjLbbbbb4q+VkVVbVttVVJMw8W2++qqraqqqqqqqrZJky2y9W227qqqp2AAAfTfnve96XVVVTsAAAm/Pe970uq1qqqdgAAGZ+zN5mZl36a+193uu97ksAADur1v7P7M3lZmdnvdu7yYAABms/SbnJJd1znJ2GjQAfTfvb9JJd1znJ2AAAT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7qVV7ebr333vNvhAAZAeGQHlAAcZ5mTFkXx4gQPg6OCoGgAgQ3d17uv2e9zzbiqqSLSSpS7qlSUkkkkz3vd73ve3131d7vvedku9a++u6ncAAAqa1n9v3973PS7quXOwAADXT6ft+r3uel6uq5LgAAHtd1rU/p+nJKl3q6rkuAAATfveklS65zJr7X1Z38AABm5Mz9mVLv77X153Wvvu9vPYAABm8/Zkkudu6rlzvgAAJuSXJUu7y7rO4AABNZ+zM5uSpd85/SoAAB9N996SVLu6rkuAAAfuw7zXZ7+rX9d/av+ld0L88/Zb3bb+m/up+/eW1UACvYVX5X774AyA8YAIoAHrurKyqsYoDt3VyVmYkknburGp9dBy7q0Y+3mYk97de+97ySSAAbYGgqVfhfAGxKQgOcn6PHuYlVZnXsu7uwAE36SSVLrl1y52AAAZn7PazuZWXXOf2VgAAHdT9+9JUly65dZ777X1578AABm52ZmVM7dVzLwAACaz9797mSXO3zn9K6AAB2fvSVUlzt85/SugAATfZ6SVLqvvvqrkuAAAfTfpJJU/rqq5LgAAE32eklS7uq5LgXd1L5d3Zlv9d19++irPps2e9JxtiANA7tQAAF7AD0CKqqr0vttt9LfvgCgABVZAekkgecz+VVWgHhkwDyyegdgAq28yZklAAAbbdtttr5vzfW8e7uZIqVbH+uwAAzckzMqXedu6zuaNAAZuT2SVLu7+++u6nYAAB9NySSVP67u7qdgAAE970k7Lu6rkuAAAe2kk/pLl3dVk19r689+AAAySZmdl3nbus7gAAGb1J7mSXO97f3313U74AACSSSdn9d3d1OwAAD6e96Sdl3dVyXAAAPb1/am5JUnex73ve971+9v3veHRodTmpDgrgANAdAAYAJFyVJ6Ynok3Ukm5APJkxVfVVACAD1mTFVXVstttikkqlQfAD62/m231vHu7mdey7u7u7ACb970kqXd1XJcAAAzP0kzMrWsu7vX313WdwAACbk/pJL1P6tddd73P7X2vusmwAAP7embkmZmVVc5zO4AAA17U3JOSSXd1VV2AAAfTfvekkqq5zk7AAAJv3vSSVVVr76qqdgAAH7U/SSSb9qmqqqzmvtfZ7YAAH7ce96SZVVznM7gAAHl+17m96zU1/b3x+5znOPftT9gA8ZUAATckm5IABoDo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qyCqSmvu4G9ENaIa+TJ8+TJuSSZIn3nWq/fvy2222gB5555556BH373s+hKEoShKEoShKEoShOyHe9OCUJQlCUJQlCUJX2h0J69eu+IXoShKEpNk2TZNk2TZPPPO3abJsShKEoShKEoShO9706JQ+84mybJsmybJsmyfXvvvjwlCUJQlCUJQlCUJQnZDvenBKEoShKEvjLoShKE2Tzzzt2mybJsmybJsmyaEoTve99oXoShKEoShKEomybT3cye++9u02TZNibE2TZNk65qNBiMjFS0NJWwaGoZpPn9Q5/OQ5Dsf6v9z70hkWDsHAuYOQtD+o66Kmh0hxDKLKNJk+SST5mSSfJkmfMkk85L/B/F/D75QABbbbbQAAAAAAAAALbbbaAAAAAAttttoAAAAAC2222gAAAAALbbbaAAAAAA7lvLbbQAAAAAPPPPPPPPAAAAAACT7+hiGhoexoPkeQ9hqL7H6PEPlF5D9HVF87557399+fS223zxbbaFtu5J1MknWSeZJ5/FJk/iJTLJbJZWVWyqtiFNpTZFNlTZUzM0LbYi2qWwrZtBWyVspWxKbKralbAbAG1VIJmqpTbYotjZBtNoGzGW0DMtaI2bRppjWyAKoiFkqGIIilAKYjz4+3OksEUtTKAuhKEoShKEoShKEoShMtMiQEVTMLa2bSGxmtnnnI88cTaN5wcybJsmybJsmyeeedu00JQlCUJQlCUJQlCd73p1Nk2TZNk2PM5k2TZNk8887dpsmybJsmybJsmyaE73vTolCUJQlCUJQlCUN5yPPOR544mybJsmybJsShKEoTve9OiUJQlCUJQlCUJQlCd73p0ShKfU6EoWybJsmybUeeedu02TZNk2TZNk2TZNk4h7qC73f2++/r6AW2220LayR7kn3JPuSd5ir9ISB55vk9iUJQlCUJS/bYmybJsnnnnUdsmybJsmyUJQlCUJQne96dEoShKEsmybJsmybPMeeeeO02TZKEoShKEoShKE73vTolCUJQlCUJQlCUJQne96dEpNl5uZNk2TZNk2TZPPPOo7ZNk2TZNk2TZNk2TYne96dEoShKEoSkKPUmhKTZPPPO3abJsmybJsmybEoShO9706JQlCUJQlCULZNk2nmdRToai80PN19+/z+fz+gBbbbbQtt7mTvt7Mnz5Mnz5Mnz5EoShKEoShKE73vEOwlCUJQlCUJQlCUJQkB3vei39ZB33347VbJsmybJsmyaE73veiUJQlCUJQlB6nQlk2TzzzvtNk2TZNk2TZNiUJQne94h2EoShKEoShKEoShKQ73vX16y+vXrgnOc4B1CLJNmTdD9+9ALbUB9FtvMk+ZHvvv4fyMd999x3NGnfffXcaaMW1kFWQVdaIKtgaIW1kFWQd3cyOZJN+ap7QBbbbbQtt+ZD58+ZIKvsDRC2sgqyCrIKsgq2BoC2sgqyCrIagG9b73zvvuZmYFttvni2+eLeskuSW1mTd3fck+TJ11WQVYFgaLayCrIKtgaIenOcsgqyCrIaIB7qBhd3PPnvnuZmZmZmYC223zxWSe5J9yT7knuSe5J8999uZN3XsDRC2sgqyCrIKsgq2BoheutzJu7uZN3dmT5JMznzlvvr0AAZ3ve9755nfhD58xV9gW2zUBduhdqq7u9ZJ1111u7vzJN3m85y2330AADMzM73vfnz5ir7Att0u3S7dSEXaq2Sddddbu75knXW9c+cv2330AAAHe978+Zve/YC9LqArve97VVpAttIWO++++uuuk84Ghg0i6hocRYLBgwfEcgdQYjgdQ6h+7Q0OoZDuHIO4p5GQ5qVgwqyLpHkfyk6fMk9jJN+/XXdUAAAAABbbbbQAAAAAFttttAAAAAAW2220AAAAABbbbbQAAAAAHct5bbaAAAAAAttttoAAAAAH/eAPQAFttttAAOsk8yRJkxh9jgfYZDuOwOIeRnyPkfUORpND5GjqP0eIfPvX79QAAAFtqcyS5JuSW3v+H8KqNg2NiLaqbKNgWyWxK2Urbak2StqjYk2Km1ItgVs22qW0GyhpaEUoCilWgShppGgmxU2RsjaLapsi2WZoApFoUoKBSmgKUIlatotitkrZNlMwG1GyJsA2E2FsiNqM2wNAUKtIFCK0UtLSqUq0jQsVAtIFKUCFLSBSW1ZqmxRjGyTYpsIUK0IVSi0C0hQFJSo0oFI0NIUUAhQpUSiFCNpWYWyGyTa2pTZUxKg0gNKlKhSBQUK0pQBSUoUCjUQjSlCUjTQU0oBQFKLQ0A0i0jLZGy2lG0ltUm0TNRStC0jTEItIpQlLRQq0opTSJQI0CtUotA0rRQlKoUI0DQJQhSUqUK1SghQ0qUrTSAUAlAUKhStNKoUlCNK0CmwTbahtJNi22JtLaZpKbZlNhFtmFtJtQW1W0bSq2RsTZDaJsmxFbW1bEthMlkWVqo2ps2MyqmQYqwWGZNm0tls2K0DUhsQsU1W0bVNmybErZQthZKyqtqNq2JmWymgatoGEwtA0Mk1KtAwo2JsitprFtC0DG0kWAykWzY2Daq2hNAyIbSGgaJoGJhNITQNUGxtZrNbVQaBiloGJK0DbJFbUzLaRmjYNEyRZJqVW0JsMBkwpkmQZE2pLMW1UwGga0Ktoo2TYWyizNltbDYbbVbIzNltsqrFMJLQMmQMmA0RiaBsFGkslsSbRtKTJLCWAwVNlLY2Gy2mYaGKqiCJpFiCqQoRXItQkymWxDAaBoDRJgMSKwrQNqmwGgaQtktmYNqzNjY2jYGrJsqKappUYDKSYDQTVMBmgZoGTS2WwGqiwZqUbRmmyYDRJmSWyU2LQKrAASoqVQhRTTVNa2bZqzDNExaGwKmgaJWqaAZK0RqmA1TVJgNGaBoTFRoGSNSYmZBoGStA1RMUsS0DFaBqkzVSsBi2oLaGgZKRQAjRApC0gjRQFUlNVEUjEhUQlFUUTUzAtiBbEVgNJoGkkbESyVgpoGYDUBkDQNA0k0DKqaBiWiZRVoGqU0DINA1JNAykrQMLAYIJVIFCUMShVFCUkRTbaGabJs2JaYxlWxE2IjQNCrQMaJsBgVoGQrItRFstpBoGQbRGxSZTEFomqFaBqQy1MrQNA0kZBklgNJWqTJLE2KaVGgaoWaA1LCq2QaqsVNGVoaBoGpVYDINA1VK0AQCtUUBEBShSUsREU1ElNKUxUAxRLQUUVRs2bRWYTMBLaoW2wJbTWKK2tapMBqmVlJm1gNqRrMZUo0DKDGAMBiBtUo2SSzSRgNSaBislpUtrZRaBpDYqNsxRmKTbZBqBoo22VKaBkpMBpVWgYWxEVEUBRQU1QpQAFAlLSNTCMkIsSBSFFU0CI2oNExEtA1QbRMk0UbQIbSTAaILQNINAxAWgZJak0VMBlQtqqMg0DINLaUmgbIGaBiDQMqrMVMzVKyTQNQWgZSDNAaBoGQNQWgaLSrAa1KtkWgYLQNNibbU2qbWaiSmpgoQpaCkoKAooqkShKWkSIGkGlEiqlpJYiCJqSkiimQkghEzSVtoGUDQMI2qFWBZRKaBokGgakmgaQRgMIpttJLaJoGQNA0DAZBtQZA1AylkGgaBoGkI1AwGyBlLUDQNUrAMg0BhRskYDUqyBpCaBkoaBqqtqqNVWoNpttFCRUkQFLShE0UDFSlCMVNFDEKNEQNUhRTSVNFQ0tRUKVSIRAU0AVRUERUkEFDQzTElJNVRRVDUkSRFLQVFClJgMRRoGmwKrZVTJWKkGgaqC0DSRNlSrQMiNqSxTEDUmiFoGipoGUJoGqo0DEUtA1S0DUC0DQNAyFtSq0DUFkDIGQNA0DUFoGgaBlI0DENA1JoGkLQMSm1ttSMSUqRNIkQlIzI0MS0JVINFIJSUAVMhShU1QRMTAUzJSrSoRCU0pVIUUNVSjVCUpSUU0NIUxJERDVAxUqC0C0q1SGyhgNCJoGFNMBjUAtiiU0DUqVmSUNA1Qo2KiWFGgaBhImgaFWqFaVS22WxDYjZGwrSlVDUpQIUrQAUo0RVFSNNICUIUFDQCUgbKbVsZlmjaobVEbVIbJVVtG2VMUTYShsUKrQMI0DUi2goMqshKbQGyVoGKSmgaVFimEJtsqbIGqraBimwGQbIMIBUTUQlJQgUKg0NUsVUUrQqUrQ+vXr11Dve95znOc5zipBVsC21VVdQN63777n37mZmZmZmAAW2sk6yT3JPuSe5J8Hm7u95J1bVVVIKqrYFtqr4W28ICQd+9j30AAALbfMk888TJu7vsC21VVVUgq2Bbaqqujet5mPfQAAAA8mTzzzd3fck5Out1VVVVVsC21VVbAFe973333AAAADzzzzd3fck66666yTrrrpVVVVVsC21V3vfe9777mZmZmZmZgAAuSfbbu85u7vOc9yTep11vOc5zm7u7u9ZJ11115knMk35p9e+gAAZmZmZmZYFgewOQPYGZniqqqqr8gZA5znFVVVVWwFe95me5mZmZmAAAPkyT5knnnnm7u+5J1111u7u6vyBbaq8gW2quhdvICve8777mZmAAAAuSW27u77knXXXW7u7uqrYFttgW2qqrve8zM99zMzMzMzMzMzMzMzMzMzwh554q+wLbVVVVdLtsDkDnOcVVXHkAdEgQ7qAMA9hyoOQ0HNEOI0P5DQ8h3wHgfOVF7DhL5GpK5DJFoaoaFoYNSi0MGhpDZFyNROQ0Ukmz3539d90AAAAAAttttoAAAAAC2222gAAAAALbbbaAAAAAA7lvLbbQAAAAAFttttAAAAAAAAAAttttoAD+AA9AAW2220AAsyZ1kjJJzJJ8ySaTQ/R1HqOqL2PY5F6loZDQ0NDQ6ouR1GjkOo+x9RyDupWoWjjc+/vPP377+AAAAFyS/pn8Pknz58+fPk+SfKEoKKCGYqEqIaCJImlAmSJB2UVfr6+uCekFIqFNtbWUkDaorMCZlExs1pbUyZrY2pbeeeedx8jzznNEF26F2qqryByBznOKqr5uA/N999v6gAAAB1knWSdZJ7gewMzPO22/IHIHOc5s3tV3vdpbeQOSTrrrnOfd3fb11069vtAAAAGbga8888sC232Bbaq9gW2quhdvIFtqrYFtucgH0A1ANEDnOeZ7799+4AAAAfck8855u7v7JOp111u6qqqq2BbaqqufQC2++++/c9zMzAAAAuSW27u7+yTv79+/esk666qqqqvIHOc5ywLbVX4fJCT6AaJJMn3JPmZkkknJknPv3333397+AADMzMzMzM7A+wJDMzFWwLbflttgW2qqryBbaqqv0A8+QkgbIGrA58+++++/vfwAAAA6yTck9yTrA9gbkDMzzttvIHIHOc4qq73ve9vIHOc5ywPnOc4q/YB995zn3w5999zmZmZmZmZmZmZmZmZmZjAYHhDzzxV+kC23Qu1VVVWwLbcLbVX6AXnOc733373MzMwAAAPPPPN3d/ZJ1111u7v3JOuuuqW2qvIFtqqq2AZbczPfM73ve99zAAAPckjJOg3d3vJOuuut3d3VVVWwLbVVV+eaASAWAGoBqHgch80OoYMHkOIedIcDmh53DkO0WR5StDQtRWRiWhyOIXKXEWhyOIuBwk0NRaGomVcQyGKaHEHUOB1DrBTkMlFoZStC4o5yHEbkMhkHA5RcqWI2QyNJqk5JXIZGDIchhWhoOBg4hyJcDRA1CE3APkA2QPkD4d89t8+ee5mZmZmAAAABbbbbQAAAAAFttttAAAAAAdy3lttoAAAAAC222ZLaAAAAAAAAABbbbbQAAAAAFttttAAfwAHoAC2222gDMzM8yBqByB8gJAMkkBgWBkDIPY8kr1D2i+0X6HsOkORuEDhA4QA3IBqQCeZu5eZ5ne973vcwAABck+ZJbbu7v7JOuuut3d3dVVVVVWwLbbADcC3dzM9973vfPPbbbQADrJNyT3JPckHe7u7u7qvIFttgW2qqqq2Bbboy1t8zHoW2220AA+ZJ5555u7u7u7u7qvsC1qu973tVXy23vPO++5mZ3ve973vczMzMzMzMxgMDzzzz2Bbaqqqqq2BbbSBbaQshLbVVV+fO999zMzve9QH0ABckuSJ8G7u7u7u7u7qqqvsC21VVVX3333PczM73ve973uZmZmZmZmZ0gd73qqq+wLbVVVVXd3d3esk6666+ZJu80PfQttt88W22mZmZYDA9gMDve/OQLbVVVVVW5J11118m7zd3d3d3nybzdvlvvoALbb3ve5mZmZ5554qqqqq+wLbVVVV666667S/sh3GouQyGhoedeeB+/AAttt88W227knMk9ySX5Mga73qqq/YFttIFttkJbbSBbbck63et3ec51kn2ST5kk/fe++769v4ADMzMzve973vesDzzzxVVVVV9gW2qqqqqtgbIG4BogF0SAUA1AOoZ9DSXP5DrpDsMS5C0PIyFXAvY7hxJ0DkaUHEahkajaHIYI9pPMk6yTkZIyRknOc99PAHzJACgAABbbbbQAAAAAHct5bbaABMgAAAC2222gAAAAAAAALkj4LbbMltoAAAAAC2222gAAAAALbbbauSPgAfwAHoAAAAAHeSd5J3kneSd5J3kneSMk8yRh+jkfo9j2PY6j2PY9jqOVQ/R+j9H6P0fo8R6QexkLqP0cj2HcfKHUfo/R59jJdR5D9HPaF4jRX2Ghc/qlJJ7119d+vfQAALbbbbck9zJgZozMZAnkDQQkP+xqQPnz586W2qqryBbaqqqqq2BjA5zfPeZ379zMzMAAttQHWSbMk9yTvJB3u7u6qroXbyBbaqqqqqqueZme5mYAAW2223yZPPPN3d3d3d3fck6666VVVVVVWySBBgXVve9777mZmZgALbbfPPcklyS237knXXXW7u7u7uqqqqrYFtqrZCAT7ANAQh7qZkmWeeeee+e+fvwAAAC3kySlKUuEAd3fEIASgERERCAREQzM0QgBKAc5znOQOc5znIGtQOc5xVsgraQDkA59+/e/x+/AAAALe8k5kn7Jkh554wFeKqqqqqtgW2qqrqSbvN898vvoAAAAdZJuScwPSE+wDMzzQu1VVeltqqq/IFvXW7u7u73kyX79+/X2v34AAADMzNwPsA+wDUA3qAZmYq2BbaqqqqqqqrYFtqrnzM+/czMzMzMzMzMzMzMzMzM9gHe96qqqrYFtqpDd3d3d3d3esk66663d22330AABmZmZmYwPYQh3veqqqq2Bbaqqqv1XkBXhyAcgG0gampANGoBpkGNRZoZqPvvRHX6H9Q65ukZkXdDIvsmkwjIwZS5BoaRWhqU0GoNDBg0GhyGDkMjUGoYH8k5QchqLAwaGhpVZGhDQ0GhkdQyg4hxDhHvvny3X9ee/Pv9AAAAAAO5by220AAAAABbbbbQAAAAAAAAALbbbaAAAAAAttttoAAAAAC2222gAAAAAAAAAW2220AAAAAAyTvJNyTvJGSTck+ZJOZJ3Mmdw7jQ5D2GofY8j5B+DQ9jI5DUWhoP6Rv3Xv75/P37+AAAAB7kk9yT5kk9yT3JMqfaHR9vt3jQDQCtCo1NUVVE0wULSqUICXe922223Um7vOc5zmc5znOfJ8yTnOfv379+/fgAAAA6yTrJOsk3JPcktu5Ju7znOc5znOc59yTd3rJN3ec5znNmSTd3zzu330AAAAPckn7JIOc51km7vOc5znOcWdddfck+9ddc5znObkm7uuz9+AAAAD3MyZbec5uSbu85znOc5znObkm7vOc5zm5JLOuuttt99AAAADiGQ9+/e2+kOc5ttttttwTnObbbbb57vl99AAAAD3JIyQc5zpDnObbbO2222223EDiHObzzzzz6+vPPPAAAAOsk6yTrJPckl+TJny/DIZAGYkllVVVVVVVVVWQAWd3rWtrXta1rWAAAB5knsySfJkt3JN3ec5znOc5znOc5znOc5znO5u7b9t99AAAAD3JJ8yT5Jkk/ZJBznOc5znOsk3d5znOc5zlm7vOc6zMyMk66636P34AAAANyTmSe5kmW3nOc5znOc5zck3ec5zm2222hCQPYh593tA9Kq+kA+IaHCOQxwlojQ1HUNDkNDSaHSGomDqOSl1BdQ6hodIuqhyHKLQbkMi0NDqi1F0HINQDckgGoBrcgTcIBw+j7tvPn377mYAAAAALbbbaAAAAAAAAABbbbbQAAAAAFttttAAAAAAW2220AAAAAAAAAC2222gAAAAALbbbaAAAAAZmZmQLAwAGAwDcDIFITcgThF5HsPY6IfY95DyOw9h8lmT5Jkz7Mkn7JJ1vt97999t9AAA8888888+5QPsI1VeQ6Lzzg8IpaU2k2LaqbA2NZEbWZbVESNACUCNIkTTBDVLTTETUCYg0FLQkpAFEVFRBRFFUVJTBFFNFCFCItBS0VUQxHe922223Em7vOc5znOc5zm5J8mTdB+/WgAAAHWSdZJ1knuSW3nOc5znOc5zck3d5znOc5znOc5zvvu33zy222+gAAe5A+yBCB585DznKsbzmr2hu89Ic5zbc5z3rMkzrrrv32+/rbbbb6AABMmQPsA9ge+++QFd739gK73ve92Arve9851km7v7ck9yT5111+++fv1tttt9AAZmZmoHoQDve2B22qqqq8IW28gW2qsVVXkCwPDUDnOPeed973vfTMw+8yQB4AHsySfskg7yTd3nOcVVVYQBmaUAhAHd1VVVVVVVQgtFqWxMzMzbfwAAHWSdZJ1knuSW25Ju7ziqqugDMyqqqqqqqqqqqta1rN5mZma1vMzMyAB7kktu5Ju7znOc5znOc5uSbuznOc5znOffZ110PF9AttttoAHWSSHyh8/Pztq230htw2qttxDnObb4888e+gW22+eLbbQd5JzJGSe5JHTm2223EOc5yOcym2U2ym2U2ynnwHUND7DgeIfId+9dw3IaGhykmgyHAwNDVGhoaGRoNRyDhFyHCHKk0NJWUXIXEWhoIBvUISWEOagJTnb75z533MzMzMzMwAAAAAAAC2222gAAALbbbaW2220AAAAABbbbbQAAAAAAAAALbbbaAAAAAAttttoAAAAAC2222gAAAAAJkR+oHsPY9j1Hsex7Gg7h2hodx3HKLkPY7hvkeoeh+DUWI4RcQ0Mhtx19KAAW2220HnnmZOc5mTnOKbZS1lNsptlNsptlNsptvfnnnWSeB9AC2222g6yTrJOsk9Q+fn5U2ym2U2ym2U2ym2U2yznOZJznMyc5zvvu330ABbagPp556Q9+8ptlMbfSEJzmU2ym2U25mTnObknyZN3mZOc5mS5Ju7ttvvoAC2222gmS5Jbcyc5zMnOczJznPckhOcym2U2ym2U2ym24hCc5vPB76AAttt88W2/MkuSLXyZN3gG2U2z9QHOZTbKbZTpznOoQlu7mTnOZk/SSbyfN5+/fvf378AAAd73ve98zvZBVkFWQVZBV+wNELayCrIKsgq+6IW1kM+QLb7z33333CZAAAW227km5JuSfMk7eeZgqyCr7A0QtrIKsgq+QNAW1kFWQVZBVkPfsA8AgGiENEA0NBWDRSyNSqYNUmfJJJ8yZM+/fvlev34AAAAxgfSBPsIBoA1AMzMsDRC2sgqyCrIKsgqyCr90Qtr5A+QNkPPPOq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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
