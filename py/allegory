#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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OCGNICZBHDSQld7RKQH79P1++XlexSQFfs7ePUqb3u6+7rZ979G/nQJpL2WsVfse9v28+4F0QneQPb95Hq97nue9pPMqSTkmG1Pez7Hvaa9TXvYXvY5WveZpefwg/DH0fvX+f6/3737D9KEEN5DHXRLQmho7y5tlHH+UVCvdROO9/lervPe016m5JNSSe2U2bxkDWUYOjyt08033Pc97jnTMogaDAGQwnKu7u93XqTlLx7Pve97fqXve9oANgzIez73ve36ve9720oQn3RzqszmyEhMEHCEhCEkKLrP3vT2/eWPe97Xvefm3oilUkqVcwliqdVWKcZMVUHrYMYyaijbdDDARUBEUBRhBZBZIjFAVRrRMtZJEFBjFifRKRGC4W1aVkiMIoyIKKLBgyRisQRiIqqelWKVYLOWe37y973ue973ttipFJSSST09JJJJ4HJJySe0Hvb973vb8GXhpzDu7vV0k2n2yaADZz27MvjTSXkkk021n29dLNFe5hAGt8AObADe+STUkkJIePlrbb/UR+/fs/ffahB4SbbaARyQDIbSVNJ02kqdVi7uTwRMqqAJC7qqXqxJJJ7xtABsA9E0UAAF9571JpLVNpKml6vc933te9bTSK77J02AXyveD19972ve96FJU06W6b37Dfve96/evdSvAc2kwwwAL7V+Uk3JPe2SSSSSeGSSSTf8TT71nlXkm0kvZ33nve9mSAckmZJd4OYaYAmkhJpYs4AFiaSqaS9ppNPWfwxgBFNMPekkuSTU8SbkklkkkhkADkl3PIA973veObwoJpNugzww0+ye1JJJ4JJJJJPLKkkk5JSb9S8ZAAh7wveAAw00pd+knZiTDTkkkkl3d3J4PZy00ve97vve9L75ISTaSUaecNJNNaMZMNMAm5JnMmGnJJ31c8lje8ar3ve97khkIUmwAwm0ru7tXy8tO/AB0AA+9+poLbNcJnvVSQU0IhhFRbIBBB+ko8tM459nKrdediq8qd8oLnIEMBioiHyWCLasjBh8WVOM9Zj6MSyEIjCAIzzMGY0odwCofRMCBlmnBYsgiIoDo+nCeRzwKdUP0u53c2saaa2xm2qGJOkmYAEhWASAcZAPnv0555fnyAVLp3jbtvh+1VLnvyXUZsi2tnXfOv3z78/egEic0qqS9xEkdoq75333315TvnW9Yz1zm25oyKyVUWsmIjMtYxFrUYsYVsYqsWNoVhBRTckhIEExFRgopYTWFwUuigsQEzy5hdFtllRKq0stErbMcxLWgqqxcMJYQMh+lJZk+qhIR56w7vd73du6v1B0U2o2o2m1kT9rmk/aQDxkA999576mL6hWCqxQEVItlo2xMbJs2tjaNMtNlVFWEWSDIsOpRG2WWBaA7iAYwgSn3dd50QTEW4INJlooclTSNDZiMQzO5db3pmKaxZtmtWo6rhZcoxxNmZlsxhluOFMZLbblxgjma1rQYDrRiONuaMKC5YVWKqhGAilth7l2wu2hy22lQFThRUTVKqs0VFGgam9mrEwwbozeS7LBG2qawNXWqstFILWS5YUokHAwXEuUMFdOnGjYCirNFi26zWhq5lTC0ctNCOXZuiKmtVQ01Iaj7dq7QFhqjSG6OqMbLYqiCVNCLdUzKYDaVDWiSQmGlzBMRTbYTAlLIesq929BBsZ7d7lj5t3d3bb9Dnd/W/ctl5qTcklVtttskkklTdxW6ttnJJJLZJJKpJJJ3ve972cACsGDQIS87qEYKgoxmKojSltlCjRJY1BjIFmuYDrmWXGmF1cFURmIjJUYxZWiRRGCq2lYpFFUWAtQqCysLEUFVZCsqFY0rEFlERNMqVMZMGSqixQNoEmJUIRawBsqGyhtbENohmhG3MRzVBxqA6Y6zZzXTKk5w4FzVC61dc5x83XRBzIi7yHWkVc3Ns5311Si71FPmpc6cKpxhNtkqcjZoqXGzKlOZTNmbc1wTENqquaDaqlOMG15o5My65xG1JiG+cgu8h1ikbKVO8hx1wnDY5hucWallWyGjvkUrrnXQabWuu+Ok2spO8h0hoq2I2I7x3nedNuTLYtqDWUdMWSbQmMgcQ0kAFU5qDFqujS62tNuY63efu1SEsDbBZFHRTIcaqNtEtqQKhLaWIoCK2nMoxNEgXeWnIQ15Qk9aiTZQFc08+Ovjr31134mzF9bb9LgmxtttJGgADqbGjptpL7G02mjG2Y2uGjDqbAaewhiF3TbbZhiSbRjbTSXwAEMYaAA6BbOtJNNRTNJvUhad72SSfSSSSSSSTve973skkkkUkkk73ve97E3JJJOySST4CjrVUfMQPdEv3OabOu+jaabXcTSaT59au9tOiNW221NNugAABhttpIADtLbZJC2/U6B34AAAtLEmmlbrLe2kkkkne973vYpJJJ3ve973ve973skkkkbcySSSd7JJPpJN3dEgOiECDwwEehAVVIQCVe970EAO2221NJqltttat00Ym0jGYg02wC2xO4mkpkxJNzE2ki20IAAAAWzqTTUmskLSSSSTve973sUkkk73ve97G3JJJOySSSd73vexSSSTve9zM1IM2EJVkLX5ohpAQId5VvLSBJpc59y9tAG2ABwEk2AAW2m0kkgAOhb9caTauNpKfaxpzTaSmJtJF5aEAACmAWzqSbbk0m8kLSSRbu7mYszM03dN3drMzMzDMzMzczMzLu7vMeZmZm5mZmaJIA8JoEjzEJoTEDSSTuJJuiAAoT5BsDowtttqV1pNpK4BtAX4LbZJNIxNpKyF5baAGk2AAETabTmNd1JJY+973vYu973vYm+9kkkbUySSSd73vexSSSTve973sSW7u7u6C3d3d3QQSxAcgbYYxCMxppW75ctpTE3bbZcDGmYABSaxph3YHwW1p6tt5aU4W4rdXE3cu7TgEAA51puaUkkLMkkk7JJJOc5znN17u7u3d3t7s7u7umZmZl3d3uXd3t7k3s7bSSS+1J3OwOhmrbbyxqgAW2m20tmkAELJJLbptJBby2X60A4AfHvWGPMzPWi7u9zdFu7u7iWZmZm5mZmZo3JJJFJJJIpJJJFJJJIpJJJEm3+5w9666KJPmpM0IPdV77377ygUvbbbUklS22226RibSQaAO8xphtp7ttvbdNJphaBACAAABdjTZqSEDN3b3fZw93d3dzMzMzMzMzMzve97JJJJJJJJJJJJJJJJJJJJOzuqEBzEBrloQZkrLtAJJF3fZnd73vBppgAJtolVtttujGk0zGkkmAHAttsVy0LbbbaAAABYmm2lMySSEkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkne9kaTVxtJP8/P5ZSAivzFFGMiwUgoLUeuSGxNZgwCK47CR5c+NkA2iJAMIBIgI9tCAfsrvX7gFyQDmakEGyID0x6r3pRTO0hFOWlaECcvKhW2yGdSuMXnLphoQcwwMdBCEhJGqrF2ze7NIiTML4zkgBkYqowIpIQUkWQJLDaKLOuecw4IoHGoiSFZOuM0QDRAKvbTomnGKMS3eFiq3XrAkkw1qlSY2MtrzCEhgYSDFARYGmzBmklTuwNuQ470Q566Q50lcOc36/rinN724v0Ql7SSSmFbAScbofJin8U5IioqCZdClpxd+M97drPvkI7GR/BiQkIQENI7xzG1D/Om26I0jFMRqGBtKuTFXHnLoN1RWqNqjENz71Q6TNpLUN7g5I7cJOPJevf8++S+KqYM1GNIxGM2QyG2CyRrCrNSszFjTUmPsj/OnSGkf3CHj33588obbNqZi1I01DbUo1LCMoarLa2zabNZMxkyLQtWirahkm02NiTZDCyGtmmypd999996p9E2orrcyG3Kq40Riq5zglhS/cK5hGMmEZiqywVtrNbabbJlJgm2KNlmpW1k1qttNLNmYsMoyahkI+45KxGQxGUNs2TIbbKsJZI0O9UpsQyyK9yTpDQzDUNpbMGnVDBOFJg21s2TZSmDVD+ziG2I2MpesSft0IyluuSlxqGlmbG939HUpBrX1QpCX99CE/fyaICtiNN2EJ/fvR+r8BBcpp4rQSJpKa7yYkpN7gEaZQWGE3iiRtudkxy5nLTmO5IZE3neMHehhp5RFkCd1JhpyS9CWKp1V4qmk0pWaTSVUqWTSzWchhp1k0KRXxXM5x2YacgSCwG1Z0rmMVzWWnqtjGnp+ruccOaW9bWLw075w9J32MCKaYBO2u4vFJu7uy2neKhrNhrKbA7OSsrkmGnN4kEco6dDDT6YABG4bxs20wwcrUxVJWmkqZiaydw0ywJwwYDDTHslppZVNJVXaeKqk6pQgqyVAjwKCqLIiGFGjatQ4FKGMLBYKCLIoLA44WkhzHWkbRzFtI2tpzUbnHGCzbMyiMQURbRbBYW1lrSpUhWVkkWGGWYyqxECUSpCjLbIdtgLAwZqMlQVTKjJUFQSsKJbKQREVZJUrAlG3x1vDT70gHRBhphvcd5eapVzFV3uGn0snQJoAOtMHiSSSSB0MNMoBhCqXJTTkxNyTM2GGmBk1SbSAMjpp8kmld3izDTkmZHEYj3oxjPA5hbafdYWQl8m5dYG9tPuw4HMaMbzGuzv10KY0+HwKS4oZStQ+f3Qde+889yvf7+8/vyPNnNJtxAQhQKKj0dfoEvZfcInXHz3mY7yYaco2XYb1rHAw0wxsQLIY2GGmBzVdGvV4rfuYzr3vaaeO+9S7mYvl87r4QDnfa973IBV9vjT409NPbbOAW0MBBxr5MOtM4YTOdOXdv2pbQM7A2cA2CWa0IQBDD8Ntfa1mYmkvNpLzaSxpJU2kqSaUw2ksJJ63k2YNlGZJ1Tk7fJsPg0AA0m0QAAEk0kJpLGmksxNNKVi8zCmZJOyS9YkkhppgGgwU0zAAAiiAHAMlBQCARCGw2gOGDmsVQHCY7MXMNOSSw7koMNMAiU5NVJhpyTkk7JOSbUN5aYCyYoAw09NMPinSkACBoxpiAAKBTAADVppKuobSRjRWDgZCWpOSSSTOc5kkAAMADgatttvLpphDujAoBO6xijPrSLn0BsU6bf8PdUfrZUoUmo1oBJ43nXJP0WoHEmYp6e583/Y/coVDX09wPlNfNOGX6RrKz4/mskD5ISSGowhXBlSVefn4lXz+n5+Pn8/p8UvWaTQGUUSSbSbkTSTchHJJJJhMpNppFNlIMJooppFJtIJJJd3STSukm0kS7snZJAADSbAA62000o0p/oBpGoasyqNQ0moZNE0icxHIllNEtUN+/dFDrL9qQfdCfc7YpmZm1s3vCOYNm1WYpbbShbCI1DCh+yqTmyGQoYq1KrFW1pTrrgFXWpC90B7qpT3HuhJ+0tptLYpQ8bihiRg1YLCWUMFahi1DHuJyhhrSpbNQ0S1D3e9RV7qHWofPffe1HlDMhiNlmjYCylgp3qThVpK0q133xJd4U60Drrii+MmyKWobKGSX7BX79ypfsB6xVe6Je73vhU9imKyW1hsm1mShlJoqLFWKDBaIwllK1Wah7ySE995e6kfPeCPfeUqXubC2bKxZQ81z3nKWRe+8999690j60VP2iP3X7o/aT9qH7986xqqNQxSxVqSNohdbipmjbWUMpahhMyFahiVirQl11wOspXcd8UnffFFdZSRqGEPdBe+8lPdSR7nvvvRT2hhMxGoYIej/NJT7orZd670KtOucWEpYh+yHJEnMQi/ukP7v787kwwmzeE14G3lS7u+8TSV4E3STScwRyS7E2FIrdapbaTTMIyikUilu8BgaYAbGkyww2ktgBOvSbkkm5BNJGjYGkHY2tNJtUk2ml5JpU21SpOUNQwW2htrIatQxHM5ZVExGotmMbahpSuuuKo6xHmtKttpbMWDbYD7gp994kHZGpFe5ST3nOqGQmoZIhkMobSVgxStoiMhpQNQwk93uIvdRXuke+8fdsg2IGrRirAxVpGKt3iTmrWMzUMqaaiMo0LrnXiOsoeGFWa1a22mbazG2bNrR+1D9+5CD95yRsiP37913bbfuFD9+5Q7oZqGq1DKjSGmobRZqGyhlDUNTVYDUMKYNIBkNKP2RUv37kqP2Uv2qk/fuL8hpSTZAZDNQ1CGQ0VW1DIZqGUowaS/ajlLQ2MhptWbZWUNRsNQ0xtQ0oNRqqahtQzUNoml+/cpJ+0u7SWMzZrLWZjbC9z3IV77x5VhCWQ21tUoZQ93LRLUU1DZQ0jSGI2kTRihqG2ktQ0oyGlT3e6pXuSL3Aneqk776KvAG2lWUIsU2xqGRR7lHKGFQ95777777+FVfQLRVqGNVbHu5tgRBEWRJ6++6xARgqikFAXD3Pffenk0S1hZQ1UmA0q1DFNQwmqxe8Dl77xJHve96wSD9vxj6fspCEB+YgQhQxH5gggQF537379WpH2x76CJ7u7AQdqSsI5Jd3fDTbTTlJJ7m5pqDTSwil0kkkckptJQAA6QyAGQTeQAsIofaKxS/xDCcxfv3F+1D9+/fLzUpdaF3k713oO8l3iTvUGm00nU2ksSTeNthoOAHyTKtAAEbVbSWGBowA+TVNY2kgACtJv20Gm3vOS93ue+++++PzTaWaHpsAAUxN5jzEkgAApjzGnmNABJJG4m0l6kk0kl73tppL3MJpL3ve3tqBmSSSSEkckG0kAGUikgCcTcmO973t7Td1eUm0lJqSCaSLAACSSQNa9JJ3s9U1f2mmGgA40ygBA0mgtttqTttttqattttqappNhpmIxBpmNJGUAAqaC222pO2222pr9m9Xt3PU7CM2zdwQGIEhIRjQkZndxNJSTemk16FwwASJpty8NpLsmFJwNBpMxNpAAHvW0TQRNJHxjaSKSbSQAAmkiwAAE0kAAF9SbSTzMkknJ7Sa/GabZgB8g00v4sSGsXvb973veE0FtttSdttttTVttkiauK4zGkjEw0zA001Fbd221czMSVttAEhJABbE1Gk0v4Ymk2/Y2m1/DE020mlqk00U0zKaSOl6KKTSW6SIS7bImmmp6+tvgSDSTMSbSMTa9jS8YYJpLCKYSTcl53eGk07ppNsm5JOgAAFtt42kvZ6Sd9EnP2k3cVy3QG22WgEDSaAtttSdttttTVttttTVNNMwNAHyaLQABNAW22pO3u7u7lbS5AkfNAL80IXMRzECPohXWgNebz4R2Sov7EqT595RLN94mkuBNNlJuDbxJJJfW0lMFNtN00yg5KUpSlKU7SppyZazSabalMpMA1I405MSY6kkk7q6TaSuk00lq7tCfJsAOAG03bbepNpp/xftfq7bSpq/w00wYARNFrAAE0A7bbUnbVbbamu26Vt7bpNU00y2/W6biEGwAOrE8x5jSWYlbbbY7idtttiaiaj553oh8aJ40lebw3IInfn5fLgE7TTZ8L97GBEKCdngkubxJJfIb0AcFbbJIW2hA0AAFtt91JNvM9G3JJ6prt/baZnwbQG01Q1bbQTQW22Nq5ltttqakkkkTcwxp0TZsA+TaLQABNFLbbWnZJJImr9U0lptug+TvqpD+VlUr3Pnyh79++++4zEJJJ3XZMQOSSSSTLSalMDKRSmNEbck73oW0MAAAMDbtvzdxXqb0mmk/TXrbfVNT9pp23aVt20kGqABGlrWlbJJImjMx2222JqS222tqmmmYGjFwD5fY2gPgA4ZjWJAAB5C593d3doi807Lv6hmMQ4CGNtpuk2q5ra5pJpJO6Taa3vc3ySPwYDckmkmlBJMDxZJPpPX3A6ZJO96FtoAAABbbeNJJez0kk9W1f2mmAARtFtAATQBbbUnbbbbW1bbbbW1TTTAAI2i2gANoA+tt+TdttttTft/S9+7nWoubIaZDSu9I/zSOmSW94ktiPOctqjah1qhzEczvdt0hiPmRPM61R8/cJPGd2oZDKM25/dXVgGxFswkuUQ1pMWxyVtfQ+nzBaNIC6uRY6qxAbUyICFMuBJ2qiJOhxTPJrWrsXe8WO065sodygq4MKlYQlP8H4fJm6T5zmECPw/MsvwJbSmNxr858TN7/CN+3b+9UfU0l5oAD5nmQ9AJkg1LOZs1HLl14I/dPFR5iO6G4I7UO+YnTttiV03RaTqrUNs4qO0TJmSZRo6obzqTp1ScqS0YRiWUNd1XJypOv750/tHbTLTUNYrYTTyhjlcouTkjviv7+4p3o2kYxTzKjgrZS1VqGXHFHOaxpG2WMtZRyolgQptlysrAIMILGWklJRli/blkM105ymUNBmZtcRzhp9zpjLZI1daqTTQ+dcQrojS1DGaqrEZTEccv3HWqHU+uSpcXRGnuXLIEqYhen5JB2yI5oQYfM+xrvGCA6u953tWTQk0tAAVrgpFO75JN7gG+4XOc4ZoLCVmy7vd9uAYANgXDgABYf0le6RtZpDYP9DV90o61FU2k6pVSQqmMLK57GNe1zvPefbm7rUkk8AtkpSajyu0LuOc4FuFAAAJIkkkkiubMgHAGBJJJEAZAAHdBkL7uECNyEjGgRrSEimgYgGiGZ1a5wCwXADQO+trqpJLNPFKNUk1inVJOqVOk06UVLCWaaSxSdSSWWCXeAaNhL7ztd70viZuBsOAAMAAAhQAAZLCKckjhIZAAabXaTum228Jurwnsh3fGFgtkk0AAqAAkuSSSABzOxCDgdsttJxJpUkm0qbSVJWkhVhJZoyEAtJ9qqaqmqodFGgDMjAOge92BrYAciWKaua3bbTq80xmmknhNJZpVozvQASyoUAAXJJJJDYCbG3DmANySaikw05JJJ3vS7u7kMJsBbAC+GGmUXm7u73djUdJJq1XPfe573fe9voGw6B1bAXwECtpIwAAMAACnXpppZtppYmBsCU6lgHxJJONyTMkkh1CDIAHGistNKmBkAsF2dy2mr0sU1oVGd8ABIAAA4VYYyABxpYaaUk1JJcOgGqACpJ0NBTEml0DZTCgAAB1gbAA61IpmSSQeZzLw07xTqngoycLDiANAe97qSAS2kJaTfe/Jd7zfQA6mgNgAddurbbegbAA6Brs4vJdTSWNNnfKuffkvihqvKI0OZslqGA2nVDcbZOsBcN0rUv7BtFoy8SmF5QjDRWGks00k2pOypIQAAD5p+95v3vdLJJNtpKevg6ett+Uk6m/eNh4AAAC22+ffza1ixJPMSoNqtqs2ZG21RsLaLbaKbE2qNhLaGyNlVtINkVFNhLbahttQ2ZrZDMZqjZstZmtkNmwjAVWIIihARinx5fPPPOm5GJstswK/zS4trFrNtrMrZszE01ix5iZmsaeAAFSZbQAEmAW21p22221tW2221tU00wD4DadWMA4ADfMaWY8zMaeYwAArMTPe973vckTwgP0QCDy67dUk0gEH5wxJZOFgdiMFZSSxgyZKaZpGQxDGKpptxdG3pZmMBni7Jh56m95lLN4ac5hSg9fur2ttPZjXxwIfNJpmK57XM8BDCrWXqbNh8IC228XksaTzPSST1TV/aaYABE0W0ABNAFttSdttttTVtttiatNtMADqaskttqattkkTQzu7u7tEakIG0kgdxFvzXMoG0RD1jKSSazfN3c93M9ZsyaLIV73fe972Pe94AsDZ0A1zCbkkl3fLJmSSXKkkkkiXybAD1skkiauL8seIxaNaSS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YUGlWJS0q0RW1VVkNCbSGViGVglkMqmQ1JMhoLIaklkNFkNKLIZDIaBsgZDKLEMQxDIZDKLIZDIYUyGkZDKyGotiWQ0qaysy2kzNpMybS1pbGzatk22Fs2E2q2tYmbWYzM1q2s202QzRbW0bbQooCokIqkFgKRRRSLAUZmZbbFm2Itkaq1RbCMhhUtMhrIbCSbUqshqhDIakVmqgZDUVGyqpZVZDIYCWlWEaEZKNrZbFW1VsRsjYTbbLbU2KbBFIRRFUVCKCwOc5zXnxSAdVbbRbKtm02qWwbKtlsbGxmjYGylWwVG1aGJTYJNhCNKsK0qxS2CBgaVVNpDYrIZRUyGoVlaEmazBsQ0GyGVrIYjahqjaNlshtQW022o2KbCWYndaadtv46mhFtoAmrbbJEnBt2221NW2221NU007bbepoRbaAJq22yRJwTdtttTUa7dK6Te/fvensRS2LHacpuGG3iikUIxFJmNuYnGnJ2Bm0DbJMyAEqpicu73q8BgACdnE3JpTUgtgBsprvMc5zgWmr9hp3d3d8TQi20ATVttkiThbbbU1ZJJImrTbTAYEmYklbar23VbeY8xp5iF0ACiWNVZQAImskxZ+a59xtppp8xJptJ7q7mZ26ngAm7smpmTCchqbaakk5tpSkpMFMpenvYnk3QAKVKUnspopIpspFNImGzGEU0hBkMMpopspFJISpIpNFMopJppvnOc2HU13vstO228TVsg26AJo6AW1J2SSSJqq2221NSG2nbbeJq2QTdAE0EAt2k7vve971NXndFez2+vSfKwG+xXCQAAkqKSXdku7skkDsmJd3d2STIAABJJIAAHcc5znAtNd732mnd3ek1d32Ju0BNQAC1JyWySJqq2221NSQ+adtvyatsE3aAmuAAWoWJNZjvd3d3cxjY3517fUIDz/CuqvKr133233l4OAGgA973ve8DCSSTxJLu7u7u5IAAAAHveOJsAd3PWSX8JvMWYnmK27f2NO43bd8xZieW3dttTQaC23qakkqbttSd5bbbU1ZJJImqracaYB8mrbbbamrlsE3bYmvu6ndfffebfyUzqc7J6AAEKMSSSBckkku4AEkl3JIBwAAAkkku7vibOaO96FpO5JJImqrbbbU1+tu/mnbb8muLFdW0TYAmi2yS1J2222Jqq2221NSQ+adtvyavbaNsATWYZd35N2298fqqIpN4NgbHuXFimnuZ1UCYlNPfJG3Jzh73uPitv1tv1AC228Tdt31BrRq27uJbnlv0533ipq222/rmJvDSwAAGN2222JqSX5p0TYHE0QC2gmi222Nq5ltttqakkkkTUklTdtqa+NG+dzlVJq+chc9gAA6BkADMu7vd3ZJcqJu5Sbkk8AAEPABQEABKAWySd94qTtv75pgHyaF0AAE1JJJIk5JBN22pq23vbE1cVtPmmBtNCvbbbU1O96SRJySCbkia/a8t73qBr8Ue9NQOgZAkkkkhJMSSSAEu7u7JIAEskkknYMAA7znOBfUn3vstPstvE1hgAB8hpYseJYlmNOSSFtbVvLbbUwAAqTkNtODbtvE0NHTYACa6mXSkkiaM61mrflbaIbV++7bfe69vvb6u13myduX4AALu7u7su7JJIAHbq7uySABJJJJIEl3d2hptPhznPdSfe1/vmnRtgcTRwKACaMs7ZOpoz7NW22xNd73ve9Sfe1HzTo2wOJqHTdABNdLZJE0Yskkkia5f2/0zqNupX3EO8ou+uP7Idq9VwQ/Tc199ub7r9V1fkgNYID1xnP0iApAmhI5gC8wQbfsVCAbQIC36rmHcybO7nXXvPTBAQIBpAWIB0FuHFwa/XDbSAbEBPZnvXwgNFzRuxLIyAvNOdSsBeMx2ixY5SEAqQBRAMQE76/hAVzp9AJ0S0gOc+8DTaxZ3O62Wl8AAAB8HN913vegAGYHbVV7JzPkIMTE0KkkgNaQHMQgh1GyG0y1DSsoOcpOIOWqOWQ1NlbU2E2irMmsWxsbLMTayhtDUNQcLlQ41DRMoyGMoayjZJbSGtMWCsskt5xR1rp94QcxsItVZpkNQyoefudamwjPK5Ffspf2J3iT9zipkNQXjH9pEsUmmoJpLek1pJpNAGJImkty7XdWQNKSSbU3UUk5wA2ARNJFSSSWSAAe8AAW2220DzTaG0lc01mNpK420t70sM0kk8xe1v7nqhNngAO0APe97no298md3z3vUQAAB9bb9baAAADAADgB8AAG+975+xtN9xtJrt3rYASSSRd413eKprFKqbaWKwlSWKqiVYx40UEYiYALBsoKBSxS0a3uGRBHCsIy22WsWdSmI5mY9LMxvWaWYtNZjzFrX3PuQAAABxtJaxSSTsNgAdABAAgD5pgBwkKoN3d5u+doJJJOCpUk2mgNSSTN3b46AAEkkkhsArX2H2ul7yRtJRNpY03M1qFoHAD4C2222gAABbd3d3cEm0gAACXd3d3dySSTchNNP2hNibE2Jv33333vfWgcAAAOFu7bbQBpsTWNNvAAAvzatvLy36ppITSaG0l2sgbAsqTDTkkknZJJJJ+oekb333333331D1RZDWahmAAAAAaA0gCBAAAAAACSU22nJJJJJVppI1Sy0zQAQkkkAAAAAAAAAAAAAAAAAAAAAApgAAYCAAvfNJMTSQVjGgAJJJJJKaaUm1nWtSSXNSYaYGwALbbbaAAAADlibznQ5z7j6so41Q0TcOcsqbSRqxKm208U0kmoBhQwRXzt8W6dNPyw+U37nTeg96e6AAXd3d3YSpJJIBAkkCAevsafsXiXLbbfAX6407b+X5tppRRVWIKwFBYoJEFIKoWy1q1mxNprLWR1wI+juOF2IE2SrZsW9+/ewXZtppIYDG2D9CRjJGCbXdVUhd4S973E0cC0ATRLbJG0ZllttpmYks7bbbEqkpL9806JsDiaOBbQE0WSd6mg1matttiar7Pb+W/t6uNOBvZ+98tiDBTT2BYcGlZumUmwNxzru8Nu4klKgZLANJgABd5KM2bRWYKw4rTYYAzLu70s6SwUa304k+c9lp9ibu72muXtttqanSSSJq4sttttTUkkkiaikPmnRtgcTRwAAE0WySRNGLLb3d3CMZm9IQU23kyMK/TcLPex97PfvvqYAHAECAMyR1JM8kuGALq7u7u+kkkngDoGQkiUknU37ve94HW13uPK6007nk2aXwbTWzofAAmi2SSJoxZbbbampJJJEYsx5iSVzV0tYldaadE3rDQd2sxrEdD4A+GkW22xNGLLbe7uER+gQE/CAjX+GIC4vPtSX3fO/36LgS5JJd3fpJIcEAAB2TF3d3d3ckAAAAD3vAEnfSd96Jov4NcaZgG01bbbbU0IC22pOSS22pq2222pq5cpppgBxJgAACaAtttSdtt3d22rvffCaSxveN4zXDZwPd8AAEkwm0kAAeLYW2+ATfvAAAFMAAAAC23vu+kk96pq27f400w0zDG0AAAJoC221tcy222xNSS221NXLafNMA+TXMwDYAC60AAAk7bb+/fvyfP8fOdVH9QyCs0omZbJmtGKVs1tY2lD+wiYbZr3u+97fPemZJJE3J5L1VT9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FmNPFiAAASGgAAqaAAAE1bacaYB8mgAABtAFttTVttttbX7Wfc1vADsLfwAAW2220C2222l9bbbfHtgAdALbZJN+XDfe996pq2222pq5bpW/ttMDaTOAAA2i2221NfW222pOSS22pq2222tO40riVx2m2mBttnAAATX25PbzX2/vVqb0m5yeg+cIUZ3TT2E3u7u7skV3dJu220l9bb807fB5t+933jYBbbJILh3ve9PJO2222pq2222pq2222pr8AAAmrbadTYG2/lgAdAG/seLEnmZjAACpCxgABU1bbbbW1tdya8tTRsLA9RskmpLkwm5MySS5zubzd3f6GHgt+7Jv1vgAD3veDgW2+qbqnrbb6pq2222pq22/utMDaa+xYAAAmrbbbak7bbbamrbbbamrbadaYG018AAAmrbbba2s+ekmkNpL9pPlDMoaq/uKHFWof3av7+8+/2KPYul4DSckzdkm1Kwm5MuAY7fLu+EPIG3b+bSVMQH73v3794AAuUDQkBcVx/m0l+xtJYi29p+qattttqattp1pgbTXwAACattttqTttttqattttqattp1pgbTQAAA2gAttTXfYE0lvCaS0dnU1vW9b3rVnDs37Ukim5JJBgAAEkk005JJuNuSSSSSQAAALbbbYm7l8rbbfF/LGseNgABWm7bbbQaMeAHetMDaaAAAG0AFtqattttqTttttqattttoju7u9iF73pER40dMQHhJMAVRDbTXPMJCV+CAMAmO6WgA6but2NAxLahUpat5d4QCzGScSTEI5RATt/t3t/eimMWshoGwyhAbdBVw4qoqrIJWogkA6QBkCGke/I30by5c2RCI+N9VV96NeX4ED9ZJOk7p0hidinXSLzeywKu9Q96DMgV5vXBFa45RXfjm9+HCV6dQIV8kkPLu22CTJ3UJIpCYijrz53533eP39yKD9aWyR/ZDmMrBaz7qg/SMo/b9Mpe/vnwINtCQLGCD7Pfep+6ULNqZ3a+9ft+GktUbacRfdaK1zZqUc5lpzszJ2ZlppLk008yb1eFckw09STMytyVAy0zoFAiYad3fbudi5Yk5WKqUsNqkcaeN84GQAKtNPWvk3vcOAQ4RfNPmldmvL6fewq0m+TO3XOc3zJ7vL7TTDVNgcDTT7gaANmE006bPgNBpplt+ty+Ftpnve9r3fj70IXs8hjj0b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L73gAklZrsgmktaAs4BnOcySSd6SSSQ6AGAFuWW20p4ukk1mNPTTZ30++k90OyScrvNSckkDgBo5ve97AuSSSSXKVtttoYB8AU6AAWgAB0NXdttiupFhNJTJvYASSSNu7tXTSSVUm0nmNvePWJLmrb9SgAAFPrbfrZToaaZgAbLbeW2gBsADtoAXZogfEDyaS5O7TSR33d+9b6+w6AfBQANFtVvbaAYCABS1pq220AYABZctttAAADfbdW8tp5Npd973vve973eW7v1toAAACE2JuYg009nwAXoAABJNySfABoNNMAOB8buNO3lvLPJpKa0r8e5933veNgF5bbbQANQNAAVtJRp5dW2mw+TaXzTS2AUtppppW229tQAAABbbbVaGAEG0lymk0wNBJO3V3dkky00pJJOSaT7bq29tDgB8AdDVtttoAAABZMkkhSmJNLbTSOgbOh95NJSTabbEc53oe8AAAFSqXOc4d6ABtppAAdAAAAAAAAC3m/vc97Im/dTz9VxqhqGzUNpLIaLZIEMQDE2IENjTF23ve3JlXv4AnWEq4Tp5ydHd36SANsAAAAkkl3Z27u7u5Lkku/KSe1VJpIA94IpVJpH311QCbDGfqqU2Am0jdhISNZSF+sArAA+LIUgoxVFVRixBY3mNtrMTbaWAbAAbQFttqattttqTttttqattttqattt6jG2Gm9gABRJAABUnbbbbU1F9fVb+3pLKxWxNi12sdO7TZYveWx0AbTZIBhcAMpsAJwkE2ABy+97O3SskEBJJINMG2ASS+pucO970u01d3d37rTlTE0B0ABNAW22pO2222pq2222pq220jTDSaA6AAmgLbbX/HxpAABU13Wmk0r+6sWPFzuc/d2Iz7vf4Aj8/HpD9stttANhy27ttK25PpJtF800oAABJJAJJDfk0lcTdZ1d3fvWmrbbfRphpNHwAAJortttqTtdtttTVqtttqalttI0w0mhHAABNdu7u7oLd3d3Etn2SYSP8h38a2DSTX3G3ARNet+kWJPSoHROSSSSEl2SSSE73ve9LsUppwQBpMCG000imBIHZ6SSe/VJSq22Rp3E1qySSJr8K222pPtttt66mrd222pq2SQjTuJo3gAAJqSSSRJySSSqtJ1dq7eL9vvM53W97Rw/aTc73fc76Be26uW0Cy222puS7u7u7sQBoAAAku7vhw73vQtNZbbb+rTMSdttttTQsAAsTUkkLamrbbOwWm1dW221tWSSS1NZbbbak5bbbamp9yczevvx+8CvjvLcadttCHgAA8FtttpZJJJLbbaAHmmkAABnU5jPOcOpoV3d3fracpJ3d3d3akrbbYA0gAAqattt62rkkklUTUkkkiakkktqaAAImrrWZzE0ljqWLW+i7qq5iu9uG036Ys7O2m/QDGw008973E373qjltE2AHLJJJPNNKgBIECmmkAaaYgA20pXOc5z1ttd73u5P1TVtsnYaTWAABRNAABU0LLbbbE0W222pq2222pqSSSRJySTd0Rz38+71kRkiA3M2z8M2vffX7s7oze767v3gALDEl3d3d3Lu8Ju7u7VjTS7TTSAAPe8W22238+973vffk1JJJbW2tW222tqSSSRNSSSSJOSSSRuSSSWpLVttsTVkkktTUkkktaT5+WZ93y6u+M5zv77h6Z30p+AADwWSSQhbbbu5BNpFYTYGikmkWZaaRA000gPe400vZ+zE0l+/OSTve/q2rbZJE1JJJIk5JJJE1JJJImpJJJa21dW221NWSSSJOSSSRNSSSSJqTu1MbSXV9cOKv5C8Hw+DWtSVb+/fo8zr+z9umvvdXW360AJcttratA4wAA800vGgNtNIAG2ARgBtppRt48SSTvrGklbby21tW2ySJqSSSRJySSSJqSSSRNSSSSJq2222pqSSSRu2222UCK771u/3NIPzSA1IB6Z8ICVrP21M7duNunNTEy7Mn688bIBvr+N54vkxndG9cTd/PyS5oERRKEmgRjQIfzIBR+RdMR1aGLrWxLiG2ihCsWBJYQEFlBgkrSNoVjs1ucqHKthGhTIZI2B3XKtQ0cPvK5Fm21VpN2aeTprpwrjOUjpyFXKHn86nNdFqGmFPddeAXYP792eah55Q/ddyHdSu5HHbRLgjI/cuyOhVomkbzJ95Q98fukHyiOiNmfHRHVDoK2Udahz9wocSfnTpHW68oeF7jz+Q7VfNQ6RcmaZsx+8/v7PNKmmV200le1d33FsC00kGCwrEA4Q6H3fgNgAGBVbbOIA+4AfFttttA8YkYzWm941dez7nue5oNX628vgLZjAkgN2m65vew6Ekkkk2lqbu93zd6uwOAEAAAtAAAF3ve94vU97mt/e973gAJIn9i+D75JMD6SAAAAtqST6SfABwADlumncttoAAAdcySSQAAO/dphw6BbaAB0DZrpdW3ttABdwD4LY2lU2ksTazLbaBWYAEikkkAAAAiXFdW/W2nm0lzQvZ73u+94TbqFhppgAAriDTTAAE3yzUkkoAAHAD5p236236gEDQEkU0k0pd3q7u+Cu7WUmkob5zgAAEALbfAAAAatqaadt7aAAAAb3bbe9t0m0j4NNMDcIbM2aae7b9bvl6uYacnZqZSaQmkrpNJBkDAGLu+XfQNJNIAAhq223tptAAWGjTTSDdtsvbQAAADVttvbQAxaaaR9emg+5NHm2n14k0lTD4ge8AAAGoONSck6K40wANNNIKAQMWmmkAASlbMAACow35Jt84u4upu6zMzN3znwVak8iNi00VcnCnMb8NCDHbaQFpgg9907l9539+6BJQjMa+p392/tTpLbf362220ALbb9ZNC+t3fLu7u7u55t+973vb5VJpL3ve973preHFKsIKKoviSo6u2BiopFCLCGybKVs2Z1115Sq+jHrWy2bWalNgtpM1tay22rZszNbZGyGxstkyZW2s2zGUWKorBYIMFBVJFBZAJGwbAbbYwYzo7u7u4R27u7ugt3d2SJqSSSRNSSSS1tq2/W21NW2SSAt3d3d0Ru7u7uiPlJrCHBpR2TsSJfv2okl30LxN2+3JJU3bQ4F0m7aUzt+vFcVuqAAAAAAAHmn7O3JNa1JPfhtq2222pq222xtSSSSJOSSSRNSSSSJqSSSWttXVtttTVkkkiWNLYzMzEjdy/0UUFRXsYkwYCC/0KDfCnb+s7PWTvvJ/gAPGX3veAAk9dJu7u7Kg00rA16qTSXveNtNL3sepJpe94AAnTvec4cTXOc5zl9b73Pe9762nVKqdUNpvo7u7u7WmxtN927u4a022mzg7o7u7jhNtpsbbwH3Sd3dpzTYx4B10rbY7mYsxK2SSRtzHmNZqVN221NcxhJtPV61bZSb1S4BL9vlibu79JPX3skkKAAHzTC36220A8n7NJv3vbXva972/HAD737MTSX79+2pJ3vf1bUkkkiT5JJJE13skkia5JJJa21NSSyJq7sm7qRd3eZgLMzNzBGm7u5gjjIiLe7RzoluroMTY22vQgxoJu/e/fmdmZ+3N+/X5W2/WgQAAJLbbaAB5ttP3ve94Akg00gAibrzZL733BtrmOc5feprve973qT730kkTUkkkiakkklrbV1bdW2pq8kkkSckkkiakkkkTW+aWvft+94vj5p+9+/FtLbaAAAAFttshbbdySSRSSSTzTSKbaXqpNJY9TTAA99zOc5yHmnixK23ltrattkkTUkkttTVttkiTkkkkTUkkkiakkkkTVttttbUkkktST3+NeF19XMXftBT9U3fa+z8vAdOpsDbttomwD4814Pk2UwGnzdzeeD4OnwAAAAFttv1xeaeZ+S1kkk9W1ZJJI2pJJJE1JJJIk5JJJE1JJJImpJJJa21bfrbamrbJJEnJJJImvTX2TFiW9/HsXv0/fsv4sgaoBbfAAHQRv97wAEnrdpu23xroAEAD3sSaQABx85znCpqKSST9W0d3V3d3COH3bu7hzGxvd3d3dBjGySSTqmZmYrbbbLmYpJJKrJJJbimTJJLxN5NxPWg+A779bbLlttBAABwAACyFu7bQ6BpNgBwNB+Qe9734/fiNzMzP2ZmZmfG7u7u5mZmZmms3d3exJ5bbbe973ve1SSSTve973slttt7U2Sd0EX2/ms+1zO+5v737L+3ZcG2cAPgAQAAAFttshbbaABo/e973vX3rbRpB73uErN/dO7v25mGZnqe7u7umZmZl3d3fZmZmZu7u7vZmZmZpu7u7uZm7u7Muv36tu+qRAVcejayar90n1ggrNn2+EBmRO4ICcqOh12973t9EZaQEPrJBhr2/CU+qtyXzv329980EfRQgPkgId+pUiGQ6GRkK3Po8T3MQE0rfmgGezTLiUVtfceJQAADgB9vuu9+73gAGYBqZvYGb9/PN7f0vnsekdkYjlKmwjRHOTbG2RkNQzSMZk2zWbZrc1zG02moaRtTdc5pGlaVMho2G12dquNKaQM3UjiptJWz+6IuMlduz96/vUOd2+0PvWtiNZEOQ5xZJaI2srhb7ao5v7ukfdOw+ddLwuZ/bpU+tQT+zKEIgElBX3yFKR5X0wgW199kfD+EGyfSdl17RsAEUM+tt+5ab+ADgW2220AAAAAA+A9czNXW8a6sWs9fc503mKXd7u7JJAMJgEbee3V911dLJiSAEgJu222SgaAAAly26tA4GgAUknk0l1JpZ237fve97wABOdbRirMTN5NDDSKhlpWVnDRhTGGFoZmLNtazG97WPW7edgAAAGZbbbbQAAALbbbaAAAWSSSFQAGve973iB5CAOAAAGk2W8ts+u6BxXEagcBBWk0zAAArSSTMAA+005J9IS6PgA4AfNsAOAHk21z3ve9z3ve+7bq/W2wNAAAc6m8TfU31tbiz776SAAAAAW2220AAAA+D528t5de7lRme9pp896+90AttttoAAABa20lbbbQAAAC2223TTSoAEDGmkAVWyq20AD7Ob8m2/e97t9S222+AAAAxppW222UAAAAttttoABpppAAdt1beW6adLsAAA82wAAPAAAGLTwOffc0k2nzgAQE2kAAAW2220AgaTYaNNNI97iklfwgJz7eMQsoS93wlq4aYkDbWFYq+RVirlZK5Dgo4Uak8uJV55u7+j7qPfOV/a/aP7GY0lrEl7Em5jX2+bk36et3bbeW31ttttAtttUhbbaAAAAAYm7bbeu7u1e/ID8NB3d3Hdsvm2Hd3d2cMOazMTttt7cSrWW229cxySSdbXe97ZMzMzMjMzKzOOFXd3V3dMNoN6fcU+rt+xN/roQAH5N+97YwA4mwKc0AL5Nkm5GnyYm5mQDYABIAZCFAAQ3Sb7rve99qSSck1JJOSakknJNSSTkmpJu3uxu7u7urMzMy9zMnM1fqQoYxDDu67bn5TWvbvLPZfr+9Pe1QAt8AAAgALy222hbQNgAdAAAACd73vD8u972yd73ve9imL9bbbJjTtv1tttsknecu7jde7t7t3d3ubrl6zd3a5oW/hx++ifvvvc8fp72gLbb62222gBbbJIbTdtpOSakkm5JJAAAv3e973vjvOc5zrXK5znOzqeTUkk4n3O973vZ3ve9vWnK7bbZJJJV2SSTve973sXJuT7X2lvPvc59y2fvwW2220tt8AHve9622SQ3baHQNGNMADoIAAJ6d73vuVd73fexKY/pqST9xty93d3ZmZmcZyS3Y3dnHmZmabu7u7l3d3mrJJOSXabxNJbU9gAun78AGgACW2220ALbZJC38Hve972veLb222gBb2ST9ffpbbJzve972KSSSc5znOSLJJJLu7u8M0A2de7vUhdvd3d25u7u9hrhCPRbOZAJfqaZW7u83clNOTEkk1KlNOSZkkzdNO7u2nq8XczJPGwAAskkkD3gLfWSTwu972Sd73vOdiySSTnOc5znOc5z9E3JJJO2SSVSSSTve973s3zc38nWxqlsFGtFNQwA/zVK4hpUGsCTUMUG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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
