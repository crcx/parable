#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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tgAfAkmwAC202kkkAB0Bph8Y0m0fG20kd1jTNNpIxNpLoAdttAKYABY2027dJvLbaSSOSTvevve903dN3dttttjbbettt5mZjabbb1t+++/FQflop+yWlogL7hOiAA7Qvy+NgdGFtttSutJtJXANoC8C22226RibSRbb9baAGk2AAETSbTmNd1JJY+973vYu973vYm+9kkkbUySSSd73vexSSSTve973sbckkkiTkkkkTaSqazMS7iaazGmlbuXLaUxN222XAxpmAAUmsaYd2BwLckkkJQtxAbMTZhsL8BAAPutNzS3d3e81bu7uvd3d3czMvXs7u7t3dvHLbe7pu7uvMzMy7u916+8zm1lwAAOq40+c6GW22/WNUAC2022ls0gAhZJJbdNpILfrZeWgHwBwD5Lud73vTrXe963ukbu7uuIbbb1ttt6RG7u7um7u7u6SSSSKSSSRSSSSJNu6Npb3pJttJruNprFjSTSSMbYcDTgUvbbbUklS22226RibSQaAO/Y0w209223tumk0wtt7baAAABdrHmKJtNLFJPt3r4Ld3d3W2222222223u7u7u7u7u7JJJJJJJJJJJJbb28SaSmaxppffbX33zSTba+++ve2gAaaYACbaJVbbbboxpNMxpJJgB8A0wA+qMDgAAAAAAAWJptpTMkkhJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJu7u6295wIgDzHgsqSAQkvSEhIUKITBSCgtR04EomZgwCK46CR3NecIAxCEQBRAFEAS6IAW53nc756BF9iAJzzdRAHdIA81Pm854qC0d0mC1jJuQCOPNWbVKnUrjF5y6YaEHMMDHRIBISRqqxds3uzSIkzC/a9gdWtts0Wyk2ltRXJ5hRZ1z7mHBFA41ESQrJ1x/E2QDZAKvfnutGCbcYoxHtLGXUkJJTMpUmNjLa8whIYGEgxSIsDvcumrZ72O91HHeiHPzpDnSVQtez8lkhX9aLPy0numGGma7Qw+O9D8iTP1KOZaOErG7145v3r2/n5CHdpf2YEkOaJsbUP88bbojSMUxGoYG0q5NSuPOXQboowrYVqVbnfgq8TWyTA3zByR24iceS+v73uXiqmDNRjSMRjNkMhtgskawqzUrMxY01Jj2R/dOkNI/cIePv333yhts2psmpGmoaKNSwjKGq02bZtNmtTMZNRaFmgbUMk2m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wAFQAElySSQAO/cEIOh6y20nEmlSSbSptJUlaSFWkl9R8EAtJ+qqaqmqoeez3Pe94GAAHvdga2AH0SxTVzW7bbOoacc00k9JpL6lWz7mwAllQoAAuSSSSHAE2NsTfE2JsTe973sOSSbik005JJJ6XZJJANJsBcAC+mmmUXttXd3u7sSjpqlSaSpJ1arvjh05097fQNh0Dq2AuAQK2kjAAAwAAKdemmlm2mliYGwJTqWAcAA61JPpJJDyEHwAHUivmmlTA+ALBenvkm1e1qmtio+50AEgAADpVhr4ADrS000pJuSS4eAN0AFST0mpLlJNLoGymFAAADrA2AB1oEbAkg/p356ad6p1S0UfHSw6gDYAHUlDpMackSk+2AB1NAbAD523dttOgbAA6Gl5LSaSxpu8E3q9afU2ksbvKI0OZslqGVW06objbS8YC5W8Ridaouur58Od75+evF8xpopaaS+pttNSelSQnZJ9JJNtMBsDsv3ve982kvFknYXd3fFd35NgfASQAAASAPPv5taSeLG1mJNpJZjbzBra0rbYVtU2U22imxNhW1SbKtpW0GxBsiopsJbbUNtqGzNbIZjNUbNlrM1shs2Zo220giKEBGKd7e97+umyKLBUSSSesnJs1M1ts1o2ttpLWbJmaxp4AAVJltAASYBbbWnbbbbW1bbbbW1TTTAOAbTqxgHwAN/Y0sx5mY08xgABWYmAAFbW6mks1pJpRXzm9t02kmllapJLZ0sD0Ror5JLVaNHxTTNo+DUNaqk03F4be19NaD7q9Jr7yb59K+vSSndKUBe+o1qU19NwNtJpmKZ7Xs8BDCrWXqbNhwQFtvF5LGk8z3e9771TV/aaYABE0W0ABNAFtjauW222JqSSSRNQ007bbepoLaACattkkbRltttiajaaWY4BtCQtt2+Z8mgWFrreaACGvtb++mamEk+npcrD2ZmZrMzACwOHgDfdJsALb2+NgBTAAA2m7bfd93ve+qVSf5Y8Ri0a00+YzEYY2YjE1Lot+tsTRizFcAtvUklJJJI2pNSSSpdTQG+c008RowzgbSe0szMYW8tt5mY2sEAADbMaeY8xJK2222vMeY0816i+0s/c2+Oa173vpo/XkDnHwJ4eugB7wAAAABJJJIAAABbbbIXrb930k7+fgfB+mEUWQPMDzDGQPO/X26evsaWsWNgXltqaEAfW3aTkkkkTUkkkqVTVujGmZ8aMDSaCwttTQgC85wI3d3d3SDRS3uEAayiCanMbiwaT7mu91JfX9h8F27bVbQLbby8tp06RN3Lpp26ttPgAAC0MNBb21+76SSCVbVuv2NMOgdbUWfABAE1bbZIk5JJIJVNW2/W2pq5TTTC3lxNCC2gCattskSckkkiaN91uae+cdX2JNLd5PSTlZ6Ab6UIL+D4gekkkkkgBJPW233ve8bAAAttStD3e973vo2pP22ncakn5vi6sSWLG8wAOwNjTzE7aIttaR3WgALU1JJOyJqQ207QDaXU1mwtAE0K22SJPveibkkTUgA4ogClK8I2gwrs2VSIjt3072+eZ8aQS3TTNr6X3a7VV7rT39v31Jv5G7IvBrtpswAAF5W7QAHfQAPd970TfvjnJ4AD3jTO813vQtp9zSb9V3d3xNVOy7kgmhy2yFSfZJbdRNY6nJJIl+xMWT2mnbbxNibneyT1TVVtkkSfe973siYtUE9nxyaSQa6nFdluUgpKdA3HuHmG/Wesgakkm75f2u97PX9cwDh4DnST6Ju7u7xST0pphoCSRS7uyS7J1CXOc570TVWV/tNMADqarklttfMzEkNsQAAxZidwAAiaqkkktbRjTttt62qpJLbU1JJ3vW0YNu222JqL671rW9W/W38L97vve328km56+9bdW20IEk9d6u7AAAAJJFd/epp+LO95w6X601zFjTx/saYaAD5paySS2RNVCbALa2pkkknW8x1NySSWtoWNOmgA+TQrJC2poVtskSY25JJI2tXtu9a3zeq2Z3gWdEr0AS11Xd3dkCAHGnsD3Pd0e96222T3gAAAAAttqjb93vfSeia/Y07bJLE1620Ct7QgAtTdxZjxZmMy222xZmY28WOCttsVxLMTeZFd7adtodSmK229kTUE3bbI2urd3d7zSCmtCARySAJCAEiAPJAHHNnCNQ995714oulFkOvekGEA5+t/mkgGwIBupAKEj66MS5aflsYqpxlfRLzR7PiAe5xNEA6YQ27/eI9e+N0HtDzoru6Q666p1INJUXmyAb+2TpvkwGkASAVIA6/Oso/MkC5hrQU0fJoKJBo2Lmd56+znObTfwSGvxvz2T4GARSEJ6tE5lT1XfJ08+9xeq8+8c9yy/t+587OSNf2c/uKh6fLiHPvkR0zSaW+VaUbfu2fLut6+JvlTZnS87bad1qETSRQAqWwQHE0kc0ENHQE0kBYG121Xvve94INpIABEkXpqV9JIH8+pP22Q713ormE61sczmv2Wb2bPT3ve94sgzgB8b5SEJuvvve7vnQ973ve973g5bby20A2AcDTttttoASSSLve2JtKuVWk003d3s6ACAAHfkkhU2qppp06V3d3fiCAkk8t0u9N+94IgAEGmmADAsAkkkkkEBJJJJIAADTSUu/km2vk0lSaaZo5xe973hoAAAAC2222gAmABbErbaVXd3cktIYloADQRbqSS56QQAAFtuVJJJIHqaA2AALTTu7uSaafpEbAAACfK9TUkkhJJJJJJPSSSQAGwAALbbe26TfvsSaXm0kAdADwH0k5Jpp3V2SSS5xNJUk0qpJrUknbvyTaStNpL1av67uSAACA9bbbbcTAApibpgFv1t2m80raAQKmkvJtJe173vAXVt3b44AAAL2kwACHgAAALbbb5B73ve97wAW26TTSttoQNM5wAO0++15tJeDvQPEkkkkk+++NgAAU00pJJJLu7u7u7AAAANSKQk0m+/cSaave6vr42URvvNc37nvF+Bckkv3hXd3ZAAAAADoabd3d+94JJJJJJJIaASADuDbbNg2NiLaqbKNgWyW1I2iNtiW0jYVtSW1C2JTaqja22E2VW0TY2kW0tobUtls2TYrZSbI2htFsptC2WZtVtK2k2Nq2I2to2DZmq2tpNqNiNlVrFLZUtoGwrapsjaE2mxWtsqbGwFsW1smyK2psNbahsmxG1bCbbLNU2SbVWsbJNkmyhsq2DbaK2K2Gw2m0lshtLZbRs2FW1LbYTZDYm0ptKtpLZtEtqGsobQtqbE2VbNotptLYbFNqK21lNpbFsq2rZsDarZRtNhbJbSG0jZGy2iNim0pbCtZLYbRsmzWRtU2JbFbWyG0S2U2pNgto2iti2q2bJtKNqLalsq2WyWwbbIq2mwtqtraDaRsNkjara2KNltFsW1I2UtotkNoTYttibS2M1Um2ZTaCba1TalsgthsrYRtK2K2lWylsraCbNjZRZpVbU2bGYI1DFWRhmTZtLZbNkshlS2FWjDZWwtrZWxS2oNqmlZBtRtWxNqWQyDItBaVYi2S2SbLWkaRjaJkMqjIaqVtsbbK2lbQshlBkNUbDIaGQ0MhpRZDVRtZrM2W1sRMhqhkNAshpSyGU2VK2pmmxtQ2UzQDIY2JNlkMkytJNqsWZqGaNqyGoawGQ0hsVNo2IbLZm2rZtGwbQ22m2yllYqWQ0plFpJrIYYZDSRlMWxsi2NkkyGUltUzNhsNprLaNttaZm1La22raixMhMhpUtTIbLYRkNAjJZDapshkNEthbW21Ww2NjYtktrGraRLS1Sshi2KWQwppYVtRaDJVbGy1tJaFZqFsgZDFS22o2bG1ttZjZtmWwzUMZW0VTIZRkMpLSyGKwmlkNLKmQyTRMVZE0lkMVkMSZkMhlkMkmlWVSaMo2bLbbZbNtswZo2ps22bNbajZVVkMIbQNKsiVtIaVZKsViGQ0iyGKyGQyGQyGJZDIZiVZDKmQ1DIaVMhqqrIZTIYRs2DZNhmRts2jaZmzbZWY2jZsq2LZLYDYEyGiqzUMhk0aStKtA1LBVstoWQypsRMWqhmqKyGUWQxJqGZDCshkqyGlWa2UZiGwTahoMVMhoDIahkMIMhorbZtWaNobRtWYosRgsIsRUCLBYsVQUU2DNGxNalFbQTZbSU2hZDQtim1JjChkMgxqBkMIZiRtIm0LENVVtaxTIYTYhm2CZtqGIZKbbUkyGgWQyBkMpsUNZtGY2tmwtqVtJmLaLLSW0bbbWyJsBMhpRZDJEsrKGQ1SoyairSrEmlWBbCNhTUNQ1DKmQzENkMoZDQM1KxmStkNUWQ0imQyGIZRZDVNVZDWVW1GQyMhpsVtFbNZrLZtmra2TabNjY2GzZtsjatltDYtosqKQEVUigyIjFUVgsEVtaNMazCtshqkyGSNpVRosqEyGqFZDKGQ0irIaCmzaStIYhkMRtQxDKGFkMhkMhlEaQyGxDC0hkNSsQ1DENSm0TIZVYhkkyGVRkMg2oNBiNpmm1M21mGy2kzWzYs21NhZlFUiIBFEQBRYsFYorBQFRWQiqEFikiqKwRGIxEFgpGLEYpGKsUVSKwTTM2rY2zakLIaKjIaVbVtCTYFqMKDSrVJMhoobKqshoTaQyshlZFWQyqZDUkyGgshqSWQ0WQ0oshkMhoGyBkMosQxDEMhkMoshkMhhTIaRkMrIai2JZDSprSzLaTM2qZk2lrS2Nm02Tbaps2E2GzMVrZrVrWsxs1tlsozRbW0bbRs2G2aLbZNo2tps2W0bDMzLbYs2wptKwYU2FWlWETWlrIayG0STalVkNRIZDSks1UDIaio2ATQaVaVaglpVhGVK0itm02Q2g2I2RtI22y21Nim1TZLZm2zZCKCwO973u/z1gB8rFUkFgCx02EtlsbVsm1VbRDagVtVlWJTYJNkojSmqMhqpbBAwNKqm0hsVkMoqZDUKytCTNZg2IaDZDK1kMRtQ1RtG02Q2QW022JpZiTazEksxM1ppgAdTQi20ATVttkiTg27bbamrbbbamqaadttvU0IttAE1bbZIk4Ju222pr5Rq6V6Tfx7AvdIpcF75ym4abeqKRQjUUn0bc1OtOT0PG9IG2SfSAEqpqdu75u9BoACenU3JtTcguBCjhTXu673vT1TV/aadttvU0IttAE1bbZIk4W221NWSSSJq020wGBJmJJW2q9t1W3mPMaeYhdAAoljVWUACJrJMVY1zfGkmmnykm00nyrufT11MACcuybn0mk5Dc4mlJJ3jSlJSaKZSyZmpibzWZmYiikB8mikimikUkiabNaRTSEHwaZTRSZSKScpNSnKlNJNN8O9+96JqT9tp2235NWyDboAmjoBbUnZJJImqrbbbU1Ibadtt+TVsgm6AJoIBbUnbJJImrtez8Qj4n37u+e53wi+PAAW55AW3xbb4A96BoACQA+AJJJd3ZAJJO64d70LTXvezbTtt4mrbBN2gJqAAWpOS2SRNVW222pqSHGnbbxNW2CbtATXwAFqFiTWY7bbbbixZizDOEOJpIy/k+/c77e+85Z7lxYAAABmZmZgMJJJMJC2222gBbbbbQ97x8mwJrvp3vr+E3mLMTzFbdvmNO43bd/YsxPLbuibAE0Z8FtsTVkkkjauZbbbampJJJE1JDjTomwPk0fAAAmjLZJOpoXdcr74bfyUm530mQAAhRJJIBJJJLuABJJdySAdAAAJJJIlySTdpv3LbbfVJySSSJqSSpu21NfgN8aZbT5NdWI0ABU0ItttqTkkkkTUklTdtqatpxpltPk0QDoAmuYZeXibvt30mWuWIpN6OnTg+S4tU0+T7dQJr400+7Bth98e975/K28tt5QAtAOpsDfVDWjVt3cS3PfZz07Peiakkkn65ibzFbaJsAY2AW0qatpxpgHE0IgAAmrJJJEnJIJu21Nctttsqau7u7vyauanfa9Um772FzNAAHgPgAPpd3fLuyS5UTdyk3JJgAAQwAKPePe96gFvJ6231Sck/cadtvE19baJsATVtve2Nq5bbb1NVSSSRJ970404W8TV7bRN21NWSd7Ik5JC2Jqz9wXPt7+hfPsyjOzcDwHwEkkkkJJqSSQAl3d3ZJAAl3d3d2QYSSd1w73oWk5P22nJIfJoAAOKtLFjxLEsxplttAG1b9RtgAmdAAqTsNtOSTiaBrA2AAmup26UkkbXzWSbUG3bRDaOcgWTn76SxTFO/eJS/ve773vc9bbd3Zd2SSQAPXV3d3dySSQAAAJLtvmm0/t+++96JOdr/cadtvE0ICgAmrlnbJ1tbySDbtsTU+kkkSc7UcadtvE0TA3QATXbbJIk+96JuSRNX9z/Pd45VK/Yh1lF1876fch4rtUgQBtZV97rdc5d+OxAGoIA7kvi7RAO4tKfMF+xHzzvy7Q2iHm+95UrKo7W6+Zfei0ZAEkAKIAwgBWG2t3Tr7dVkAUgGfc572/iAdJ8w724nLzPvfd997oa+85xKwF2zHaLFjlKTmQyHXz75/IffO994m761D7tgljxrFnc7rZaXwAAAHA+33Xe96AAd+0B3Z3zTS68TxtcTbSUxtJGJpnNUbIbTLUNKyg5yk4iuMK40qxbRsW1S2kNZNYtja2WYm1lDaGoag4XKhxqGiaRkMZQ1lGyS2kNaYsFZZJbzkjrXT5xA5jYRZUzTIahlQ8+861NhGeVyK/aS/YneJPvOKmQyC8Y/s00lqk01BNJc2mttttIA1JE0lyXa9uyBtSSTinKiknegHACJpIqSSS+AAD3gAC2222geTbQ2krmmsxtJXG2lvelhmkknmL2t8+9UJs8AB2gB73vfejb3F3u/ve9RAAAHLbeW2gAAAwAA+AOAABvve+fsbTfcbSa7d74AEkkkXute5qqa1Sqm2lqtJUlVSVYx40UEYiYALBsoKBSxSi3uGRBHCsIy22WoCVFVlFZK0UsFilua13vve973ve9707IJaxSSTsNgAdABAAgDjTAD4Aqg5d39d99QSSSdFSpJtNAbkkn13d+OgABJJJIbAK1zDmul79I2kom0sabma1C0D4A4BbbbbQAAAttu7u4JNpAAAEu7u7u7kkknJCbaZrjT40/mn809gBJuSSckkkknOd40+3v77n0hQBpsTWNNvAAAzANd0HT4mxNiaSpJpISaWgACypNNOXd3fbtAAraSEmlgAW1NJVNpPE0ljxY2ksy22gAAGgNK29t7aAAAAW22422nbQADKmkvczbT9z3vepbbbfAAAAW2220AAAAttttoAAABbbZctAAwEAE+80k6mkgzWuAHvAAAGNNI6lzfOAQDgaaYGwAttttoAAAB8OdTec+t+1vj3ZRxqhom4a4qbSRqwpNtPVNJJqyzS8akV9vi3Tpp4tPlNYeObDMmeAALu7u7sJUkkkAku7u7JIWU0ykBcqSSSSSJTkppyYsTaapFFVYgrAUFixIgpBVgOWtWs2JtNZayOuUR566jxL2VrIBW0htbU3Xx68gvMKxkggIqD6wnEwQiz32tahPvvrxNCAtAE1ZbZIk52QTdtpmYkshAAqQkrDnGnbbxNCAtoCatknepq5mSQTdtia1XLv3Plz7ejGmGqfvcX0QaKafALDo0rOUyk2ByOed3pt3Ekp3UCB74NpkkALv4o+s4ivoKw6rTYaA+l3d7X20tFcOd8eSfu580/e97aavctttqa70kkiTkkrbttTV+tttqaqkONO23iaEAAAmrbJJEnJIJu21NTFLNpaXMzM7vaxc5+5rT6Hcp0/e9tgAdAQIA+kjqSfdkgACbmpJJJ6SSSYAeA+CS7u+pvO7Pe8Ftq/axXNNO5cW7dpo5gHAATVtkkiTkkG3bamr9bbbUYsx5iSRmrpaxK6007ly37azGjSwDgBwaVtttiTLbbbU1lJpLQmktLFSaS3rZxtgVMzVzgT6SBbb+AD3fL3ve973vAW222FtttAAA97wAWz1snomhX8GvmmYGjE1bbQATQFttqTttttqattttqauXKaaYAfJMAAATQFttqTttttrau+ewTSXPq5rn33Th0M9gAASTTTSUkAPFsLbfB4tts9bLltAAAASAIetttnqmrbt/jTTDTMMbQAAAmgLbbW19ltttiaklttqauW040wDia+zANgALrQAACTttttqa7+2946Uf1DIKzSiZlsmZlaiNrNmrZFXzokuD58+s9mZzMkkkkTcmJZVU8zuZmZy0SScUkm7w1J2SfSWfJKSSVIBJLkGmwk6mzqMSSffSd761NW2/vmmAcTQFAATQFttqTttttqattttqauW040wDiaAoACaAtttSdttttTZjTwqxrLWbWyvWq9eHK9ZRbQTrTbzPlk028rKf2cwzp3mvmV75N6AvYjWm0l6SSQiu7bdxPKpUUB9mLTTrOHm2E+AP2vHsbfugXgAAFty8b8ms937vfeqatt/fNMA4mjoAAJottttSdttttTVttttTVtDPmmAcTR0AAGkW220FmPMaeY0AIABJdNJPKSRSfz5pJaVaTSVJfb1ul8dsNEwkkkkECApNgAekn0kkJIm5FNyQOBTAL4AAp7XgD9O/p3v79E0K2nzTAOJqrttttTVckkkScUkkkTRVbbbU1ZqGmnbbxNC7bbbU0KSSSJPvfe973k1aaS1qjQBBUTOkn0kkJNKSYAeoXYAHvetoBsvgAL4AAAtt77vpJPeqakn7jTtt4mhdAABNFtttqTttttqattttqattPmmAcTR0AAE0W222pO2222mZixLelS7beV9vfMW63nDWX9eWBAkl2NJSSSQtST5KSTcptygJJJckgAWUAAAELbetv3fSSeia9bfxnWmBtNX6222pqySSFSdtttiakkkkTUkh807acTR0AAE0W222pO2222tPmd/UaTThDFYrP8Q1Drtyh2h7933uhztDt+Q7ocyH92VcQ74dy6BXyTH2uO+XHEEBl3OFhjmJQUJ+LntmBhAEIFIAnfw+TiX8snTpoaNTnu6bm/w/OXS/TIw0m59AkPySRHTY2WK6KtmhiraKsSuLAXCmlFirlyZMgaTlC65Q4UMitQ/ZyhoYKxVzzIXIcTlVOGhV+7dWJZQ0itDXVBecdUMR1DHzEp1Q0o6tyh/cUfcgrzRJd0Pp6HR3lLvaxlsUyqtEujgqxGUGzLcobhOOCcK2DgfDdXXFDH7jqoZszWKxZDqh70R5qHZzLlQyhgyp2ckXE5zmKsVczYmzGXNS5WXzzwmvCmxFbUNQOFMc1tJdtcOkOc0s1tsmzMoZRhG65xLIbNlR1Qyj+6FOo1vmS4+8Tyhqv7+68ZNNXNJJueye02kvk2E3ySfTx9rYJpLfdBDhEBh3AAKAAIGmUwAAKYAF+sTSVzdtp73tJXEk0g02u494qVHvu+8dOy7vvPruySSQQANO57fzu7u/r4vugABkkknbTQGgCBpQAAAAAAqbJJ95JpZbqX3ve8AAK2I2hIMGAeagiBDyEJbYvva97vgAADkk3JIAAAHS6ttt8e973ve8AEkkl3ZJJISk0lzy020jYHgLtZlvgAo8A5JNttJSSABWzGswALYk2lcttoFbS6sZgcAsaVeW22h0DYAR3LbbafeTE0ljaSxa9r3ue973qYAAFMAAAPrbu22gW6tACW0t007bswC01oAALbbbfKTSbSR7333ve95AF3bbfrQAK0mmYAFsbSb+WLGseZXlvLQBtpIADAO26stt200gAOgAW285TAO/dOgb35ppAAAEkknZJ8k0pJJOyXd3d3dyQAAAtttu02laAdAxppABbLibS3jTS200rbaWVGNM4AHweTaXzTYBwCe9pNgAAbTTSKlWu971PpIHQAAA2Y07beW2nyAOAB8F55JefHXXXhOvbq3HByXuNeLSUxVgMYWSQgwYEPqYOH5zX53353+D6h92n3IdC6M6EkkkuxpySSQuVJpySSdM94ACsD3ve8ewAAAC364077vpJ31rTtt/h80wDiaOgAAmi2221J22221NW2221NW2221NAAADTuCA3xpgH3yTDYAAk2l3EheW/bze/3uFNMDt8ck1Kack9A+14NgBy0rqRSmnJIF7mlc5805PSdgEkggAImygEA2BtFcoV6973umW6pVVU06qVJJAiMStttCpq7tPmmAcbXyMAABNEkkkbVSy6tttqaiVxW221NRq4rucackm01Lu7u7tNXT2Fa+W74eMyVnNmYBALu6u7u9Wc9v32ve96XATYNsOnte9oAApgEDQe94AyRd8m5Oz3qmrbbbak7bbbamrbbZE1cUtv75phpGJqfSSW1tWSQkTVVttkSfe973vU13ve9sia538m7+XueJ7XtwAOgeYAGk2B4CAcAD7wAHQPe9fe14AAttkk9z7Pt/safe/vcTV/AAAn9mY0AcAOGNPMWY08wwAAhjTzFmNPMAACmNPMWY08xgABTGnmLMaec0AHQpjTzFmJvMAPvmmAc+xp5izGnmGgAAVWNPFizGngB8AHyzGnixZiTz2oTW0KnVLVO/u952tVva3wRowAUknpV3bbaBbbbbS+LbbfF8AAAW2ySWLuu970MiqknSpVSTqSSSS4qpp0qVYk8xAAACzGnixYAAFY2AAFTQAAAmrbT5pgHE0AAANoAttqattttra/ayfLu980HDsLfwAAW2220C2222l9JJJ6+34AOgFtsknl8d73vvVNW2221NXLdK39tpgbSZ8AADaLbbbU1y2221JySW21NW2221p3GlcSuO020wNts+AABNc30VffE3ObTc7Mg+9IUfcpp8Cc5d3d2SK24m7bbRS+tt407fB5t+933jYBcoAkBfvvvvvoeSdttttTVttttTVttttTX4AABNW206mwNtcWNgB0A5jxYk8zMaAACoWNAABU1bbbd22vbVYvp8AWBlHCSbkuTSbk+kklzvvr+u7vPSoCbADtyfSSSSSQAk5JbbE3F0kk96pq2222pq22/utMDaa5iwAABNW2221J22221NW2221NW2060wNprgAACattttramvlrdEfqH+cXKGZQ1V/cUOKqbSXNpsOeKKM1dLANpyT67JOKVpNyfOAa9fbu+khI27vG0lcpSTAzMJJALbZJN6Xcf5tJfsbSWKe7e39+qattttqattp1pgbTXAAAE1bbbbUnbbbbU1bbbbU1bbTrTA2mgAABtABbakjMx/s0mkuaTSR6ETWvsS5999ze7OnpzNySKckkkGAAASSTbTkgfAAAAAAAAABbepu5PKett8VfnjaAACtJgAADdx5badaYG00AAANoALbU1bbbbUnbbbbU1bbbbU1bbTrTA2moKrOYmkhNxAIqqZ32SQK/ogDAJju2gA6but2NAxLahUpat9d4QCzGScSTGQcsgFRJpKwFm9EA/W9BrdZttm221M5uZrIfENC2I7PNT2pXXcxa01ryhznPGpwSaWG1tb6t506QxOxTrpF936WqpXeoe5Va1Ko7eckozlwo/dc3vVx1fuvkS8+1Te+eebYrr58lTqWijrz3vzvu8ff7kUH2xbJH9kOYwwXxkqukrRXW6Wid9e/zKfHyaaT7iTS908cwu2n2c3uTi8fE8mkue+aYvWc57Od+9y57vdtMhsIbKmkunGnuTm70rkmmnuSfT7klQPmmeAoETTTu79dz0XRNXUUrVU2qR1p653ofBJJa009a4m97h8BD4l+afdrezy3yc9iKtJv7uduvvvt/ZPd+vtNMNU2B8Gmn3A0AbMJpp3PpuSak005d3u7qyL5pwA0dETTT9z0Eb6930/CAZspAOSAMgH24TO/d948Faek2aA3b242mt42k+5iaSxpq4m+3lIdMMaZgATvd3Gnoxp4fbAkoAoHNgQzuW229ojYcAwPttPNju93214ndtOoBsPCGklZp617bTo3PoFsaeu408u/AEMRzTTmBs+v1umnl1bQPitG2n3ZsPruxtJtbWJY8d409W7tLs+Srxs409h9wOLVjXcvGnq9+v1MDTTAA6K407bbbBfeT+XuNP3vT09teV007at3dtoEwNB8AM+DegA7hpph3YHAAO627eKgSnwB8AcAAt3d3djSaSEkkmUAAHONOSTckl3q0AJU2kjAA1bE00lct7aBpppBA0Y0yHDemnbaufSAAHwAF28tt3800u3ckXZJ4SaSD5Aak9Bp6Tcng6FprSbDYATfdNO5be23prTTDR8AcDVttvdWgBDptppcD5Bmvu229ioAHwCOBq+TfQNkD3tNMAAmBTekkudS7zvO9AOoAAAAAQYAfBsDoE0GmmT4i+aaWT3MbSXffZN6zbzFubwnO+c67onhaQ9mJeMK9kYiIIojvdp9030W4GsgICLQQF1xc87589/eFwAPrX4AA971ttttO222+MPAAWAADbCSSSe8NtJX+NKTSaTknyaSf7G0mv2NurGmgAAqTttttqattskTVttpGmGk1eW221tWSQtqaAAtqakkkkSckkLamuZ+1QJ9xNzs5ed4pJ8m5PTerYl9JJIWAvigpNgB8Hr373pdknGmNsBAASSSSSQ73r73vvVNW1222pr8AwAE1bXadTYG20HRAAJRQA6BtNVZbbbYmpJJJEnJJJImrbbbamu3M8b3709r3uYHAubku3kk3JIHbJJJJATckk02p6B8BYBJJLlSScu7+OHOZxp9zPk1EEAATVpb9bdtq2222pq2222pO2222pq2222pq22nWmBtNHwAAJqXd3d3ba+r1NppLFSaSbWq0g34Cb8XlVt5b+rtttoFttttLZJJPzaS8Hve8Fttvb4AN/eXbySe9U1bbbbU1bbbbU1+AAATVttttTQAAAmrbbbamgAABoAAATQAAAkyX7UQ+6FcDSi/e+fe6h4yaSqm0lVJMVNNSvqbSafr7d3wOnvvYXLbbSq2+DibD3p7ugAA9bbfrbvwAFttttC2093Xe9/dTc/ftpoAAAbQAW2pq2222pO2222pq2222pq22nU2BtNAAADaAC21NAAACTalu1t4mksS0PaxLMfO8Avx+vKrbb+qtttp+94AAt921JK220tPNNICbqkmlJJtNpSagUbSSakk75N55X8Afv1TVttttSdttttTVttttTmJXVskiaoAACamSS8adocSZ0CACaLbJI2q1ltv1trah7JObT+17Sv3vXqb+979z1tOJsLuRSSFL4DSbA6iHoru/e8Xe7uNNKU093JIeAsEgC0379mJpL2a+SAOH71aADl607dJq/W0SYaBNaMtttqTskttqattttqa3ySSRNUttAE13vZL1p0NtrR8FAE1nhelVveuU3VJJVzgm+SF/a+Mwk9ZIFtoAfvdPgDhb4TYW2y5b5NpHveJ3KpNJGkwAOtNIzA400gL33veB1NXBPWtW22xNROSSSJr9JJz5pyaTRnBJIwwAqa+khbak7bbbamrbbba2pO9PmnJoxNGfAAFTUtxJLmLfue8oHf3gD8AeAACngAC31ltttksG2HxSTSknykkmoASe+xZ72++9mW2uNZJuSSJqq2SSJrvam5DqSVumt5buSS1NZbJJEmSSSRNVW222pqZJqQ2m7dNO2222prebzZTnZtc+kiizutZixo10Lfx4tqtv7yAACngQAWy797xd2SC800gAAAaaRYaOMpJtP3ve++a7rv33vRNSS221J22221NW2221NW22/o0w0kwAABNGABbE1bbbbUnbbbbU1bbbbU1+ndz2v2k3SAb3+p57r9GEAy6tBlcmMgFFSEJJHO2URFiIARlbnm/OPSAhTyiAJOa3lEa73CAawKQBayAVE57C5ysRszedseQRBiy2lNRVwXU1tSyZyQk3F9lIAg77sPbOW6dNIA3vx9ogDakgDEc8dTW9pjJgSlT58dp5fmzxnHXmc3Pv+dZDe879dBralPje9EnVitaoZNtmi1nzFxSaRkNSNk7oZkr4rH5zqh0Qvfzhx0vOlU9uOCp1CYqtm1EyfORyIxtA2SMozBN+Q+cUdMq2hYjIa0oxHtDCcmahmraRsTY2SbVDVUucuWIeo5UPmUdYRjYlm0S1D7kOUMR/mjmNQ8OB+1F1ZVhRpNqhzEnC0/tQ5NIWtbCVpVoaYq2bLZttYqy653vELLZq21oLaNmtTak7aczZZkV7xQ/deiLNYmltTXMbTf3NcxsKRN/e2Ft+vveAADN5A8mkuc971933vb3vYAEngAD094DAC3LLbaU8XSSazGnpps77e/vePBupJJ2SQOgGzvOc5wC5JJJJcpXdttoYBwAp0AAtAADoau7bb5XUi0mkp8c4AEkkjbu7V0kklVJNJ5jb3j1iS+1beUoAABTltvLZToaaZgAbLbfrbQA2AB20ALs0QOEDyaS+ndppI77u/et9fYdAOBQANFtVvbaAYCABS1pq220AYABZdXd3dySSSST7t3q75d3BNpAAAHeXd3ltoAAACE2JsTYmxNja4uc00+c4AF6AAAFt5bbygGg00wA+Dhvjumnb29+s8mkprSvD33O+97xsAv1tttAA1A0ABW0lGnl1babDibS400tgFLaaaaVttvbUAAAAW221WhgAebSXcaTT973PeAly23wG2mkAB0NJ9t1be2h8AcAOhq2220AAAAsmSSQpTEmltppHQNnQ55NJSTabbEffd6HvAAABznOcAAA200gAOgAAAAAAAF2b974zyv71Z9VxqhqGzUNkWQYEWQIJAEikCCjEn3d9+93mZPdvEkt80lXuzxjk8O7vJIA2wAAACSSXdl+973vS7kkkmIDN1SaSzMzMzM/D8UgH6/WYBFDr3usigRZDvbCSHXUJ+qAVAA/VkKQVBVFVRizEsxt5jbazE02lgGwAG0Bbbamrbbbak7bbbamrbbbamrbbeoxthpraAAATVttttSdttttTU4r6reqSqt0uCbFv2vHtpssWYuDoA4myQDS6AfJsAJ0kE2AB2/e9PXSskAJJJBpg2wAAlps973veLtNXd3d55pmGJoDoACaAtttSdttttTVttttTVttpGmGk0B0ABNAW22v+JjSAAImhY0mlf3yxY8X1+/d2Izne/wBH5+PSH7ZbbaAbD627ttqbBt222q7GmlAAAJJIAAHMTSVxN19d3d/ompJJCNO4mru222pr8V222pOWu229dTVq3bbampZJCNO4mqZh8Ad6Qa222ENtt8Ng46HHmBWYkCiIUd8274Refq/AtB+MPenkwAAPBb4AkJ73ve970V007ikk2mBDiaaRTAA97cvZySe9U1kqtt/VpmJrVkkkTQLLbbak+2SSRNSSSSqpq6ttpWmYmtFttoJrLbbbUnLbbbU1rG3V9FyfZn7ffs+7re9q/X9pNzvd9zvoF7bq5bQLLbbSySSSeQBwD3ve97wABPSSSeia8rbbf1aZiTttttrattthU1bbQATQAXtxtSSSSNqSSSRNSSSSJOSSSRNXnezub5v78fugr479bjTttoQ8AAHgttttLbbbbbbbaAHmmkAABud13venk173ve9nmndJO7u7u7trS5znOcZBxbu7usgbbbYQ223ukG7u7rIG222Qc3d3d5yIJUQAtCeHnfB20nNe9A4m8mrPT1pvIBrgbadAcTYFqcu7ibkknLu7u7uxppQAAPECmmkAbaYAHE1znOczzTyk1d3fbu7TV3d+92Ymrbbbamrbbba2pJJJE1bbbbU1bbbbU1JJJIk5JJJE1cnshxa19tNJd53aFS6QOS+3eu+v2Xd5gAFhqS7u7u7ttSSaTc45JFBppXTTSAkkAltttt/Pve97335NSSSW1trVtttrakkkkTUkkkiTkkkkattttqaySSSJqySSWpqSSSWtJ/flmc75dXfGffd/c+PTO+lPwAAeCySSELbbbb5NpGaTck3KSaUD5ppEDbTSADjTSKyqTSX799ik3O97+rattkkTUkkkiTkkkkTUkkkiakkklrbV1bbbU1ZJJIk5JJJE1JJJImpO7UxtJdXPtZrn3mmJeWVKY42+T9+/aMV+939IplLy23loAS5bu/el3d3ckkGmkGgPmmkADbAIz3ve+aaQ29fvABP180krbfrbW1bbJImpJJJEnJJJImpJJJE1JJJImrbbbampJJJGqrbbbU1m56Xudn7MbS8zMQBzUQBPDfBAFEriHzKrZzFW3aq6mq8SzbvH2QB9vwPU48QhE+OVvHNZeHhfqvuic86laJ80jf2cKPyLpiOrQxda2JcQ20cJzNoJLCAgsoMElaRtCsVGNskHKthGhTIaI2B3XKtQ0cPnK4LNtqrSbs08OmunCuM5SNVK1Dz+dc10WoYwp/a69Auwf33s81Dzyh967kO6ldyO3US4IyPvLsjoVaJpG8yfOUP3j70g9ojojZnrojqh0FbKOtQ594UOJPrp0jrdeUPC/Y8/kO1XuodIuTNM2Y/ef3P73tpf2+fUL4ru/atAWmkg0WFagHZ6dk33ck+kkAwKrbZ8gDnwBwttttoHjEjEjWm/qSvUNc7vhzUmr3d3yySXc1oSQFpvvfvvvenvAAAfJcPrfr368tA+AIAABaAAALve978vU977W+e973gAJInzFwOcSTA5JAAAAW1JJyScAD4AD63TTuW20AAAOuZJJIAAHedph8dAttAA6Bs10urb22gAu4BwLY2lU2ksTazLbaBWYAEikkkAJJJJPJXV3d3dwbSXNRFAdAibdqKjTTAABXEGmmAAJuySSS/AHAD4A407by23lAIGgAEPiTSLby3d9F67XyTSUN970AACSSXd2SSSSAFtTTTtttAAAAN223626TaRwNNMDcIbM2aadt3bu3lNNMIcNpNITSV0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9Im0gAAAAAAAIGk2GjTTSCrbb5/IfvfPfj2Xvavv38r5fWso2s1RqH9Q1DhpHFXJFcKNSeXEq883d/R81H7zlf2vuj+1+0OYkvYk3Ma5v7cm/T3bebtt+tvrbbbaBbbapC220AAAAAwxpgFvOcOTycWNr8saVttvblzMSttt61GszE5JJOtRrJJLbHcdtttm8TUkn0mu973ney23bfDhF85zl85ypSAtby+8LTvm+WRHnmhAAfk373tjAD5NgU+0ALibA+Prvd3ZIAAEgB8EKAJc3Sb5rh3pr0kn0mpJJ9JqSSfSakkkkckkk73ve97CIbbbzW3TfmogN3b3nOLPJyarxfW+cXL5+97xQAt8AAAgAL9bbbQtoGwAOgAABb377470/KSSSd73ve9imL9bbbJjTtvLbbbZJO/ffffakySfSfffffTs9X1epe9727pp+xVrDXwBwmeDUku7uy7u220ALbZJDabttDocAOW22+D3u98c87u5u+fGttvYGm23rIWzu7u4Q0233s73ve3rTldttskkkq7JJJ3ve972KanZzeaW+e++++tn78FttttLbfAB73vettrTt1ab4AfHQNGNMLb9araFvfd+93vvqu97vvYlMfJJJ+jblttt73ve9q7W3Nnd2mm23pu7u7rzMzHot3dzd5REIgDansAF0/fugbNAAEttttoAW2yT0u8kAA0Eu77d3dyXfvc72eyzPXd373OttvTd3d3czMzN0W7u7uZmZjHoBtat2XjTstttnZJJezNNP34X3u7973i/safs+tu7QxphoAOGGNMDYBu407buSS7vIAABZAAA8SS7L973iLve9973W3mPRbu7u5mZmZmZmedIjd3d3Xzd3d4bu7u62229y1WzVkciAFEQQlEQAQogGAH+aSuIZJDWlRNSSptNt0m0lSbb5TaSU7PVJmZmS5JAv5tttfve973ve8YAFsskhQDYHAAALbaAF82/ybSWY2ksbxYk20sbSWNNP2AAfu973ve9kkkhGnbbbbJJJKpJJJ3ve972KSSSd73ve9jTmKSSS8/vrb9976knlDFqGMoZH+ajhVkFirVe3JTk+ff5+evn59evXcYAABbbbbQAsvmm9FtvmFvgAAttttoAXzaa/W22/pJJJLJJJIbu7u6223rbbxpttvd3d3dzMzMY223uvJggHsxAHlzQ0sdx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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    print('allegory, (c)2013-2016 Charles Childers')
    print('------------------------------------------------')
    print('.s       Display Stack')
    print('bye      Exit Listener')
    print('words    Display a list of all named items')
    print('------------------------------------------------')
    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
