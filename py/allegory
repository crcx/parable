#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
	# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 3:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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TNAO973vepWKZoB3ve971KxTNAO973vepjDIDve973qYxTIDve973qVimcYxRqgXfbu73bVYo+7u7uz3ve973eQkg0YCApoQkCtiFRff2ZKH0ihShQ5D7CAH7vXjpSjrCjzmpJT333aE5zmxYqjWKxTNVVVimcM4xVVjAOZAIAOw2BwPgfA4GwOjQPrvWu970XKrGMYlVJJJ1NSbxiqxVSSOSSQd3Ju7673q7X8kn0kGQycrGKqqohnmoDve973qVWGQHe973vUrFMgO973vepWKZrGKZAu6vN5u7tysUyA7d3d3a6xTIDve973qVWGQHe973vUrFMgO973vepWKZrGKAd73ve9SsUyA73t3d25VYznFYxisazVGYh9vjcom+aqjmEnHMc3ijTNYqsYNYwzUziqqqxhmgcyAJJJJOw2fYwHXT4HwK4G+UHzo0C77nve9BjFVipVSfSSGKNI5oElrWs3YSBdaERu7W7gtYCDnrAANYgQe9nVHvS4BHu3e7Pe9497t3PKD7TmKqqxRDPK1YO973vepWKZoB3ve971KxTIDve973qYxTIDsu7u7KrEyA73ve96lYpkB3ve971KxTNYxQDve973qVimQHbu7u7XWKZoB3ve971KxTNAO973vepVVVVJrAr7DdrRRrM3vnUSXXXW6CcznG8UaqsViqNVRrjWKrFUOOZAL01JJLnYbA4HwPgcDYHRoF33ve9ArFYwpGRJJN1jGMYqSb17u7u4hALWgQdSERrQINYgQer3uhCL97t3N3oEjWa9e7s7vd3d1pISxgGeaA73ve96lYpkB3ve971KxTIDve973qVimQHe973vUximQHe973vUrFM4xigHbu7u7XWKZAd727u7crFMsgX3ve96lYpkbC7vve9aI593T3d3vezMztASBQwEBLDSIV53ko6ZvctSJzEqOsIrn2nmSXvmpUj7Eon2UiDeKUvsVQ+ypcyVFzBUOeaqrvOZqqxWKNcarGMVjPQCSSSTsNgcD4HwOBsHJJqSSXfe3d2cGJJJJJVM1iqxVMjdDckkkmKrAapVYzWKrFUbGuydk7I7JqSSTIHMUHMQLmIBAtZvRHd3d2ZmZmdoLn3cHe973vUxVTLOgO973vepWKZxjFAO973vepWKZAdu7u7tdYpkB3ve971KrDIDve973qVimQHe973vUrFM1jFAO973vepWKZoB3ve971KxVYrjN96JAQOrQdRXRfvSu6OvpSQjurutYrFUDmQBJJJJ2GwOB8D4HA2Dkk1JJLvfO5rGKl/W+FsiRsVu7t76GCO6NrWazWc1uxu7u9m767teLtJLXdyZkGeUB3FVVUhn7QHe973vUqsMgO973vepWKZAd73ve9SsUyAXd3d3cximQHe973vUrFMgO973vbtqqpmgHe973vUxVMgO973vepjGGaAd73ve9SqwyyBfczMztEdrx3Q4jjszM8gH5CAF7O91qTVYrFVM1I2zjFVhmqxWKoHMgAAdGwOUHwPgcDYOSTUkkvl573vQMVJJIk1JuqqqqpmpI+kkkjsmtYqsVV3duXaSSGKxQAyASzQHe973vUrFM1jFAO973vepiqwyA7d3d3a6xTIDve973qVWGQHe973vUrFMgO973vepWKZpnFYoC+973vUxVYZoB3ve971KxTIHZmZmZ2pHPu7u7s973ve93kJEtIQQ215h4y+dOu9J1CcwqUd4c80qUe8+96Kk5k5vVRU5zmxBzKmMYpnFVWKxQOYqqyAAB0bA5QfA+BwASSaAk73ve2DFVVSSSXaaqZrFViqk1I3zFYqSbkiSaxisYrF3dp2QFgCTPA+crFVisUSOVoDve973qVimQHe973vUximaAd73ve9SsUyA73ve96mMUyA73ve96lVhkB3ve971KxTIDve973qVimQHe973t21WKZoB3ve971BHPu7u7szMzM7QXmAkLWa80hN1d4XO0Inffe5R5z7nS5lzKCcznNFUyzjAOZAExWKZAdGwOUHwm5JJyQBJJqSSXfd973YAkjd3d33u2NYgQa0gELd3uL7u7u71TP2KxUl7u0kgXMsVipJJOyZA5iqrGKwzjGKqsJH2gc5znOErFaaA5znOclUmKpkDnOc5xVJWKZoB3ve972qSsUzgDnOc5xVJWKZwBznOc4pKxWqawBO973vUrFSmsATve971KxUQu7u7tzMzM7RHPd3d3szMzO0SBGxAiH7xpf5m/2iv4RtmZnYG973rYhIRBEAIKAQTciEH1/ft70aCS8bDEc/vffedOufz6I4/vojZDetjmzH9BdYpR1GT1Ua6xOZhqDUUdWVFXVgXRiYTS5Ly6qqjonq+jo7z++sUMIWxg02Q1LCWdAqaFPAIJAQQNm3xfS4qwPNSzzDWuaJYOcMbu/dYT1hlRQn4ROs6ik/hBqru/N3J11hQZYiRZYQk4QUdL1aGxG6pmQRpxsRrZBjEhov+UykNoLuSQO/QHsdR6CC8r4/V0Z0fw96zfpAoIUiDuXIUHXX47K7ST5iRlIxEyomRGFNpCE+u9+rfu4SQLioCDu7c3cQhbqorJRmSjFDGa++59zOc+iOAJMbSSSYhA+O7u7u0ELh93d3d3CEGnCSQQWCcy+7p73dyETMzT7O7u5z1JL7Pn3n32icznOVXGIZFlEIRCGqgEIBCoBWvvvvvvvvuJI4ZSVjKFjGSwyZIMOUjWtc5znOc44Iwo/aIXzXWtaNUUpIpAyohCDIIQCjKqMCIQghKwCzQ0xLZZMLJLILKpiIzIjASkq3v3e/ffvg+hQYQCCgAW++5znOc4o+VGYormawRmaiGkiISqLWH33333333wijAqje/X3Oc5z6IjmEjLEwkYwIYMoC1MTUlUjKKMgqQhQioUkwIUSMSNSSMUYwsGJViZEYVEz37Pvvvvvj6BiRgjEjERmYzEwRmZYgwUsqhkOYKlmShgLBQ17vnN85znCDgjLGTIjMVmMqsnIjIjmSm4lYBqaKEoVBYAgRC8/fvvv333oj7MlGZMpDbATWc5znOd/c+ckjJUxm+c5znPOfVUuMSMjEUkKlZ999999957tRHaiAZb3ve/e9KpQElVVYvM1UkkLobyBZNtAOjYXisUd2PjC8VVHNhxtv5tt8dP8wAG3qyISUSkkofG9Cg1VYr3N7pkdISSSSEZA6R9oB0bDuKxXaLc4+MyakknINgdNvjbbbvoEgUAX9WNdfW7zuZizuZgRkDho0A6NhzFYo6cfSpUgHA2B0aJJO+rFVWDJ73ve9DNAkuVJJAjIHxZrgHRsPsVijo78D4HA2B0zMzMzLIUJIhQrOSHQA5jTbyszMxZjYIyBss06Do2G8ViuGzj4HwOBsAakkkX73s+973ve9EkkkkyARGQNFmiw6NhrFYo4H1h8DgbEnJJqSBfAJADDt4szuZmAAgABvHLbbct2aEHRsYrFa1oTcmsVipJv1TNZxQJXuWYoqRCA0wR1fdG++s3vpFdDwD9zinC13nCeQoQYGCOZOSzmKYUL5+++9PiuGlDPjkKEM1Ypn7fg9OC8cUQgMgs+ByuJQiZUQgAqFCrh8S2XxRCAbadJRCdCv13zLOQoQcAA8HIUID6yp9nJlqElExXK6GchQhjHKo+OG8RN73v4Q+JAvcDIoaASmqXIBvHKCqKWIOjCwsysg8DDA6kxKGgiloKE8ujMFDIOoUKEyBpBKaTIEswwgx7nrowzDCoKIrMKMTDMSprCMjITJyACh6OseoMimIBwjMwSJyE96wKSkOqJ/MuQVR1kS5JUkZJhGY4JERVYQBRkJErjnvuQoV22BYg++UQp+wODd33ij7IULv2ZnvrHbmnJnADsKEB8HyzMzPY2+QoRIEAFByFCAtX9wO/KfN8ShZOPguiUJRxQkok4HwcShWB1PJWZfyUL7Ps7mQ0czy6c58cShAUdf1KXxPiULKU5WZzRzSbRlzscYwR2dfcCSShAg4aEaFRkRlKX37Ul0zrX7Xf7JNn33iivtGpaswMRMUD+3XvX3uvsRNBqFlzzZPjKOJQiefJQvLMz7Cr4lCb4AgPBxKEB9eYQl+N2pWO/t3vfaN7NB7fve44zM5cAsACSSVJOQc45isUjPXLq7u7tMjqjYJj6pIcOd/fsJOtaxC9/RH6IyQyImEoiOchKEuJREd4dDA+823Lpt5l4m3znPRHAjBGLGIXN75znPQIPAIGgEDYkII7uq87unu7vqQj74AoF6oY/u02/oUJ4zwAeAEAylCyc6Jtt1dh8NtNuU22AEuYUJ5lwlF+tWcShYNtu2nKUJt4zhSULMrn2Z93eKxV7qsVfvPlWbqsUB1ySblXerSSU231vnpMiIhBzpR0BLrUQqpdzO1mVj4HzIHTQ2B0ADjWKxQV8NySBGQ4NsgEZJ7ufs7hKCZAV8c/ZJ9zqU94uHeY31vG8zG5bb89kQeAkMzPsxXnEoWebbd+fG35RC6H0ZCsKzjGKxWK3nXwOQoAMU44oNATQTGSkZmuc5znOcVefYn0v8JR3ZPfmG4d/sEFO4swf4/zGt5L91q/owSNSod4qlUqh+gQFOQqByVVN796RQ/nmfyQH9sVwU3KKB3IIb3iiIbgBEdyIi7gFE3v7p+r77777777777774OjYHKD4efA4eAkkbNtihKE5iFChzd39cxbA8oUQgShKIZ3d3akgN36ukXMBCRzS5nZAj5/MUnOc5znOfuaJzVEcwiOFzmuc+/DPQoQYHg4RCSgtvjdt4Ntv0JQohLnNUI5+hV/lVlIyIyExkSmIj+1StRGJkRmVGUoj+xRRxQFlFGEQ5IIc5znOea8QUPJVV88wQQ85iCG4SgaEvcUyUpSgaEoS3ggihzFJNYpJMiMiqm8IZkImswRiIqsiMkVjBDrAv379+/f3vnskj3CVL3JCewqoPkg+CnMVFE+3ilKUpSlKU5OSlCZImQtmKoCBZUGIj+0kGqrKyVMQWIjEKyIwsiMN5JqIxEcxwQRJBDnOc5znnnnqivsgh+yI++++/u1HkRjBGJGY/YWQlCZAmZjQmZgmQNCUJkC1iZrUFMiTI/sKo3gVmSAnSCEKIQCEc5znOc1rwUTyFFPIVDyEEDXnOhATcJSlKUDQlCbgTISzFMhKEBQxBDmYIIQop1CCFCoc5znN81rxK9xVT3FQe5Sl7/aEn6QoACFWmA3Dk5CUJQmZgmSJkpZgmSlKUiCBuAEoAL+wodUpZSgsiMJYxSlYKsCsqBhQZJYxBD9gCqUqgg8kUec5zm/NePkqIeeYCIecxUFH6BoSlNwJkJZgmQNCUJkCZCZmAqGcwM6zFVkTJRDe973vmteHkh5eeYH3MQA3A0JQlCdZglmAWYZDkAUJlkjkoqHIUQ6IBB3ve975vzz0+xA++1EffSf37pP2E1kWa0mQNCUJmYq4AZglKUp+lAFuIyomRGIi/sqQayCA/rFFZhBqIQQlEZBCBMZVGshJoRlRWCMAKcuc5zm/NeAB5IiHnmKKPnnOlBE3CUDQlKUDQlCW8EswSkBETkiqdIISqr0QoPOc5zn9557Ke4pQ9x77/bRP0RkBiEQkEJUB3CU5BZgmZgmGYDQNA0DQlIgm4RAxRE5j7KNZCd46xIGHWKk0or9NCohyEQeQI8hVDXMERHmCR+xV/YI/ELIJP2CUfsSl+xRC/ZUofsSJ+ySIhExERCJUKIUIly0222yISUAAB7xZoB2hsexWKOB8eABv5tuyIUQs7lxEK/R2YsA8oSUA1EKUoOzN9b3vfwIP2s8RLv7D6P0dqKP2Le+6AKxisV73vaxVYqgTsngJMzMzBQoYAHkHIiIiIQfSoUKElqiEpgsZD+xEDURhBmZDMywRlZEYKu8amQimJEgpRBBUghCIpznOc5vWvFAXyEE9CFAiEplJUUqhQfvtVKX39pEHaRgUfsTWtUpSlKUpSlKUpSgVAZTNRGKo/sVRqIxVKrIjKisqshKzFKpYIyqlMghKopve973zWvFQfJRR88xBHv9oormImZZhQP2IS0YrIjKgyIwKyIz+wE1kzBESiEIJJIipAoSm4RDe973z33z0X2AR/MoITVMoMxQiFIVMlRRRTIeyCHsgh77zoVQ3KUpSlKUpSlKUpSlCAI8z06UQpEAOc5znOd9+etRR55igIeeHN/lKUpSlKUpSlKUpSgd36BAQ9QQjIjKsiMQpkIyZEZkqxkRmIjERkRlMksCmRGKlZVYr+yIQ1EZBQ7gQVxUZAUE7gROc5zm+9BC8wB5ieYpS88f21wRjBBUAKBuUpSslyUpSlKUpSlKUFT9KCD1IgjAIRRGFQf2UKtCMqVWZEYIzIjEqGVWBXWFGqphRiCAQkpYqVhBCUKDIjJhmRGUhlFkSrKhhRWQQiQQpBE5gKc5znN96FRNBI+sqrBE0RFJMRDUIL5KInkiIvnvpz8eIjCG5SlKUpSlKUpSlKUoAFOskBf2IEdUqzMRYFkQMRHWaspSwqpkRmIjJGQjEjMRUxQyVVkRmZSmRGJRgjJE8yIOXOc5vzXkir4EqgB5IigeQKo+Xhc+QQwQVqAQhVENylKUpQpQpEmQIP6FQAeSsi3EZmGRGSI6wo1EYiKAc5znOb91oNa1o58oi7lKUpSlKUpSlKUpSlOpBDdJJSv7JJfyEsihkRgwCEoBUAhB3hhBEERSwfo5znOb8888D3qAiSqKEoCoD2PffW3cx/YkNBZUMRGP2UzKUpSlKUpSlKUpQP6V2kyR/Z2kMlWRGKDIjKoIQYRCYKkEIAUO8Vcf3Oc5zeteAPh550innhzpQU3KUpQG8xSlKUpSlKUpT96Z1r73pQdSXVVJ7CP3aCQAQ0hB+6ECD5r9v5ykg/sX2FCfZPsVR9i+yip9kQoSyYxh1KCVChKQABsAAALb422wAAAFChIKAOgNttttt/Nt2RCULMTzPRkxhQeQREPMzG8HL99CShKHMQobf0JkKEo4iYAAHGQlCTnHyEoS5mZg3jYA3CSUQ2222AoSUHC3ve/xvQqhm7c7UNwIpwBC1JSnOc5zf7SqH79ig87OfflKUpSlKUpSlKUpSlOoBD2QQ7zDkIAdwqqUoibnkKHNc5vxU70KBk0gidyij31gghuVTRzBQDcpSlKUpSlKUpQlO5aypDrAG0RhR/ZBqg6PN85z7vzXutc5vtSlKUpSlKUpSlKUpT4i50fG++99c5zmtfv37m/lKUpSlKUpSlKUpSlNyoEAhHOjn2xM5zn73Ufv37nPtKUpSlJyclKUpSlKUpTsTm/x2AhzWIIc75z7911zn29qUpSlKUpSlKUpSlKbgEJUCbnR+6/In3N73zvR333z7elKUpSlKUpSlKUpCtwJuUaQHn473d73vm/O+++fcUpSlKUpSlKUpSlKU5hz3n333O+++++97+lKUpSlKEuYJkJkGSlCWYAG6ufjrnOc5zvvvvvvnvOCZKUDQlZDmYq5mCZKUDQkiJ9gpfsSOYmse4ke997SR347K3s931bo8blOYhQk5b5ChJJNj6022222222xQkoDA4AAoSUAAADcD4AAb973vTmKndd7zvvPnpd3duISUZgz5ImEB8EREQuE3ChAfAZmTWMVVYqru79OyAFADIBPe8b3ve9777777737sS5igZmCZKUpSlA0JQlmCvOjnO+0TnOc535OrUatTqTm/uhMgaEoSzBXMwTJSzBMlKTGDnRznOc5zeta3rXOtwh7GQlCUJZgmSlKUpSlKfc6Oc5zXOa1rXffPdqUpSlKUpSlKUpSlI7w++++3veta1rWt+7UpSlKUpCuSGSlKUpSmjnRznOa5zWta1rXPdqUpSlKUpSlKUpSlKd76N75pE5z3nO/Y9886NXvmP0pSlKUpSlKUpSlKUdMxycOfje975zn3m/fffUT3375SlKUpSlKUpSlKUpTeG/vvvvvta1rWtefKUpSlKUpSlKUpSlI/Yfffffffa1rWta4e7UpSlKA5mKUpSlKUpSn27mvfQpHeVmZiSSA/NCSBANiEHmCXuBe5CQ/siP7FVfZ/YSX2EovvtAH2Ej7JKfYih9lUPsSfuaQLmEmc5znOc5z7mcAys0EAD1Yqqx73fe9773vEqoXoUJ8bfm2/m27QoUKMqvoqgbZEKIgOQlCWZmdzOZnFDlQoiG22JQki7Oh39+9T96hc33zCaRHMIj7f337iJQ7bAA8AvQoQUBQAAHoiElCJUKEiYSiISA+QHgDl3dXd59EKZiFMwlKUpSlKUpSlA/Ye+/j77OSJu/W94eyex7Pk61iH0pSlKUpSlKf2zFKUp3K5Bhzo3ve+c5r7zzzWv57wU3KUpSlKUpSlKUpzDm9783vWta7737tSlKUpSlKUpSlKUpT6LfRve963vWta7737tSlKXlkpSlKUpSlKUpzDe975zmta133z3alKUpSlKUpSlKUpSm8PvvuaRN85z97ex75hrWPI3KUpSlKUpSlCU7ZHJUpU5hve985zW/PPNa59z2AyUpSlKUpSlKUpSlOYb3vfOc1rWta1z3alKUpSlKUpSlKV9CZI7w63ve971rWta1v3alKUpSlclyUpSlKUqmFJNsEn7eiH9iVKzIFerkgCnIBQTnOdIqpyd30oMcyI5zQcyoQ5kKOc1EcD6IUKEIA8lEIALoDoA5dt8bbxgA4Hw973ve973vGw9WKqsSs1WUXd/CbwhRChNpttsCIDiUEpKISIQXchveO9iA4bne973vW5BE9vZxWMViZrFYxjEqsSak8ssS53VD4dHd3daSF3Qkua+Z3d27d3fZnbyQ2kNpKUpSlKUuYpGYDQPPOjnOc99ROc8688zz7zrzmbgaBoGhKEoSlCOcUKeLkqY5KUSgBv2VVDzA6oUvigyUpSlKUpSlKUpThhznOc5zWta1rXPdqUpSlKUpSlKUpSlIx99997733339rX3vylKUPIyUpSlKUpSlKUje97++77773rW/flKUpSlKUpSlKUpSlOYb3vfPETnOe+++61rm/lKUpSlKUpSgK3AZKUpzDnOc5zmt+eeeeec+4pSlKUpSlKUpSlKUpzDm973veta1rWt+7UpSlKUpSlKUpSmFMwoOIAAqqqqowiFM7MRyUlkxyYhTKUpSlKUpSkICJ3KqDt11b20hf20oGzEhh/alRO8gS/v7+/ur9rm6Iuc0oQ5iRcyCuYQnM5hU5+/bhK/ZEUgADeS+NttiiEke+MDhQYAAAAoSUBQB0Btttttv5tv5ERfeQoV35UyzWY/tdbt/b8UB3vcCrsxE9set78NxuNxu8D2IE3uOg6lVV3O4fn9996tXRPUju7AQkBrtpAg1oQIIXn6fe6Ce6FBLYI9Mc67pO74Qg+nj74AsbTbb9CSSShynKSSiH+jd6t3d3drWta1rnu1KUpSlKUpSlKUpSlN4b3ve/56ic577777555zf5SlKUpSlKdzkpSlKUpzDnOc5zmt+eeeeec+4pSlKUpSlKUpSlKUpzDm973veta1rWt+7UpSlKUpSlKUpSlKHkHOuc5znOa1rWta57tSlKUpSlKUpSlKUpS3b3ve971rWtfeeb+/KUpSlKUpSlKUpSlKbze973z1E5z3r333r2885v8pSlKUBW4DJSlKUpSlM5085znOc1r7zzzzzn3BShSJAKUpSlOZzm973vWta1rW/dqUpSlKUpSlKUpXJcheZznOc5zWta1rXPdqUpSlKUpSlKUpSlKQoAcgRQOr2DUih1PsvJeQgD6aO86VHuFEneP77UR5/fa2Sn9lUH7AqcwqRzIjmEqcyRPcqcxEpmhtQAAGbS323xAAOB8AANh6qxjFfpLu7/fvfv3vA2AyQSEYADeZmZl28V3dvMzG22202222AAHlBKiISJiIUJAfIAN71rWta1v3alKUpSlKUpSlKTMQpmIRPEHwBvoULZycnMz7L5CWh8oWQmRk5OQlmCuZgmQNCUJZgAc6Oc5znOa1vzzzzzn3nBMgaEoShKEswTJSlKU5hznOc5zWta1rXPdqUpSlKUpSlDyMlKUpHmHOc5znNa1rWtc92pSlKUpSlKUpSlKUpvDe973veta1rWt+7UpSlKUpSlKUpSlKU3hve973z5E577772HvvnXLcBW4DJSlKUpSlKUpSkDmHOc5znNa355555z7ilKUpSlKUpSlKUpSnMN/ffffc1rWta37tSlKUpSlK5LkpSlKUDu50c3ve/e+a1rXPdqUpSlKUpSlKUpSlKeZQCHX7PusP3YqF30YVVuBBAtQJgm8/dCAG979/CAmPXrGMViqxQ3TejVVhmqNKs+oFcyAerFVWGvT3te970O0NgcD4G22223822K55dVXQZjOAAAAkB9CUImAs6kSvphZmZmXby7u3mZzG28rFmZnYjJWNvrbb9ChQlDbDyd3Z0KqjNqUpSlKUpSlKUpSlPJ85+OHN7398iatczd37nvuH7mblKUpSlKUpSlKUpSgeYZvZ999zveueeec3tSlKUpSlKUpSlKf0/pOpTmG/ffPOd71rWt+7UpSlKHkZKUpSlKUpSPMOc+++/fuc1rXPdqUpSlKUpSlKUpSlKbw3vf333ffe9a1v3alKUpSlKUpSlAUTWJJJJczjOO973ve3PAAAYvWJJJJVXznOcv1gAAYvWLuSSVVVVVOwAADGJrEkkk9znOc5ye8NttttttttbmbfYa0iQQjorc3cyk8yx+0Uj33UkdYUTv33bn7SRzOKqqqqo1jGMSSTmJmVAAAZWaCAAcD4HwOBsPVVy0oVVVYVjBKEo+qEoAABtNtttt9xWKk1ID7OKxikkkzLkKo0zJUk5MbbbbfohKITbIPIAAqqqqowmZmZkGAJrEkkkuZxnHe973vbngE0xrWDDK9YuSSbuc5znL9xhhgvBg9f2Lu7u99qqqr7AAAMzWJ73ve3KqqqdgAAGJrE973vblVVVOwAwAHcMT7Ekk5L1nGcc1O973tyAAAYvWL973vbl85znL9YE1oAMXrH1ySSqr3Oc5PUAABmaxJiSSVVVVVOwAADunMaz2ZxmMaYxnOiSyIwwRlUX7VU1KlmUqt5ZlU1jrFI/baSOZEeZ51qkeYzvP2+hGJH2ClvKrfmtda17reUtsolpjVVkRgjJR4QKCIg27rMWJoBYwA5hEkU3MNksIdTNOqagdOG3R6YmKIKJuSMHEDtkjEIH3V3rxA3cAILlwAguJGxtsJcDcPhw5uIcOZjzjugm3vQHWBDWxkF+MDI/EmRkgjhRtofY3+86RCWXn3tv6d7ffOar1/EjhgCXzQAlPn8Nw5UsgETtXU+9mfffSaShNQxsYgatXXCRzbtKO8SOojNRHRAgqBpIkobaSBKRyCaEU6c9vvb57KzGCMzPQnwJkxiTPeuuo4FVjFVdY5o+OjtVMVWKrLTYGlTj6k1RFiYSMUsRGXMYqqrWK1iqxit6zvYs7UZbJJySbkDwfMmLBgGMVGTkRhqtQJEIgSQofXXd3X2CXbG7u7tViSOaGZIwwpzXNb555znPAnFUzFVSASCEvpgKGZMEiFQwQzCK4ijiCYfpzrP631+3ve/t+HkioSJTO8FwcJxHM+OvvvvvvtesoERzXNuc5znPHHNFiIxDGMZlqjWghzPvv199999r4ghoBQl+lBSShrXPuua5znOeqlcSMlkRhjAGEjKmJGmjNc965zf33z7KI9nTSo0tpGTWvudc5zr7nifWUU+P3W2/OoSSbfettus2EcOAADiFkvIJ2sViq7U1NySAUB0PsgFmgHRsDgfAcD4EkkzWpMyC4gBdXd3d2CgBGQCzQDo2ST6ST6B8DgbA76Z97eve973vfWZOElypJIBQAjIBZoB0blVKkgPgfA4GwO+Zrft+173venrASSVJJAKAEZALNAOjYHA+B8DgbA7n3L1Xe86rFYqvZ9qe8FmSSSXKkAFACMgFmgHRsDgfA+BwNgd9n3va973veWkkkkgAFACMgFmgHRsDgfA+BwNgd9isYqve9r3ve977smZ9JJ5FAAoARkAs0Zye63lv7777z77v5EV9kQaYkRH+S+wKD1CEVAi0B9d3QiUK0e7zlVV7m75k3J8+tj++PjC2222BxtvytTLfIfWABcAksOn0y6+T43xpu2AARQBieYru7wxgRk0HQ8BxqEoUZfEl5iELWISFTAIYIFEVW5u/cV999999re9/KfEAdzkfkhTJoGiZBjacLi+S7KhLkwkdDDCkJT1h0CweRdVyFCqsUH2D9YGBYHwJZmTl5OZgDEYHADuRmLO5mYHhREQkrUqMmISiEuKI+lR4+K98IMBUyX8222nTA6AEYEb0d3dcVu++zs7e1JLhCBoSQDQIGihv4CLALrN9b39994pqpCkr5+z7rYAQAAHe3d97d2FYlKzjnnzbbdIhQ4fIhKI4oSUfSsnvz623jkkAAPm3ChZnszDzbDx8HEoQLoFCCwbbbTfEoTYuABni2+tttgEgAAVVVVUyIamZiFCiYShLEdn46AD+pt57MzFePZ7u7u1Ag59x3cU+7vtUpCB0kIGQGfAXhUJt/NtsqIzOZmZg7QHwAUeRKQga7rn2fBN9KQhfUQ0V6Kv333cvgAAKJA+Lv6EuRChKqrtAYwAAD2Tt5u+3msViqki/jaAWa+xvezmKd09nd098cIBMqMlQJJLYabPifpf2fb71Vde97YHaqpPbA7VDZo1VYo1WKGwO4GwOgANgdofzbbbbbbbZCahJRMQohUfHA74lATvxhHCMjRqqxQOASpJJJAyKC2QMnaxiViqxVZqqpisVVVWQTIoFSk0qBYVDEnUgg4DeAiY6u6s93eSS7Oc93d3e8ISOjeqL7oBHdHx7WQjWt2F8fQjN8axgzMSCbimkCW7993YAIO7ZA3d3bDTe7u7uABZoAAHA+CSSSTH823XedI98CwqIUJkQAADzMcJQk223WDbALURAVMQlAJQADxttNtiLEVChHQPAgAAASBAgAqqqqqTzBgMAAdT7Ekkl+zjOOTvf3e9v9iAAAO5X9ifpJJVYxfOc5y7gAADF6xfrzmSSt4xVV9VSeAAAY3lifYkkk37FVVVJ4AAB3DE+xJJJve973PdGAAAmE+xJJJfs4zjnOc5y+eAAAZmseuSSVdVVVdwAABm9YlySSt73vcngAAGZrHpJJK3ve9yeCqqqqqQQ3IoeHXv7P2Qo/bu+h4/t++xIQT0AAC3oEAuaBBu7u2bWamTWKxTOKqg+AHFmvgOjYHA+CSSSSNh3WPXnuM5xWKz36u+hQuwoVnD48e5ChJBEQvl9IuzMyHehz60HE/QoRXUvpSJSSUIlHuB8HvgPgDIhRCglEqEoSHnUNt9dUSlCPP7zeREQn7i9mDpttttt2ohJJiH1HAAr2973OzAAAE1j0kklzOM473He97254BiDWsM6Z0xpesXd3d3Uqqqr9jl5xjOtNABhMav7F/ru7ut73vd9xi1gBm9Yl3d3dVVVVX2AABgxNYkkklVVVVTsAAAzeBi9Z+xd3d3fcQzjOOs97rHWc9Yx3tz8AABL+xd3d3dV7lVV+sAAwS/sXc3JKqt73J7DIAGZrHvekkqqqqqdgKqqiqvpAByPYBCjNYgLn79E7SqSKHTjaUSDIFBGP6hAAV9spBVST3nWQCAAAe97z2fe97ws0A6NhJJJJD4d7X3313QPTu7m7G7zd3Rp1bfzAPiFCAAG21kklSSJLuXdpOyG8VigO+5iver3vc9JVVVVU7AAAJf2Lu7u7nPazjOO6xrrj7muXPgAAN5wZMexf7El3d/Y3v32cZxVVfbAAAmrXcknu85VVO+8AABmaj9JqScqt73OwAMAE1570knPc5VVPcAAFX0FBvrN5m963+dxuH3mKvsnvWB5nnWeMWxmAAAN4v6JLu75Veqqu4AAAvUSXJOVVZxnFVU7AAAMzUSSScqqqqnYAYAE84q5C7MfKZvy9w6chQjvgC25bbfk2/lGwjusgBSMgFmgHRsJJAOPh93Oa+qvnvT1+NveHZqSSXL9vwCT3cVimZmSSSJJJd2k73vvee973temJPJ6Oycqt73OwAADE1570knPWzjOOusc5rlz4AACYv60m5Jyquqq/WCtMa1jBhjC9RJd3fKr1VV3MMMFABm9RJd3fKre932BgAAmvPekk5Vb3udgAAGJrz3pJOexbOM473ve9udAAAx7C/rXd3d8qpznOX6wAAMYxjGL1a7kk5VVVVOwAADM1EkknKqqqp2GAAAH79z37Oc5xjHvXW/vuXfceu7uePDIBFAEYxWVAF5aZALZkkknYbCSSSSHwvt32unE1KktmSS7AOySSSQkklzMiSSXdpJIAPVive9n3ve9OVVVVTsAAAmokkk929ZxnHe97+725+AAAvVpJJOVV85zl+sAADF6tdyScqqqqnYGDABjE1EkknKqqqp2AAAYmokkk5VVVVOwAAe1piNfJJJOdtnGcdYx13ve/rmgAAL1aSSTlVfOc5frAAAvVruSTlVVVU7AAAwZxjGJqJJJOVVVVTsAAJmZ5izqhd53iR0qg8A+uW235JQk2/nTRrFViqBwoAQAXMySSTsNhJJJJD4X6Xzfs+X2/a95JJd+kkk4zisVMzMng9fvVWPb8AktOXevuc93vve973vc9J9EkknKqqqp2AAAYmokkk5czjOO973lzgAAEv60knJyqvnKv1gMUNBeokku+VVa0Gubfp5mDTk5mYZgJmWVTzOXOc5duVVVV9mGcW0BL+td3fL5VVW77AAAI1573vSdx29ZxnHWOu91y9QAABi9R73vXOVV85zPL9YAAF6tdyScqqqqnYAABn9Pokk5OVVVudgAACMYxjOMdY9Xv37selUpSnn33febGASDfpbzPLMzMy3j+WMVpQAgAuZkkknYffBz1e0qAOgYnPW3ZSz3IXy5yIhTPPcgklJ5lwoR45KiFxJttukQoWPjb+bdmS7OnA4SHE85mZhyU3dQoTA8vZ1KEPyIUJurdJ2/MoDvUSB8iS+SABdVVeMJkAAI1573vScv2cZx3ve9xnON9ZuaAAA/X9aSTkcqr5zl+sAAC9RJ71zlVVVU7AAAMzW5qSSpyqqtzsAAAmvPe96TlVVVU7ANa0AEa3NSSVOX7OM473veXOAAAXqPe9645VVfOX6wAAL1Ek9c5VVVVOwAwYYYxNbmpJKnKqq3J4AADGMmM4z1nPzGcVW81vOK1jft/B7wZAlypJJBRQAgAuNAOjYHA+B8LvNV2+cs1cuA2y/eL10+J7qakk/Ue9Qe8HBK8kkk8Ne9r2arFekk3OyaSSScqqrc7AAAPYn0STk7O3vOM473veXOAAAYvUe971zlVV8q/WAABeoknrnKqq3OwAF6Y1rGDGDGb1Ekl3yqqt32YZxYwoEuW7e975zzWta1rnvOAlhlE5iJmWVyM5c5zmucx93iJ7770e++8/bfsccwEsMouXLnOc5zzWtb88858c1AmZYTmAmtNYWtd3d3yqqqq+4sYYYLDN6td3d3yqqqq+wAADfN/ffTcn2cZx+lR71+9n3ve96XKkkk8FACMgcNGgHRsDgfA+F+qXyue55J573vAbA6A+qsU972ve74AbAAfG223bbbbbbGSSABdVVVRkAAAmokkk9fms4zjrve97c4AAH2tXq0kk9yqq+c5frAAAvV3dySqqqqp2AAAYJqSSSVVVVVOwAD7WgmpJJPVVVVc5NQAACakkklXM4zjve97250AABnFrkk3JznOX3nL9YAAF6u7uSVVVVVOwAADM1GcZxJJJyqqqqdgAAAx+5737GtfV9zns9733p7wyARQAKAEZdG3DRoB0bA4HwPhYll+B3dmA28bb4wAdgAAA28zMzMzHmXd3du3mZmZjbYBIAF1VVVGQAACakkklXM4zjve9725joAAF6uSSSqqr5zl+sAABi13dySqqqqp2AAAZmpJJJVVVVUnmHtaABNfMZziSSTlVVVU7AAAJqJJJOXM4zjve97250AAC9XJJJVVV85y/YsAAC9Xd3JKqqqqnYAxY0YwZYXq7u+c5rWta1rm+G8SzDDMRMyyiKvO/Mz8KNxHNCNCP7AjeCP7rQgbbVXE3QhBZQCDMr3ZoAg8AkLIj9oR/biMEaBG/YRoAFBDgLHENjIb6CEog5SgFF6SSxCMegILpzDkcAIMKAQNzOfTIyrzWO2tkvBGe5sDpvW94qbzybAQXCRbEOBOIG5AQZIvX7AoLCNCNZ1gR1Ee365q72ovPOveo+Ur2Ev7mV9mFYfWJRCiZTyFy5+6/PADkoBiBIb7ujt326kCCUnm7vT3oBAfAFVVYoFBlisVigUaqsVHvV73vTHve8w1uMh22K1kBCSSTMElCRMJRC7EQVyOdD4LsJpJKIlRP4b3ve89nlesz8IlMxQCqYxWKrNVkUBTOSMgxVYxjFaqt4vdVWKr76tHLNXLxWKxVSs1VVjG9akDcXRpwPmeYrFYDvA5yg38DNdGgTsmZJCiKAEqSSdk0jIBZoaD4bAFCzQD973q973ve9oBa7u7u7AACgBGQyFmkkk5JNwHA+B8DnlYqqx7Pvb973ve3OW2051MTsmZJAigAUAIyHAnGhms0qqHRsDgfA+ByViqrDJsCugJJJmSQIoAFACMgFmoyDo2BwPgfA57GKqse972/e973ujSSSdkzAEUACgBGQUJGtAOjYHA+B8DlBsDuEkkkkAAoAFACMgjKzQDo2BwPgfA573ve373ve3ySanJJ7rJkAigAUAIyTWm/VPe973qv2ferE9kQav2P6BUchUHqTIyT7N7JDGU75y/ru7IsMM6eR0HdJNpu2QfcAOAAO/ll3fburfG227b413ve9bbbAG/VWe5zrFViqqsePnRPABVBI0hsEEsQQmjd3dz2/Hffd0d3dy83fUoXDybbtNYABIchQgAC0phQhRCbzMy8wbEAAAnmZmZmGW4UJKJziSiIXyhJRKUQkoOHvAA4TzMzMzMbYEZl3d3WLtASqVisYxkJJeK9glxtsAa+n5ttvPCefZmZjMcQlBPAAAG399MqIiFMT982BxKEAvgAPBxKECPszMzMWYAAB4AF4AbbbbbbC7u7u7BjABVd73ve9e5mqxVY9iqhIAoALAbbd3eDb82/JKEpSUJTNS6JnNc5zknFOKee0I+RH1Wknrh73ve8ARWJJJJcyB01Shcl/Jtv3VMKFKFEJKPe8AwG22228jZXarFNVOe9WO+97z1+9QAF3d3YswAAG222+yohQlVffe8/phQnxJQ8zHNt58/VwiElAFUACWK7u7u3jbbZ73ve973vezjFYqgCAAUSSZk1VYqSbGwBZrFYoPhZ3fwPuD5lnIAaqsUAsAcl6qsVNakkgHeD5wSSSYqqrFazJAgHB1zJ8CPXiZxWKmcVvNTNamqxWPZrOar2arGK+vresd7zXZyb89ZnoCKABQHqxVVjz2Xs+973hZoB0bA4HwPhfpfOe8kqeeAAAABttttsMhQhKDgEttvMwz2Znxg8zMzBtgAAFVVVVBDhfieTMzMzO6tjOcXd3+u+SZxnHve93tzoAADNrkkkqqq+c5fsWAABeru7klVVVVTuIAABmaiSSTlVVVU7AAAJrEkkkqqqqqdgAAE1JJJKuZxnHe973tzoAADFrkkkqqq+c5frAAAvV3dySqqqqp2AAAZmozjOJJJOVVVVTsAAA1Wf2vfYlfSbk973vPe9v3ve/d9QAK0axWKBxGQCzQDo2BwPgfC/VPquqrGZ2ve+8UjE5hQshQunuXChUF+DmdUQnmZjbhzIEhgB0B+bb7mVChGc75XIs53MO4PO5x3nXZ73pJJJJKrnOc5yVAAAJqSSSVczjOO973vbnQAAGLXJJJVVV85y/WAABeru7klVVVVTsAAAzNRJJ+xjOJOc5zlVOwAACakkklVznOc5KgAAE1EkknLmcZx3ve97c6AABermpJJzlVfOcv1gAAXrF3dySqqqqp2AAAZmpJJJVVVVU7DBkRUUe19fHXXwdgm4Qf0qr+h1JqVAdRu3IhuF3IC7gRHcCO4UM3gi7kBHcIoO4A3Iq7oSSB/IRwAAATbbbbxy2223bfGPe96/e9v3vDgfA+FyfXmdp1PL/fJExsqCQ3e7KiFuldhLj4k3xzDlaGtE5b3vez6ea+6E9gzrF9j2A93i/Zh9IN+jugDWLWawNYbyEQI5r5nMruYgDrSiFEImIiCVCiETDJAAKqqqtb9N1BzIxcCCGeXOc5znNb2ie+++++32YYewxpoAvV3d3d1VVU5y/WAABeru7uSsYqqqqnYAABmaiSSTmKqqqp2AAAexPtJJJN73ve5yAAAexPtJJJLmcZxznOc5fugAAXq0kkm973dVfbAAAvVru7k3ve97nIAABmaiSSTe973ucgAAGea1PY1mbmcc793nPZ97waRQWZkkklwAFACMgFmgHRsDhd1e7vu7N7er3vLBQA7J4Ce81ySfZg2ZmLPDb6xt5mZ2FCzBvxCiFAyZkkk3ve97nIAABNRJJJu5nGcVVVfqAAAmJf75f6STf79e932wAAO4v613clfv37e5yAAAZ9r01ySVW973J2AAAfT6TUklVve99nYAABnMak1JJXOM2xnOKZzVX9jd6gAAD6Yxf671+u7vnPc5znL9YAAHMYv671vckne1iqqp7wAAHMYxPpNfpJOcrFVVTsAAAy/Tv7GMZxiTXz9W97re973JyT3ve0AszJJJLlAAoARkAs0A6Ng+k76ru/X73g/e9+97wIG9ABvLycz2ZjeZl3usDQBv5tvXTzMzuYP5+FEJIA5YBd+97xhMzMzMgBNe9qSSc5WcZxVVU7AYsaM4S1zOcznOc555vaJ77777zzwo3RhmZYTmsan331v16u7u+cnOc5y/Y5eM5w0aMDBrWrXer3d3e+9qqq/ewytnGca00YMXqTV3d3zlVVVfcYtYAZvXrv767u+c3ve77AAAJr3tSSTnN7qqnYAABd/X2/tXd3znpnGcc5zlygAAOYZv6TV3d3O9quc5frAAApzrX1bWyWZZgJAHAmQB23OZmYN40AAwoARkAsAdkbB9J313frv3tVWK94O+APePe97wJDwlD8zoCW7W7jeX27v7cwbbfW237QDkkk5ze97nYAAB5hPpNfpJOc3ve52AAATXvakknOb3vc7AAAJr3tSSTnLmcZxznOXKAAA5f0mru7v3e1VVfrAAAvXvvfXJJ3lVVVO+AAAmpNSSTnKqqqdgAAGZqTUkk5yqqqnYAABNSakknOVVVU7AAAJqTUkk5y5nGcd7jve3OAAAfb+9n9N/Lfc7PxKUIw9hTfuNttheBPwAN402LmaxipJUkhkRkQLAHZG2233Movtq4FKiF99YJB5zjUKMwe8A+hQjY2VEIBt63xvkQ228q2szGmp0sMhQqJK7LzmZeczBtqsfFxnwWG73c5tyS+95znOX6wAAL1JqSSc5VVVTsAAAzNSakknOVVYqp2AAAbxPpNSVJzlVvc7AAAPYn0mpK9Vb3NzsAAA/Xf6TUl3Wu+/u+e8q5kZgUFBQUUXMM3vN75vVPIUK729ErtRC5yeTKmOcShTvwcDd27qt7vsWYY0wwwavUmpdrvnKqsZziqvsAAAzNSakkmucqqqTzDDIDNXN3muZ++1utazmvvse39tz3vA0AsyARQJJJUIzsIyAWA26zH82235u6G/nx5ni0gHQIAOgAUHQG/NttvQDiUKshQnL+3KzNbb0PoUIAAseYNtt0wOABd1XvGEzIAA9iax9JqTknOX7OM473nLlAAAXqTXvXJfe85VX6wAAL172vXEnOVVZxnFKnYAABmak1J6TXOVVVOwAACa97XvSTnKre52AAAexNY+k1JyTnL9nGcd7zlygAAL1Jr3rk5fecq/WAAB6/p7Xrid5yqrGc4qdgAAGZr3te9705yq3U7AAAK5+x93GcZx+1rNV9jNVj3db3xHvdGgFmQCKBOyalTMkAZALA6LO7A/N2LPsHjfRLoD4mxtu2+NoAAG222wAbbu7szMCG2wlKEB8PMzMzOz0k1JJOcqt7nYAAB7E1j6TUnJOcv2cZx3vOX9KAAAvUmvVcnOXzlVfrAAAvUmvXEnOVVYznFVOwAADM1JqSSc5Vb3U7AAAJqTUnZOcqt7nYAAB7E1j6TUnJOcv2cZx3vOXKAAAvUmveuTnKvlVfrAAAvUmpcSc5VVjOcVU7GLGjODOTOWtarRf13q75d85Vb3V3++iHDcDUQREQogSMqvuuZm7+A/Zk5++38973vfb9r3ffe97k97Ngc2inCwKCSS5mSAsAdkbA4Xd3fbK5mYNjbdtv5gHQA9jmFCbbABvQ4023oG5mZmZmsG22IAPBwALuq94zZ2ZnnOKZmZUoW/L7d5u3u3Y4ULMu3FO80AC7+/TUl3fOVV1XbAAAmve16R73u95zmM5xznegBgwZ9r3te93tVve9+vsAAA+n0mpJKre97nIAABMTWPpNSSVV9xjOOc5y/UAABiak171yc5VXVX6wAAL1JqS5Ob4qs4zilTsAAAzNSak9JzlVvdTsAAA+7WN/pvOMYxHuAjWRS7zn7UR0i6RaEhWwEHqubzfshudn7tQII2ABBHu2hHsqyJNYlX2JHHzu2IxoAQTexcE+Ne9m69zkkiQEGgIGkIJEkA9hw6hAIK2a147w4BA79AlfnhkU/bG+sTloyJ1goLgzoXmioizXe0lN96EaEevu/yF5vT95q6zGKqsX37k7e4nZ4A1kDve973qBMy53bj5IQmmKgAQfObv32/fakgEucRvKSNYAxgjMmVkRkDCoa1SaIrTFRaZQsDSFC0gtKIQSkyNBTQxAlMooxABIIQtfffde++e/jFYqpmSAlVWKwyASqqsaqsNAfc5RHMiMqjCjFDMRGUChQopSqBMAsDIoMM4qsVWcgExVYqlZAJWMYxhkAjIBKYznA5QffMVVYrDI+4A8wlLKDGTIjIjIoz/P373PD7GMViqZkmp4FmQRnGKzmqxWKGSlAAKH28d3b2ghBz7u47u7QRzgnemuc53zPvvfsFWCMJS2yazJBqJjGMVVMjo2lYrFMjgffqxiFCADoASoThJJKKlt/NuMfkoUJyzQCzIAqSSSQUAIyAWaAAAD1Yqqx73ve+973vc+mmh0u6xWc3eru7FmQCKABQAjJJJOyagHRsDgffUD7gT7Py87NruTkk1JAsyAQACg5wOO5lSgOGgHRsDgfA+BwBPA0PeLMgLlSSSQKAEZALNAOjYHA+9SsVVY9n3vfe973uBuSSckmgFmQklypJAFACMgFmgHRsDgfe973vfe973uJmqxUk3JqqxUmgAGUkklyoAFACMgFmgHRsDgferFVWPe9733ve99JJuSTzo0AuACKABRnIUAefoRGUB9sCvYBHrrGPsRFz95vr1eCwdXN9m7vttgByQCgTfW6RCmQOngAAKVVVVQ22222573v3W22wAAGmoUQqlKFEJebfn5sG22228TmLzKTIpUMsCDKhymb2woIgiOgCkscCgMMaMwsz7DoIIujJGczMcyafow6IqpypcsaMxWc4zmtVr7n3AA58DFViq7fe97vnbHTbbbbSeZmZmZjbJAAAtXd3d26EplKIURAHQAPm8zPZmZWN/Ntttvt3c4in5+9t7u6gQaIQNIEwBMQBr1qEk+kk+gACSSSSAA9VKxnGMVVYzWMYxnIB4NhR3dViru7+v1zPvez73veEkkn0kjgAJJJI93jmCO5ABwhoQA+3u7uYkZmZnXfIULFCSgSShJChQlwAKDiUIlurfvX70eYI7u7u7wgQcIQPu7qAEFgIGAgYCBpjQIMnu6szu7u7ug7gZu7u77dgAZxVVWMBlWMUrGKVjFfU9dYqqxnWdX9d3ce1isUAAd73ve9AABd3d3dgAA5Jl3dubu8fzbbm6IUJKDh3yUKQLDiUK0mszMy6zDkQoS+ShdkPgDCk22/Nt/Mg0aqsUg4Gw+qsVMySSQAASSSSQ9jGKqudbrFVWOc9971z3gAAABkAgAA5znOfffffe2rJR8xIyqM0a1RYSZkRMrBkK71r77nPOfd8+SOZ1d3d3agSQc+7u7u7A+Yawga1pa5ZrRCaD4Z8wS8LIyVmPJv1L3vvvv5Gfmft3m9W7vy2VpgSAGZeLMzMbbbTbd5OS5mSAsAdkbA4X6SpL8l3dr9JPHgIe973venhVYD0zJJJ7wWB8Bg8zMzU9SJRJu7zd0Luq94HMgAA9iax9JqTknOX7GM473nLlAAAXqTXvXJzlVu6v1gAAXqTUl3Ocqt7nYAABjyfSak5JzlVvc7AAAHe6733vc5VVnGaV7vgAAIxqTUnpNc5fsYzjve9uUAABzXva96Sc5Vb3OwAAD2L+k1JUnOVW9zsAAAzNe9r3pJzlVvc7AAAN1Oc5rn6qr79726nY9Xve9r3ve95ZkAij6gcwaU1isUJ9JczJEZLObDh0bHR35fp8vDD0S0Im++6dukGbNvt+6+wjd+EhiSgk8lCM60T8UAF4HAbb9Vzi+yiUoTfBvMzJzBt8lQ3nYUJ+Tb8FBwCTnKqs4zSp2AAATUmpPSa5y5gT3333m9VVVeZGYFBQUHM3vN75znkqt7vt4Yxxhhg16L/X+1d1d83v9+vkAAAzNdmveknN7/c3OwAACa9WveknOVVZxmlTsAAAJqTUnpNc9efNYxnHXWfu9ubAAA3f0mpLu+eqt7vtgABh6GMX9f2pKk5yq3uTHsMgBnmMz2v3vSTnKre52AG22222xlupUJjC6r6+7s+3fu7uju7uLMgkuVJJAKAEZALNAOjYyOHfVJJfvkk+kxjFJ4aDgH3gKAOjTbbeZd3e2Zg2zMzMzMG22227e4oDngAu6qkoqaMJmZmZkAMRiT9J6TXbeaYwYxnHOaxzl+/AAAZ5i/vXqS7vnM+5yqv1gAATF/XepKk5yq3udgAAGZr3sa9Per9P36cgAAG/T977U97c7vGM7bnIAAByfemu+9q6exjOPL5y/bAAAvXr12/eqrXzVVfrAAAmL+vupKkriq3udgAAGOJ979r3pJze/36cgAAFMYxnGLxjGcLi4uviShJ92/t7t7o3qD4AMhQoNWvf2f379+/eIoAFOjYRkAs0A6NgcLvd39fyfXd37MNYrFe96/e96e973gUBJd3fV2kjwB7x73vd72e972veknN73jGdtzkAAAmvTUnpNe67jOcXrGM47393u7mgAANr+n7XvXJXL5yqv1gAATF/W97fvXyq3udgxY0YwYxrTWWMMaZ8v6JL5z7vv9+576c4CZllUREXM/F99ze+d99o7bvkwzi2gL1dtXcu9c9mMYzjnNZ44v2gAAL169e9cnOXzlVfrAAAmL+u9TUqTlb/fp2AAAZmp5r3pJze/36cgAA5rT839+cvGMZxj37dfc1rv2vv3P1378DYHRoBZkAhoBZQAjIBZoB1f7M7J9uefXcrGKqpE8Hk8BPJJJd3d3dYxVyTwkkkYrFDb3ve97wD2veknN73jGdtzkAAA9ifT7Unp2fdvm8YzjnOfX7QAAF69eveuTl1WN7vtgGDAerC/0vUqpK4xnOKrG9zsAAAxWE+97XpJVffTngAAO4993s+3JOc5vOM7bnYAAB+n3ve+lSa93l/YxnFVcmwAANX972ruSr5+/X2wAAO2v9PavclV99OQAACCT972vpJVffTngAKqs7Pfff32kQTiCECAnsoKHcTbCT+xBzEryTmc2F/YEDkghyQQ7lD4hoSJkIAVOQIpyXqZpkuYqgHO8FQXkqockEOSIvPcVFSRHnPec5nOc4LMgEUACgBGQC2+Nttund32+3d27reviWzMwCA3dxbvjmA+oeASbqq8aqsE8dkk96sJJFgfFIkAAMJhQlDfIUREOYYAfTcnK++nIAAB3E+7Pfbknu8v7GM43u/fgAAO4v71z66k5fK3u+2AABevX771yc5yqqp2AAAZmpJ9JJznKqqnYAABNST6STnOVVVOwAAF6Yv67v67u+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IACIhBjeSSHj4AB0X973vve9973ru6q+977sAAAzNSSfpJznMcqqnYAABzE+k/T9JOcre9zkAAA9ifSfp+knOVve5yAAAXf0l3+u75yt73fLAAAmvek/STnKuZxnHOcv2wAAM3qS7/STnKuqq+43eNGNaw1prWMZwv6Td3u7vva3vd+x3OLaAl/Xf7d7u772t73fOgAAXjGMYu/139u93d97zHK1TFX2wAAJzH70a7fd75d378B9+97zgbA6NA2WZdAig4HxQAjIBd3d3dpLmZJJQAHveez6/e9vwBUZklSebdMoPAADltttvAAPHgMyve8XkgAA9ifSfp+knOVve5yAAAZmvek/STnOcqqnYAABNSSfpJznOVVTsAAAmpJP0k5znLmMZx3vbmwAAKZX9d3f67qqre7vtgAAfT6ST9JVVW99nYAABmakk/SVVVvcnYAABNSSfpJznOVVTsAAAmpJP0lVVX7GMnnnOb7qqqqqq78cQAuful58ghznniJzzlyD96ghm7fSCG94gh+UAK+hKEt3kJQlu2oSS3sJQle7u/bu6PlM0LfFmeAIoAFBwPploAu9Xmrvt5+qqSSfmUpnzQfYk0NsAAUQgNhKEjZW7u7u7tZmZmZhmNtttttt5Kc8l7CUJbvIShLk7u7r7u1VVvd32wAAJqST9JVVW9ydgAAGZqST9JVVW9ydgAAE1JJ+kqqre5OwAACakk/SVVVfsYzjnLubAAAq/ru7/XdVVb3d9sAACakk/SVVVvcnYAABmakk/SVVVvcnYAABNSQ6FVVe8GEzMzvJXOJTKlLZ3d3u7VVTcJPPOc33qBMywnMBMywjvOgEN66AariVvfPs339z79379d/vpJJ94OBsDo0D4szwBFAAoARkAvN3d3fUknsBqsYrwTslV4ASfSSfSBWMUSSSSQAe973ve94YAHQ27u6rdb1KFzk8UxziUKeLilbO7u93aqq97d3UoUnJlSuSpUqeLft3d7u1VVvd32AAMAmpJP0lVVb3J2AAATUkn6Su85y/2MZxzl3NgAAZxV/Xd3+u6qq3u77YAAE1JJ+kqqre5OwAADM1JJ+kqqre5OwAACakk/SVVVvcnYAABNSSfpKqqv2cZxzl3NgAA3FXSWqoBAKfoSSKm+zcSSQveu6ALM/hGRHYj7+6977UMd5pvzemFsbCAKiGNzEcNVEuSAEDsZXO5ECkgi3TC5qQEFmY69t1eHbjlJifoIaB+hEaAgcUwKk6YatEEOVEMYwes9uo9xylBfgEIEB9J+C2eWsgl3GPzzImt++bk2Zrj5iAX3EEvxIRlDf2jTYxt1boQCYgR6mkgE5qPV99933AJFOEIYACS193LvdhbO6BGKqmWccAQ0B2qxjFVirzNTNVipU+5z3nEqHjzVUsatSRqqZeZ39xdm972+yDrOa2KpR1oJhlazTbpKIhRLb63ab4REKI73vRAA6bddSDBTrvkSdSYJW3lv/2/fvv33337fMySe+BwNiVVYxiqqrqqrGaxhlfxru7RCBc+73c+7r0BA0xtgkPGkCDadJASc56u8bseASS1IQMEgb3ZOqJqmgWyzUqsYxTMklya+u+/qrGKhPp4u6AahQkozOKISVS+9b82/oShJ5B8DgbA6NALMigRSZkkkl0ADNVilmguNb9WKqse493XveX67xWKzw+OHWau7u/rscDYHRoBZkAigAUBtvHLpttu2+ChJRn0woSXHxgFDLhYpV90+ccD4HwOBsHJJqSSFmR8B2lKkkkkqAEZcD4s1NtA7Z3FYq+G/gAPgcDYOSTUkkLMgEAAoARl8DizUrFVWGQdHMVivg44HwPgcDZJOSTUgLMizUuSSSAoARlsDtmgHROYrFZrjuxfC8mw+Bwakkk7I0AsyJJLlSQAoARloBI173ve973fe9rFYqV80HLHwPgckgDo0Aszko1isVJIp3uPtaMaXOG+iBgNg5+xCLmah5U/fV99vu8chD6xInauZys8RN91zvrjqQimPt5xNz0m+yiX19sIR729NV3UfJDYfX98oPoUL2cD5AeHyFCdtfNt/O4b7ChT8+qu7o7elCMngZrYIb3Xv3ShG+37vs+fuak5znOc57zRPPwDXrSFyhZQko8TChfF0DG8hQuKIT4223bUwohfMEJvGxANALdndzc180I593UUUuHOL3vFYp99lWw7ZAAV9adnPsVisz6T7hldO/YrFZfHzsV7msVish8W04SSgmJr5KFIB0BvIULkKFSXMzkZm5rN03oKQhx0V3dndAI7YIN03e7A66BE7Hd2dXaJJApGgFMKABdIIjunt96dtamgqgRO7V33dc9y8xuqBEd33HZXyH31VivtvhbmWtVWKHwTiu+xCSpB5KFwo5QXUKEY8622207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33wVkzIAAc93373q3v9+97ngAAM1jXfe/fvere/373ueAAAmvST9JVYznFfv0nIAYMGOT733p+kqqrG9yfp4AAF39d39d7/e/frvvbAAA5zCfpU+nd/r+xjOP13z8AABjp7733r/elb3+k5AAAJrsv3725vOM43+k5AGLGs4MaY0x1f0ufT9+zjOOXW7vuLvOcNGmtaMArHX781+9e7+/Uxy+3vN3f0JRkqIDkfAbG7ub7dA6A35tv5tum7fNALVJPpJPooAFAF3fU1JOSSVJIk/A8JJUnpJJL9isYpYN5lbMpKEpUa226iFCWhp6IUJAAADtvjbbd/X3r93MMhbPJmZmZnVu6vipu/3vYxnG7vv4AADmNX67vcuu7/XfLAAAmL9q/V7c/fSVAAAMzWOz0m5W/30lQAACTz2JOSt73+k5AAAOT0+xJyVve/0nIAAB7Hbvd73i73db3v9d8sAADk+9P2JNyqqqv2MZxy7n4AADq/rveLvcq+c5yrv1gAAc+/e7evu/Qvkr3c6oWbeh9UNtspAHgA622+cDZY6VrUkkl3Kkn573ve9yve8AUAXd3d3aSTweLB4SSTw+JQm22ohNmB8QoUqFCQB1AAADbbbbbb1AAAg86qqrzebMzMzMzMyBjifSbxJuVVVW5OwAADk+k/Yk3KqqrcnYAABNSTEm5V85z72MZxV378AABiVi/13eL5u6qq/XfLAAAmu9x2fvSqr9UnYAABjyfSYnv07VVW5OwAACa97HvfvSqr9JyAABh7OJqYkxK3K7znOXvGM45erYgAAxusYv9Jib/S6qq3d9sAAC2/tarsn2+cmMYxhXed7sVXvXU3u6tjQ+Gevdvd99KlRtXu7vdvd44GwOlZkkklypJJJIoACbbbbu+3d/XbzMzU22w++ShGAFmAUEB73vDuMViqPpPT6TGKxVTc827glREQoDwAA22QAGLM+sKrrdkzMyAAxxPvex6fpvtVWMZ2k7AAAJqex7v72tyq3J2AAATXvY9j03K7znOXvOc45dz8AG861jBhhermIdPa7u63XFytXJhQucnimOchQt+3HPz7u1+5zzlwnMRMywnMFPC5zvnfOd9813rX7nPOXCcxEzMwrMBMzmb39z9vvvneu+c94TyrFyEazLCPQOZzm+fud+6vfPPvyJ5zOft3SuZYRlmQuZYRHM5ze/2++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14Zx1oC9Xd3e7qqqt3fYAABmakkm5VVVbk7AAAN/id1emY3d16bjhJbu7u3HgH1tvX6W3L8xsg6a1JJJdxkAigAUAXfsSbkk87IrAeCST3ve973ve9mZmZkKFmDYm+KMzMzyiFCXs4koGyg97wAAHHe973hPZznOc5znOc5znOU1JJNyqqqv2MZxy7n4AAC9Xd3e5fOc5yrv1gAAXqSSblVVVuTsAAAzNSSTcqqqtydgAAE1JJNyqqq3J2AAATUkk3Kxiqqr9jGccu5+AwYAvV3d3uXzGOc5yrv1gAAXqSSblYxVVW5OwAADM1JJNysVVVuTsAATMzLW8iEo+rts20388d46qve2r0bbb7kk+UH3wOBsNnRroFmQCKABQBd/Xd7u0kkkiSSSQAKmarFSSS+/q8PjwEngAAAOOc5z4v2c5znOc5znOc5znPsT7Ukm5ve937GM4q79+AAA3f13d3u973v9d8sAACakkm5ve9/pOQAADM1JJNze97/ScgAAE1JJNze97/ScgAAHp9qSTc3ve79jGcVd+/AAAbv67u73e91Vbu+2AAByfakk3KxjOKqq3J2AAAZmpJJub3vf6TkAAA7ivb973PV73gJzMk+kkfA1wNl+971+96te94LMgEUACgHe+u7u/eJBw8+plJJ4gACSZmKIWZjbbIhQkBIAA1ELG2222373ve9v1ZxnFVVb97sAAA9PtSSbm973fsYzil374AADeV/Xd3e73ve37c16lMqYVcShc5PFOz7e7u1te97u7eKVrDDBoJi/tXd3u9736t3fbAAAvV3dzc3ve+7k7+AAAmpP0kqcxnOOVVbk74AACak/SSpW+VW5O+AAAmuySbm973+nJ2AAAZmv0km5ve9/pOQAAD32MarT+yUlCXyj6S76VsJKM66Wvdr7I2+6dbb+kk85lKrFM04GwOitD973vT3s+94EUEZBSzVYxQ73ve1XejlYhN/JQgOKgL+UQm2897MOQoX2ZmZWfLHSctS5rCIUJNt5mDxpzEKEmw7ChAAAYSm2227b4235+973W7JmZmZlTKMzUkk3N73u/YxnFXq3gAAXq7u73KxVVV1d+sAACYv7V/ru6lb3v9JzoAAE1J+klSt73+k50AACakkm5WcZxVVW5OwAADHk++kk3N73v9JyAAATUkk3N73v9OTsAAAmv0km5ve9/pOQ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vvQAA9WKqsM1nGKSiWfcAAG222368iF6U5j6V9f0dUwuyNsJiCGoa0okglokiAbY5FDaUyZxtf3bIAB3ve970AcD7FYoAAAM4rFS7q7vttc8973PenvfUoo4AAcWa++qsVJIpnHdDkZJWKrFUyCqkvGKqsViZkkgAP767u/eu2+xCUNtvzbZChKPHhAUUHejbgEM1WKAWA+LNYrFBJJAASSSSagG7aqsUH2trviUK+++u+cKlJomQ4lC8H2B803xKE2CwC8VjFGg7WKrFVkfAAAfaxisVV3f1322cYrFUAQErGFiiE+z8KElGfP5KFChhhbRTG2222wO3nOMViqu7u7IAAVUkkkkAaxisVQCzE3O933q9W1VYo+HSEoSCwADmYs4lCzMrMlciXbbbzHxYxjFY0AiqxiqkkkkDpqqxTICSSTOMViqkgIHwOAA9WKpRQu94BQDf2OZpvnszLzMbbbAAAPAAAAMAmFZxmqxiqznGaypGRHIjIjRiqtJLUorQowpHdmt85znvOfVC05rnOcIYAF36Tk+Zrd16q+1JJ7wALNBJySbkkn0kn0ij4HA2B0aAWZSSd4u9pJta6AGACSakkkXisUEl3eMYq7tIAAAAAd73vcViu9eqqoA72qqqbJUIAAK9Ve8MlQmgYeCqqveGSoQ20wKr3egQkvwpha3pu7VVVQoWB55zrkpyoNc5znO+c1rWu++fcn2U4lQ78Bu7Ve73XsqFjU8S2FO7tbe7Ve73XspRsxrege93vTCVC37rpFd731xQUHMbfWbBZoAAk+kk+kUfA4GwOjQCzKSTv1YxXNN970TtYxSjb4Haxiuj4TeKxUkk5IlST0kw5ELMwxu2wS6APzbbY+P6FCbb6oTeA373SFC94BQhsG/e6e8BELMbbdVVe89TTmCVC3d3b3a9U1727uwkIDp4LV3XvDCIa2Q6bu2ruve3WoTAPFBVe70MUJolvrAqvd6GKFiAPFBVe70MUIG+sCq973gxQvduw9774qqLBtttt2aAEkl39dp9Io+BwNuB90afve973p72fSSd4l3d9p0BJyJuSSJJJJHJ2T6S1d727taVUkkgEmZmKIWtsAPe973gFCZIAHve97wChAABlVVdqjepQtlQhSo+nft3d3fedVVbuqFu7oBVVVVQCUAABVVVVQChDbbZVVVUAo9KTkAoMyNzMzK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557888EHSyttZQeKjIHnnnvzzsVHioyWS9TitsYVHFRklWSxJMSyWKWVGVQgAUPe9z3uigDphaghaoEfCMqHve573RHS0yKAfXve573lR4r1xW2MrbXOSJ8S0VksqgyBqWSxUZLKjJZFfPnzv587pK6TCI8Swl5557887SV4llRksS9JhJ569yZkzvrJJkyTM/TJz9zXN3j4AAW2+TJbbWwAAttttupk1kvElfhKn5ImCpksKxLKkMlkslkh+X5evy887qVXiWiXpNEHvpLglktUlMllRtRRZLQoyWQXz538+dyRybMQryTUmkxMliWSxUZLJd9+e/PO6Sukygu++/XffYl0mhLxUZAylMS0liWSyo2kCyWhLJaKDzzz3552qV4SylPSYQuEtFRksEsSyqNkTJbIGJZLITJZUZIZV5557887pSeUvScioOEsqyrRLIGQMgagZiWSyWSxLJag8889+ediI8SyoyWUl6r3uZqJLolkhktFR5579+edqjpNEHhUYpZUZLJeeee/PPEvFWVYl6TglxUYlkslqWSyWEt5557888SXmTO/O/37qZMkkznOGva+AAAAAAAW22232TJknJkyfZMn5+b/Pz88COhIBFO97vvcF6KgEhVSoB4EZRhH3vc97BPh3vd97gn0S+Jfavnz538+cHd4S8889+ecT4l4l5ZczDM1ZHzy2yxXi6lgGw1ZGW+eZ1777r33uZvJOuusz9kmZmTnOGtnwAAAAAAC21gPMkuZiPfmfPnzPsWpYWhe97vvcDotSR3rxdfslvk81ZMzN5mpYBsNSwDYaljZVeLqWZmZhmfpbuWeK8XUsA2BuWd1mZmZkmZrJPskvX3rd9AAAAC2222gLbbbb7kzJnmSdZkkzNS3yWWW97rve6ln1lV4urI+eK8XUsA2GpYBsNSwDYaljZVeLqSPnkk88l/eSSZmGZqWAbDUkA2GrJ73nzZZJma6zJJmTJ+81brft+AFttttAW2220BbbbbfckySYdjvJnJk3vfF1ZP08zMzmZqWc+jp4upYBs8lgBw8lmWUDh5aTy+AcHUsA2GpYBsNSzryTMzJn3UyTJJkv3xqgAW28mQHOc5xZkAFAABqZNZJ6Ij0rCk+/efe++J+Jd99+u++LtjxXi6lgGw1LANhqWAbDUsbKrxdSM8l84uuLqTfkob2GpYBsNSx1rOGZMyTJjwa99vABbbbbQAAAAA9ySZh2O8mcmTe9/t77elC1BC0d73fe4JznNc5gHOc1zmCAbDUsbKrxdM8snivF1LANhqWBrzWu8meTMyZP2SdZMzMkF1rdvABbawGgAAAAB7kyZk73Xe91LPp55ZVeLqWOlRNSz6K8XUTnOa3Cc5zm+QHi/MAyVO97vtwShKEoShKEoShKEpTnOb93OiUJQlCUJQlCUJQlCd73fe50ShL2LkJQlCUJQlCUJ73t+9nRKEoShKEoShKErJnXWTNayTJkn31/ft28t+Attt/ZJbTQAAAADzJPcmTIdjPsShKEoShKEp/JyEoShPSPvb97OCUJQlCUJQlCUJQlKd73fe50ShKEoShKEoShKEoTve773Op6MhKEoShKEoShKEoT3vb97OiUJQlCUJQlCUJQlCd73fe50ShKEoSgL2AZCUJQlCb9iPvc57OCUJQlCUJQlCUJQlKd73fe9E1AkQrQlCUJexfe9z3s6JQlCUJQlCUJQlCUJ3vd97nRKEoShKEoShKEoSQxfLK9LJXuVri0y5nVCe81V6IvOIusWh6lCzfzPn173y1v0XskXMBHBRlGVFdYqOJZEtkslkvaWK5aHUm0mJ1zL+R/N85pNCtJ3JcVHMlxUZLFDiXCXCWlRhWoGJZAyoxMnM355+++598AAAAAAW2220AAAAAAAAAAAAAAW2220AAAAAAAAAAAAAAW2220AAAAAAAAAAAAAAW2220AAW2220AAAAAAAAAAttttoAAAAAAAAAAAAAAttttoAAAAAAAAAAAAAA8mTfuTJ1mZMnWTJ1J8j5HyOaT7J8k0K6HcdVMm8kmZrJkuSMk/SSZnfnn79rZaAttttoC2222gAA9zJk6yT7+f8+JqTak2VNhGYlNpS2ik2RsI2gzVVtsRttUNhNom2yibUmwlsKrYi22C22KmwDaFUhmBNmxLNmswrEIswEwi00pDREE0iNFEkgSTEEwRFCjFTEfnPz8/OdJYIiGiZVF3CUJQlOTkJQlCUJQlCYlNMoyEFMSxJQUVEqNBVEQUe9iPue9mxKEoShKEoShKEoSlO97vvc6JQlCUJQlCUJSejIShNq+97m/RnRKEoShKEoShKEoShM73vN9zolCUJQlCUJQlCUJQne933udEoC9gGQlCUJQlCUJQnvYj7fvZsShKEoShKEoShKEpTve773OiUJQlCUJQl7FyEoShPe9v3s6JQlCUJQlCUJQlCUJ3vd97nRKEoShKEoYSGEhhIYSGLxQBhmMssYm+LZ3vjGMYAAAW1MgGwAA9F+0fI+F0AA8FhUPv7z773PP5OQlCUJQlCUJQlCUJ73tI797NCUJQlCUJQlCUJQlKd73fe50SkGhKEpPRkJQlCUJQnve372dEoShKEoShKEoShKE73ve96JQlCUJQlCUJQlAXsAz3ve9zolCUJQlCUJQlCUJQne90j3vdCUJQlCUJQlCUJQlKd73fe50ShKEvYuQlCUJQlCUJ73t+9nRN5glCUJQlCUJQlCUJ3u997nRKEoShKEoShKfTkTOupM8vm99ZmTMzvJnUzJk5+5zmt+34AAAAttttoAAN5Ikfnz5859iUJQlCUJQlCUJQlCd73SPe90JQlCUCUCUJQlKQne9737F8r+Qgme973vrwlCUJQlCUJQlCUJQne973vRKEoShKEoC+sAyEoShPe973eiUJQlCUJQlCUJQlCd73SPe90JQlCUJQlCUJQlCUp3ve977y5CUJQlCUJQlCUJQnve976F94ShKEoShKEoShKEoTPe973vCUJQlCU/U5CUJQlCUJ7PC+Pz8/O8537+/z58+fAAAAttttoAAO8X58+fPnzPsShKEoShKEoShKEoTve77xHusEoShKEoShKEoSk/IyU972/ezolCUJQlCUJQlCUJQne933udEoShKEoShKEoShKE73u+9zolCUBewDIShKEoShKE972/ezolCUJQlCUJQlCUJQne933iPdYJQlCUJQlCUJexchKU972/ezolCUJQlCUJQlCUJQne933udEoShKEoShKEoShKE73u+9zolPpyEoShJDCQwkMJDCQxW9mYAWWWVKWyyzxjGMYwAAAttttoAAAfM+xKEoShKEoShKEoShO97vveo6hKEoShKEpPyMhKEoSlPe9v3s6JQlCUJQlCUJQlCUJ3vd97nRKEoShKEoShKEoSgO91zme6BkJQlCUJQlCUJQlCe97fvZ0ShKEoSgSgSIE5zXOcVNQlCUJexchKEoShKU732/ezolCUJQlCUJQlCUJQne933udEoShKEoShKEoSm73uu9z16DNSTJznOc1vnPgAAAC2222lttttB5kgHeTNa15rXJk8yZ1ve+LqWAbDUrbfJFdrqWAbD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bQA+kyZmc5znOd5M1rXmtbyTzJnW974upYBsNSwDYalgAFsABlrLPFVZYBuBqWAASzzn6WX97LbJ+8klyZ5Jk6syefffXXPvrbbbb8BbbbbQAAABuZNZJyZN5JrJO5mSffffZ7LANgy3cs8V4upYBsNSwDYakgGw1LANgy3cs8V4upvySBvYauqqqqq5zNc5mqqqqqVjPa+vrn4TJ9v775799bbbbfgAAAAAACSA7yZrWvNa+yTzJnW97/b33LANhqWAbDUsA2GpYBsGW7lnivF1LANhqxtvliu11LD9LL999zvc7322/YDQAAAAAA73vfJaWXve953UsA2H6W7lnivF1LANhqWAbDUsDXOalgGwZbuWeBsNSz9+3nmtdzWu/373v3Jk2/PKVbbbbeAAAAAAAOZMnMk7yTrjvdc59sMlu/FeKAAAAAAAA21VUAAAAz7Wa+57Ofbe+xfLLL5JZfImk6k4k4k0mk0mk7+ScpOaTSeWk65859999k6k8hWJ5EtJoVoixMFaTUoxHFRksqMlxAyWVGSxBinCWJZBkuCXSXEukusUHEsETJapTKjgrnCXJLcSxLCXEuCXETKWxLUsKxBxSnEtSyWJcS0pZLQriTScUnsnMhcyYmimeSZPMmTvJJqSXr95+bUAAAAAAW2220AAttttoABbbbbQAAAAABbbbbQAC2222gAFttttAAAAAAFttttAALbbbaAAW2220AAAAAAW2220AA/i2223nAALbbbaAAAAAALbbbaAAW2220AAttttoAAAAAAttttoABbbbbQAC2222gAAAAAD9kneSe5kye5lHyOY9jqOiRqTmTmNSfVR4l9S6JcV9V1FeUvEDmZknWZJMzeSb337+3VttttoAAAAAAB1kneSAa1rWtaAAAD9bVVQAAAAAAAG2u973u25kybmTvwaHAAAAAAAAAbmTWScmT9knOc39gAAAAAGW1VU5znAAOc5znCGta8zXX79+3JOvO/3rpWvTgAAAAAAAAPMkW2/mta1rWgPpbVVQAAAG2qq9tqqoBrWta1rV1kmpy8a0AAAAAAAAANTIH5rWta1rWta19bVVQAAANW0DYAAAAAAbknetjz8euAAAAAAAC2223JOsk6oa1rWta1rWta1rWgADnOc4AB9bQAYAHOc5zE73nPT328AAAAC2222gLbffffZb73vegAAAfW1VUAAAAAAAAABtqqpPOWXvenp77793ve973vQAAFttttAW223cyd5IS36ykt737PsAAAAAAAAAAy2qq7jbV2qAAABtz3jvfe99e+/d6AAAAW2220AAd73vegAAAAAAAfW1VUAAADIqqABlks/gSyst8ltk1LL5JZfMmTrJk5znN85znwAAAAW2sBoAA8yTmSTM5znOcu973ve97VVVVVV/W3MzMzFVVVVVVd73ve9+zJMbZMnmTJfvvvN/ffffAAttttoC2222gADUyMk76B36W3MzMzMtuZmZmKqqqrltzMzMxVVVVVVVVVy26fdeve/HHJnc89fPf4KWxB7SyXhL766PEso6497779kxOtJ8kwV5CtJ2rAjmUp9VqiO0ulR+Jdk4odUnCaqk4hgrE1G1JxJgTqPqeJ2n1Pydp+/AAAAAAAAHUyAFABbbbbQAC2222gAAAAAABkgAALbbbaAAW2220AAAAAAWZHQAyQABbbbbQAC2222gAAAAAAABZkdAD+LbbbecAAttttoAAAAAAAAD2ZDsFttttAALbbbaAAAAAAAAAG5kHi2222gAFttttAAAAAAHkyeTJymjlPqaPqfE+p9ThPqep4nxPidJ8j5HyOY4oT7H2PsfY+x9jsnlUniahXcnEeJOY9j2PI8k5jJo7k9TqTwqMqypfUsqOfkQPeJLr3fN1eW28AttttoC2222gADkkmTrnec5znNTJMk/jOpMy22272qqqqqq5bczMzMVVVVXszMz333e973vdkmv2pk4P2j620BbbbbQAAAADcyayTkyd5J+yXn33x96qqqqqqr7bczMzMy25mZmZuK7VVVVVVVV15vPed13qe+/e+++8AAAAAAAAS3zzve96qqqqqqr9bczMzMVVVVVVVVVVVUySSSyd73nvvvvZ90aAAAAAAADvdS36WXVt++++++y25mZmYqqsVVVVVVVVVy25mZmZlls9nvvvvvvvstue973uq/kr9fXzSoiGxGABH5r75r58+fPrbfgAAAAAADve97LfPO9735VViqv2TMzMzMmZmZmZMzMzMHxVVVVVVVVTJLL+ll++5oPrbfgAAAAAAAOsk8yT7JmZmec5znOeyT3333333e973tVVVVVVVVVctuZmZmKqqu972amTng0AAAAAAAAANzJuZN5JrJOSTM+yZPs/a/d71VVVVVVXyW7nivEVVVVV9tuZmZmfpmZmZmW3MzMclvvl5vnx9kk159znNXnPgAAAAAAAAfZMn2TJ1mTJ39999zWta1rck8VX8qqu1dqqqqqqqqqq79knvvvvvvuuTl8ttvwAAAAAAAAO8k1kjJOZMn7vnOb+VVVVWKquW3zMzMxiqrFVWKqs0q8XLb5mZmYzw9nfd+++5793ve96AAAAAFttttHeSfSySTX333330VVZ7mZmZk8VUfbb5mZnvu/rJOupJ3bbbu2SddSTu223dsk66knfvvvvvrnltzMzMcskzMxfctvnlt97Nyy7jDRWw71tGMZZZkYuRStkr4vacYrYri0qrrGVX78ud+7nNZW9aKEZlH5mCMQIxAmaTLQrWk1rWowm32TuTi5JrSa0nsmJkmhX6GhqJpOI3EmVLik0mSkxLJDEsJZLEslkslxLJcSyrCWFYl4q4JcJZUYlksliWSpiYCaTUmkxOZNKZJ55mTJ5mTJ5JMnXvffmrVAAAAAAAAAAAAAAFttttAAAAAAAAAAAAAAFttttAAAAAAAAAAAAAAFttttAAAAAAAAAAD+ABwAC2222gAAAAAAAAAAAAAC2222gAAAAAAAAAAAAAC2222gAAAAAD3JO40nMnMnMaTiT7JpOZelcS8V4r6S+pagZLCWyZOsyZP4ySaP13TgAAALbbbaAtttto5kyd5J1kyd5JzJO4p+hLrWH5+ff37jQrQotCCysJU1RVUTTBStKpSoJXve97AD8qqqqq5bczMzMVVVVVXe973ve973t7nuSezJz9rWtW34AAAFttttAW2220bmTvJNzJvJCW/WV+++777ltzMzMxVV3Fdq7lqu1dq7VVVctuZmZmKqqrbVd692a37v9mTJ1o176cAAABbbbbQAADmTJ9kyd/fffffb3ve97stzMzMxVVVVVVVVVyW++SSe++2273ve973veta3zlt1bfgAAAW2sBoAABrJOZMyZ3zjTQANtV+zMVVVVVVVVVctuZ77777ve973ve973vfXuTIwCuAW2220BbbbbQAADzJOgN7VX625mZmYqqqqqqqqq5bcz33333e973vfck3ve/293znA2ALbbbaAttttoAABzJk6knOc5z7VtVeLltzMzMzLbmZmZiqqqqqquraq8VVVUAVyWX9LLyW+2XnPfda5znwFttttAAAAAAbmTvJNzJvJPpmZma493vzNa71rW7av2ZmKqqqqqq6tqrxVVV3ve973ve9731157+u/MmR4a99OAAAAAAAAA5mTJ1znOc+y25mZmZq2qvFVVVVVVVVV33JN73v9ve973ve973ve9lvMBoAAAAAAAAGsk5kyclvkksv6WX9LTz9+/e/lVVVVVVfZbczMzMkkVVVVVVVVVUAMsnuP3mZknfGhXwAAAAAAAAPMk5kkzOwa1rWta4qqqqqq5bczMzMVVVVVVVVVfXd4nNWyssu5Zc5LfMllJbbZ3SdSaThRxJq4CsE0mE0cyeRzJzJpNDSdUmQMl6VwidFR0l0lkulR0UuJcVGJbiWVGEsl0l0liXFRxLiWS5RV1kydd5JMzuTMzM11yXNZ+/d791beAAAFttttALjoAAAAAAALbbbaAAAAAALjoAAAAAAALbbbaAAAAAALjoAAAAAAALbbbaAAAAAALjoAAAH8ADgAFttttAAAAAAFx0AAAAAAAFttttAAAAAAFx0AAAAAAAFttttAAAAAAFz9JkuZMneZMnWSayT3JN5J2lldq+q9qjgnFdq9CZXRJ7Gk6jmTuT7JVgrqPlMn2TJfPfd+nOAAAAAAAAB/GZMn2TJ11Jk666666++7yedZfn5+fn50DpFLQNKlI0CNIhRrUo2sw2NrNVmkmyNKBSpMFBBDVAU0zE1IBRQEyMjCFEVFRBRFVVFEkVE1NFUlNAQStAUIKwQUsRRVVEUUTHvvvvvvqqqqqqquW3MzMzFVVVVVVVVXJbyeOb/eWX9+4fH333e973ve9AAAAAAANTJqZNZJyZOc5z3336yTrqSW223e973vfuSXqW+++++qquW3MzMzFVVVVVVQAN9+6/a7+++vOb94AAAAAAAABzJk+yZOsyZOc5znNyTe97X8qqqqqqqqqqq5bczMzMXe973ve973vlySZms+8+5zm+c4AAAAAAAAD9kneSd5J9kl+tv3333vyqqqq/rbmZmZiqqqqqqqqr225mZmZ7bczMzMft91uftb33pQAAAAAFttttd73ve23Ut+kll+++++++VVVVVVVVVctuZmZmKqqqqqqqquW33vPfO/Oc5vnOAAALbbbaAttttoDmZMn2TJzJPuvvvvvt73ve973ve972qqqq+23MzMzFVVVV3Fdq7sze9+b3vzJms7591809yQAAALbbbaAtt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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack_values']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
