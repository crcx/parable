#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `48 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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XftTWta1rWu/d89iRu7qqAdAAACRvYCNAHbuqrhwOgAD6JPb3v6t7u6qpru/KrWq97rbd3VXO93X3vJ7N3dVWu7OB0AAAJG9gAAk1q7qq1W/N1rVVvTXgQ7RsAAE42Dp726uq1VVd+Sp588558SO8u6qpdcb8CEq43sAAEjewGgCPpLuqrWpvf22ue+nQAI0AXOL888rt6qquvJvWr7VVd75xz18Jy7qqbB0AD0PAT6ObeAADt3VUbARoAnjYfCPNbB079qTmvveTy79ASqVyHuX60gCmAlQCXIY1xmtA2ZfO49e+PbgCVXoCT3TK31c3nHxVy1JcdagSj9AEqnenbrZixvb5187M7MAS97RCTQJdkge5d8dcK5ijIwEmwEsb8b2VPczTjOMzlc3LASu+2U1ec8XzZTNoYyx+itgy5LlVBqVXHQCV3QCTUx+zjYuOrASv113z74OV29ASwBK2QG23IsnL48F54wbN7VNyIEvVvnDwIH2+7d1snn7aqpu10BLR97x9fO0wEp3Kt8Ege+gZyXzGcsc9vt0db32bZvO9nAEuXAytbl3fM7veObgCU7K2874zu4Alezubbt9nNuzlZ1wQK+EvxOdyMfMiSDJSQAgFMJzm8r3u+6kI6/Q9u6qtb5sOlTjYOkqN7ASp45wOkjewHbq6rhwOnTYDZ717uVje3JuRnfZW3NaQHO5uWkg116Zzuq19r2ve/bu6qnvejoAAASN7AAB27qqNgAAACcbB0lclbquzVc+1p7z30kb12cmqq6rmtX5zvte+/aeb+dSBgHgx6EjewD7Q8B52quq8+2pt586e16HvoRoAnGy1rVzXm9Vrnd/feV97de8vPNwnvbJesznbvw6SA8kB3tY6IPAdVt749hx4kBxq7tVHCQl1CpSQHp59dXgOgQZraQEuNICEZW83ee97wDfbuqo+3vg+6AAAE42DpJ2X69989ESTlUvm/OVvze/Na+u6que89HTagOgASN7AABJd1VeOcDoAAATjYOn11Q4BW7uqru91qjwIAHve973t3M9WZeawmNID3rp9u+bqQHuTvgAAAE42Dp92VW975uquq95utV985507I39N3dVWvG3okAAAEjewAAdqrqt/PtPXr5AAABONg6dm5e/px59zx8O8u6qjgdAAACRvYBa1eVzd3VVzQI6bAABONg6Sanuuc9b54JHfW/aq6pzXD50AAAJG9gAAS7qq824HQAAAnGwdJ2pvdU3zgG7uqoB0AAAJG9W22222854oHtzM99nPTZJN+X439pQMlS9l36NICq9u2QdesziSFY9eZ3fc84dZtxAlNK4++QsQic0SRzWgSgCTMnKPGAJRdASm1NdukFNN+YCTvZy6ZoCXIXcNuHtifb5casBLAEvddCvgrgrgr1VORWyf26Fc9CvQrpU+ivor317Fc4K1tQ44imTKnBIXcKKwBLwCVEdgJMk3zR68zSCoCg7vm/fLnLlwVEEeXdVTYOgAABI3sAAHbuqo2AAAAJxsHSVJ7d1Vb3zdbc5wdN3dVQDoAAASN7AAB27qqNgAAACcbta1qUr7Tzt3bl+u7c46VHHWWVUort1UyZTCNmWZXE2PYSNGEZHKTqPPOB7h2rdDG4RSc2m79N0qqapyn0uAgucdlXTjLgNMQNoDWUMKh6j2K9L7VOooTj9LB1UY7kvaIY1WFLVMyW5VS0WUlTQu97Ou1bb4ZxGm1hHA5WyixGyizywnLzFu99V3rKa1Ur9aO0YwCmzMN2iWswUW1GbmrlogxbwXDOXdhGckNp52zlcpnu8VntlkeVH4JC1ZFg3UMp8qmm6tkCqhsirtMqNjVPNg/HDmTWzW7cZJCuM3haOFpsbJjlDlwc2429ZUyr5tea8HZj1I4xCjIbGJvKR6zWTdrzXLgD5HVF2RjaZzR1GjzRGwcOce2mS6lPsrRqA7slFMkQ2bF7e1OPhXuwVEyhj3TjKWb6SinRyGYzjDJdNPrKshSuU07cCUqyXV1rEHtiXXxpiGzlOcLjNib1Oju3QA256cruWw24GMuq9SqmO216+VWVUmyV1mxzTdGyqcNg3BkpTa2pW7pgFtdO4t5WWa+rIDYPc3tkrEwbeFXLUqWRhUqhmODq6qSSHCyjbp1nItTsVMpnC8ttx2ckht1ebg1RrIZr2yNGmOSrqcioxuqxozo4Y3Vw7ZhcuBEk25Br1iSsbRcKPLaunCEuiDH05D0ukSgmBnA1g7Xu9qIYrecIqLQF2WUOPIRuWglMeQ8Ue9OVnnOcrRsXXDAbzFhZzCdZbNRxznjbrrbhTMLZ0w0a7mLTZVa6ZtFLiOEO6XwlLlVuYaZajVRomMMa9XMJuDfLM3vNRzSpChD1zlpvoao5UznNGM7UfdTK9XfO7unXXhheR4Xd5jWJjqDZfHkrFYKDa1qsZxzLyJRikcG4DbbZTnGY65JrhfKrlwptyI48uKDJIcqOJE1slLHuKJtuDID147ZyqyxspkZunKYMtmcC64zONXXKqk6KY2OZbpttsbbbbj2Ssp0EGrNyu4ereeqjIk2n31cqiQ9awv0LdrjJnFpYi2l52jEnDhMOXlXWNSuujMBBDlggtwEFuu9zfd973ve97wEjewAAdu6qjYAAAAnGwdPvq1XdV7GvPPTpu7qqAdAADASN7YAAO3dVRsAAAATjYO+93ECWxg+enqvPe97iH7axIB2/A6eVPXzeVnOJ366tst1mLvKSAy9u7M9Xs6e5voAAdu6qjYAAKBbbecgTmvpihyKCWeec5bl+1bu225QA1d1VAEbr0PDoAG/Q8OgAe3dVQeAAD3vft3dVUu65q6ur6355870ADegEAAqrqgLWtat72AE9bHoAAAEryT75976SR9z27qqHr10AAAJG9gAA1vt3VUbDsAAAE42Dp333db+53ej7nn3w+5VXVDwdAAACRvYAD7s+u6qp5VfSvJret3V1X3fK85rab59192JxWwdJ9ydlb7vx33zvUj7lVdUPB0ABQAkb2AADW+3dVRsOwAAtttuburbb9b5oBfOALr7ezk9zYI7G06ICDoCT0EEhoCTh2q9U07oCVcalgJWUcesO16i+AJSmarJndEi3T+0Dn30K6t95FdivQr3CunfrsV33wV1x0K6FcqObCvoEnftvBLWWciUQCSvsu+73vfdXLBA48HQAAAkb2AADW+3dVRsOwAC1q17sPT6p3Td87NeF3VVznbb372TsjW6q6oB2AAACRvYAAO3dVRsAAAAd4cDpvna3qarUrfvtce+8Pod5dXVao2HQAAA7RsAAFdrWuarjd3VVNbb4JHY1sAAHeE757zl1dXVK5r6d8vnaq6rnPep9AAAB2jYAAEqrqvtuHodNgAA7XvV73vc97qs6s05t1LMbL3xCVHIOoaPHV7JvubTqu57CaS04bb5LrOb7vr2rSKqVK25z112AAADtGzABgfdu6quHPAgAAA7xd22/W6QXFQioeoLEFzaCwApAl2qbIwSbEmIiSjZCRuNwSlRyK+ezc76Y3THGzT3FcJeq91H2K5Fe6jRWivkV62OXzhtcx1tqc3OkVyK7ivjQ52iu8es5zrdfWkeor5CvUVuIfIrRXvuqGetPmuc0V6FeorouPsTVHfVz30/t7hW2FaKimt62QCgj6yKhtBOZ8ADoy3l+RDl3VVosOgAdo2AACS7qqb2AAAAO8OHvc97vObGq2rqIttjbZicYDbGUzJVGB4EAjDwkgxJAxBeEXRl5lUzlxW+XHd0LHQoPlJAetJBBBXOVXN3sbu6qgHQAAA7RsAAHbuqo2AAAAO8er3ve571cvsHT5did3bt1HjjMUcnYPHz7r3z312Ru7qqAdB6843d1Vee9nNztffbkAACXdVWmwAAAB3hwOnfo7x5Xt+73zx8N3dVQDoAAAdo2AADt3VUbAAAAHeHA6TvkIL9zGxYGkVXRZ5CBwcfNyr9z3vS7qqAdAAAFfVznB8A7d1VGwAAAB3hwOk4Zd0t48yynHRR2Qu1oCT41YCTOWQ7hEuy373dASbVgJOAJbO3Mq+srBXHUvorsVx8766fBXZ0K1LqBKuWxbRtXJ4y+c8t96yr5c3nu+iQHgOgAAB2jYAAAAACcuXV1Tmw6AB0YgXMoBKmx0Pzj1IDpLtz1X7vPe5o4AACquq2A6AHHO975VXVfV9Xe88AB7d1VB4AAOaqfaqb9V549RAAb0AgAEm7uqre29gAA2A6ABvwHroAE97Wu7nLuqp7zz30AA6bAfDgAAbjRbfrbbbbWnyge7BDgIZ7qKBmgQZAQY6BBe3TlSXU8hA7QgcQgcQg3KtCCpaEDpCBxIw9QB5CYBPlAgOlYjACagP2z7mt5mfW3XnNjx86AB2c8u6qtteB2I0AbAdAMHenOGAAO3NVCBJA+xQN7CzW/LbbbbbbbzH3FCuevfPDqO6OAAAAAAKq6rpsB8OAbAdNgOgATm+1Hu+CAfd8rfNVv7Xmqu3lfV194nLuqr2dHwe6D0AA54D34AB5d1VA9Dy7q79utXd1fdXdVf3e/c+6J66gAOqbAAAqrqgAAAAd9OHoAB5d1VdNnoTV1V2VtzzzgAAdU2AAD5VXVHAt+C3VttttaaPsdiRE+PPPeIhPUQykIHEILSA20IM9XIhetnty88BXznzkp8FeqHwj2KwrCve+T25XWcld5htmrlkFSGYVxC8AJYArr2K/s3xXX18Cvgr104oxHBXYrgvgr6Rx7yd8cFfO/cV0itFehX8K+udguwrRWqPorRW/uort2lcRWlPn8ECbOIDgBEghneIRSFLMQg5c2IQXzOoQbnEIGkBrdnJyvVlQ7PV2/Svqqr1q7rzz3z34PdB6AAeXdVQPQ972c8733V3VVp93nXegAdU2AABVXVAAAOmwAAAB304eh9NcceBAAAB5d1VdjWz0AA6bAcA+AAd+OPAAB894SYV/CuCuNI4K9CsK9iuCvgrgr+FYV7Re89Nw0sxzFckBoEbAQNAllJAe571Sd7A2A6fDgAAdjWwAAS7qqaAAAAD3uK/hXBX8K+Cu4rCvYroV2K+CtFfBXsVhXQr5Cu/gr2FfRXwuhXsV2K9exXwV0K7FehXr0K9/PYrsV62Hdd7y9YTCDgx1R3K7d3pRgCUAEpVVV39VVd937Urzz193qAAAAAAAAAAAAW222222223YgvA5FF9UX0FdFXd6u6u9Xeruqrpvz5JAAdNgAA7Gtg5XOcJd1VRvYAANAEAB9XnZ2vrurvl3VV99XOPt+OxAAd4cDoAAAAB7y7qqD0zM54D37AAXN3Vtt+t4P2gV0fDVF+UXerzft5a3d1VAOgAABvpsOgAAAAHbuqo2AoHN++ee3dXflffe89HW9AIABVXVAAoAAB3448AAE+u6qtNHgKACfVqu3XJUu6u9qL9okJBBYAum8939y/W/S3dtttADuruqrlngdFAAAO/HHgAAefXdVWpxt6+HfDg5bVF3q2ILwBfQF+x3PeALvfM+ymc7DnJXIqASYCVgJXDvgEuAJaie019dfwr0K4++hXBXoVhXBB+yxyJryBrWs3579mXAEGy22237RwAAFVdUcrnnffTw6cA+AAd9OHoAB9Xm5z27qq+u6qnj17OgAbAdAA7GtgAA7Uu6qtU3sAAAtttv27d22/WmyQBYAv308UXRb5siN3dVXoeHQAAA96beAADt3VUbAAAAIbN63eAcwg60eDpRaotRZ5rfttxu7qqAdAAADfTYdAA7d1VGwAAAB7wPTpLu6rVdccA3d1VAOgAAB2jYAAO3dVRsAAAAboB07Jy7q7c88A3d1VbASI0AfDhyuc4GwHSgA6bAAB2jYDii8PMUXgK4oF3rnLz635QMLNWgAD4cA6bAAB2jYAAAAADdVd2u6u/LuruXdVW2x90ADpsAAAAfDgAAAGByvd+Ty237t5rxFeKLBRYouy278vLiXdVTQAAGwHQAN9Nh0AAAAA7d1VG1ttv13YgtCoulF2Cu+Ir7vnnLR4D0AA2oDoACquqAHTYAAJ42HwA973nztCQe9AAIQBJtuXO+mzObfKMvTcOcVJh4MzAEmToCU8CCAJRHoV6ivgrr2K/v7iL4i7vorU+AL6AtdwT32gj9yL8AKu1A9+rM33O990JeUhEwiEEuAEaQgV+nvPfpHgPQ5XOc3GgdAAAAAAAAD6uXdVWpd1Va59zxt8+dOmwAAdjWwAAS7qqaAAAADvhwvLbbbbbbxMo64osPlF0Kpvy+3nwADpsAAEpoAACXdVTQAA415554ABFXd1dSdq933z15870ADd3VUA6ABsB0ACdbcAAD67qqHAAAnaul3V3zytVrVVV3qqq7l3V395876dgAJpsAACquqAAANgOgAT1segAF/au6u5VXd7r67qqcePQAAOVvm5vfvtduqvvPPe/IEu6qmgAAAA74cHwADmq1N3Uu6qp5d1VPfPD4ABsB0AAANxoHQAAAADsu6qvG+B0vk6qru9uHw2A6dNgAA6psAACquqAOc5wADmgOn1DgG7uqoB0ADYDoAHaNgAAAAAZuVUu6qvnOHrrJXLurtsHQANqA6ABKpVXVaAAAADvpw9AAHt3VVoPfe97vauu+AS0ShmXnR+3re2da8oAlFVYAlnKNASwBKxGCBWLzEsEnTKq77vauTvPeObr7333zwblAdAAAAAOAfDYDpoAigAlzW3t3VVrngdCrrxfleecCG7aqbbDpKqebmq3tzzg6bv3Wg8Om6m9+vB66dd9/w+79yd3zJn3cABrxvc42ekABGgCNAEaAI0ARoeee657z3lbbccb43y7u7vWrq6zL59zx+mkTznOU4CEuZbalW0Ado1rYDujgAAJVTd3VU5wAAGwHQAN+h4dAA+l7127qqbe+Am2wI2A6AB1TYAAKVV1QAADYDpQAABXKA5znPhz3vlb797d1VHffn3Y98D18PQ8BQAABXw4AAHb7d1VRrnAO1V1WjgDpsB02A+HAAAitAAAT7tdVV1Xjz30AAoLbbefBIKhoVXSkDj6guq6xCCVnpFer5w79Tk+xXLi0VxxSW+Ql2Y79drnL710xFc1bUV7vfylcvWqbFHU6Ur1y9JWjqK7X3tz3nd0zm0OndU9RXqK1sFd1ztK9aqT13fNOz3Uc+VHfJoXQAWsQIxCNQ2AIu/QkbI9slZwh37ivvD1FfGeu+kV1kVzMK77YVoB3cmOtyf0RiAC017tI0tAl6CSRhRb7hBxyoDtKgvj8Pl9kJCQmzD0Fd+ffSoL1Fdq95jG2hvb+1A9OcKuTp/cnedvddVZK1w9hdPi2XbSrvVVd32qq6r3tffb+8n0h02AACtAEG+a1d1Vc4BGwHTYDpQAABXeUqXqruqvVXqq7v6zfEaS7pXP7Iru44pXWrvsIILxQeILsfDnOfe37mZbbbbbfPFqqB98AA9DwHoeAACvhwAAPruqrtG+AamqoQRAkyxxc9mcaEk4tVJyFMCmkCINuAJMYJEiQJeYOiFEacOnJ33Tlu9cc41FdporkV6k0laqeym7NFamWS/t7itNfdyj3FbiT297CtFbCsK26dXxHqQ9V0vXU0VyKOPr3O0Z6lPT7Y3OIrtrkVjduHYi+AAeTaAEQA4883zPvsy5ZbbbbQAUAHTYDpsB4D0PhwN81zhSgBzV1V3qrn/tV3dVc2CANpRWyFsI2iqpbSW0g2SjYpVtItpK2oKbJS2hG0SszWmTTZsps2JG0S2hU2VBtE2Sg2VST/H/yS/0v9H/D/837q/lfHv+bn8mxV/FNvv77/d/g+fz/yl0ZvxVU18fGP5Vx/z/XnmT9f6/2fj+sPzghfsvWhFuz9r1XLMhCM5lZx1g4j9v7fe07pxvstPGKA4RO7c7s6+8QcYihPgdnPRFXu1xzG3IMmHubmbtFTttsZdb27s77PYYezh5+7znuVp3KGmUkgRSlDcbKGiukqtlFbRW+lN897b7jzJj971WxJrzzyXqtVlXR7uHrONetHWF2EIxMKAiQMPOclsbZslsjAY2MESRAMiZO+/L/T+ImT6R78/2tiEvp/VH3JWad4c511KP0nviV1ton+M0H1pCUL3c361PslXw6DG+MEGUMcbaTcByQBxz7N+PVCReGSXVmguoEu+4K+6K/Nvv9FdQjrW0NmwSKQYIsUQCOZ7efr+xFEvdIJpbaoyq0VpB3o9dSf2OkGG222tsYpNqK/Q3Ob93ygd79nacioRFZ6ILNeW27+ulA5cAVQt17q2297dRVG91rvbbcfYoviT+onNmstbpwVyK2R/KiaITTrUVUNMDWu33V+toi9gI+97l3VVmb79mSqu7e700Bm2a8wJ8xVVZ6gvdd73vO97n6SQBJPxNA4QUnyhLx155689+eeffNFfqV6/n6kugOmgvsnuv+v399+zveGflRg6UXs1Lby24gud2bJJJy8aTYk2mvgOHTp1JeJpN4CLSDJCLIfEEF19q33zltoINdm2zEag+4Fe6jQ5YOEF7pA2QhBEE881u3y2/KKpsxRE14GoQRd7ztt5lwBeEVUfb7u39Pv3T1eNJueST9Pg7/FVVtttt+fX9Fq5PAKuruNAHTckkz9n79+/c/fv3789Dw4ceiPejgH7uZzOD0desz9+/fv379+7mZmBJUkwEaAOmwP2fAcACezved73vJ5OTySe/SU8ADh+CbP0kk+lNAAAqyoAAKNAgAACGHgeHMD9fcPD9070P3fbTOXlvl/W2/vcaugehraA4aXxq4nbtu+5y3hi9STQsWHOByBw+OWpNvfNxZ53fPMS3MSWpJ2rhtzW25Fc5zjeKlC51vM8z3raeXEsbSWLJJ5JJPZiYswDwA8MOrUvMS4a14k0je537vO5359PA0DgAeoxL9JPPLrZiA4W2+3Lbb7a7b7a7y28ttvty22+26rdS/b99xpqbi98aSeppuJJptNpN7777JJfbVttvltt9rEZjzEmPjgxtxr4aVNtsH1xDTTStNjkltOjNsMzYbNJtTarNbDbZubjOuc1VjY1ratvHHFmm3TnOa3HGVmls1Y2bNppqnBxmMGMYYxz5jWc5mbfb++2/lstv622+3KrqVutZi9kk89TaT73toACSSQASgHgB6W2+0A9DWvu7ud73vnegel8+6fl66mk29fL7z9bK/V57qkk89/SS/vQA9PgIpJJ3vZR/ZmZm3xctv1tvW4/RW1W22EvsVnIrVTRPGk1mSQAOpzMwAkkkzMVzSgAHqAp6AWJowJJJ9+/UWJJvzEk3jSw0/X63y3rabM+vL5e34Ce5JIffFt9tt/dne6UD9nNIcRgcRhxGP5GH79+/eFygHqTDWAAAUPrPfmn3ns55JLZJLf3e973vX555/XUDnA9X5H+NVBBkUN671fpn8fxzd/jk+lk/STkkAPgIkmxJN4mLIdtlulAtuALQF7pRE1P2tfs/W22STsxtJSSUAADhJJP0knkkk9kNDlVttpbT9lwqbaTy39bbaAaGtpIAnskkkq1SSST6GJNK4gAA6ULaAGtpudUkodAkkkkyTW0lJJJ+kLxtN2222yWd7WzxJN1NNJJ5u+W0PzaS/Z3uHmtpKSSU+DdDW0kE/dz3ve+d6Sn5AAfg4k255PpNSaU+koAQwNbSQAAdk73ve96SpGW231K2239VzNSi1XQAhBmJq3W7duW2+GGGGGBqmJygepAFv5K4AAATve973pIAfgEHGk2IaaTb8WNYtW9W6Hl+uX1qIz0QXVt9vLb2oonqKfaQWTvuu997936/kE6AwkLCz+JIPYvZ2fKR/aJDWRPpuAjN5/HF+TVVENor/BTq21rWbWNZmbZ3jrTnFAoc5zaCodiKPv338X0FbdKIlhbV3V1VNXV1V2Dz2rq72HwADluZ994KqimjIHhz4RUzgiey59y8+/PXsiEpzEgX9lSJfSIPIQT3ve759dsauQcYUmNogxuM54w83Qxw1zeOYYOODhwzDOA2EbGhtsrYVcG00Nporsp2XIooxxscGpBkbVOUyRwG222NxiphGR+3cgJJHXrDnO9vvu973vEhKgAkEJECSCgZATIILczmZDcmaNYZtlmy0bajGybbbLamMabbbZttLYmraY2zXyMlAnfe9nuekKkxqdHALGXKE1Gqddd1ajdU2im2EqKVBqpJJAIyOGUKQqqCRQqruggOqKY6jq03RAaG20222CaBjZTXZFjRMZFskkIwG2aQbbbuEbYNWNjiWWUom3lOWZFbRkkbZdA6qNqQbENxpS4iQYh0FDqihupAobdu3Tg4gbG21ZE4y6uxxuqjKkHUhYx1MyDG2XcbEqT9LGhUwLg4VQ06JE22MZGYSU1aHUI1VoEkUrqW7qU22mCCVy/fToB7VNXV1Zy6q+SST6qi/tVJyb3vve99x3nRHnnvSTPZ73HliPHoZ70k33vHBHWd72Sd73pwR1ne9knfAHvTx0R5nvN726JV01Q3vaSdq6b05Q3vY+q66+c5JOc5qRx85ySc6Ad7PdEcBDdtNtQEk2ISA7IOKk2NMI2McISSBBobIwUdDMaL2QkcIS5Q22MarM04a2nNxlmm25uWy222bJsbWxrbW220c1zRrbTmd5znHWLbZs2nrQ71HNLmCbSrai2JTppznHWKp1jrripLm61sir1kcakdspsrYRzWGzKU5aFskuYmNtzXKjKtoXNLYlHGDaWmZc5yGyTFbSWwq2JTO+I4bFznLnHKmTaVo9cqU65xXU2d65tVdaXVWVGautdduM3LjZzltzmNzOMr1iv7HvAcwHdi62a25rvvrq6I5FTkdZXek3Y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pRkWC2sP2ptTYtk2pzUObmOc4nMWybCUeYquqSZJQ0VqAsVNVTBLITRMyK64UjahE/fvOdXWqV55wleeedSRP2ofsnOcTYtk2TZOc4m5xNzibSq8111zkLTSW42mwu85bfLdSTcxNGbjazE1uNjmk3OJzFsmyc5yk4XNwbFVeaSumSjzzz3112d6k885Feeefu6bFsmxbJtTYtk2TfuVCaKxBorQo81VRzCE63JU1iNsyK0o0VlVmqrmhDkVpVYVqiPPPOc6qutJXnnKSeeedUqvv7ibU2TZOc4nOcTjnC2LYthAeZSOorKi6Yk8885zqU60KrzPPPPO0H6K1CzJWitUT9i2TnOXNc1NqbU2ptTamypWqq7181H9iHrPXvgJcnr1xdywrtSnmVVeYqPNUe8A+ecRJ5oVeaV+wr8FfMK4BH7AHWKl+ySftUEdZUl+1RH7FI/ZUfsUu800oEyqq7I0GYdTLuqo3VXVW6UtxENnvUQ0d73t+73AF81QQigMtttoIW4CG+z6dh5D1RE6aO7OQ7DsPe6O91bbUqqczNIL2229+bZJJBJNgAeIAEn7uSST2TU0kl3JUleAtUzQ81VUuRWSW2htrCtWisldZyYgjJWiNmMbaK0SPPPOc6VS61VdmFbbJtampTbZSeecqSeeedES9pWkq/am1NqbU2ptTam1NqbJVGpuRWVV5iq5FYlRYVtqlNDQqbRImFYSLRWAPPPOddahdYlPN5orzPM8+8oGyDaJsVF+0qjhlaK1JaK0JoreYBzVrGZorENNSVirU8yV553312rvJHdqK1ttpGs2StltszTbNmza0eaK80V5551JT9qbU2ptTam1NqbU2psiSau942m8xJpp23d3njzMy3iTSbtp5Tam1NqbU2ptTam1Nl8ykmis0VqtFYkNCtNFbVTNFbIrIrRWpomUmisQaGV5qkpcFaKutUinmoPPOudUU6yi8yeaVDzzzpfhWog/am1NqbU2ptTam1NqbSoOZQWFZorJJeZAuCtRFtFYVtFaVS0NIutJyFpWxhWm1ZtlZFajYaK0xtFaUtI1UTRNSGitorNFbVB5yo88651STrS7tBYzNmstZmNsC8zzVFPPPOnuJkftTam1NqbU2psptVJLzIqXQrbRNUapSyK63LUkwUaK2RWkaFZK2iViNQmittSNFaKsK0B5orzzrrrRV1iJeZSl5iSeeefYruBbYVqEv2g2cxzU2ptTam1NiInmhE6itsaK1FXWKuRWKReeec76688888+pU/am1NqbU2ptTam1NqbIK8ypPxCaCtFY0lsdZxjMZm1Y8zzzrrrrvrDNNtmybDbDzPPPOnqZ5pVcqMqsis/am1NqbU2ptTYbcw5qbKB5uilpVorUGisqsJkra20VqlOuQ5eeec51U68888890h+1NqbU2ptTam1NqbU2L1x73n9u/Pg+d+xSvPOILkbff3goD+7obARU8iKB7EsFVsGxBFsUXkbe98B7BFne971MTM3mZkzM6wHtXd0VOVQH1F3eASZRy6u6q6knLqZd1d7pqysBfU033Gk31EkkhAAAG0k0AAACSbDgAfmmm0HRNIxtpJVJN5+xqrannnnOdLrRXnnnnn33Tam1NqbU2ptTam1NlVeYS5pSNoh+15orzzvp1gOsVXmVJ5lK8855qp+x+zmptTam1NqbU2ptTaKjiKxV5qOSXTzzznfXXrzzzzz97ptTam1NqbU2ps2sxtZjTuoV8t5u220jazG1mNrMaWz9lzU2ptTamxcit508889ddc63nnnnn33Tam1NqbU2ptTam1LMbRqt81pN2+btttBtZjazG1mNrMptTamy/c5TYDm1S0286ed90PPO+us688888/fKbU2ptTam1Nm1mNrMbWY00ndQG3nLbbK2sxtZjbamyb7xOZOY5qbJuclNvOnlu7tttJdTW4txLcSeYmsxNZuptrd1NbjazEnmNO6rbu7bbeiay60k93U3NTYtk2Tc5Kc5xOamlC8nsRyCLIIKb3xA1vved7mZn6WKLdG6q6urDxQJJ2akkMqqu8yZ5VVdg9qicAM73verqruTGcqqCe5VXVC6uq4k73u6q6q773qR0AASSTf07M5sk+AR03dAAmJrMTWYmsxN5yubmHNTam1NqeceeevVDzvvrrzzzzz98ptTam1NqbU2ptTaazE3dQG3nLe208bWY2sxtZjazG1mNrMbWY2sxKYtxtXVbd3bbb0bWY2sikikikikikikikiPdHe91rXe973OqSKSKSKSKSKSKSKSKSNo1AbugB0bWY0sxXE9xtZjazG1mptTam1POPPPXqh5u++XWeZ55y8x5v2ptTam1NqbU2ptTamzTuoD3l88ttoNrMbWY2sxtZjazE5vKbU2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DX32n6FJYnqb2IfaBD7fkBGu9Zk+q6uroPKqge1SgBGg3JJ9PP3e98734Qk0gAPk2gbAQASQ5dVdyST2TMSeXVySYZmABmZnqTSAD0EAAADBAVfnmNZizE8xbRbDZGyrYto2VsK2ooTMG21WzM2qzGajZsts1sG2zMMxmU2d9yOd237+Zww5zOc5luxhgAAd/M1zDGGzMTYedvPXnr3qG77788888+wAABy7kk27bbfbAAAHLuX5NSSSdAAAZ1ieZPJqSSToAADJudk1JJJ0AABNzsl/eczM+fMzmZ8vy235kAAAXckm7fLbbYAAAu5bG7JJJ0AyjQ5dyW6ttsDzXykE2o1JISJASONt/EQJeaBL8533znfbqecus0Tb1u888887pX9qpBmZsATIguZn6+lIWW6UCwUtt8jSSST6c8STz6vsa5V3Vb3Wzl3VU8pxN7N1JJKLfhppbxYsQB78uhr5Eml7w91eGpNNmI7od756ppwxrTwDW1xJtJJyKC5LuzOZn3YY/cBC7t8tt88ttn79JFJJJPm21Dp4jhuAB0WK7uZmZdyW/v7zmZnzy22z0AAC3zJs27bbe0AABnZ3Xe9733oAAHS75k+TUkk96AAAz3vd3e973vvQAAJuSS/vOZmfPny22zoAADO97u7JJJ2AAAMkm7ve9733oAAHLuSTd2SSewAAD5ucznMzWZnMzH3dfGffKzpr9T1b7l8SaSfm2eNNP98X73ud73ve2dkACkkmCe4PJPNd73zqa/Gfsz9+/fv2Zma7MzO5mcZJJ99813uSCANgd+973veu973skydm7skk9gAAHLjjL5lt/M/fm7nOZnxnxXOVltnwAADsy/MtPy22+0AACbVv5888kknegAAcmxJ5uyST2AAAZNib82SSTvoAAH2X5V39+OczMZ5v6r5b5bsAAAfvMDL5V1fy222AAAMu1dWSSewAADPqeRNfkkk9gu5uvMeY8xY7+1cXFttt7e97ne9731dsXIo4B8UAJ5JJ97JySYBmXmABJJJLq6qQSe1V1U1JuSABJJO973ve/dySTYNpoDDcDoHbiqzGxnOUNxzZsPOc8550nWnrJOtea+aldvHcuNC91JpbubmLHuvVq1O8uXV/bbb39vOZmNzTHGuczM3W4qrq/ltt7l+85mZutxzTm5fKurbbfbdAAXaurbbfYAABNib8rnMzPFVbbPwAAC7U1Lbbe0AAC7V1ZJJ7AAAOTYmpJJPYAAAz7vufv787+5mc53ta3zte972+5JJ7hJjYERQAKAE8kk87NSSSSSo6bAOEk9n1VdVG5uTvepJIAONADySTzve97JImpJJPYAABnOZNib8rnMzPLbbZ6AABncXyrq/ttt7QAALtXVkknsAAA5Niakkn3oAAEnkTUkk+wAADu9d+eXeczM8knyTvgAAE2O67JJPYAABb5V1ZJPsAAA53eu673vez2AAARHP3mefPkkn2e++vfffffz2d87nd73bqrsHpRGg7zve98yTI160Om8JJJJhJIJMF1dUn0xzD0PAO9733333333ffe973s9kTUkknsAAA2b5E2/OczM8u8y235ZoAAG3ypPN222ztAAA2+VdWSTv57ABlGmfF8q6+22yc65c3eY3c3N3nMzN1oHl8q6ttvfZjmVoHl8q7+/vOZmeW22z0AADb5U1LbbO0MMOG3yrqySd9gAAGsnkTUkknsAAA3ec5nJ7vLq7zVb5qvPa815v2s8+vMzBpJJMc8ih786bqrqigDva73Kk3O1N5ee1u7qq3VNL1cAA+UzMI2kvOeHMSaXDwD4N/dSuqaJJJWNSeUPqns+kwZ3M7VXVZ5meekA99SaQfSezySSAAdDcNwADpmAABs3yJ5nl3M5meLbbZ9AAA2+VNSW2ztAAA2+VdWyTvsAAA1k8iakkk9gAAGzyJqSSd9gG7oAbN8ibfnOZmeW239zLNAAA2+VNSW2ztAAA2+VdWyTvsAAAzU8iakkk9gAAHIvNKmuvrUaSuRRiQ2gTkukRKL43zPfszMGgCKABQB3ve973psRo6SQfszMk5meZh5d1Vdbkk/UGNszB0DMzMwAMzMzJmb1NSST70AACZN8j5PL+c5mZ5bbZ9AAAuxZ4k+W29oAAH7nOZfLS2SfYAABh3e9O973v3oAALqeSEkn7Lt4cMcrGNxVvzfzeczM8ttnfXoAAZd5lW7u2+232gAATZCTve/egAAc7vWZzM7rve9s9gAZmZmZmL39ybw98OJNI/fgD4MAAIuxQAKAO973vcqbmDpBmZh4D0kkkl1dVJhuSSTKKZmZmZmY2A6E8au6qu8OPcZrNZvWZmOta1rWtaAMd3N7m8rnMzJNkk7+YcALu+3y55JbZe0AABlXLbJJ7AAAOTZCSST2AAeboTY5nMxJJOz2AAATYeXHOZmVbbbPoAAF2wkttvcoAAF20tne/egAAE3ZshJJPvQAAMfZ739x83nj8+fM+fnzNe++5ncDQkk7KkgBRGg73ve9yqkzdAOmZmZjMzM8zMeQJJPvvne5JgAkkkknoeAzMzNazMOtAAA7vXM5md2/nOZmed7ZO/QAALvKscS2T7kAAA7veuJk73v3OgAAZ+u+d6472zs9gAADIkYk9knsAGUaS+bfz85zMzbbbfuZHOHWGaZubutxzdyZ9v54rnMzF+22/fy7zd5nMxppgxNBaAHoasWPNxJpbubmLMRoKpNK2+ef35p5ubbbb189+fz0laKwrCuYV3grrCt+5zO8R73rqK4K6+ef37+EnsSYV196FeddxXP3OCrABKVPgASYgWz4owpkbMkTBjkRHxNuXyDASdU1oFAJYWAk3Jfp83T2NrbCfPe+OdKPQriLq4JSJHGIcFGN0AllC5x4qCwEoAlvekFw6wzSK676bTz3376mtd7593OfcoIHr8fD6zoQaUakcI9p3XuV7vffHxqUDV3d1Va0AhVXdXXLvUkk+kgAJJJSSd73udaaS73vZJ2ABDBGNpIAIF1vQCCckknv2XdVdeVdvt3sP3A++DPzaaeJ5/EgAQw+kySTs7M7KBKqXdXeqrUkqSQprRGgVVXV0aDboBdS3mZr77PkRcIqpvWsvLbvHaNvQ8a9uqug+9D32g54Dk5Uc3uT6djpoCiKABQOm0aSSSfSbAAJJJJIAAADYG3TQ7JOySQBQAjQa0HTYD5NySSeweA8B+VVXeazOAz4bAdUHec98MUk2c38SbJ8CSbA6AeTve+d73pBpNh3vene9p9brdltt6cAVsnmnyACaiCS5iW4tx7iOAB0+++++++OjADhwxAXlZVXVbSd773rMzMzMD3vd973vTYdN9SSSSQAEqrqtZVXd681rd3VVVX377z7nc7222221oBsikiIxmZmZzM6oEkkkX7FPesk8k6uknoINbSR6AGZhJJMDKzMzMwAMzMuqu+93VVbYKDAFgIL3Xffe97cTMzMzO2220bSST6SKsASqXVVVgCqy8S0AAIuZOffffvvRd6AAEaaRgEkkn7GtknoAQQAHga2kgEeAAAHe973ttPKiFRCohVOeeeeXl6dtttAne973vbtAAG6qrl1dVLq6rPMTT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cDWY0YkpiShqR+SaWpogWWHl+tt72gAp2IvYIp2Pe9ndCaWAAdtaaW7m5ix7raS3c3MLzcvvr5mZtttv3udYxhoF2rlt9tve0AAC74uW2SfYAABncTzxMkkk+wAACbEySST7AAAJsTeZzMv5zmZnltts9AAAu1NSS23tAAAu1ctsk+zDDgHRPPEySST7AANa1rWvMivL59r7PfsxjMzM3mCZ00eggA72u+97vvXLknZr3KAAZmYfSbku6kk8qqvypdXVbrYc99ZmZmYBgSSZNzue6urp7VXVecHvTSgO5oAAE2JuZzMX85zMy222fQAALtXUktt7QAAO5fKtsk/YAAB6O+eTUkkn2AAATZNSSSfYAABNk3dv5zmZltts+gAAXYd72ST2AAAWvKW2SfYAAByb073ve9+9AAAmPzzvfz8zM5zx2/1fe+193977773939+DZJJ9JqQCKBJPvvvvvqu9J3ve972ylttrtD0Ced73v3xJJIAAGbCT6eZJPMDMzM3qSST7AAAM5G9TfOVzmZlVnLb5+3cgBng05hm3yLvy2228yOPO7q3c3M1Y91bt23fecttt7HdSaW7m4a0Ltu7tttvsxzK0Dl23d22232AAATZN3ZJJPYAABNk3dv5zmZltts+gAAXbd3bbbb2gAAXbd+eeSSSd6AAB+fujZ8kn7+ySZkkmySSd+9670CKAO873ne+5JnZJO97mYAZhmZmZgkgZnuZmZmZkkkkkkkkkmd73s5zmZySTd2SST2AAAcmybuySSewADDJsm7skkns4AAW+W7u/PznMzLbbZ9AAA9xy+W7+eeW229oAAF2Td2SST2AAAcmybuySSewAACbJu7JJJ7AAAJsm7t/OczMtttn0AAC7bt88ty23tAMzMzMzM599fOec9D34OkkmySSB0MAAIoHTdVdV3ve97klTKu6rNjjUkl00tM5kAJ42kv30GmkHvoB6/VO9873vPupJIH1VdUm59UOUPXoeXQoE5mZmSSfPPPJJJPegAATZN3ZJJPYAABybJu7JJJ7AAAJsm7skknsAAAmybu385zMy222fQHut3hw4cMu27+eeW22951jGFC7bu7by232AAAcmybuyZJJ7AAAP2eSbuyST7AAAJk8k3dkkn2AAGZmXOcO7vM0Oe4k0rbZ7JNkkkn0Xe972SRRoD7ve979nk5hzx8PfmBmB6eCj1Lq6qST9JO5q7qqaeH79mfYEkkgASSAAH4A3dJJPpmZmZmZmZgOs3vd3b85zMySSd/QAAPs8k3dl5nMy232gAATZN755JJPYAAByb3u7ve97370AAGCOBu6AHxmZizFmPMmLZN3b42kgCd/QAAJsmzzyXM5mW29oAAF2Td75JJPYAABybO7u973vfvQAAJ575k/J8n2eSTve/u970OqkkkkigDve973JPu43wBmAABpwAD9O9++++DvekkkJJO9kgwD8Y2kuhwkkkkkPQDd0APjMzMzMwAdZve7u35zmZkkks+gAAXbd2+X7mczLbe0AAC7Zu7JJJ7AAAOTZN3Z3ve/egAATJ5Ju7JJPsABlGxmybu/nxQO973t4EgfammBDUIa0oGtTUkndSbu/kuZzMttsxjBjme/b5bu7bbftAAA53e93d73ve2dAAAXN/dDq5+/e++fr77772/UADzhoAHRTvne/TXkmUAd73ve5NzE7NfV53vcwJJzGB6AE6u/fd6Y2kpIAAABJJ3ve9JO9k2TyfI5zMyST5Pz2SbuyST7AAAOs3vd3b85zMySSd/QAAJsm7vZeczMtvl7QAALb8+eeX7JJ3oAAGEk+bs73vZ7AAAJJ83ZJJ96AABMm55Ju7fnOZmW23v6AABJPm72SSewAACSfN2XmczJJ5PYAAGGTZN/fPJJJM64AE/fcnz58OZnMzORgrmiT3utFboj6R1BX91313+t5rfc8y1BcgAt91L9fAF8VSAgcgKlgi373l0+gLIgibgC8n3ssbzq5fOey/efAQaAlAEqlMBLAEmqGuXK9A6wBLJ3c7mngEmCe7SuOGe57nqOV3i6pfHt8YaNK+QebS4wbWOMRQJAFgC+W+9AX73zv3vkQXJ755rE7mYGtAGj7773774B7Xgfc9yhXTAJxQU8muc8+7ne0VEORBdxUrmQthW0y0VqLKpc5ScJTjCXGomLaNi2qW0RrJrFsbWyzE2sitBCILBZLbbcuCLbbbbaKJZbbbbioaBurbmfZiguEQWKrAqwrGRWsVbKRtCtZEgMVUIMUFkzMttuILSW+FtPZVVVW0OmyNAEtepPJJPPO3VKmS2+e220OQRRIiMIkAWILxpNvP4A9PAD802mZ+k2SSSfSZJJ92KSAiw0ulUNTPsMzMuAoWW2ltuAlgABJc+yZmfGRFSALAQbrlaqt6h03Euqq7aHw4lXV00PSTypNIAPAAxNRNNpKSc73v3fW0kpobAdcbB0igAUkkknZoAAkkkkgAyqq7zMzPMzMz0OAfDYkn0mpICKAcCj4CNAHZqSSSfDgHocoHnskehwD5QPd7T2Z09GSquqVVXeazMzMkkkkmYAJJJJIymlViC5NJIguRVd70QukENdJvz3MxUkkkmHDMzPc7WZfkrWq+33fe97ncwAcne9873qABJJPJJHoBGKB0RHcVV5znnvfu97bbbbaYWM+5tOZtUc3DHNsubWt/bjYzWMoAbQ4oDYEImyQcc9RSYMdEaE1JIpGm15kKY221G2lHE2RDd61Xnu/QACXVXZXKSSe87JD4AuVJJ5d1VSSPRmszMzJ37uu973MPsvVaq6u6qszPMzMbkkk+mAB3ve933vbieS71fs5mfYguAAwEcky2233Lb4A73ve970ACSSZVS9XdVd6u7vTZmZmYCSSSSD0x5d1VZveZmeTne+d773MAA72SSpq7qqku6q1XWrqrGfW22wELbbb98CHAF6KIYghoUPvu+dzSgZPu5nbb9bqxQLbbb8gtQWW2220BaAiQBYwiCyAAAboBroCCSSSSNXVVd0ARKqrvPNVnMw78bqrqpJgAB4D0AAAAAABJJJJBGgH0y6qrvPdcyszM7mDgGrursAgAADhu7qqNb73ve/dAAAACgHTdVdV57Khzm/PQBwbUfH0873vO9SAAAAAdNy93qlX1qK1VbhzliG1AasIADJbmZ9nwi5NZltt+xBVstt5b5PDvdXvd6I3x+eZ59994/3wH8L9cVt2+K28X7Vfs+mU5mZgdoA7vfe972s73AJJkkkxoZmZiBdWbMme5mczMzI0Tve9JySQD4kkklRUriuN+YsxZmZmLG2Ta2bWWNo22mxmmZLZZjap5555z0lTrr0Hn791UnsxjM4c45mMYcSedAAAcpdzy3d335zmZltt7+gAATZN3e9kk9gAAE2Td2XmczLJ5PYAABybJv755JJPYAABN73d3ve9796AABMm55Ju7fnOZmW23v6AABNk3d73sk9gAAPmp5Ju7LzOZlt8vt4cMZlGM3L5bu7bbb7lUAA9/O8nOZ45uPOM5f3fPfby2iA+0ACfRd73ve972KSSSRfY2kt5995997996og33G0kL0APRpdEk1JAyzd1dUyruqzWZt03NVckxJ3OND2mvVHfdXdVTbgzRAOrjlbbp7JO/O/d3e+zvfvQAAJk3PJN3b85zMy229/QAAPs8k3dkkn2AAAd3vd3t5nMySeT7AAAM6nk+bskkn2AAATezdkn5O/egAAJk2fd3b+85mZbbe/oAAE2Td2SST2AAATZN3t5nMySeT7AAAM6Zk8nm7skknsG2222222++hKytar4OzjbdwYVubFPfu56w4GwHVSSSSRQB3ve96d6AHoHofgXskAMA5+APpNn3333D77r2ST8AMAACT99dDm97pJ3v3oAAEPeZPk83fy8+Y3nMzKrPLb38AAA/J5Ju/JJJ9gBmY8w2G7rlaaQHATW4gDd0AgJoA3Q8CRdxZiZn7Ti8Pd5fNW4lmNpK5ctvEn+RIbvgACaJDd1StNIDgNr7APN3QABXFmPMbSX11JN+eJJvV3Ek3577tt9nbZJJskkrSaKrLcttpJ1QB2SSSREkkkmYHoZmZkkne97ne9SSSSSSSZmZmZmZgCTPhzezpJRZjqoXf3M/NpK5bb+9aRIbu+42kgAE1+A5u7K00gOAkwDd0AATQBuaASJoQQ33mcutpK23y42gBboAAmiQ3dkkkbVwA3dACNrnZ539VVd7355v3PPM9/fu/gOAfDYDpoBO973v6TMzMzM8u6qjKu6qsz1YJIEkk73qSTASAHQ+qrqknIBJJ3skgboNs6AmogObOeu3W0lcdy5cTVJd0AATVVC7oADa9yd7N2STqa7993d2DbABNAG+TzwvraStvLiatDd2AAJqq23d0ABJ973d1mZmYJfs7m/PVQD8gsRFf0FAfoTpiHr1wl5zlah/f3VR5kS80V5or3ifWWyZrRpFeZQeZda1tY3nEg89ckR5lVeY0m7ibbV7qbabxpNW9tu22zv7vc73veyd+++++++kknZkVDUrmY7ba7b1WgH5AHiABphoAegepLwAJJ3ve97EmmAB+RgASfepNKTiSTXcTST8x/Hd3e9bfSSJqSb3zzyXxtJAHnuZixK0N3fAA9ElUBu6AESfe93d73ve9TVkm7sE2ACaANnvnhfG0lbb4mrQ3dgACaqtt3dAASckm7skkiTuNPGlWftOMs1szE1jc/dUo5x+/fvLbG001cMbbSA420jwrSa8TSttvbbtkk7+73O973sj7jTS+z7H9978b38LGZ5xJpaegH4X7dbSXQBgApI00oJ3MWXLby1a2kst/DTSk+8nZikoE/Tu97+qrqpNyNgbdF3PvJMu7qpqrqvNSY3uyJuACaANnOF+bSVtviatDZzgACaqtDd0ABJySbuySSJqSTd2CbABNAGznLc+bSVtviatDZzgACaqtDd0ABJySbuySSJruJJTE1rup/YuLOJJvEvs98As7bJJOQQAfAaBPpNSSQne673vehPZMp4NVV1WZeAHQOAB9M78vvvvjpISSd73vSSQtttttsm973ve/rIG7oNsAE0AbOcL82krbfE1aGznAAH3FmPMbSWZVbbu7bbRXEwDd0AImpJN3ZU2ACaANnPfC8bSVtviatDZzgACaqtDd0ABJySbuySSJr79Uk2fst+5+93z6+/W9uZmZnMzMx8Ngnvw158OdTtd73veiSTDdDWZWZkzMeZmZntZhJ9JOTDAkkmAABJJJMMze95l3eZmZTQBs5wvzaStt8TVobOcAATVVobugAJOSTd2SSRNQA3dAATRJNW7L+bSQB4mqZdt1HOW22poJNW7KACTANW6AAJozzJiTSJ3iznnnv7zwzv2ZJI4B8Ngn0mpJISTAMZJcki6qhgShyqMzzNXV1WazRuTD09MEzMzMz7MzAAADMwMwAATURgZlufm0lby2/k1bb3dtttqatDMAAG7mYlarcy222pVK23MtttE1EYGYX82krbb6mrbdOctttqatDd0AASYBu6AAJMz9nP32ElewrIsi9829CtFfX9wVd4Ak9x+1AlgCTywEoAAdsBCgCTTYO+yu8rrVsQlvN5fQevvJHTXOnnuee74afgFii6AWd5277s3vm17c7vJnu9dk+awfbNlZIR99Y+ogG0Rk8+vfed73xbFkJEgJ8ADIqEBGIrZFapXJpSOJGkq0To0Mlvlt5bpAAaqfIoHNKiOkF2oGrfLy2+mILFWKKxBZbfLdW3EFA8BG6t8tu7cEBNrBVLrV3VU2eAWPaB5d3VKqroeSR9+pXtFaqhqjX0qHupx1BYIuxCJLfLy21UFaz5BZrN57mZvAV7EVRNxFET5BcC7DyKqGu+e9973O89jAgyApBRGKIlFdCpBFgrIQZpBZqfx3vved73vgJw6mhBkRdIHAmwE3oQWBqW+XfLbwqgsJCECCDAYAtQWT6+XVt9VU3EFwBNQdCCzM+8yczLRK9Qyp9O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ugACVWN5jVtu7ttttvOYBzLYu222zK5nba82375tJW2+Jr3Flpl2222poA3dAAEmEw0AATQTDQABNAG7oX5tJW2+JrQkWeb62k7+1v8NJu9++t6ZcS9+xXH7kV+/ciu5L951FeecivPPg0740m/rbeW2k/STZ3ve/e/Zkz77fsX0k8q0nJPx7TW6q6pmeXmYj4Mwl1dVJP11V3Gq/H7MzH4AAABbTUrSbvLxpN8y23d29ttqaAN3QABJgG7oAAmgDd0AATQBu6F+bSVtvia9tt3dtttqaAN3QABJgG7oAAmgDd0AATQBu6F+SaVtvia5nqSb3Uk3EKeec883y/cz2/re36d73skHocA+GwPZN973zvSnqd7lySTGZgAkrve971IBQAAkkkAA+MbSQaoAbectttqatDd0AASYBu6AANzGaG7oAAmgDfOcC+tpK23xN+227u2221NAG7oBJLjOGGZzMYy23d2222ZWZzMYwSaWK23d2222q4k0sWLMSaWK23d2+e/hHnnnnfrEZmZG++d+JtFdIOoaFUkJGd+vee8AB7EQzfu+eALEJIj+VzBIT5kpnicHMY2h3Btpjpjc7HAEoJB5gI4+MSD2RCewBO+c5z6/G4XQ8huCSBlAXza/T1kkhmHzXXTmazYqfwrAuZK9fPHpPfvpyZvO615fe9Ps950Rc7s2bmTe0NamgFgieCKHd+c87nM72gIezSgRG7urrurqrv7R46olXV1YbBHQLgqgFuoW7tvLeAip6e6ABhp0VV3bXw+6RojRJVSSSQltAlJbxRElzeZzM11RSb3fpe9873mZeeCDBUPPaggeKBEQHfOee+eO/5d7e523u+y22+W23223dvwKiPFQiOTOeZmsy4IDZb9bLb7gCyMVCCAwQhZfL7lLeYKoVRYCslttpbmi6D6amq7VXdVNSSIb8+9/VV3dZme53v2Zi7q6u6Vvew9knLqrtoHgPQ4B8NgOmpKkknZQABwB3TpsBzKqrvMzH3o7d1VeTcw9G3gPOyTySTkB8NgOmgCKFAkqSSSEafDg6ecyqq7eau6qt5vMyZ9jO3dVXa9PPD0beBXnivOqmV2kgK3td7zte6AlvrSAr3svvnRONIS3777n3F79MgcbSR8Bh+F3G0l3vfu978LmdBs1JYaUkneKBrz3ndzp07eXPuSqBU0EFVvs9z3PX7nsSAzvquZdc96ufAmw0d8NAhnLq5rmB8CG/Zc5ne6UDssxwem7uqr7Te5JOTU+3d1VSPPBs3d1Rbb5mTO2+KBLb3XedO3SgW/XSam983OogZ4aAX1BYgueqBvn3O9vbcUDQIXVttvwqagI+yCBFT6KBk1nmZ9nLLFAsttt9t0oG7eeqB7bfY6K6ecHTfdLB8U4eDR7y7qqlt3nmGdvPFAnuZ3y9+6dVHsZzagTve9873M+UDXsUCZvMzO/WF80oH0t3cv2ueRQPiffefffe3Eu1A5u7t9t8uIgJsgCRioXxQLdW3N30Kxb4oG7ffBtLr7Ty7qq3L8nkmpN3dVUB8o3dpKSSSfReiaXqPG0kB8fHELutpKSSvHAHdGz0POtl6u6qud7vXd3dVX3ZzseAFFPDyL0+PnoeAAd51FEOCij75O+975igdzO++22220Eq6q7a2A7Kuqq7aAN3dXYDofDlVdVIN3dVQjXpOSST2RtRbbmi6vLb5nQEDvd95y2+bUDMwzHx03VXVAO9N3dVXNNg+N3dVUbBPW93dVRvySTzckDpu7q74B932ScqTUkBKAy6qrydzOVnmZmbu6qvQ8OgCpPpN1V1U+k2OAfUD6qq5NySSKNB6cHw7o3d1VHod905d1dngd9Mmqurt7wM+zNXdVXPk+1745vXl7rVac28+CKkkkkaPhzZBt1MOgzACVd3V1u61V3d3XFQgqvsUWy23kMvxgIzMtttwAU4IXVvltt4B9BPoH0fovZ0nf5ayG4C+FYTiC680IL77by/v2IL2KDT9xtpyB4mk2Y0m0uBwxpNh+AOGYPhugJ9Nd73vQAzMzMwSSSYSS6uSSX7MzWZ7mZmVmAAHWlAstttt6gvYIL2Ip2Ad73uvD+XnfQXnnnUR5lDzzn3W1WY2ltjOZltu7ttttvDmczGMMzmYZbbu7bbbbwzOZjGLbd3bbbblZnMxjMMaSzLbd3bfvm0lbb76sWNLLbd3bbba00rjay23d2222pMA3dAAE0AbugACaAN3QvzaStt8TX7k5zy4/Vure/337X7uZDskA9Dh02+H3B4Sak0vp3vfu/flPJxJpSSeSCXAADoC4YGJNIANk79978voSB62kgAADsxJpSSSSSSSSSdmTIAG3nLaW1NWhu6AAJMA3dAAE0AbugACaAN3QvzaStt8TVtuznLbbamrQ85zgAETQBec5bbbU1QN3QABJgG7oAAmu++d9zmpceIP34OklJJAAnskcA+HeHBJrve970gCv2ZmZmVmYZmZmZine978yTAzARoAEkkk/STgAbugACaAN3QABNW23d2222poA3dC/JNK23xtW27s5bbbU1bTd0PwB4mg0OboAETQBu6AAJMA3dAAE0SG6AAJqY0m1PoAqtgCHkkAE36B3nO+997FAyZ+8zMzPMzMa9Dgh8NgeSd53vegJJJJIHgPQSSd739dVdzHTeZmAAAADMM3vM/du6qv363z1Y6F33ltttTVtN3Q/AHiaMkN0ACJokN0AASYBu6AAJoA3dAAE0Abuhfm0lbb4mrbdnOW221NWhu6AANNJJLuNJpq4kkm7iaSd1iU6UaEnn7iK9W13twK2tGomoEnICdh5AFE5999vf7z79+/frba8B6HAPhsDyTvO970DpewzM8qrqsPj7gZmZmSSd73qSQAAAABlZmZve8zMzMq6zMze9AAE0AbugACattu7ttttTQBu6wABNW23d12221NAG7rAAE1bbd3XbbbU0AbuoAATX1tvm7bbbU1FvOJJv3uppvnm128/dtLE2vrbfVX793n79uvv37M8zDkn4fDYEne973pQAAfszPbuqrMzM9wF1Zqquqaed73vn7o2m5CHu4mmwDxJthoB4m02YmAAASSShbbd22fNpK5beJqhd22221NUL5zloB1NQDm6AAJ/YmThugACSiA5ugAFxOhd3bfr1JpW3iatt3dttttTVtvnOctAImgC85y222trvhf29757nl+t8a73spS5aHojwHjMzM+zMzmZhuSeVV1Xe/fd9+PXniTSk73zvV3veySQA1JpAfkAMMk++++PupNLv7sbTYa2kvAA/AAMxASFzEk3bS23tpbbfOc5bQImgDd0AASYBu6AAJoA3dAAE0AbugACattu7ttttTXgBvvOBfW0lbeJMA3vOBbbU1aG7oAAkwDd0AATXfe5fczntv3nn7Fb2ZfzvLxNvuNO28flt+/Z3PMweP2HocB2a1O973vpHhJUkkkfszmZmZmdaFc3JJJ9GVV3YZmd/ZiSbup222/m03bQ9bTYAABJPkmlJoAbugACaAN3QL1tJW3iatt3vOW221NWhu6AAJMA3dAAE0AbugACaAN3QABNW23d2222poA3dAvW0lbeNq23d7y222pz7s/Zy6lf373xNW3su/mAB7+RIegB5OtpLuNPQ4CSvzs1KkzmZgMwGdBJAkn3333zTS+++kgBwxNNgHiAAAJJ3ve73ve99qDltt3dtoFratt3dtttE0AZgAAmoYF3bb71tJW3ja8ttzLbf1tTXJN3ZJJI2jAMwACJqNybuySSRNRowN85wC/m0lbtxteAZgAAmi77n7p6krlz7fu/v1Sbzeyeed9/fv0tqq9tvlt79fx5uLEz0APLcsnsknJBJO973uwHdH6sz7MzN+dB2jMHfs++0+++D9Pm03AwAAG02AHrMTbV1mZiruqG30m4vMg3V3Vb1vQkiqs6G7oAAmgDd0AATQBu+cAvqbStvG1bbmdtttlTV23MAD4EmcDd0AATQBmAACaiMDzd0C+JNK3biTttzLbbbW15mJNLEk32CWI5q40JVOyA0ygQSRAlBuedCBU2/lUaYJuvlAEofLvO9+WPeIEvelU4AlDO2U3YCZOymmAJMdAwEo45TiBKtqijfUb3MsrZedst8cQJdQbDXXaPeMONPOKIQ/XKdRAqqW+XGDLCMBJq3JdhzGOmNAk63xOOwQNgJOMcBN+4viZ+z97fovt7p+N5t9O3Uk3ndnqxZmH76nBEjIqh3Wd5ztuURYTdAAN2RaJqhk22aLWd4LipSILJbbcy40BYAoSAy2220RaQAS6ttttTYW2ligXltxBvVXVXdVxxKHR4D1LqST6TcJV+bil9s4wQ6IZKWzaqrE3LbfrWiYiLAkRRkAVgKwgoNlttuWdAF90CtIKyKgSGisK1oqyV+isquTNFaJkGxNjYDaisBzfv3ed7920hJAQgAvoKaRU99/l3vfufW6UWQEWDIosJFESILdZmdt9tQXEFgi3Xltt8tQyBEF9DQNXWhXVkTIppNlUcwBoGJdXluXdoi4kVBCEJEQAwrEstFbW02ttmitPvNvt5bdWoJUQlgIESRgSQgAJMG1rU2gfGnM2WYlOuffvr5bLcEF81QRZN223C1FMLLbcwySSQjXAPnS7q75qqq+AT4q7pwD0PJJAPQ4B8akkknY0AQAAAH7WZmD5NyTB8OAeh4DwHocEnsk3J9DjpoB2VJJJAoARrYDvTYD4cA3v7ijwA5znNAFRd1Ve5mZnuZmZQOAfAGJum28xp62k9P2cPAPgkkkkkIftAPQV2d73vc7k3gAbkkn012bOAfCg9DwAHe5Xuu/Vuqq7+nk++9zMwttttsAAkQRkV3HUQ81bbeZbaAHe973u+/dbu6qmjoCwaA4QfGp3v2u77915BlVV3737lVV2+z7mdzUzJXsknkgAo7Xe973vWkaEahdVdTWpJJJLAHw4AAHgU9DKq7v7MzPMzMwJu7qqlST2TsegApVXVKq6rde1V1XoV766NgOjve973uugIA5lVV3ze6q6rztc8zM9zOyYCgAAC6q7Te3Ftt2Cu1F4oFt3nOazNqLzM1ly/WgD2SckkgAMuqu+6u6urrMzz3MzM9ADl3V2B8OVYHwAB6TkkkkAAOySSSI1V1d8u6uwPke973Kuqq68yuVn33vmZmAAAkkkkg5d1dgfAkkkkgAAAAAB2ZrYMzNgOaAJJJIB8OATYD65bbbbdYMLq8t0oFn1qBhFBYgshEFkQurbbbRBMAWKpIqrAFgyCqyEYl1bbcznOc528u9/xzzvfGk13tlt+dttv4+ocALfZySeyT9PDwkqd73vXgPWZmZmZgAZglp97ve7999PO972SSoC+ZiSbtaaVtttEZiSbtAJPvPr3saaMT/HLfd3nHmNpZqeecIeecq9aVeecK6pqMGxtrMTTSWW25ltttSYBu6AAJoA3dAAE0AbugXraStvH5iVtu7tt7bamrbd85y2gdTQBu6AAJMA3dAAE0AbugACa7uYi3y3xp22nxjNbw9DwHhscDgJ5J5VXVd/ez7v4w8D1JpH0Nmr2STiTShJ32STUmlAOB3vn0++fwSKY2koLJJJBtJQgABO9kne97+73vZN3ZJa2krbxNW27u9tttqauW3d0ACJoA3dJJI2jADd0AImpJN3ZIAJoA3dOnyuNNK28TXltu7tABNVoA3dPQAf/TjS/JW27u3220TXuNNNzennh4fx99bb4ASeySeA8aMzme5mZzO4TybnfP0k+zGeZkkm5JE+kkkHTdVdVqpJO9+6y7q7DMzAkikAACTvfvvvq20zKAW7u073ompJN3ZWmXraSuW6mv1tu+c5AATVtDd2gAk5JN3YAAmvWgIc5voAJogHN2X5tJAcTRJN3e1JpW22pq23d3skAbQHpzmkklxqnkTa3bfl9mP9fu229iSVttvzv62ngHe973vne9Jz2STve/ffDkhwABJpSCYegHkne972QAO+d++400vvvgkkEaB6mAHqbTcxpsMzMzEk33vfe5O++w3vckmVdZQb3t+7d1VZmcq6Dc5wFXX7MN72CquSTe9kkiakk3doACaAN3QL1tJW3iatt3vOW221NWhu6AAJMA3dAAG3dPfOnzm5Oe/SZ999879kcA9DwSSSSQ4DySc73vd0AJJJEkkkgO913V3VV3774+yhnmZmZmZmAATve973vZN3ZJJBNAG7oF62krdTV8tt3dtttTUkm7skkiTkk3dkklE0AbugBE1JJu7JL1tJBqa4AbugBamgDd0AASYBuvQABNb9+S3QOZ9mTAHoc8E9kkkhwZmCSSTMzMzMMzMzMEkkmBLq5JPO968kkAGXdXeZMzeZmYA8EqrqmvRvb2SSQTQBurQL1tJXLdTUy3l3LbbbU0K3ebbaB1v4hnAttvlSVLltv1t4moGnnNAA6miHN1AAETQGAAA2osDhuAACazMxpN50xAfqrbb2/blvKHoB5JO9kknsk7OeySLtgT9VXVB5XdZwfVV1TDfhQ8qrqsKnkne8SaRJJ3vfvf2fpBtNySAAQMbTYZnl3VVgF1dV9TTV3gdo2G97BBNAG7oF62krduNq23d22221NW2+c5y2gRNAHnOcAAiaAN3QABJgG7oAAmgDd0AATQBu6ASJq223d2221tT3s8uc7554km/O/fcS339wPP07afgAPx8BnAJ3v3e970k8kA/SZDyMPuQJPw8GPZMDwFVdVNyTvfesu6u2rursZmZmYkk73vUkmwfrzMJN3ZJ2VtJXE0AbunwFtTVtu7tD4mpqSU5zQAE0SQ5zgBbU1TQ5ugARNAW85ttttTXKBec5bbamiSbuySgJXHbbu7bbaJr9uAHgBJQMzPv36fv37n79+9yTkkk/fHrwkk73vQHsmPAwkkkwO973t1dV3vQyqu7zW6ppAeGJpsDjabIHjabAnjabmXMSTYABttkkk73d3ve97KmgDd0AsbSVuprltu7ttATVA8Oc0AOpqSTd2SSRJySbuyQATQBu6BJE1JJu7JJImqAbugW2poA3dALG0lbqT8D2eoxpNz9+89++v4S+++skoFVtvit7beAEGmz8k0gDwAnkkne979999JJFAAFgAd73dVdV3ve9OmXdWw0DjabAAhhHIB62mwA6ASkkm7s/SSFTVt5ec2gBE0AbugACTAN3QABNAG7oSSJoAN3QLG0lbraAN+5wABNBJu7JQBJgG7ve22iW261q220T7U+3TICdiC+730BK+GYAlR5mV8SG23Xu08q95fxVnLvl9Nc88FDLyedOHM5rm/M7537777tATXfZJITYAGvjxQYAB5nPve9zrlABNew0CroR0yV1aGLrWyRwVto4qc1sE5SsbXDTLm4tzhzW2abnKRyJsStKHWSuW28ttASgLBEZFTiy2+W231BYhUlLfb4oFtt9tttuLVUhJJJak3DRPU6a6cRcZypXTl1VVd1oOjzV1V2FfcdD4klQVaD7HQsQWBEQC23ltbX2ggJs3ry2/W8qI/c78He+9573vc76gt0gvN91B3VS7pXHbUk4StR75diLsRUgqz+Xe9zO5aouuwTUtvtt5fUFt8t9tvtLb5bbfL6KjURHQiyEKSW85bd2ILEFqCsgK2ILqatvLbq0EAIAB4bNqG4W237LL4guA2W337DPgyZmZbaefkFig973vfe97nfUFggOkhEgSEDNCC848O/HTYD4ckkgPAeA9Judo2OutgOm7uqoB0PAegJJOzUkB184eDj4cfB6HgPCTySTk98g9662B9JqSSQigAViqq71m8zMzMmaAOmwr0U8+9Hj0czMzMzuN8lSSe+19Meeh4LABjV01be7quaqpN1nle/Z3uYv3i73ne+970nyk2SSCfPfd99D5JAAAHtUPvvZPPPJJHodNkkkkkABX3tZ57u6q7T2e/TO5gAlX7qvfffPLu6knne9gAGvezc1JPOxHoD43d1VK0AAAVXO973zveh959MrN597ncSSSSY+HDfwk+k73sV9oeAl3VKuqu9Vd1oAW0AKSSSSQAlV9Tbkkky6q793uU0zO5mZVXVylS6UC/ffffHIffaUC222/W28RDiIfXV1X11dV3zzzzveg9DyquqD0nJJJbdW223wRbbb7UQqIVEPegqfd7XLq6u9973PcxjMzMAAAFVd1dAAJJJySQ+G6q7sB19vJm9KBmZnmcvl8vulAtv19uxF6AuS6q7zPfM3d1VZkzPdgOm6ursB2SSSSHKA+G7ursSfTs5JAAB4D0DVbu6uwHYyruqvt6u6u8zPMzMzOmwACSSSSDd3V2RqquqHTVbu6uwHYl20ASmgkkkkhJJJJDLq7qqAMzVaUPXTb0eeeeSck5vfe9+1VXVQHw4fDe7hmZwz3Mynlttt1RFoiFREZEYMEF0OlVNRk2RUDk3Zd33l1bndDr0e3VXer09cNp9PLqrvvd97j6fdn37+P3n36dll7skqTTrVt88avbby22z2STwHgTkk/T3cmZmZmSSSSTFgCSd73Wn3u/ffTzve9kklaaVttvv7MSTdtAA6SUA+VVu8STzMzMAN8T983zEuM2W0bBtTYTZVsZ+/fu6VftHrWa2ts1SbItiZra1pttGzM1tqtqH7zlXWmy2Wmq2azbNNNtm2m1jTZsuGczMzhw5mAxxjLbd3b+2225zLby85tACJoA3dAALidtu7tttomgDd0AATQBu6AAJq227u2221NAG7oAAmraZdtttqa77yZpzwDlfZjrTuxlZ3Mzm8zMw6SSTySSSTyquq73vfFU4Paq6pJySSeVV1UKPQ5VXVCNSTyu6r7XxJIAKau6qhJBtJTsaaU8kRgcAP3e7n2973tEk0XW1aZ+vLbbamrQ3dAAEmEw0AATQTDQABNAG7oBY2krdTVtu7v1tttTVtu7oAAkwDd0AAfcbDhu6AAJqfjTHuc+5f2JvEsaTS9/W9stoAB+R8BwAJJ2mySTyTve2b37776z6fYfH6rzzM9GeSPQ8ZmZVXVSck73zobTcknlzEk3bb62m7duJpukkkk7ZJJJJOzG0lJJu7JJa2krdTVtu7ttttqatt3dtt6GpoA3dAAEmAbugACaAN3QABNAG7oBY2krdTVtu/c5bbbUlaG7oB0JfFuNXbd3bbbRtd37jMf7fuJJpr9+/e1q+33yw5Q42YAeNGHxwNvtttttne9+7nne973zv2/j9iY0ZJJJJkkkkkCSSXV1UkgymZqTSAADve973suYkmwLbbtskD45ttt3dttoJoA3dAAE0AbugFjaSt1NW279zltttTVobugHQ1NAG7oAAkwDd0AATQBu6AAJoA3dALG0lbqatt37nLbba2od+h6rjzz957+9/Je++/PzFmZj/XttttrYHEfAeuq/e/v379+/fv35IHoJ3771O9SJJJJEkkkkHe933V3VV3venwy6qruszMzMxN97G03JJ8AYSSSthADd0CUNTQBu6AAJMA3dAAE0AbugACaAN3QCxtJW6mrbd+5y222pq0N3TQOhqaDpu6AAJMA3dAAE0AbugACa+55xfp756eHp97v30l/AQt/WzkkD66uqA9PXkkkne18SSSG6q6oB2SSS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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
