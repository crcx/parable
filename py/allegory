#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_ROUND = 16
BC_COMPARE_LT = 17
BC_COMPARE_GT = 18
BC_COMPARE_LTEQ = 19
BC_COMPARE_GTEQ = 20
BC_COMPARE_EQ = 21
BC_COMPARE_NEQ = 22
BC_FLOW_IF = 23
BC_FLOW_WHILE = 24
BC_FLOW_UNTIL = 25
BC_FLOW_TIMES = 26
BC_FLOW_CALL = 27
BC_FLOW_DIP = 28
BC_FLOW_SIP = 29
BC_FLOW_BI = 30
BC_FLOW_TRI = 31
BC_FLOW_ABORT = 32
BC_FLOW_RETURN = 33
BC_MEM_COPY = 34
BC_MEM_FETCH = 35
BC_MEM_STORE = 36
BC_MEM_REQUEST = 37
BC_MEM_RELEASE = 38
BC_MEM_COLLECT = 39
BC_MEM_GET_LAST = 40
BC_MEM_SET_LAST = 41
BC_MEM_SET_TYPE = 42
BC_MEM_GET_TYPE = 43
BC_STACK_DUP = 44
BC_STACK_DROP = 45
BC_STACK_SWAP = 46
BC_STACK_DEPTH = 47
BC_QUOTE_NAME = 48
BC_FUNCTION_HIDE = 49
BC_STRING_SEEK = 50
BC_SLICE_SUBSLICE = 51
BC_STRING_NUMERIC = 52
BC_SLICE_REVERSE = 53
BC_TO_LOWER = 54
BC_TO_UPPER = 55
BC_REPORT = 56
BC_VM_NAMES = 57
BC_VM_SLICES = 58
BC_TRIG_SIN = 59
BC_TRIG_COS = 60
BC_TRIG_TAN = 61
BC_TRIG_ASIN = 62
BC_TRIG_ACOS = 63
BC_TRIG_ATAN = 64
BC_TRIG_ATAN2 = 65
BC_VM_MEM_MAP = 66
BC_VM_MEM_SIZES = 67
BC_VM_MEM_ALLOC = 68


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCTION_CALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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RAUuJcBBLg7iAoXEUNxu/bqsM1WMVWQFpd6u7DsmpLLu/Xd7VZJUi7u7vu7q+qnoB4AptSSosw9o5Qbu/Tdqq1VUNh2pKqSjlVKA8TvkAaLjfru7tG3qiFy4ohZ73vAXrbbb11VKlQAAAKqqkcLA/Fna2ICer0fKHoAqfCITcSRTn33333298HkUQ5ylR5z68h5i1ECoFRSRSRSRSRSRSRSQQE+giBUVAGQRU+jmKp9999993hyCAciqJyCAvICocig8n0QA9FJFJFJFJFJFJFJFJFJBAR8KIQVD6KtKgYPvvvvvvt95y+973721JFJFJFJFJC4NRSRSRSRH6jB9n777777m973vf3rUkUkUkUkUkUkUkUkUkB8ohPsH333333185XJznOfXtSRSRSRSRSRSRSRSQST5ifYMfZpRD777777u973vf3vKSKSKSKSKSCkgpIp6CIRBCMn2D7OQH777777197Dve9799xSRSRSRSRSRSRSRSRSRAX1Hve973t/c5znOfX34SoJUCopKpaqlAqqEqKSAyCSCfUfffffffb3ve97+9f1KBVUJUUkBkEkElUKFVQlRSQX6j7777777e973vf3fKSAyCSCT6hAqqEqCSFQagkqhApRAD6CyAoTnO5ARdaJX33x3v3197DsqVUhzXsqVJIr4QAAUeKhsqqqL83xsAVVVIPAfm3ujbfzbFSqkHQt8D4XZVNJ9MVWJJdvXYBjGMYTYH5IukB+DhfqSoONv3ve4lVKkjd2X2SSSQAGeB8Jd3V3d3d973ve79374SopKoSopIDIJIJIJIJKoT7B99rQD999993vOc5zn3uKSKSKSKSKSKSKSKSKSC/Ue973ve39znOe7372RJLgFRSRSRSRSRSRSRSRT6j7777777e973vf3fKSKSKSKSKSKSKSKSKSI+o973ve9ve973v3fKSKSKSKSCSfMUKgDIKVVKSKfUfffffffb3ve97+75SRSRSRSRSRSRSRSRSRT1HvfaAfvvvvtd7TyHJychyJ96lJFJFJFJFJFJFJFJFJEfqPe9d33f3Ofd7373lJAuBUUkUkUkUkUkUkUkU59g++++++1rXd7393ykikikikikikikikikiPqPe9d3rWvb3v3fKSKSKSKSCSfESopIpIpIpfisc94xMm8bqa3rQqKIZiguoCOoCqIegIBuej6IKP0RQR72kQA7BVPQBUuKIIXERB5KlR5JJM5KlVVQ5KqVOdAAUeKgFh0sXxbV8A2VVVF3d3fd3V9VPQDwBTZVSUpftZ3N1WVKqt5VSpAA+Du8lHJJJIAGyVJHHzVblRuVVVDzXYA0oh2Aoh683fvCqcu7u7u797NJUABgAAHUkqVItKqSLpJJUgMHve173vc5ze+c568qSKSKSKSKSKSKSKSKSKeo9732wH76vvq7O95zJyd7R9PRSRSRSRSRSRT+VSkikiEmohEh+wfv379+/ft+5znOc/X8pIpIpIpIpIpIpIpIpIp9R973ve9ve973v3fKSKSKSKSKSKSKSKSKSI+o973ve9ve973v3fKSKSD9VKSKSKSKSKSKSKfUfffffffb3ve97+75SRSRSRSRSRSRSRSRSRH1HvZPT6AP0+j993A9nY8nJzlD9D0UkUkUkUkUkUkD0CopIpIrR9g+++++++3fOc5zn1/KSKSKSKSKSKSKSKSKSKfUfe973vb3ve9793ykikikikikikuqV3VK7qldpUcQABmZmZhsiu6VrnEMgMgMgMgMgkgkgkgkVVHsRACQEEzJBAAH76ANfRQVNQBETB999kQAfo3NxFVuKIXdAFwAEAuIot3SiF+9gRU8eu75VYrF3d3xebu7uzxp0bOjYHA+F3fLu7vl2bBdYxjFM1ROSTd3d2Iid73ve99dh6A3BVC4KrcQu6bsVSi4367vVwBHk5EAXkFVffSSXyqrHgA2B0DM+xisYk1jGNuh8T1gGZmZmEcVK7VLi5xUuWqXLVUQiASKfUffffc4A/ffY7Ds72jnOYfp6KSKSKSISeiFRSRSRSRSQH6j7777777fuc5z3e/eypIpIpIpIpIpIpIpIpIp9R973ve9ve973v3fKSKSKSKSKSKSKSD9VKSI/Ufffffffb3ve97+75SRSRSRSRSRSRSRSRSRT1Hve973t73ve9+75SS4JUUkUkUkUkUkUkUkU9Rj3vfcAfvvu572u8rnPvZUkD0CopIpIpIpIpIpIpIp9R9999999v3Oc5zn1/KSKSKSKSKSKSKSKSKSKfUfe973vb3ve9793ykikikikgkh9EqKSKSKSI/Ufffffffb3ve97+75SRSQDkaikikikikikikinqAFQ7AAWQFEMVEAaAAUPeoAETcRUR172H3vYQUG7oUFAuAAFxAFuCqty4VVUmH6kqpVRdUqSsAAb12222KqSQaHA2w/AeA/AAqqqQYAfAN/NtflXxVTap5UlWkqV5IBu6ZVVVTe7FFYA+nqAfe56Hoeh6HrhAG84DEREAuNwbu+Z767u74KAh2dgogckqpUgAPY52pKePFfF2SVJvm7u7p4bbe/JVSVUttbaqkqrf5IfICSTMzMzf3fKSKSKSKSKSKSKSKSISfoh9g+++++70B++73vNa+91SRSRSRSRSRSRSRSRSRT32D3va972/uc3vf1/KSKSKSKSKSKSKSKSKSKfUeu/ve9ve973v3fKSKSD9VKSKSKSKSKSKSI8PsH332vvvt73ve9/d8pIpIpIpIpIpIpIpIpIp6j3ve972971e9+vKkikikikikikgfQKikikin1Hve++70B++73vTvOc+17Skikikikikikikikikin1Hve373t7+5znOfX8pIpIpIpIpIpIpIpIpIJv7B997Xve3veta93x9EqKSKSKSKSKSKSKSKSI/Ue977777e961r7v3wlVQlRSiNRGoVFJBJVKhVUJUUkUgiIVAVXsEUQwbxWFUAPoAo+hn1KIffdwIj9ERA+iiqXFUULiiFwFELiCJcVLgoheaG1ACMgHjTqjZ0bA4HwPgcDYu7bxVYxX67pJP367H67u7X3V3dfAklgYrAUBUAABVVV3d3dfZTySSo8qpVSK+S7v3ve3ve0He9+75SRSRSQSfUhUEkEkElUJUU+o++++++uwH7td73Bzf3sqSKSKSKSKSKSKSKSKSKe99k++++599vd81r6/lJFJFJFJFJFJFJB3VKSKePsHve1999ve86193ykikikikikikikikikiPqLu/X72971rXu+UkUkUkUkUkUkUkUkUkU9Rd373vb3vOfd8pIH0CoKSCkikikikilyBPsHve19z68gP31XLuuzvKQ56lJFJFJFJFJFJFJFJFJEdB9gu7+3729/c5znPr+UkUkUkUkEkOxKikikikin1H3333332973rX3fKSKSKSKSKSKSKSKSKSI+ou7v3vb3ve0d793ykikikikikikikikiEn0Q3gRC9/YNAoZxmytCCgfQTX1CIGu/dyAKP10AoBd3guW1VYZqitKH1A5GQLrGMYq7l3q9+u72e8bA4HwPgcDYJdOdTMzdzB7qqquvakqPKV8keQ5UMqSteqgAAIAACqvtU8ivgGeogjznPHtF3fve9vG973v3fKSKSKSKSKSKSKSKSKSKeo9d373vvAPe97kO97j6eikikikikikikikikikiB9R7Hve973N/c5znPveUkUkHtUpIpIpIpIpI6jqJiKfUffX99V3ve96193ykikikikikikikikikiPqPe972fe3ve9a93ykikikikikjSu0paXLqld1Su0qnEASTMzMzJpVK7UkUkUkUkUkUkUkUkR9R73ve977wD2d7XZqd73Bn6vRSRSRSRSRSRSRSRSRSQT6j773ve1r33N7+v4kkAAJe95/azJyTnPVzk7AAAPpvXvdnvdqpdVPdAZtre9aNNa76fu69g+imBBJvmuc5sEUN7pRQ3BRE+5zB99SiFxAQC7pFu7u723LLu7BGQDxp0bOjYHA+B6qvyr4qux5ShKlAbu7JJK3ZJSqqGgABYvioHKklBIAOAAAqqqgGe1KqqmZm79Fd3du7v77T9yNNGAGs3qSTMyTWtfd73t3k6AAaDN6973skqsu7u89gAAGs3rMkklVVVVTsAAA1qb1JJJKqqqqnYAABN6kkklVVVVTsAAAm9SSSTJrWvu973ve5PABoA1m9SSSSqy7u7z2AAAazesySSVVeu7ueoAADWpvUkkkqtaqqqp2AAAb9+mvvttOb+1rQFQgiEboRCkBGCDJEAWVSCASBIqMgAkiiFEBQ1AUMQFDELya7ytbEQgKG4qichjlCN+1rIgLshSLFEIIhFUISF7ze8bdsAEkJNQajop5hKhU2TklCWOWvZCZkybBAiAGSsKqqADIIOhFYLECANbYgQAgWy4BpGUyJe0ZRGp4rfaruRxgoOTuaCSTJEqFRRqCoSSPgZUCzFMoRECG6+5r7XXV25Rczfwz6SYgKNwBRxa0VDwBi9YrvPbv3jphGNQkIAFNObAULwaFUNQFDKiEpBDIohmoqYMkkBRcEwDETMzi7vvb71FiiEk6AJYgJEhBEmMYu+970VDYzvcd7d5u6eqIRBurxd3ebvFqlmlEpAAYJAFCIjBRCNqgUlKiYrGLuzl71fDt6xq7u6vd3eLvl3ewOkSDAICBCACRLUQgUtKKUlAI1L0Zu7vV7Fu7zm7u73nOxTsQkRCBAUum6xe93d7FQsAGQUAirFEIPShUKqMCIhJBgQYwAApFGkEozGsF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wfdkkkkkAEkkkkDve97+CHJDnOcwy23ZBVttttttttZBVtttv7AIeBDuBDwIYEEIeBOExMTExOicicExPzE6JidFWk8kMTFWKGk0qxOU4KuKuFWJynCrhOEWJirE1RahwTCYlicCdScJ0TrBLhMoqxNKGKuSnOE5JuEwmCcJwq4BkmwmkwsouFDhNJiYThNAxMJwmJwTgRwmurry7u79urrlVde1d1vzXmm/u9+AAAAAAJJJJIAAAAAAAAAAAAAAkkkkgAAAAAAAAAAAAACSSSSAAAAAAAAAAAAAAJJJJIAH8AD4AAAAAAAAAAJJJJIAAAAAAZVJ3RPtP1NT9T9TuCeCdk5TCdFXZPSdCcpyU7k8Kqv2qu68qqu71trZ1JJJJABJJJKUrWta1rWs0QREKqwLogd3VVVVdmZizKzMzW2sgqoEEsh6fTLx59+/fffffjve97vegSSKBsA8u6XdfXdS7rve81rWvLlttuyCrbbbbbayCKsgq8nPuc5yd+kkkknwBJJJJABKu6XDnOctttttttt/SH27u2222222293d72iSSSSfAEkkkkAFVeZmfSHu7u2222222222227IeC+LIKuVd1vvOc53774AAAAAHe7IaE3d/Egq2222222222sgq617rWtd5mb33774AAAAAd73uyG6+eaW3wJ+kLb54222222221u6zMzy7rvN7zffvvgAAAAd73ve97kh2Q/SHZD333ltttuyCrbbbrWXdZmZrWta1rWta0b3vZ98AAAAAAzMzWta1rWta1rWta+u6zMzWtW222221kk/1ggyGBJPAhgEMCGVV1J3fez9+/AAAAAAdCfSH4JJznOW2222222/yQVcGQWqSCqkgqpIKqSGhDAh3vvvvr99+AAAAAAZmZrWtatttttv6QVbbbbb55bayHgQIIRhOifcT70/hMquKtJ4TQc0NS8lgpXalzQ8l3pcBdicpgJxTRNJlNicJhNpB+p8p+pnlPj+U6fymrq/ak973vez4AAAADy7oB2SSSQAAAAAA7R6AAAAAABVWSSSSQAAAAAA7R6AAAAAAl3Tz27oE5Kq5JJAAAAAADtHoAAAAAABJJJO3dTwAP4AHwAAO0egAAAAAAEkkkkHbuj0AAAAA7Xt3Xt3S7pd1l3S7pd127pd0tcF0XBeC8F4LsXgu5eC8F2LmiXRdF0Xcui6LvF4qpeC1Q70uC8SXJei9F4LwHJd6PtOyeirSag/ExVz+hSd39zkT74AAAAABu7PqqJ6N3AEX7CUO/Q3eZmZmc5zqne9zWta1rWta1rWtay7r27qd5zOT9+/AAAAAAPLul3X13Uu673vNa1rWtatttt2QVbbbbbbbbd+3d3779+73ve9++kkkgAkkkkhlVeZmta1rWta1rX13Srbbbbbbbbbb2Q0CQhy+AENkJJqc78+AkkkkgAkkkkh9VXXJDnOc2QVbbcLfLbbbbbbbayCrrWtZdXdVd/qq68qru6v95VXVWkkifvwEkkkkAEkkkkKq8zM1rWta1r67rM7351SlN3d3VKU3d3dU3d3nOc3VKu6zM1d1vMz9uqq65dXRJIfvwAAAAACXdcu6/VV1V85zV3XazM888888ttttttZBVtttt/eSHfeced97+6AAAAAB5d0u6l3X1yT+BD7772222222222223ZBVttt1rvLqr++73vfp+/AAAAAHe973+BD+BDAIc5zltrIKttttu7Ib3veta1rWta1rWXdZmZ+Oc5x39+AAAAAAfVV1ve9+VrXuta1rWtay7rMzNa1rWta1rWta1rLuszM+k5znJ374AAAAAB9VXVXve961rWta1rWtZcFW222hLbbbayCr+/gQ4EKkhv5nJNiZiZirYmMVZlMymKbwn8J06UzEzE+k0miYq+iwsSaTE1VcExNKDExSwmCYmJiYTE4TE4TCwTJMJ7FwJwmKsJiYmJqkaTJSYmExNJ1VXXlVdXde1VXXtVV17V1dee47+7PwABJJJJAACSSSSAAAAAAAAAAJJJJIAASSSSQAAAAAAAAABJJJJAACSSSSAAAAAAAAAAJJJJIAASSSSQAP4AHwAAAAAASSSSQAAkkkkgAAAAAB3y7rwnynynlOqr6T0nVMTynRMTCfC+U+CfSYT2mk4Tyqu78qrryqq6/iruvNd9b6n3wAAAAAD27rd3X1Vddu68qrr27rt3WKn2Q5Hx743rQjQCtKgylKQlTVFVRNMFC0qlAgl45znN5Ibu7bawnN3d2Q3d3VVVVVzMzM/e3dTnOZx39+AAAAAAeXdeXdLupd19d1JJN3db3ve8zMzMxVVVVVdkN3d1VVV0CHvfffffe9++AAAAAAfVV1+qrr33331VeSG7u6qqqqqquyG7u7hmZrMzMz85zm3P36SQASSSSQA79999+gAb+5ziq7Ibu7qqqqqqq7Ibu7qrbboQ/VeSD97vN+5+/ffffd73vQkkkkgAkk7d1LuuO97u7pznOc3IfpDnOc4qqqqqquyG7u6qqrl9+5zm/uffSSACSSSSACSTLs/BDAn7nOem7u7yQ3d3VV/m7u6qqqqqqqq/yB6EMPQh0TZDve93n38+PwbAJJFA2ASSK9u69u63cOyH8kCeb776quyG7u6qqqqqq5mZmZmZmZmZuqupznNyffSSfAEkkkkAEkk+qquvruu+d73d3W973vMzMzMzFVVXBWqqqqqv27r99+/ffffd73vQkkkkgAkk+qrrt3XlVVXX6quvp+73qqqqqvshu7uqqqqtVW23dVV3z7nOd7939+AAAAAHe979IdkPwST77775VVVVVVdkN3d1VVVVVVfIQ8CHIQ0+n7zoQ4J7kDCfSYnKThMclWFMTVOiYnCYmFidCYixOqcQOhV0TomJ0VdEnCcKsJuExVhMTonRMJwq4ThMTkSYnntVd37dVV1zubmZyfABJJ3vepJAACSSSSAAAAAAJJJJIAASSSSQAAkkkkgAAAAACSSSSAAEkkkkAAJJJJIAAAAAAkkkkgABJJJJAACSSSSAB/AA+AACSSSSAAEkkkkAAJJJJIAAAAPLugCJd1lVV1uqq68u62XIcUO5dy6L0HouqXRc1R5TE7puifCfilpV+E/on8u653vO7nz4AAAAABqn2AJ8glCNVWfTB5F9Pp9Oj0il2ptJsWyLYGxrEjazLa2ZqswTYltJrGxjRVAU0zE1KNNAUJAyBRFRUQURVVRUlUQRVU00CUKi0FLEUVREUER099999VXm7u6quyG7u6qqqqquZm7uvbunOczj9++AAAAB3ve973uSGSHZD9Ie++++qqqqqqrt3W973vMzMzMzMzMzMzMm973uT74AAAAABl3X1Vdfqq68qquu673uyG7u6quCtVVVVVdkN3d1VczMzdVd3Oc5zk/fvwAAAAADt3Xbuv1VdSquSTMzMzMzP13W973vMVVVVVtVXZBV8kPXzm73+fz+d73vegAAAAJd19VVV13ve9zMVVVVVXZDd3dVVVVVVXZCc5znJ8+AAAAAAbuz8BD+BDz33338bu7qq+7u7qq7Ibu7vLut73veZmZmZmZmZlVbe97qr2/T8AAAAAA8u68u6Xdf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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_REMARK:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    if os.path.exists(home + "/.parable.on_startup.p"):
        load_file(home + "/.parable/on_startup.p")
    elif os.path.exists("on_startup.p"):
        load_file("on_startup.p")
    elif os.path.exists(home + "/.parable/on_startup.md"):
        load_file(home + "/.parable/on_startup.md")
    elif os.path.exists("on_startup.md"):
        load_file("on_startup.md")

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
