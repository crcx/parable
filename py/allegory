#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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02Bn79f79+8/fv378+D0HoT2zW0lIAEJ8Hp6Ftv620JJJIVGZmZmYQAW0AdNgfs7mZ5mZmPg9D73v278v6/uXf7PczMzOZjZ5d3fe37ZAAOlWVW22zrX2ffb98sO32X9ltv36hfbUcu2+X9aep+GAH4NbRby7b41cTt1W6rdVzqSaFiw0PTD0JfyvEm1GQx1sVTCGwIASaUA2ENwgSiIh1tJtNpzE21q8y5c+/W+P9iuNyeTySS+mNndDnDA9R4upNLE13u97vfvyPDJ4HgaBwDnmHutSSfe/rrZiC8ttvtxW2+AB6DOBeW2325bb5mJffb9nnnt4013cXvjST1tp8x9babTSTb5757bZfbVttvm7vO+z0okR8XEFq9VXASPq6i1q7tm5znbTozbDM2GzSbU2qzWw22bm4zrnNVY2Na2rb844s026c5zbjjKzS2asbQhUVFVShSRFIgivItF99797b7bbb+ttt/J5lWJySSSWySSSSd73tkl8C3222+0DxPve987iTafe9PAA9L970/L1400lW223y++fHTwy/tQB57+AP3oAe78dnJJ9JCQo/szMzb4uW360+bdcUbDbbVJ9Ua6UYLKMaTWebzveyfUiZmYASHe5mK5skklp6gA9ALG1JJJJ379RYkm/MaTeNK5f1+t8t62mzPry+Xt+ttP2AF/W222pNKGJY2ksaXl1u2223vuTKB+9SYawAP3e2eNNzkklttJJJJKPdf7P2e+ff97aSnz/NjT/jRNtJ/Ykn/Hv3n1/j+P45JJA+A4Ad973vUk31NN4s70kknUk3Ek2a2mmty7tttt8sknskkoAABJPe42ku93vSdmehraSA4FVtv63W0lTZ7hkGuNJZieZiaaT0PwW0AAAJJJJJKuIAA+DEmlcQB6EkygRAW266lVmYHR6D4AB+/a8qpVfv37v6U58ffvw33xJNxJtJJ5q99oBJJJJLIAwIbqpIH7My8zMzNyVVAOyUAAJJJJJAlSAD1IA8tAAAFzNSi1H337l/d6muW8bpobnbx025cuIwv1vqMT8EHiXG0l0At6lZbbbYCAAPiHAA/AHoGzzu9740m+r800m1Q0Mgj4RB3Xe+6vdi5CE3PdXdu/NSA9ovnSjbmuc98+d999+VLzfazbWtP7OTNuc2rTT9y5n7X7XW9azlJZpDNf266Z8K453uhf26Od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AAmvftX3fkZTaottuIMgLzD5nr9WNID58+dXd0d3B00HgWnAOc5znM7mZmZmCEDzDQ84MzMy9Xd33uXySpO6nevxmZmZmB9JUl3fl3d2B+zMze94Cqgm75V5mtpIypu6vLb4mvLbdOc9tttTVobuySSJq4sAN3QAE1JJu7JJIlcWYmAb575q3EvN1tJFTe5dtv3jaSzFmNYrbdOc9ttvtbtDd0AImriwA3dAATSSqSbxNNgHC22/pJskkrkqZl5mszMwWgDne973vXiw4D39mZn3ygGYLu7v2u9679e7NA7JUhszPczD4u8lVDYMzMze94CVIAbec382krltviapMNAAE1VLbnN5mFVM0XptmZiVA3vYEqF68a8utpIA8MTVy0y7bbaJoA3dkkoJMA3dAAE1uSdqSbx/Z55t5y+W3t2QeAcGzsaaOmgO/c1znP3cz2szMzOGSqkmZmZhS76vt5sKlSZgSSAADpsD27u/cLazklSZmZ4AG7oAAmtAN3fXbraSt13FcTVVt5ec2222pqgbuyVhqbQNrX+0A3dAOprve93dkkkTUkm+c5L42kgL5cTVtu7pbbbfszFiVtu7tttpU1bbu7bbaJo5371eZzznrbSSrSbxppt3E2qeal6tSr5qTzHPOhXmlJ3pR5lHmpctNpazKyUeaKrzT1rNmredJR5+dJSvNA8yTdxNtq4m2m+tJq3tt222SfSZJJJ95+/b+/ffSckklk1K5mMAAvVVQD8gM9mZgAZ7JMzMzMzMBklSgv6Xnek708+k1JJqTU0k/ccA3dAAE0Ab5zhfG0lbbfU1bbu6W221NW27ugACTAN3QABNAG7oAAmgDfOcL42krbb6mrbd3S2gJq227ugAJOSTd2SSRp8y408MSTerw1rixrFjzLWVZq3X56Ir89Xffff755wkvN3gSA420jwrSa8TSttvbbtkkk+kySSSLuNNL7Psf33vx38LGZ+4k0tAPIputpL6SSQi73rTS7E7mLDAOWrW0ll9BypDv3b1L/FtXzDwC7u7vV3a41JtOyDbSDU0u4AbugACaAN3S/m0laHiaANnOAAJoJN3ZJQEmAbugACaAN3QABNAG7tufm0lbbfU1bbpzltttTVobugAFxZjzG0lmNW27u2222pmNrmNvXynm434s8STeJee777fbbaSSTkEAHwGkkkn0mSfSbO8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ACaJDdAvW0lbeJry23d2222ttqfT2e+pNG7FxY8W/vfp77799nesAfB6AAPByc984hS7723i7u7u7sfXd+Xd3dSpCXqqkl3d3d9yZmeADAAdvV2LqVJj43dkkASYBu6AAJoA3dAAE0AbugXraSuW62rbd3bbbbU1bb5znLaBEkAbuhbbb7idtu7tt+tvE0Aec5wACJoA85zgAETX7i/MazAP3odAHwegfVKkD0W92Z2ed+++zMmzGmZ3ABhd3d3dru7u7sGpKSkkkk7BtNgABO9979v3x+73SAbugACTAN3QABNAG7oAAmgDd0C9bSVu3G1bbu7bbbamrbfOc5bQImgDznOAARNAG7oAAkwDd0AATQBu6AAJqT9xZiSbN8S3F4H6q9tvb9uW8oegHkkk8kknsknJJ35XsnfylSd8kqTa/O652SpFs16Xpt7JUmxkcvtpKkB9fe/c1x3KqVV4ZmZmMzVVKrMzPaqSZmZj6NNSm93d3hYb3sDI1bbd3bbbamgDd0C9bSVt4mrbd3bLbbU1bbu7Q+A4mgLec2222pqgXnOW221NU0OboAETQFvObbbbU1QLznLbbamjOfu9hn7s3nk4km/Pu/cl+tee/Pxn3MzMzOZ3MzzMzMAHD57yc1zO/dzNVUk3276vv78BmZsu7u7u13d972LyqlU1VSqGZmZmLu7u7td3d3q7fqwAhu6BJK7iVtu7tttomgDd0AATQBu6BbG0lbqa8tt3dtttqaA4c5oAETQBu6AANrmAG7oARNSSbuyQATQBu6AAJq+q22zL9er26AAfre23lttkkkkknknnvvJPu/vvu97eZnlVJMzMzM6Xd3d3a7u+96u7ySqpphwxNNgcbTYB42mwA9bTZlzEk3Qttts+kkkm7skklTQBu6AWNpK3Unbbu7e222pq28vObQAiaAN3QABJgG7oAAmgDd0AATQBu6AWNpK3W1bbv3OW221NWhu6AANqbF1eKY0m998zPOentS/fv1t6qaFVtvit7beAEGmwAACeSee+8k+7+++73vZJAC7u7u7uqgbkqR9JKTU1Kkg9n0g2mw0DjabAAAjAPG03JJ9snJCUltt3dttATQBu6AAJoA3dALG0lbqTVtu7t7bbamrby85tACNgG7oAFqatt3dtttE0AbugACaAN3QABNW23d2222prP3FnN8MYImIQJfAEm/ngEp5q4rOi/ROb7McfMy92vYdjdRPvWJBPmIz4cUcsbIhETe1fzsn3cAhhTFAAHiUgTAAq7+X+/fv4/Am7zgq/COmSurQxda2SOCttHFTmtgnKVja4aZc3FucOa2zW5ykcibFGFTc5zn7znOVU5UYk2qfDbHwX9UlVqpFTS/bu7u7AXVKqqmbbSWpNw0TydNdOIuM5VKrybkklVNaBzXftvJUqr+vl2ADuZ3CQK2oBNAk0NCAO7uzt47lfSVJKnk82OBUqV3mdkzPvvR19UlVe6o+evYqvYJ7I6vdiS6pGK+dPcj1IWg38eed85zvnfZHXzS6w+u/r9qSqu/bv4fKHoPX0qqlKlSp1I2tctuc+fOc565lGUclFtSS5oEocd3Z3dHcCABgAUSSkEsLvnb1ftSVXZKvVny0XI0F3c/SSq9bSBd3d1/PnzfloEmIBQhjQxsYX1+bF9X02A4PAPg9B6D4PFxocu7u7u7AAbu7u75doALd2eA6920HDg8F37d3ft2PQfB55d3d85d7AdNAFoACYklVrN5mZ999999pzMzz70evh5mZmZkOzve979GHvweru7u7uxjUjVN7qTzVS83PN69+zmZvM2D4PXnO6PPOMlHe973LkmGZmZmD6Rd+Xd37fbbfB0AXLAC+6nOc+mObqSqv3PfmZmAXd3K+1PnPfZJQ973oAdvdVJPWg9d77YfAfXe6qSXq7u7AByvEvy7vl3YDnvLyZvOZ3My7u8BweO972d73oE5oel32qkuVJValVNau7uxdNAXcu7u7sAHZPpe7v27u4NJv3diMA+AEmn1TJraSkkkkXcRuqkgDtXd3d3dgD4PaqSXd+3d37YdNgPZUqlSpFSpFSpPmSNLh8uNNN/fe/v34IAAABJO973ve97JASVUqAAEHlVJD1w3VSRe9cG5Kqi+3fLvd2PYdPPgc16Po02JJv3Gk2HAPgNik1tJSSfSamnXYaqpIPnT01JUgDyOm5KkfXd7qpVXd3Z0AAAAA1N1Uqh1q+dvJVSVytVUlUeNZmZmAD0Q3VST4DoBuqlUA6am6qVQDtrqmgXfZfu73VSS7vwAF3u7u7vhMqVUkzMzMzmZnkF+++3d3znLAAHz679v29XdgsEcXu7+9fZH2SvqSbFppR1OgXWrWvJqqqSc15Z9wAQPakqtVoHySLxpN/ffc+ns8PP489737t6rdklSadatvntT9f79+8/fv378AD0vjn77X3S9dWy7u7u7F973veuru7uwakqQD9UqT9+/Zb7+zEk3bbbQ6fqB4H75VbbfPW0sxZhRu7t+VXzy/FScEKhKhJIVUJC2Jszzzz3Ieafmtq2ba0S2C2pazZmW2xtbWtZtqrzbkk4hKKpKSUKQRUVAgk2mNNrbam0CzWw22zGYDd0ACJqgbugFiSat1tAb+5wAATVobugACTkm7skkkTUk3dkkkiaAN3QCxtJW6mrbd3frbbamrbd3QABteLucbSQeBqPj5E7zJ3ZILO5meZmZj6SpGh4Pj41z1JUnnuptXO9u7jaQGx07W7u2CC93uvu9sggjd9uvur+l6nddd73q7uwqVIAZVSTMyNpHkMQdDQF+APN3QABNAG7oAAmgDd0AsbSVupq23d22221NW27u229DU0AbugACTAN3QABNAG7oAAmgDd0AsbSVuuY3by79zltttmJHv2/v05DVmLPv3PfvqGJvEsSTS/T4XbbaAAfkfAcACSdpoAI8D3n37753nbvveZ+lfvAMzRmYD13u8nt976YNpvve98uYkm6E9bTZduJpu2gBmAIC2g3vYZmblTMzN7zMzMympgHm6AAJokN0A/AJoD9u6AWNpK3U1bbv3OW221NWhugHQ1NRIDm7oAA2vksA83dQAApjzGupI4c3dQAAmh4/cbTTRpiXmZWvPLfL9eWnGzADxow+OBt9ttttskk7M8k985wKqSdWGX3ve971Yu7sXft33vXe5KvOkkgBJJIXMSTdttty25JANgTMkk7W0kGpq23Pt8SaVtttTVpmAB0NTQBu6AAJMA3QABNEmYAACaCGboBY2krdTVC79y2/rbU1afLdAOhqaJDdA9AG1V3fvfD1dM8fi/Z557+vyX79+6/MWZmP72ywu/ra2BxHwHtSfvv379+/fv378A9PvfPL+7zve9O973verF3d3fer3eqqSXd2+sZUkqpmZmXmZgxtNgAAEkkrYCttu7bQBNRAc3QABNEhugFjaSt1NULv3Lbba11ZQu7bbaN1YknmNULu7bbaJoA3dNAATQdN3QCxtJW6mrbd+5y222pq0N3QABtd87xfeeBz8fj74C+W2/v37n788AAOHz3nPvfbuSpO97d3a+973verAPaqSF37d3d2u71eqqSXe5fd7Jytps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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
