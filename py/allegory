#!/usr/bin/env python3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 100

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCTION_CALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
# BC_FLOOR = 8 ## REMOVE
BC_POW = 9
# BC_LOG = 10  ## REMOVE
# BC_LOG10 = 11  ## REMOVE
BC_LOGN = 12
BC_BITWISE_SHIFT = 13
BC_BITWISE_AND = 14
BC_BITWISE_OR = 15
BC_BITWISE_XOR = 16
BC_RANDOM = 17
BC_SQRT = 18
BC_ROUND = 19
BC_COMPARE_LT = 20
BC_COMPARE_GT = 21
BC_COMPARE_LTEQ = 22
BC_COMPARE_GTEQ = 23
BC_COMPARE_EQ = 24
BC_COMPARE_NEQ = 25
BC_FLOW_IF = 26
BC_FLOW_WHILE = 27
BC_FLOW_UNTIL = 28
BC_FLOW_TIMES = 29
# BC_FLOW_CALL = 30 ## REMOVE
BC_FLOW_CALL = 31
BC_FLOW_DIP = 32
BC_FLOW_SIP = 33
BC_FLOW_BI = 34
BC_FLOW_TRI = 35
BC_FLOW_ABORT = 36
BC_FLOW_RETURN = 37
BC_MEM_COPY = 38
BC_MEM_FETCH = 39
BC_MEM_STORE = 40
BC_MEM_REQUEST = 41
BC_MEM_RELEASE = 42
BC_MEM_COLLECT = 43
BC_MEM_GET_LAST = 44
BC_MEM_SET_LAST = 45
BC_MEM_SET_TYPE = 46
BC_MEM_GET_TYPE = 47
BC_STACK_DUP = 48
BC_STACK_DROP = 49
BC_STACK_SWAP = 50
BC_STACK_DEPTH = 51
BC_QUOTE_NAME = 52
# BC_FUNCTION_EXISTS = 53 ## REMOVE
# BC_FUNCTION_LOOKUP = 54 ## REMOVE
BC_FUNCTION_HIDE = 55
# BC_FUNCTION_NAME = 56 ## REMOVE
BC_STRING_SEEK = 57
BC_SLICE_SUBSLICE = 58
BC_STRING_NUMERIC = 59
BC_SLICE_REVERSE = 60
BC_TO_LOWER = 61
BC_TO_UPPER = 62
BC_REPORT = 63
BC_VM_NAMES = 64
BC_VM_SLICES = 65
BC_TRIG_SIN = 66
BC_TRIG_COS = 67
BC_TRIG_TAN = 68
BC_TRIG_ASIN = 69
BC_TRIG_ACOS = 70
BC_TRIG_ATAN = 71
BC_TRIG_ATAN2 = 72
BC_VM_MEM_MAP = 73
BC_VM_MEM_SIZES = 74
BC_VM_MEM_ALLOC = 75


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


#def bytecode_floor(opcode, offset, more):
#    if precheck([TYPE_NUMBER]):
#        stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
#    else:
#        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_round(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(round(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if a == float('nan'):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(len(stack), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        memory_values[int(a)] = memory_values[int(a)][::-1]
        memory_types[int(a)] = memory_types[int(a)][::-1]
        stack_push(a, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names:
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices:
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_ROUND:          bytecode_round,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if len(stack) < len(req):
        flag = False
    i = len(stack) - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if types[i] != TYPE_POINTER and \
                   types[i] != TYPE_STRING and \
                   types[i] != TYPE_REMARK and \
                   types[i] != TYPE_FUNCTION_CALL:
                    flag = False
            elif t != types[i] and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - the BC_FLOW_RETURN instruction (which jumps to the end of the slice,
#   halting execution).
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            elif opcode == BC_FLOW_RETURN:
                offset = size
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []    # holds the data items
types = []    # holds the types for data items


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    stack = []
    types = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack_pop()


def stack_pop(type = False):
    """remove and return a value from the stack"""
    global stack, types
    if type:
        return stack.pop(), types.pop()
    else:
        types.pop()
        return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    return len(stack) - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            types.pop()
            types.append(TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            if is_number(slice_to_string(stack[tos()])):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCTION_CALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCTION_CALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_names = []           # Holds the names for each slice
dictionary_slices = []          # Holds the slice for each name
dictionary_hidden_slices = []   # Holds a list of slices that previously had names


def in_dictionary(s):
    return s in dictionary_names


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    if in_dictionary(name) is False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        if not dictionary_slices[i] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary_slices[i])
        del dictionary_slices[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice(attempts=1):
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if attempts == 1:
        i = 0
        while i < 10:
            memory_map.append(0)
            memory_values.append(0)
            memory_types.append(0)
            memory_size.append(0)
            i = i + 1
        return request_slice(2)
    else:
        return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = 0
    memory_types[slice] = 0



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCTION_CALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary_slices, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices:
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(types[i]):
            sources.append(stack[i])
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #0 fetch
#   &<pointer> #0 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        if name != "":
            report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(0, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `52 "Attach a name to a pointer"', s)
    add_definition(':', s)
stdlib = "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TWYftR0PG02TW200pJxJKo1UlUCfRNRo3VSRqVUGZ8zWZmBP379+/fiLumcTaW6cOGNpI8RwNhu5iElx74hBRPRHz5OHu6FPgQXPMnYBCU/apgHfPyN2Y1yeSRppcSbTUxfYaYQ60ub1fJKkeHqAAvJM35mZmZl1VVPczkzDMzMz3AAAMuZm/KqSc5u7md9AAA3eTMM3d3fdAAAy5mGd73v7oAAFdud6d73cz3AAAMuZhmZ3v7oAAHbne78qpJzmZmZ30AADLnenczN3e6AABtzdNzMzPcAAArLmYZmZme4ABCEo2ivzVRznOZ+c813r1XHN699eeypJX377ypUrn79+/ONAFgAQEn79+/fv2nxJOT6dmU+ttu22gHQPT4A95uSpAXd8vHgLaAHslSA+73ve973ve5mTMMzMzPcoAArYpN5N3yfOXcqpOJrVVqbu54AAB3Je+TZv3d3d9wAADL1vnL3MzM70AACsvGWzMzM9wAACZeMvy8zMzO+gAAbvNbfz4qpInL1rzd5u3gAAD7UCJUqbzW237u7u7n613RRRElta227u7vuwqpIm3VSRcsiruSqm81tt3d3e3LmLHuvXutpLNuLi84uW222STJJJ7B96h4+DhAHOc93zl+3b32vTuK3wGYAAHe97znC76u7u7sEkkkkyTUmlJJJ+AMNwADpmLHlxw5zca5wTzrnnPOk6096J1vN564855ytaqZ8XFWIiK29bbfm7u73QAANvW235mZmd+gAAVl4y2ZmZnuAAAZeMtmd7390AADM5jL+aqpJxrW7vfAAAMvHbdzMzPcAAAqVMvGWzu5me4AABWXjLZne9/dAA2222OK97cASrDZrM97y927u383587ufcBaADhHgOc5znHdC7q7u5d2Lu7v2/bu3HHZKkvV7qVd773r276u7u7ttpsHSwAZmZrN6zB1rWta0ABO312/NVUk5mbu7noAAE7G81tt39u7vdAAA29bbdzMzOoUAVl4y2ZmZnuAAAZeMtmZmZ7gAAGXjPObdVJObu+bu54AABt6y2Zu7u90AADb1tt3MzPcAAArLxlszMzPcAAA+e/OduueeVn378zP2dwaB8PEbN1JVA+IA5vnOcz7Xe5mZ7zNZMy8zeMwAAO97l973MO7y7u75eAAABmZms3rMzMy8AAAxeMvfKqScVMzM8ztp6LJCrl3VL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6JgsqFUVS7reZl3eZmZ+mYsgaiCIiD6jJ35QCXxvRXU3n1d1v1n13vdG7fe26avt93d87F3d3fOc5zmTuZmZmZmZn79+/fv37MrMA/YLu7vveru7sAGZmZ+SaUk5O970ne9PJJN3YAfWpNLdzczNWBC2OZl3fK+KqSYqszOfMudk4sALzmZd35m1Kk3d5vdAAA292/PvnmZmZ3oAAGX3t3fe97390AACYZzMu7zMzP2AAAdvvbu+973v7oAAHb727vflVJM2pUm7vNz8AABt7t/ec3d3d7oAAG3mX5zne97330AADZ775c177nM3UqTv3czMkGeZmHeXeu9y7u+3AHOc5zmdzMzMZrAMzAF2zMzAtd5d/XdzDMzAC7u7u7v2SpC79zzve9u77mZn7AAAK7fe3d973vf3QAAO33t3fcqVJmZzPcAAA3ebt3fnyqkm7u7ufgAAPYm83b+c5u7ue4AABs3mZd3mZmfsAAArt97d33ve9/dAAA7fe3d9ypUmZnM9wAADLzLu9+VUk3d3dz8AABt7t7zm+7u73QZmLMWYv085ffJ+ADvf297374PpMkgE2dkDvTdVJO973vcu5eTNSVJvPszPsr5ab1VST557pmHlVJPuFSpD75mZ9X0u79u++O973q7OSVIPOQ3tsPS3tNRb7b33zPO9735znO5mZ76AADt97d33ve9/bi7ooooirXMvDM2pUm7vN92IaAB3eac3d3d9wAADLwzflVJN3dzv0AADZvN295zd3d90AADL6d73ve/ugAAV2+ne7UqTMzme4AABzOZl3eZme57gAAGXmXd5mZ390AA1rWs/b87e7/b/e3zmZ3v7d3d3bpoAtAHOc5zjL3mZmZnczPMzMzPF3d/Xd4W0ppLsxJpSSNpUJJJJlkoYBAAnpmZnzrvvWZne53zMzLu+/u97+wAADqX3t3e+VUkzMzO/QAAP2czLu82pUm7vN90AADLzLu8zMzPcAAArLzLu8zM7+6AABkzmZd3mZmfsAAA6l97d3vlVJMzMzv0AADLzLznM2pUm7vN7oAAG3mXd5mZme4AABWXmXd5mZ390AADM9+7Pmyp885yVN8987f78/XdtgOmgC0ODxzfOc57nc7mZ5mYAMGwMzMXd3eDGZmYOgMrMzMzMzALu89De9szM7mgAAdS+9u98qpJmZmb38AABm83l3u7u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Ld3bbbbU/2ZjVtu7t9u7u/NVUkIVUkN3dvznN3d3fdVUkIVUkN3du73d3dzUlSIhJUiK3d272220uJNLFizEmli9223d2362lxJqIhJUgbu7d3v37VSTd3d+fUlSIgk0sWW277zltttUWNPFizGnltu7t/Xd3d+wqUiElM3m8zybFE8Vfz558+c588ttoAHAAn6SbJJJPpMkkgjvvy+377mZkDrV4AzMu7u7u7Xi773uX3LvEkkkkkkkk9kA9AAJAOboAFFmSUiElN3du73d3dzYVKRCSibu7u7bbbasxp4sWW27u222jrdtu7tttomrbbu7bbbU0Abul/NpK22+pq23d22221NW2+c5ygBE0AbugADqa3pq+TvnmvtZzPs7eAHoPg8A4Ng73nOc4AXd3d3di7u7u7ted7znM7nmXeHF3d3d3YAAZMzM3vYAAmgDd0AATQBvnOagvG0lbeXG1bbs5y222pq0POc4ABE16AbugAJOSTd2AAJoA3dAAGmAb40uYlzGF42krbxXGnbbs5y222pr097Wt/e+fZ9zmdzAPQfB4BwbB3qSpO973uVzmM1nn2qqSfZj767u7vCXd6kqS7u7t28u++VUk73LvKlSHMZnuBtd3eOgAA3vYGSVmZm97zMzMxNAG7oAAmgDd0AATVtt3dtttqaAN3QvyTStt8a9WNgbuh+AD3HmNrMzMxK23znOW22xVYkBznOAARNUDd0AAbXikN0PjPg4AAeAE9kPA/ZnczN5mY73nOc5p8HpZuSpDwFud8vy7u/3WmZUqTMzM5dSpDwAGA+DMzMx148PZKkHmQb3sJImpJu7JJJE0Abuhfm0lbb4mvcWW27u2221NAG7oAAkwDd0AATQBu6AAJoA3dC/NpK23xNe227u2221NAG7oAA2pz8+NpM81srSbt+vb0y4l5Gk3ty8aTdutJvxpp39xpN260m7fkmnfGk39bby/NpK5bs/STZB3vNc1zm+ageyh5d/j6NbkqQ8pmZvt8u75hhUqS7/VJVW1B+zP379gXYSSfSST9JOdUz9kyZK0m7+1pN6rbd3bLbRNAG7oAAmgDd0L82krbfE17bbu7bbbU0AbugACTAN3QABNAG7oAAmgDd0L82krbfE1bbu7bbbamrbfOc5aARJXMx3NSTfupJu/tXnZU39qT377z73399++5f796D0HwedNjg2DXe85z73gj4DKzMzMzMwHtVJAfAXd3d3dgu7u7u7OyVJMmSYAABIAbugACqxZiTSxYlbbu7bbbak0sWLMSaWLFbbu7bbbakZmxG73POvPOc555+flDzzzz37IzESpEbu7d3u/t3d34qqRIVKRu7y73d3d3s1UqREJKkR7u6c3d3dyakqREJN3Td3d3d2SpESEqSBu7t3tttpVjTtuZbfvm0lbb40kvcbWYuin1nzCuyX3lVObbZ6676pW1IQ/oBJoSRLuIgSE8uJZhGDgCWREY5nHObc8576FcutUfmUdYt1wSnfrKWM6BSyWgbDdASy6Crhpttj2yfmcdbm1rYqfRWij377n595+atWtkQiPh7qqvnR6uEJPpJJwlzDkBWJOko931+69585++EdZqhkqlOaqSqaPdui5UqU10AtqXd37d9koPs65znOc58Sp061FGNWhVyaPvNcPvX19vl2CQBRdNAto5VSpU0PTpvKqVU155ndZnh93t89lSVoSQVeoEBSQDQgFOZV1Sn799d8353fJzQeXd3f13bwXVVKqSu1VSaqU076bc59BcznPecznOd/CsyzMUZBYhnPureO7tQkg5ISYJJvt3dN30GxvDrTUuSqkaDt3v5+kqqmZn2Z3mZiqlSqn2vPth35bypKpoHoPg8A4NgOmhAXd3d3d2AA3y73d3wb8A5wXVSS/nng+Hr4Oeg+G7u7u+XbYDpo8u7u75LsAQAW04PB03kkqnmqqSbzeZny5SAkvsqsdZfyufzMlIDvdPd7p7QEse1Uk8Pvb3LG6qSejx5PjTM8qpJncwwETW0l3vfu9n0X7ok5m5kxa2sQvzaU39zmZ5mBc3VSTe/ZKk886+HXzvtVJPoNnonJ6/gmxSztOoEG8+2Mu5t98y+6KqSG7eD43VSTmjYeNO7qpJbx6TZNbSU73vne50i42koAafhE1tJT9Gxmua979fpDfbQryKyK+7ob9+8+fO+d2pAQCDo7undzWhIlghY2IBoRrBBm1ve7OfNIDn3d3ezJ1pARzVSTT7wd7YTp74Otc1d3d3y0eHoyT3jaSzkfe+d/dXxP3jaSyAeB8IbaZieSkA/nzp7u3fJARjSAez87u73M6oSA8+6evb3YSAexu73dfajpSAyenuvZ3yEAiRgIaaSDaSAjdnd7Z6w1NLqSAnuuu6iN8jHtJARuXt7z7oSA7g4l6qpJd3d3fU+yVJ9M9qpJmZ3O55Ml7qpJd3PL8u7sd0bPgp9ewOabqpIc8HoHN+Vd+yx23wfB6BSPuSO9SPs8/SkdkJ5nX7z9+5z939VSQPvgNru7vnZUlVerAXKklU0AbqpVHTbVVJHXpuqkgT27uy7v27u7X5GweVUqugnPR97kkqSZnkzOZmXntVJNyVIDhdt7qpIeA67uqkjQF8b3VSQ2+u78u7uwbAdceVUqvT6GnOguAPhPLu7ypJXB5mZmZuqkgDunq2pKkO8bHgHIAAENB8eDhzV3uqkl39d3x9oeA+PKqVT1oO3xvL0IS+b8+a9r0w6UDH8mPlZ8aQHd29VVu+3Octo4PNljx1eOAZgALu59996qTUxVTyoxVXeUr7Pud885a4kqVoAuSSqnJUjZ6dN973mZPn39Fh7ECWVAgSuvfXvr68gS+mISD58hJpgcTSbMaTaXocMaTYfgDgEk/SN80PXe85znCeg+u6wBmZd3d3d25d3fcvV5djMwu7qVJd3d2APBwNJsNabXcafoZ/I8XLrSTtvGk0ribSVutuLEmrbd3bbbRJgG7oAAmgDd0AATQBu6F+bSVtviatt2c5bbbU1aHnOcAAiaALznLbbamqBu6AAJMA3dAAE1N/c3cPBB+Akkh6D4AA2HN8uSpOX37rn0HiTSk+nm9YlySSQ6AuGBiTSADgfd97x3uXf1VJMqVIZMzMzAAAEkkADd1gACaAN3WAAJq227uu222poA3dYX5JpW2+Nq23dnFbbbU19bebofgDxNRBw85oAETRIboAAkyQ3QABNQDm6AAJrsDd5zme5mZnwPQOaAC7B+753fOe8zPsy3pd1+HoZnLwAzKlSA3JXLx4OmYC2gAHTYGZmZvYX5tJW2+JoVt5uy222pqhd3Q/AHiaDQ5ugARO227u222lTVtu7tttomgDd0AATQBu6F+bSVtviatt2c5bbbU1aG7oAA2vMTTTUxttrixtpJJdxttLUeHodCUADwAnskl3d37fe2+Oc++++v25d37drq7u7uxd3d3d2u+97UqTve/qkqsMzMzMA4PAH6Tk8k/STovQN3QABNAG7oAAmgDd0AATVtt3dtttqaAN3QAiaLbbu7bbampJN3ZJJE0AG7oAWpoA3dACJqgG7oACTaaaMbSSd9hKaUZCTnnf3VFdsFZkSbBV8hYxBztpIQid97du/mdfvm/Vd3d3ov27u+9Xd97Yb5z7z77t73d3d2S7vD2SpDM7nNgGXd3fe9y7u7AAJJJJJJJJIAG7oX5JpW2+Jq23d22221NW2+c5y0AiaAN3QABJgG7oAAmgDd0AATQBu6F+SaVtviatt3dttttTVtvnOctAJcStt95zltttTUxJN5Z54jEk3iXNr9/c99ttibX1tvqR+0NXoE3yknv173v33VJJ+/e/fv37vnVd3drl3d3dv2YAu85dyqku7u7XbKpNgQ93E02AeJNsNIYeJtNmJgAAE5JPkmlKcvbb5znLbQiaAN3QABJgG7oAAmgDd0AAT7iQcN3SSSJottu7tttqakk3znIeNpILb6k7bdOcsttqatDd0kkjaGsAN3T8ACamS+bve8vn3LfGv1pLAKeB2HoBGXmZzC5n2ZzlyVJ9989XdvZKkL872d73q14NyVIOQzqXfOczvfe9uqlUbqpF7JIfgAGgDqTSmFzEk3bbbb923l/JW27u32gCaAN3SnzaSA4mgDZzhWnbbU17bM4cAAbX2BM82AAJoJhoAAmvAOm4ACa7TSGFttTQdmQL1tJXtvjavlu73lLbamizfs6Znvv7fb557iv18dpxNv7GmTXyU/BPPC2TilSHF/d6D7zn7zfn32Znjt4cXd2D9nHwervFSpC77zuu9ySqq8Dn7WpJVZtMAD82m7aHrabAAM6GySfEkmZO9JE0ZE904G7oARNdamSbuySSNUA83Q8+bSRNTVy+226m0tzcttE1393u7vbJIk5JN3ZJKCaAN3QCRNSSebve31tJTJ3U0Z6eBmAX9RNEmefvPxtb+5+9lTMs+pdv2fcmY96PO9y7+u75np7zk/fffZmDAwAtgC7y+3d971fcVKkPKqVQewG8zMw6ODwfpigG7sCUG161gBmegAJqIwMySSRNSSZgk0gvU2lbeNq23M6AW1NW327gACTCTd2SSRNCAN3QAE1JJvnObJeJNINMSYBu6AAJrzPM55Ye/b3F5793t/fr9369lVVpw6ffj8ebixOe0zMzPwDwc5z7767u7uXdv0ALYQF3l33ud73LvJ2qlUAFVKpbN59RibaaAACdzvexzu9N7Obve9J1NSSbugACTAN3QABNAG7oAAmgDd0C9bSVt4k7bd3bbbbU1bbvnOW0DqSAN3QAC4krbd3bbbRNAG7p8+d3CPkeyu36n6gEEAJZaPoZz9VEgJdc3rcd5wz1I2iuNuOBczc86ffKUoVjASZ6fq/Vt55AlDiIASZc1MNugEyJ2aaYAkx0DASiIjHCBKYggnpInJtnoir6jGWgSu864bmyWnYNCHUxOtApfiIt7IQYm9mAEmDzbDryIpjASdbxGugQNgJOGOAErZvzsQiG/dOGEIbhx9fOnLr6o+XuTUfW/XVACT9EIRfihCGm0kg2K+r+b3zhCXDngDqyLRNUMm2zRaz1gtKqZFZnOc5z77n1wVgozCzOAJUqrmpJKjaXqqkl3d3U8ku+wcF1JValSVUnjno95d3d329BUAL79/V65FL7Zxgh1KrJS2bVVYm85znPeccT6SsMyUsxSsKsYouZznOc59zPwV3oq4xVmVDZorCtaKsldxWVXJmitUZBsTY2A2orABD+dfdnboxtggYAlYJEISRd/fvO+/38/e++UrYlZbUrNqSaK7ju7trdQJeQJMQlsVu73V3CNYNAl7OFV1kjqyJoU0myqOYA0WTmuec59zfOJX0yojGMyQMKxLLRW1tNrbZorT7zb79+ffv3n36k/cQ02sbZgTYNrWptA+NOZssxKfeffvv8NFypKr3aSpVa14C4VKqXGgEAX29Xd3dnSqkqe+A44a1VSevQ4+D0HoPg8A4NgO3d2N1UkHgAF3d3d2a/fZmZn2Z3M2A4PAPg9F+Xd3f12eAcG13d3y71YC0ABABbQH33333xrzXTzwdcHnnngHe4AzuYNBd6vt3d2ti9yqqtaqVuqkpzPPPszO5nugcDM5mZnv2dm985znuZl4AW1Lu7u7s0PQtwBdgHDd+Xd3eS9E3JKp5n32ZmYBUqS7uXqSSTWqqpK1qqrzVb1JPt3d+2sALe3d37d9tw3VSRoHi7u/ru7B4By7Bfjbp66ZJKr7vPJJVOZzzMu8vNOB6WBtd3Lvl3YaICdu6qVLu7uwoBfb1d3d2ADzl3u7+u7ZJVVeZvMzMzOfXfl+3d2ABElSKqSJVSKlSKlSKqeezXu6qSe++gvgALu/bu79sNm6qSA+Pb9kleyVJrsqTsStCCJpggzfgCXogEGV866zvnfOnu7jgF3d3e+Xew6KkqrqpJpsHh7JVV7VSq8C13bdVKoB0hd3d3d2AIGl3eVJVfaqpUqD0zMy2gDyqlUBweSumxwPgD5d+WAAAF3q7u7u1tSpVeVUqnA4teSSqu78lSpWTPvuczMwAu7u7u7AA8qpVBEcAAALu7u7uwAABbXby889z3Mz3eYOFtze/dA4AAHB4AAA7epKku7vfZWpe7DpVVc1VSVWRWYyKzI5rnOc1998ieisqmYkkkwEmJsSSTY00bG5u93cezM+fL+c4z93n8H3fj1pNH1sPPzJKez8AeW22fpHgPBznvteiruwzMqVJmZmZmZmZiSTvenfvv379Pvp3veyVAXzMSTdtlttEZiSbtttA73vwNNZiUob5znvHmJtZjnffCHe9UNVsVed9U6ozarZNtZiSaSwA3d8AATRgG7skoRNZmZve8zBJQb3sCVA3vYzMyVMA3dA+VxppW3ia8tt3dtttqaAN3QABJgG7oAAmu+qEXNxLM8xbffL+9qVzMzjVtbfnweg+D0Hg5zlyNL9fl8L0eAHqTSJANX4A4k0gAn4kEmkABn7v33zTSn7uLpIB3ve97G0kVKkZmZmYtqSpDV3d3fMvDe9hmZGgDd0C9bSVy3U1bbu72222pq23d0AASYBu6AAJoA3dAAE0AbugXraStvE1bbu72222pq23d0AAf/VjStt3dtttE1OatSWLEnjSTeGfpuarU4399nufw/Gfv2ZmHwegADwcnNZ9++v9P36vzO9fvF3d3YeH13fl3d3SaUjTS73ve9XejabgEkk73vQAAAJ93OySpJuy4k0tPg3dAlBNAG7oF62krbx+Yrbd95y222pq0N16EkjaMAN16AETUkm6tkkkTX0mzckL1tJW3iaFbt3u2gCaITckkkSc7JuSUATX7i/MazJV+zHb360vY27bbfnf1tPACeTEmlJJ5JOzzZPy3954MBbITTM7koAYXeAY73ve9y7yNVUkCAPEwIeptNmNNgAEnfe/b98fu907DTcAAE0ENWgXraStvE0e23zLbbamojIYAAJMgbugACaJDdAAE0SG6BetpK28TXltu7ttttTQBu6AAJMA3dAAE15jTSi+i8nu4b59r7n3nvvuczMAfB6D0HweDhmXUAg32Tjz3u7c3Y17u93b7d3d3t97MyffCJDwAAAkkk73vc73veyToAbugACaAN3QL1tJXLdbVtu7ttttqatt85zltAiaAN3QtttTVtu7tp8BxsA85zgAFElbb5znLbbYmgDd0AASYBu6AAJrffvu/vt8988/B993zp3s9A+D0AA49Pc7O9599maqpIu7s6wAwu7u7u13d971d3dgAbTYAATve973O9JIBDd0AATQBu6BetpK3bjatt3dttttTVtvnOctoETQB5znAAImgDd0AASYBu6AAJoA3dAAE0AbugACattu7ttttbXmNJvIzEB+qnLIr7Z53ct4B9mZnoAA8F/fuu/SVJzNs67clREA30PG0lgHqTSA6p73vYk0pJJ73ve/vs+nRtNySAAQMbTYB42kgAnqhpiZkkn0kkk3dklraStvE1bbu7Zbbamrbd3aHwHE0Bbzm2221NUC85y222pqmhzdAAiaAt5zbbbamqBec5bbbU1QN3QABJgG7oAAmrmxdPFu+8STf3v6+/vL3y2dVN/AAfj4DgASSSSSTyTz38fe/Bv77v073toAHQ2Xd3d3d1UDclSPpJSampUkE9ZVJvuNpsAAAne973vezve/t73neysIAbugSS3Erbd3bb2xtJW6mvLbd3bbbamgOHOaABE0AbugACTAN3QABNAG7oAAmuAG7oACaoBu6BbamgDd0AsbSVupPPuLM9+tt+9v3y7NoAH63tt5bbZJJJJJ5J39P3nn7vfs5fbzADC+973vXV3d3YZJVVmtyVEB4YmmwONpsgeNpsAPW02ZcxJN0D623yz8pJJJu7AAKmrby85tACJoA3dAAEmAbugACaAN3QABNAG7oBY2krdbVtu/c5bbbU1aG7oAAkwDd0AATQBu6AAJqTvFMaTfV57ub57+bSR7Uv379e3qpoVW2+K3tt4AQabPzTSAPAPSeyZ+83mKe953vZ3Vr9u7v27B29Xd33q773rve5VSqvNknG03ABppAEYAetpsE2kAHQ2UEAbugBW0lbqTVtu7t7bbamrby85tACJoA3dAAEmAbugADVtt3dtttqaAN3QABNW23d2222poA3dAAE1QN3QABNXz8fv0nR6d8baNYlswgS5Ak6M0BKV5/H8OuZ3LcbddFXUTd07rD07vvGyJB7mIv4e14vJjPno9pcTd/HwCGGsUAAOiUgTA9+687/fufnATOsaFXBG2JXVoYutbJHBW2jipzWwTlKxtcNMubi3OHNbZrc5SNRMwlZULOc5z3nOcBcFZSJtJGJOOfdfUkB3dNoEmg5D7a3d3d3u7u7r1LkkhjbaEJpCHINAjESy20i0xqpW2gUznPOc58lffffXbQBY1CVUlfarclaqSq1JqpUkgcWhXySpJU8nmxwKlSu8zsmZ9nO/3799+7iuaivN9VB1VS6pWnTKSaJWUeaukraVMVWfw/v37nOfuZlVKrfNSpvQ+u/r9qSqu/bv4fKHoOulS+klxKzGOPda5z33znN8yKyK4imYVcyK1muc55znNc4QMEk9nk8qpPNQHbae1JVXJTQ+Wi5GSSd71VJN+ZjaTkknoHT1pN4mknrWpqpqa1NVA4O3q7u7u+DwD4PQeg+DxcaHJKkuwDp4BwXd3d3doALaAOtNAODwD4PQeg+Dz727v2+cu9gOmhu7u+3OXYBMSSq1m8zMvnOc5zW2Xjj5fr0eZmZmZmsy5d3ffpg9+D1d3d3d2MakapvdSeaqXqbZv7nvM+2bv27v68F23sZKuSpOc5zmdkmXmZmZmD6T19d/Xz6/bsfB0AXYATnOc59MtupKrM+379mZmAd72V7qenvskoe970AE8ne9773vfQfAfXe6qSXq7u7AByu673ve9AOe8vJm85nczLu7wHB43xe7u+XdgnND0u+1UlypKrUqprV3d2LpoHezve970ADsny7ve+d73sGk37uxGAfACTT6osmtpKAJeobqpIAkqS+973ve38HofB7VSS7v27u/bDpsCK9lSq+1777wSaXfvlxppvwP3P34AAAACSd73ve97YBJVSoA9B8B4BwbkSXVzSA3dnNzZ1z0JAd3dXdPdXdCQEk5ImmxJN9xpNhwD4DZJJJ9JqadAOgAeQHeXu91Uqru7s6AB6D4AA1N1UqnttL9528lVJXK1VSVVtPczMzAC7u7u7sEaqpIBuqlUWHTU3VSqAdtdU0C77L1d3dgAvve973q5lSqkn332c1mZnt9vV59Bfth8jVVJHQLA2IHY4PADw3o3furvy75qpKrSR+yS2plkVxcqpzW3xhUm+WO94eHTd32/akqtVrd3d/B7UlV999z6ezuffun38fu/C6W0klSadatvnjV7b+8/fv378AEen3v733bl9u7vMu7u7uwne973zv32xed++9n333073va00rbbff2Ykm7bbbbZQEAfKqlznjaWYszMWYBvG/XrnrR1tm02TYNqbUG1ta7779JV3l7za2tsyk2qmxM0UpUCqIREUJJCSVMy5JOKJRKSklCkEVFQIKhUSKhAqoVJJKKJICJEZmX5zmZgAmrQ3dAAEnJN3ZJJImpJu7JJJE0AbugFjaSt1NW27u/W221NW27ugACTAN3QABNAG7oAAmh+qYluYcDUfgPpk7skEfAcACSSSd2867rrQQVUaJBm+3bBBu9Pve9oILuz4vclSXdra5ft/S9Tuuu971d3YEkkg2kgDyaagwAJ9JObuySWtpK3U1bbu7bbbamrbd3bbehqaAN3QABJgG7oAAmgDd0AATQBu6AWNpK3U1bbv3OW221NWhu6AdDX3Gg4boABcbCd+3zxLzy/fYm8SxJNL2/d5ZYXT4APyPgOABJO00ADwPeffvvnedu+95n6V+Axq8zMA73L3JUl973pg2m/oB7cxJN209bTdm3E03bQACSSSSSTswAN0AATRIboB+ATQH7d0AsbSVupq23fuctttqatDdAOhqaiQHN3QABtfJYB5u6gABNfJIDm7qAAE0BmSSXraSDVMeY1by59viTStttqa75qfcSTTXx77a1559fPr3nbd42YAeNGHxwNvtttttkknD57zn3vuElSXdhl973ve9WAe1UkLv27u7td5Ka3JUg8htmeY+D3P2tJJu22222SAaAZgAWmpoA3dAAEmAboAAmiTMAABNBDN0AsbSVupqhd+5bf1tqatPlugHQ1NEhugegCTA+3QABNRAc3QABNVTd3uB4pn3q8zPf1/Je++9fmLMzH+sst221sDiPgPWlfbbbbbJJJPJP373zzF39+/fd50v2Xd37djoAqVd7Hge3d3lRJtSSQAJINpsAAaaQE/STlbIYAboEK2krdTVC79y222pqku6AAJMkN3QAB1Y1bbu7bbaOrEk8xq23d222RtJW6mrbd+5y7bbamrem7oAAkwDd0AATQBu6AAJr3dW8AD8H3Qvlttt/Wzkkknsknkkinkc52qknPvuG7td3dgAF3d3feru+97JJJFJJJK2mzGm3cxJN7cbSVtttvZJJMkkkk7N3ZJCtpK3U1bbu7e222pq28vObQAiaAN3QtttTVtu7toAJMA3dAAE0AbugACaAN3QABNW23d2222poNDm6AXqTSt1Ne76cu22/vvifcysOAFX11W54AZmWAemd73vElSdzfusmDjklSDyru7tJUgesqYeyVItp7vupl3d/XgAAAetDxlVJN5rMzOfpP379+y3fuctoFTVoec5wACJoA85zgAETQBu6AAJMA3dAAE0AbugACaAN3QCxtJW6mrbd3frbaJflbbd3bbbUnJJu7JJImjfu+fs5ixLnN8Lf3v79f637YyZmZ3MzzeYDoB6c5rnPs5mLC7vAHCPP2YB3uXfklSXd3jfAOgzNSpVZgC7wAgbrdkkgmpJNW7JJY2kjE1DAzPwACaiMDzdkkl6mgDMAAEmAZgAAmoYGYAAJoAzAABNRW7bmW221NAHnMXM5gBfW0lcuJrmz2H2teeX3nv79+7dtAHTYAAPjve97zi77eru7sgB8AL71d+Xd2cG5GlJJPZNkqCSVAd3tknf3bAA3dAAqaAN3QABJgG7oAAmgDd0AATQBvi5i4AW/NpK4muW27u2221NAG7oAAkwDd0AATWgG7oACakk85fPAC/RtJXE1mZ9+6Hy8541nm+/v333337v79bQB02AAD5znuuc8+tpUqR8HoIABd3d3dSrvY8D0G37MzMy8zF3lVKoEN1UkzDySTs+X0nNvOAAVpWhu6IAC4n9ltu7tttiaEAbugAJqSTd2SUBNAG7oEATVtMu22wxNfSTObJJ2YmhBMNGBDE1JJu6CAhia91c95+8PO3fVICVXEVPz27E/LEJXnu3hCUe8AlyFl3kdDy97e73RGWIS2ygYefr4EE9VeyXrvb75vX8jKAS+IEoj5lTnyCkQyPRYyZhW/j+FnawEpJ+WscNJAzvX8T9kfPq1Wpx91nXbAD4PfOb5z3nPgD7f2ckn5dPUoxtJSd9mh8daXU03E03ilclE2JWkrnJtjbCYVorNSsZk2zWbZrc1zG0zFVkVjMplRme75zfOc59zMpWUWKYjUVhWmxs2jo3Pv36LAB2SpSaqpJNSqkkjYBBAGj5ISgSQ2khIbiI5vu7djd3d3gSSUAFVUqrmqqVK99j0O9XJk2SSSTV6JJvY8jSbFzT8HwdjzE07WUi+qic4sUmkraoyepPNz+AADH1pthuySfd+/d3vO97JI25Vc1UupJ9549enRKkSV3U7o99C0iAkYkCVue7uzt7ieAAgQIhx3d3dN7AXaALv9KrJUusmbzMzuZ6qqqNaHwdvV3d3d8HgHweg9B8HPR6+22NVKoWFh6bqpIPIu7u7u7QAW03d3d33t7AcHgHweg9B8GvLu7v6+3sB00Lu77cu7AIBfOc5ycg17d3fv1289B8Xd3d3dgAAPRl61re7zE/yxbiOnvv495FO9773vSSQAD1EaqTt6u7uduVjM3mZmY70kqS7u7vvbGwB29Xd7ux8bBO973JJVc1NVJVazdqfnz58+fO7u7u9eJHM1qWTcqhopjbCYghqGsKJIJaJIgG2OUQ2lMjUTu/c6ABrV3d3d3YAF3d3d3YAX3ve971cA3mZmY6ZED4ANyVIu/ru++35Y+l6jfT4hdVKlRoAupUkqNAe7qpJ3vfe9dvb0Hwe1KkB8GSpVfZmZn2Zme8u937d3fTYA+8qVzv1SvqlKlee8u7u7AAcXu7u7uwAHqb025jU+nNa+zdVJPry8zgAC7u7u7sBVSVQC7u7u7sAGmqqVQDpqqlUFtFoAu/MklVv73ySpVBy2MAAANVUqgCwF3d3d3YABuqlVd3d3y72PjdVJC/AAZUqTMzMzMzABWq1d3d3d23KqpUAdJKqgu7u7u7ADpuSpDbdVKoC1jw3VSQPYau7u7vuSSq/REM8PAwNnskn75tJdzve973skABGOpJmZmHr36x37gEaqpIA7d3fa/WsVbWaVaK/YrRXDUriJqkpoVZA7s1v7nOe858omuRnd0943Q3d3d7utBjSCMhLGsaD41zqSb1JGpKruqnvl+XdrvNAHT7wPgAPnOc5z7h75d3f13a7u7u7sXd3dzvV3d3YAAaaqpIuw6OiSSSdybO970SSFja/hY0rTLttvbiauXMxK23d223txNjWZiYBu6AdMTY1gBu6AdMTVxXHbbu7bb24k1JJtXOHGmkBwE0Ab+5wABNBJu7JKupzE1bltu7tttqazhjSnnDgHp29PtyNg6bAAB85znOXJUnG8gGSVJmZ4oH0lSC32wnslSD59ffO96SAABIAcCGEkne970gaHjaSAAh3nOEnfk13ve+c5zo00pDhE0Aeec99zMXKhd++eeXd32VED7zzwZl1P01gHnOcADrTUkm7srTSA4CTQBu6fABczGmsxq23fOcvAJ42kjEncSy23d36221NefeeZOecPD2X472ZJJJJ9JskDg8FtPnOa5zn37MWC7wAQC/ru7u7d727vy7scALu7u7uwSSKSTd2d73tSckm7sGmkBwE0AbunwANoA85ivnlA++xtJGJqq23d36221NAHnOckknU1JJuStNIDgJ7jUwOG4fgATXpA3A8AE1Jv6c5zOYpJPLjaSMTWd8W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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary_names, \
                    "symbol_map": dictionary_slices, \
                    "errors": errors, \
                    "stack_values": stack, \
                    "stack_types": types, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')

    try:
        c = bz2.compress(bytes(j, 'utf-8'))
    except:
        c = bz2.compress(j)


    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary_names, \
           dictionary_slices, \
           errors, \
           stack, \
           types, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    try:
        raw = base64.b64decode(bytes(s, 'utf-8'))
    except:
        raw = base64.b64decode(s)

    u = bz2.decompress(raw)

    try:
        j = json.loads(u)
    except:
        j = json.loads(u.decode())

    dictionary_names = j['symbols']
    dictionary_slices = j['symbol_map']
    errors = j['errors']
    stack = j['stack_values']
    types = j['stack_types']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_item(prefix, value):
    sys.stdout.write(prefix + str(value))


def dump_stack():
    """display the stack"""
    i = 0
    if len(stack) > 100:
        i = len(stack) - 100
    while i < len(stack):
        tos = stack[i]
        type = types[i]
        if i == len(stack) - 1:
            sys.stdout.write("TOS  " + str(i).rjust(8, ' '))
        else:
            sys.stdout.write("     " + str(i).rjust(8, ' '))
        if type == TYPE_NUMBER:
            display_item('   ' + '#', tos)
        elif type == TYPE_BYTECODE:
            display_item('   ' + '`', tos)
        elif type == TYPE_CHARACTER:
            display_item('   ' + '$', chr(tos))
        elif type == TYPE_STRING:
            display_item('   ' + '\'', slice_to_string(tos) + '\'')
        elif type == TYPE_POINTER:
            display_item('   ' + '&', tos)
        elif type == TYPE_REMARK:
            display_item('   ' + '"', slice_to_string(tos) + '"')
        elif type == TYPE_FLAG:
            if tos == -1:
                display_item('   ' + "", "true")
            elif tos == 0:
                display_item('   ' + "", "false")
            else:
                display_item('   ' + "", "malformed flag")
        elif type == TYPE_FUNCTION_CALL:
            display_item('   CALL to ' + '&', tos)
        else:
            display_item('   ' + "", "unmatched type on the stack")
        sys.stdout.write("\n")
        i += 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names:
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack, types
    i = len(stack) - 1
    if types[i] == TYPE_NUMBER:
        sys.stdout.write(str(stack[i]))
    elif types[i] == TYPE_CHARACTER:
        sys.stdout.write(str(chr(stack[i])))
    elif types[i] == TYPE_STRING:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_POINTER:
        sys.stdout.write('&' + str(stack[i]))
    elif types[i] == TYPE_FLAG:
        if stack[i] == -1:
            sys.stdout.write("true")
        elif stack[i] == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif types[i] == TYPE_COMMENT:
        sys.stdout.write(slice_to_string(stack[i]))
    elif types[i] == TYPE_BYTECODE:
        sys.stdout.write('`' + str(stack[i]))
    elif types[i] == TYPE_FUNCTION_CALL:
        sys.stdout.write('CALL: ' + str(stack[i]))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary_slices, dictionary_names
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary_slices = []
    dictionary_names = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9000:
        dump_stack()
    elif opcode == 9001:
        dump_stack()
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    dump_stack()
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    home = expanduser("~")
    try:
        src = home + "/.parable/on_startup.p"
        if os.path.exists(src):
            load_file(src)
        elif os.path.exits("on_startup.p"):
            load_file("on_startup.p")
    except:
        pass

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
