#!/usr/bin/env python

# Parable,  Copyright (c) 2013 - 2015 Charles Childers
#
# Perform a POST to this script. The resulting stack, stack types, provided
# code, and any errors will be returned as a JSON object.
#
# Fields:
#
# Paramter         Notes
# ---------------  ----------------------------------------------------------
# code             A string containing the code you want Apologue to process.
#                  This is mandatory.
#
# Setup:
#
# Copy this file, *parable.py*, and *stdlib.p* to the *cgi-bin* directory. Make
# this executable, and setup your server of choice to allow running it.
#

import cgi, cgitb, json, signal, sys
import parable


def handler(signum, frame):
    print "Content-Type: application/json"
    print
    report('FATAL ERROR: Execution exceed max runtime permitted')
    sys.exit('fatal error: execution runtime exceeded')


def get_results(message):
    """export a parable session to the specified format"""
    sequence = []
    i = 0
    while i < len(parable.stack):
        if parable.types[i] == parable.TYPE_NUMBER:
            sequence.append("#" + unicode(parable.stack[i]))
        elif parable.types[i] == parable.TYPE_CHARACTER:
            sequence.append("$" + unicode(unichr(parable.stack[i])))
        elif parable.types[i] == parable.TYPE_STRING:
            sequence.append("'" + unicode(parable.slice_to_string(parable.stack[i])) + "'")
        elif parable.types[i] == parable.TYPE_POINTER:
            sequence.append("&" + unicode(parable.stack[i]))
        elif parable.types[i] == parable.TYPE_FLAG:
            if parable.stack[i] == -1:
                sequence.append("true")
            elif parable.stack[i] == 0:
                sequence.append("false")
            else:
                sequence.append("malformed flag")
        elif parable.types[i] == parable.TYPE_BYTECODE:
            sequence.append("`" + unicode(parable.stack[i]))
        elif parable.types[i] == parable.TYPE_COMMENT:
            sequence.append("\"" + unicode(parable.slice_to_string(parable.stack[i])) + "\"")
        elif parable.types[i] == parable.TYPE_FUNCTION_CALL:
            sequence.append("Call to: " + unicode(parable.stack[i]))
        else:
            sequence.append("unmatched type on stack!")
        i = i + 1
    parable.collect_garbage()

    p_map = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_map.append(i)
        i = i + 1

    return json.dumps({"symbols": parable.dictionary_names, "symbol_map": parable.dictionary_slices, "errors": parable.errors, "parsed_stack": sequence, "types": parable.types, "code": message, "slices": parable.p_slices, "typetags": parable.p_types, "memory_map": p_map})


def process_input(source):
    lines = parable.condense_lines(source.split("\n"))

    for line in lines:
        line = line.strip()
        if len(line) >= 1 and line != '':
            slice = parable.compile(line, parable.request_slice())
            parable.interpret(slice)


if __name__ == '__main__':
    cgitb.enable()  # for troubleshooting

    # Cap max run time at 60 seconds
    # (This seems satisfactory so far, and keeps server load managable)
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(60)

    # get input (in "code" field)
    form = cgi.FieldStorage()
    source = form.getvalue("code", " ")

    # setup Parable
    parable.MAX_SLICES = 32000
    parable.prepare_slices()
    parable.prepare_dictionary()
    parable.parse_bootstrap(open('stdlib.p').readlines())
    parable.collect_garbage()

    # process input
    process_input(source)

    # return results as a JSON object
    print "Content-Type: application/json"
    print
    print get_results(source)
