#!/usr/bin/env python

# parable
# copyright (c) 2013 - 2015 charles childers
#
# Perform a POST to this script. The resulting stack, stack types, provided
# code, and any errors will be returned as a JSON object.
#
# Fields:
#
# Paramter         Notes
# ---------------  ----------------------------------------------------------
# code             A string containing the code you want Apologue to process.
#                  This is mandatory.
#
# Setup:
#
# Copy this file, *parable.py*, and *stdlib.p* to the *cgi-bin* directory. Make
# this executable, and setup your server of choice to allow running it.
#

import cgi
import cgitb
import json
import parable
import signal
import sys

cgitb.enable()  # for troubleshooting

def handler(signum, frame):
    print "Content-Type: application/json"
    print
    report('FATAL ERROR: Execution exceed max runtime permitted')
    sys.exit('fatal error: execution runtime exceeded')



def get_results(message):
    """export a parable session to the specified format"""
    sequence = []
    i = 0
    while i < len(parable.stack):
        if parable.types[i] == parable.TYPE_NUMBER:
            sequence.append("#" + unicode(parable.stack[i]))
        elif parable.types[i] == parable.TYPE_CHARACTER:
            sequence.append("$" + unicode(unichr(parable.stack[i])))
        elif parable.types[i] == parable.TYPE_STRING:
            sequence.append("'" + unicode(parable.slice_to_string(parable.stack[i])) + "'")
        elif parable.types[i] == parable.TYPE_POINTER:
            sequence.append("&" + unicode(parable.stack[i]))
        elif parable.types[i] == parable.TYPE_FLAG:
            if parable.stack[i] == -1:
                sequence.append("true")
            elif parable.stack[i] == 0:
                sequence.append("false")
            else:
                sequence.append("malformed flag")
#        elif parable.types[i] == parable.TYPE_BYTECODE:
#        elif parable.types[i] == parable.TYPE_COMMENT:
#        elif parable.types[i] == parable.TYPE_FUNCTION_CALL:
        else:
            sequence.append("unmatched type on stack!")
        i = i + 1
    parable.collect_unused_slices()

    p_map = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_map.append(i)
        i = i + 1

    return json.dumps({"symbols": parable.dictionary_names, "symbol_map": parable.dictionary_slices, "errors": parable.errors, "parsed_stack": sequence, "types": parable.types, "code": message, "slices": parable.p_slices, "typetags": parable.p_types, "memory_map": p_map})


def process_input(message):
    parable.MAX_SLICES = 32000
    parable.prepare_slices()
    parable.prepare_dictionary()
    parable.parse_bootstrap(open('stdlib.p').readlines())
    parable.collect_unused_slices()
    f = message.split("\n")
    counter = 0

    f = parable.condense_lines(f)

    for line in f:
        line = line.strip()
        if len(line) >= 1 and line != '':
            s = parable.compile(line, parable.request_slice())
            parable.interpret(s)
            counter += 1
            if counter > 200:
                if len(stack) == 0:
                    parable.collect_unused_slices()
                    counter = 0

if __name__ == '__main__':
    # Cap max run time at 60 seconds
    # (This seems satisfactory so far, and keeps server load managable)
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(60)

    form = cgi.FieldStorage()
    message = form.getvalue("code", " ")

    process_input(message)
    print "Content-Type: application/json"
    print
    print get_results(message)
