#!/usr/bin/env python

# parable
# copyright (c) 2013 - 2015 charles childers
#
# Perform a POST to this script. The resulting stack, stack types, provided
# code, and any errors will be returned as a JSON object.
#
# Fields:
#
# code                    field set to the code you want to run.
# multipleLineDefinitons  allow definitions to span multiple lines
#                         * requires a blank line between definitions
# discardInternals        do not return the memory map or consumed slices
#                         * saves a considerable amount of space from the
#                           result set
#
# "code" is mandatory, the others can be set to "true", "false", or left out.


import sys
import cgi
import cgitb
import signal
import json
import parable
from parable import *

cgitb.enable()  # for troubleshooting

form = cgi.FieldStorage()

def handler(signum, frame):
    print "Content-Type: application/json"
    print
    report('FATAL ERROR: Execution exceed max runtime permitted')
    print get_results()
    sys.exit('fatal error: execution runtime exceeded')

signal.signal(signal.SIGALRM, handler)
signal.alarm(60)
parable.MAX_SLICES = 32000

message = ""

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condenseLines(code):
    m = len(code)
    s = ''
    r = []
    i = 0
    c = 0
    while i < m:
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r


def get_results():
    """export a parable session to the specified format"""
    global errors, stack, types, message
    global form
    sequence = []
    i = 0
    while i < len(stack):
        if types[i] == TYPE_NUMBER:
            sequence.append("#" + unicode(stack[i]))
        elif types[i] == TYPE_CHARACTER:
            sequence.append("$" + unicode(unichr(stack[i])))
        elif types[i] == TYPE_STRING:
            sequence.append("'" + unicode(slice_to_string(stack[i])) + "'")
        elif types[i] == TYPE_POINTER:
            sequence.append("&" + unicode(stack[i]))
        elif types[i] == TYPE_FLAG:
            if stack[i] == -1:
                sequence.append("true")
            elif stack[i] == 0:
                sequence.append("false")
            else:
                sequence.append("malformed flag")
        else:
            sequence.append("unmatched type on stack!")
        i = i + 1
    collect_unused_slices()

    p_map = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_map.append(i)
        i = i + 1
    p_slices = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            n = parable.p_sizes[i]
            s = []
            m = 0
            while n >= 0:
                s.append(parable.fetch(i, m))
                m = m + 1
                n = n - 1
            p_slices.append(s)
        else:
            p_slices.append([])
        i = i + 1

    discardInternals = form.getvalue("discardInternals", "false")
    if discardInternals == "false":
        return json.dumps({"symbols": dictionary_names, "symbol_map": dictionary_slices, "errors": errors, "parsed_stack": sequence, "types": types, "code": message, "slices": p_slices, "typetags": parable.p_types, "memory_map": p_map})
    else:
        return json.dumps({"symbols": dictionary_names, "symbol_map": dictionary_slices, "errors": errors, "parsed_stack": sequence, "types": types, "code": message, "slices": [], "typetags": [], "memory_map": []})

def process_input():
    global message
    global form
    message = form.getvalue("code", " ")
    ld = form.getvalue("multipleLineDefinitions", "false")
    prepare_slices()
    prepare_dictionary()
    parse_bootstrap(open('stdlib.p').readlines())
    collect_unused_slices()
    f = message.split("\n")
    counter = 0

    if ld == "true":
        f = condenseLines(f)
        print f

    for line in f:
        line = line.strip()
        if len(line) >= 1 and line != '':
            s = compile(line, request_slice())
            interpret(s)
            counter += 1
            if counter > 100:
                if len(stack) == 0:
                    collect_unused_slices()
                    counter = 0

if __name__ == '__main__':
     process_input()
     print "Content-Type: application/json"
     print
     print get_results()
