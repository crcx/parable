#!/usr/bin/env python

# parable
# copyright (c) 2013 - 2015 charles childers
#
# Perform a POST to this script. The resulting stack, stack types, provided
# code, and any errors will be returned as a JSON object.
#
# Fields:
#
# code                    field set to the code you want to run.
# numbersWithoutPrefixes  attempt to identify numbers and add the # prefix
#
# "code" is mandatory, the others can be set to "true", "false", or left out.


import sys
import cgi
import cgitb
import signal
import json
import parable
from parable import *

cgitb.enable()  # for troubleshooting

form = cgi.FieldStorage()

def handler(signum, frame):
    print "Content-Type: application/json"
    print
    report('FATAL ERROR: Execution exceed max runtime permitted')
    print get_results()
    sys.exit('fatal error: execution runtime exceeded')

signal.signal(signal.SIGALRM, handler)
signal.alarm(60)
parable.MAX_SLICES = 32000

message = ""

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def tweakSyntax(code):
    r = []
    for l in code:
        if len(l) >= 1:
            q = l.split(' ')
            m = ''
            for t in q:
                if is_number(t):
                    m = m + ' #' + t
                else:
                    m = m + ' ' + t
            r.append(m)
    return r


def get_results():
    """export a parable session to the specified format"""
    global errors, stack, types, message
    global form
    sequence = []
    i = 0
    while i < len(stack):
        if types[i] == TYPE_NUMBER:
            sequence.append("#" + unicode(stack[i]))
        elif types[i] == TYPE_CHARACTER:
            sequence.append("$" + unicode(unichr(stack[i])))
        elif types[i] == TYPE_STRING:
            sequence.append("'" + unicode(slice_to_string(stack[i])) + "'")
        elif types[i] == TYPE_FUNCTION:
            sequence.append("&" + unicode(stack[i]))
        elif types[i] == TYPE_FLAG:
            if stack[i] == -1:
                sequence.append("true")
            elif stack[i] == 0:
                sequence.append("false")
            else:
                sequence.append("malformed flag")
        else:
            sequence.append("unmatched type on stack!")
        i = i + 1
    collect_unused_slices()

    p_map = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_map.append(i)
        i = i + 1
    p_slices = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            n = parable.p_sizes[i]
            s = []
            m = 0
            while n >= 0:
                s.append(parable.fetch(i, m))
                m = m + 1
                n = n - 1
            p_slices.append(s)
        else:
            p_slices.append([])
        i = i + 1

    return json.dumps({"symbols": dictionary_names, "symbol_map": dictionary_slices, "errors": errors, "parsed_stack": sequence, "types": types, "code": message, "slices": p_slices, "memory_map": p_map})

def process_input():
    global message
    global form
    message = form.getvalue("code", " ")
    st = form.getvalue("numbersWithoutPrefixes", "false")
    prepare_slices()
    prepare_dictionary()
    parse_bootstrap(open('bootstrap.p').readlines())
    collect_unused_slices()
    f = message.split("\n")
    counter = 0

    if st == "true":
        f = tweakSyntax(f)

    for line in f:
        line = line.strip()
        if len(line) >= 1 and line != '':
            s = compile(line, request_slice())
            interpret(s)
            counter += 1
            if counter > 100:
                if len(stack) == 0:
                    collect_unused_slices()
                    counter = 0

if __name__ == '__main__':
     process_input()
     print "Content-Type: application/json"
     print
     print get_results()
