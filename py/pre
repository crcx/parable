#!/usr/bin/env python
# Copyright (c)2012-2013, Charles Childers
# parable
# Copyright (c) 2012-2015, Charles Childers
# ==========================================

#
# Dependencies
#
import sys
import math
import random

#
# Memory Configuration
#

MAX_SLICES = 80000

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_COMMENT = 700
TYPE_FUNCTION_CALL = 800

#
# Constants for byte codes
# These are loosely grouped by type
#

BC_PUSH_N = 100
BC_PUSH_S = 101
BC_PUSH_C = 102
BC_PUSH_F = 103
BC_PUSH_COMMENT = 104
BC_TYPE_B = 109
BC_TYPE_N = 110
BC_TYPE_S = 111
BC_TYPE_C = 112
BC_TYPE_F = 113
BC_TYPE_FLAG = 114
BC_GET_TYPE = 120
BC_ADD = 200
BC_SUBTRACT = 201
BC_MULTIPLY = 202
BC_DIVIDE = 203
BC_REMAINDER = 204
BC_FLOOR = 205
BC_POW = 206
BC_LOG = 207
BC_LOG10 = 208
BC_LOGN = 209
BC_BITWISE_SHIFT = 210
BC_BITWISE_AND = 211
BC_BITWISE_OR = 212
BC_BITWISE_XOR = 213
BC_RANDOM = 214
BC_SQRT = 215
BC_COMPARE_LT = 220
BC_COMPARE_GT = 221
BC_COMPARE_LTEQ = 222
BC_COMPARE_GTEQ = 223
BC_COMPARE_EQ = 224
BC_COMPARE_NEQ = 225
BC_FLOW_IF = 300
BC_FLOW_WHILE = 301
BC_FLOW_UNTIL = 302
BC_FLOW_TIMES = 303
BC_FLOW_CALL = 304
BC_FLOW_CALL_F = 305
BC_FLOW_DIP = 306
BC_FLOW_SIP = 307
BC_FLOW_BI = 308
BC_FLOW_TRI = 309
BC_FLOW_RETURN = 399
BC_MEM_COPY = 400
BC_MEM_FETCH = 401
BC_MEM_STORE = 402
BC_MEM_REQUEST = 403
BC_MEM_RELEASE = 404
BC_MEM_COLLECT = 405
BC_MEM_GET_LAST = 406
BC_MEM_SET_LAST = 407
BC_MEM_SET_TYPE = 408
BC_MEM_GET_TYPE = 409
BC_STACK_DUP = 500
BC_STACK_DROP = 501
BC_STACK_SWAP = 502
BC_STACK_OVER = 503
BC_STACK_TUCK = 504
BC_STACK_NIP = 505
BC_STACK_DEPTH = 506
BC_STACK_CLEAR = 507
BC_QUOTE_NAME = 600
BC_FUNCTION_EXISTS = 601
BC_FUNCTION_LOOKUP = 602
BC_FUNCTION_HIDE = 603
BC_STRING_SEEK = 700
BC_SLICE_SUBSLICE = 701
BC_STRING_NUMERIC = 702
BC_SLICE_REVERSE = 703
BC_TO_LOWER = 800
BC_TO_UPPER = 801
BC_REPORT = 900
BC_TRIG_SIN = 1000
BC_TRIG_COS = 1001
BC_TRIG_TAN = 1002
BC_TRIG_ASIN = 1003
BC_TRIG_ACOS = 1004
BC_TRIG_ATAN = 1005
BC_TRIG_ATAN2 = 1006


#
# Support code
#

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


#
# logging of errors
#
# errors are stored in an array, with helper functions to
# record and clear them
#

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    i = 0
    while i < len(errors):
        errors.pop()
        i += 1


def report(text):
    """report an error"""
    global errors
    errors.append(text)


def check_depth(cells):
    """returns True if the stack has at least *cells* number of items, or"""
    """False otherwise. If False, reports an underflow error."""
    global stack
    if len(stack) < cells:
        report('Stack underflow: ' + unicode(cells) + ' values required')
        return False
    else:
        return True


#
# Byte code interpreter
#

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    offset = 0
    size = get_last_index(int(slice))
    while offset <= size:
        opcode = fetch(slice, offset)
        optype = fetch_type(slice, offset)

        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_COMMENT:
                stack_pop()
            if optype == TYPE_FUNCTION_CALL:
                interpret(stack_pop(), more)
        else:
            if opcode == BC_PUSH_N:
                offset += 1
                stack_push(fetch(slice, offset), TYPE_NUMBER)
            elif opcode == BC_PUSH_S:
                offset += 1
                stack_push(fetch(slice, offset), TYPE_STRING)
            elif opcode == BC_PUSH_C:
                offset += 1
                stack_push(fetch(slice, offset), TYPE_CHARACTER)
            elif opcode == BC_PUSH_F:
                offset += 1
                stack_push(fetch(slice, offset), TYPE_POINTER)
            elif opcode == BC_PUSH_COMMENT:
                offset += 1
            elif opcode == BC_TYPE_B:
                if check_depth(1):
                    stack_change_type(TYPE_BYTECODE)
                else:
                    offset = size
            elif opcode == BC_TYPE_N:
                if check_depth(1):
                    stack_change_type(TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_TYPE_S:
                if check_depth(1):
                    stack_change_type(TYPE_STRING)
                else:
                    offset = size
            elif opcode == BC_TYPE_C:
                if check_depth(1):
                    stack_change_type(TYPE_CHARACTER)
                else:
                    offset = size
            elif opcode == BC_TYPE_F:
                if check_depth(1):
                    stack_change_type(TYPE_POINTER)
                else:
                    offset = size
            elif opcode == BC_TYPE_FLAG:
                if check_depth(1):
                    stack_change_type(TYPE_FLAG)
                else:
                    offset = size
            elif opcode == BC_GET_TYPE:
                if check_depth(1):
                    stack_push(stack_type(), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_ADD:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == TYPE_STRING and y == TYPE_STRING:
                        a = slice_to_string(a)
                        b = slice_to_string(b)
                        stack_push(string_to_slice(b + a), TYPE_STRING)
                    else:
                        stack_push(a + b, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_SUBTRACT:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(b - a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_MULTIPLY:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(a * b, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_DIVIDE:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(b / a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_REMAINDER:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(b % a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_FLOOR:
                if check_depth(1):
                    stack_push(math.floor(float(stack_pop())), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_POW:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(math.pow(b, a), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_LOG:
                if check_depth(1):
                    a = stack_pop()
                    stack_push(math.log(a), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_LOG10:
                if check_depth(1):
                    a = stack_pop()
                    stack_push(math.log10(a), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_LOGN:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(math.log(b, a), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_BITWISE_SHIFT:
                if check_depth(2):
                    a = int(stack_pop())
                    b = int(stack_pop())
                    if a < 0:
                        stack_push(b << abs(a), TYPE_NUMBER)
                    else:
                        stack_push(b >> a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_BITWISE_AND:
                if check_depth(2):
                    a = int(stack_pop())
                    b = int(stack_pop())
                    stack_push(b & a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_BITWISE_OR:
                if check_depth(2):
                    a = int(stack_pop())
                    b = int(stack_pop())
                    stack_push(b | a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_BITWISE_XOR:
                if check_depth(2):
                    a = int(stack_pop())
                    b = int(stack_pop())
                    stack_push(b ^ a, TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_RANDOM:
                stack_push(random.SystemRandom().random(), TYPE_NUMBER)
            elif opcode == BC_SQRT:
                if check_depth(1):
                    stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_COMPARE_LT:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == TYPE_NUMBER and y == TYPE_NUMBER:
                        if b < a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_LT only recognizes NUMBER types')
                else:
                    offset = size
            elif opcode == BC_COMPARE_GT:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == TYPE_NUMBER and y == TYPE_NUMBER:
                        if b > a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_LT only recognizes NUMBER types')
                else:
                    offset = size
            elif opcode == BC_COMPARE_LTEQ:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == TYPE_NUMBER and y == TYPE_NUMBER:
                        if b <= a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_LTEQ only recognizes NUMBER')
                else:
                    offset = size
            elif opcode == BC_COMPARE_GTEQ:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == TYPE_NUMBER and y == TYPE_NUMBER:
                        if b >= a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_GTEQ only recognizes NUMBER')
                else:
                    offset = size
            elif opcode == BC_COMPARE_EQ:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == y and x != TYPE_STRING:
                        if b == a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    elif x == y and x == TYPE_STRING:
                        if slice_to_string(b) == slice_to_string(a):
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_EQ requires matched types')
                else:
                    offset = size
            elif opcode == BC_COMPARE_NEQ:
                if check_depth(2):
                    x = stack_type()
                    a = stack_pop()
                    y = stack_type()
                    b = stack_pop()
                    if x == y and x != TYPE_STRING:
                        if b != a:
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    elif x == y and x == TYPE_STRING:
                        if slice_to_string(b) != slice_to_string(a):
                            stack_push(-1, TYPE_FLAG)
                        else:
                            stack_push(0, TYPE_FLAG)
                    else:
                        offset = size
                        report('BC_COMPARE_NEQ requires matched types')
                else:
                    offset = size
            elif opcode == BC_FLOW_IF:
                if check_depth(3):
                    a = stack_pop()
                    b = stack_pop()
                    c = stack_pop()
                    if c == -1:
                        interpret(b, more)
                    else:
                        interpret(a, more)
                else:
                    offset = size
            elif opcode == BC_FLOW_WHILE:
                if check_depth(1):
                    quote = stack_pop()
                    a = -1
                    while a == -1:
                        interpret(quote, more)
                        a = stack_pop()
                else:
                    offset = size
            elif opcode == BC_FLOW_UNTIL:
                if check_depth(1):
                    quote = stack_pop()
                    a = 0
                    while a == 0:
                        interpret(quote, more)
                        a = stack_pop()
                else:
                    offset = size
            elif opcode == BC_FLOW_TIMES:
                if check_depth(2):
                    quote = stack_pop()
                    count = stack_pop()
                    while count > 0:
                        interpret(quote, more)
                        count -= 1
                else:
                    offset = size
            elif opcode == BC_FLOW_CALL:
                offset += 1
                interpret(int(fetch(slice, offset)), more)
            elif opcode == BC_FLOW_CALL_F:
                if check_depth(1):
                    a = stack_pop()
                    interpret(a, more)
                else:
                    offset = size
            elif opcode == BC_FLOW_DIP:
                if check_depth(2):
                    quote = stack_pop()
                    vtype = stack_type()
                    value = stack_pop()
                    interpret(quote, more)
                    stack_push(value, vtype)
                else:
                    offset = size
            elif opcode == BC_FLOW_SIP:
                if check_depth(2):
                    quote = stack_pop()
                    stack_dup()
                    vtype = stack_type()
                    value = stack_pop()
                    interpret(quote, more)
                    stack_push(value, vtype)
                else:
                    offset = size
            elif opcode == BC_FLOW_BI:
                if check_depth(3):
                    a = stack_pop()
                    b = stack_pop()
                    stack_dup()
                    x = stack_type()
                    y = stack_pop()
                    interpret(b, more)
                    stack_push(y, x)
                    interpret(a, more)
                else:
                    offset = size
            elif opcode == BC_FLOW_TRI:
                if check_depth(4):
                    a = stack_pop()
                    b = stack_pop()
                    c = stack_pop()
                    stack_dup()
                    x = stack_type()
                    y = stack_pop()
                    stack_dup()
                    m = stack_type()
                    q = stack_pop()
                    interpret(c, more)
                    stack_push(q, m)
                    interpret(b, more)
                    stack_push(y, x)
                    interpret(a, more)
                else:
                    offset = size
            elif opcode == BC_FLOW_RETURN:
                offset = size
            elif opcode == BC_MEM_COPY:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    copy_slice(b, a)
                else:
                    offset = size
            elif opcode == BC_MEM_FETCH:
                if check_depth(2):
                    a = stack_pop()
                    b = stack_pop()
                    stack_push(fetch(b, a), fetch_type(b, a))
                else:
                    offset = size
            elif opcode == BC_MEM_STORE:
                if check_depth(3):
                    a = stack_pop()
                    b = stack_pop()
                    t = stack_type()
                    c = stack_pop()
                    store(c, b, a, t)
                else:
                    offset = size
            elif opcode == BC_MEM_REQUEST:
                stack_push(request_slice(), TYPE_POINTER)
            elif opcode == BC_MEM_RELEASE:
                if check_depth(1):
                    release_slice(stack_pop())
                else:
                    offset = size
            elif opcode == BC_MEM_COLLECT:
                collect_unused_slices()
            elif opcode == BC_MEM_GET_LAST:
                a = stack_pop()
                stack_push(get_last_index(a), TYPE_NUMBER)
            elif opcode == BC_MEM_SET_LAST:
                a = stack_pop()
                b = stack_pop()
                set_slice_last_index(a, b)
            elif opcode == BC_MEM_SET_TYPE:
                if check_depth(3):
                    a = stack_pop()
                    b = stack_pop()
                    c = stack_pop()
                    store_type(c, b, a)
                else:
                    offset = size
            elif opcode == BC_MEM_GET_TYPE:
                if check_depth(1):
                    a = stack_pop()
                    b = stack_pop()
                    c = fetch_type(b, a)
                    stack_push(int(c), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_STACK_DUP:
                if check_depth(1):
                    stack_dup()
                else:
                    offset = size
            elif opcode == BC_STACK_DROP:
                if check_depth(1):
                    stack_drop()
                else:
                    offset = size
            elif opcode == BC_STACK_SWAP:
                if check_depth(2):
                    stack_swap()
                else:
                    offset = size
            elif opcode == BC_STACK_OVER:
                if check_depth(2):
                    stack_over()
                else:
                    offset = size
            elif opcode == BC_STACK_TUCK:
                if check_depth(2):
                    stack_tuck()
                else:
                    offset = size
            elif opcode == BC_STACK_NIP:
                if check_depth(2):
                    stack_swap()
                    stack_drop()
                else:
                    offset = size
            elif opcode == BC_STACK_DEPTH:
                stack_push(len(stack), TYPE_NUMBER)
            elif opcode == BC_STACK_CLEAR:
                stack_clear()
            elif opcode == BC_QUOTE_NAME:
                if check_depth(2):
                    name = slice_to_string(stack_pop())
                    ptr = stack_pop()
                    add_definition(name, ptr)
                else:
                    offset = size
            elif opcode == BC_FUNCTION_EXISTS:
                if check_depth(1):
                    name = slice_to_string(stack_pop())
                    if lookup_pointer(name) != -1:
                        stack_push(-1, TYPE_FLAG)
                    else:
                        stack_push(0, TYPE_FLAG)
                else:
                    offset = size
            elif opcode == BC_FUNCTION_LOOKUP:
                if check_depth(1):
                    name = slice_to_string(stack_pop())
                    if lookup_pointer(name) != -1:
                        stack_push(lookup_pointer(name), TYPE_POINTER)
                    else:
                        stack_push(-1, TYPE_POINTER)
                else:
                    offset = size
            elif opcode == BC_FUNCTION_HIDE:
                if check_depth(1):
                    name = slice_to_string(stack_pop())
                    if lookup_pointer(name) != -1:
                        remove_name(name)
                else:
                    offset = size
            elif opcode == BC_STRING_SEEK:
                if check_depth(2):
                    a = slice_to_string(stack_pop())
                    b = slice_to_string(stack_pop())
                    stack_push(b.find(a), TYPE_NUMBER)
                else:
                    offset = size
            elif opcode == BC_SLICE_SUBSLICE:
                if check_depth(3):
                    a = int(stack_pop())
                    b = int(stack_pop())
                    s = int(stack_pop())
                    c = p_slices[s]
                    d = c[b:a]
                    dt = p_types[s]
                    dt = dt[b:a]
                    e = request_slice()
                    i  = 0
                    while i < len(d):
                        store(d[i], e, i, dt[i])
                        i = i + 1
                    stack_push(e, TYPE_POINTER)
                else:
                    offset = size
            elif opcode == BC_STRING_NUMERIC:
                if check_depth(1):
                    a = slice_to_string(stack_pop())
                    if is_number(a):
                        stack_push(-1, TYPE_FLAG)
                    else:
                        stack_push(0, TYPE_FLAG)
                else:
                    offset = size
            elif opcode == BC_SLICE_REVERSE:
                if check_depth(1):
                    a = stack_pop()
                    p_slices[int(a)] = p_slices[int(a)][::-1]
                    stack_push(a, TYPE_POINTER)
                else:
                    offset = size
            elif opcode == BC_TO_UPPER:
                if check_depth(1):
                    t = stack_type()
                    if t == TYPE_STRING:
                        ptr = stack_pop()
                        a = slice_to_string(ptr).upper()
                        stack_push(string_to_slice(a), TYPE_STRING)
                    elif t == TYPE_CHARACTER:
                        a = stack_pop()
                        b = ''.join(unichr(a))
                        a = b.upper()
                        stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
                    else:
                        report('ERROR: BC_TO_UPPER requires STRING or CHARACTER')
                else:
                    offset = size
            elif opcode == BC_TO_LOWER:
                if check_depth(1):
                    t = stack_type()
                    if t == TYPE_STRING:
                        ptr = stack_pop()
                        a = slice_to_string(ptr).lower()
                        stack_push(string_to_slice(a), TYPE_STRING)
                    elif t == TYPE_CHARACTER:
                        a = stack_pop()
                        b = ''.join(unichr(a))
                        a = b.lower()
                        stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
                    else:
                        report('ERROR: BC_TO_LOWER requires STRING or CHARACTER')
                else:
                    offset = size
            elif opcode == BC_REPORT:
                if check_depth(1):
                    if stack_type() == TYPE_STRING:
                        a = slice_to_string(stack_pop())
                        report(a)
                offset = size
            elif opcode == BC_TRIG_SIN:
                a = stack_pop()
                stack_push(math.sin(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_COS:
                a = stack_pop()
                stack_push(math.cos(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_TAN:
                a = stack_pop()
                stack_push(math.tan(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_ASIN:
                a = stack_pop()
                stack_push(math.asin(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_ACOS:
                a = stack_pop()
                stack_push(math.acos(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_ATAN:
                a = stack_pop()
                stack_push(math.atan(a), TYPE_NUMBER)
            elif opcode == BC_TRIG_ATAN2:
                a = stack_pop()
                b = stack_pop()
                stack_push(math.atan2(b, a), TYPE_NUMBER)
            if more is not None:
                offset = more(slice, offset, opcode)

        offset += 1


#
# Data stack implementation
#

stack = []
types = []


def stack_clear():
    """remove all values from the stack"""
    global stack, types
    i = 0
    while i < len(stack):
        stack.pop()
        types.pop()


def stack_push(value, type):
    """push a value to the stack"""
    global stack, types
    stack.append(value)
    types.append(type)


def stack_drop():
    """remove a value from the stack"""
    global stack, types
    stack.pop()
    types.pop()


def stack_pop():
    """remove and return a value from the stack"""
    global stack, types
    types.pop()
    return stack.pop()


def tos():
    """return a pointer to the top element in the stack"""
    global stack, types
    return len(stack) - 1


def stack_tos():
    """return the top element on the stack"""
    global stack, types
    return stack[tos()]


def stack_type():
    """return the type identifier for the top item on the stack"""
    global stack, types
    return types[tos()]


def stack_swap():
    """switch the positions of the top items on the stack"""
    at = stack_type()
    av = stack_pop()
    bt = stack_type()
    bv = stack_pop()
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    at = stack_type()
    av = stack_pop()
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_over():
    """put a copy of the second item on the stack over the top item"""
    """if the value is a string, makes a copy of it"""
    at = stack_type()
    av = stack_pop()
    bt = stack_type()
    bv = stack_pop()
    stack_push(bv, bt)
    stack_push(av, at)
    if bt == TYPE_STRING:
        s = request_slice()
        copy_slice(bv, s)
        stack_push(s, bt)
    else:
        stack_push(bv, bt)


def stack_tuck():
    """put a copy of the top item under the second item"""
    """if the value is a string, makes a copy of it"""
    stack_swap()
    stack_over()


def stack_change_type(type):
    """convert the type of an item on the stack to a different type"""
    global types, stack
    if type == TYPE_BYTECODE:
        if stack_type() == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif type == TYPE_NUMBER:
        if stack_type() == TYPE_STRING:
            if is_number(slice_to_string(stack_tos())):
                stack_push(float(slice_to_string(stack_pop())), TYPE_NUMBER)
            else:
                stack_pop()
                stack_push(0, TYPE_NUMBER)
        else:
            types.pop()
            types.append(TYPE_NUMBER)
    elif type == TYPE_STRING:
        if stack_type() == TYPE_NUMBER:
            stack_push(string_to_slice(unicode(stack_pop())), TYPE_STRING)
        elif stack_type() == TYPE_CHARACTER:
            stack_push(string_to_slice(''.join(unichr(stack_pop()))), TYPE_STRING)
        elif stack_type() == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif stack_type() == TYPE_POINTER:
            types.pop()
            types.append(TYPE_STRING)
        else:
            return 0
    elif type == TYPE_CHARACTER:
        if stack_type() == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif type == TYPE_POINTER:
        types.pop()
        types.append(TYPE_POINTER)
    elif type == TYPE_FLAG:
        if stack_type() == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    else:
        return


#
# Parable's dictionary consists of two related arrays.
# The first contains the names. The second contains pointers
# to the slices for each named item.
#

dictionary_names = []
dictionary_slices = []


def in_dictionary(s):
    global dictionary_names, dictionary_slices
    return s in dictionary_names


def lookup_pointer(name):
    global dictionary_names, dictionary_slices
    name = name.lower()
    if in_dictionary(name) == False:
        return -1
    else:
        return dictionary_slices[dictionary_names.index(name)]


def add_definition(name, slice):
    global dictionary_names, dictionary_slices
    name = name.lower()
    if in_dictionary(name) == False:
        dictionary_names.append(name)
        dictionary_slices.append(slice)
    else:
        target = dictionary_slices[dictionary_names.index(name)]
        copy_slice(slice, target)
    return dictionary_names.index(name)


def remove_name(name):
    global dictionary_names, dictionary_slices
    name = name.lower()
    if in_dictionary(name) != False:
        i = dictionary_names.index(name)
        del dictionary_names[i]
        del dictionary_slices[i]


#
# in parable, memory is divided into regions called slices
# compiled code, strings, and other data are stored in these.
# each slice can contain up to SLICE_LEN values
#

p_slices = []
p_types = []
p_map = []
p_sizes = []

def request_slice():
    """request a new memory slice"""
    global p_slices, p_types, p_map, p_sizes, MAX_SLICES
    i = 0
    while i < MAX_SLICES:
        if p_map[i] == 0:
            p_map[i] = 1
            p_slices[i] = [0]
            p_types[i] = [0]
            p_sizes[i] = 0
            return i
        else:
            i += 1
    return -1


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global p_map
    p_map[int(slice)] = 0


def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global p_slices, p_map, p_sizes
    i = 0
    l = p_sizes[int(source)]
    while i <= l:
        v = fetch(int(source), i)
        t = fetch_type(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    p_sizes[int(dest)] = p_sizes[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global p_slices, p_types, p_map, p_sizes, MAX_SLICES
    p_map = [0 for x in range(MAX_SLICES)]
    p_slices = [0 for x in range(MAX_SLICES)]
    p_types = [0 for x in range(MAX_SLICES)]
    p_sizes = [0 for x in range(MAX_SLICES)]


def fetch(slice, offset):
    """obtain a value stored in a slice"""
    global p_slices, p_map
    if get_last_index(slice) < offset:
        set_slice_last_index(slice, offset)
    return p_slices[int(slice)][int(offset)]


def fetch_type(slice, offset):
    """obtain a value stored in a slice"""
    global p_types, p_map
    if get_last_index(slice) < offset:
        set_slice_last_index(slice, offset)
    return p_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global p_slices, p_types, p_map
    if get_last_index(slice) < offset:
        set_slice_last_index(slice, offset)
    p_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global p_slices, p_types, p_map
    if get_last_index(slice) < offset:
        set_slice_last_index(slice, offset)
    p_slices[int(slice)][int(offset)] = value
    p_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    global p_sizes
    return p_sizes[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global p_slices, p_types, p_sizes
    old_size = p_sizes[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        p_slices[int(slice)].extend(range(int(grow_by)))
        p_types[int(slice)].extend(range(int(grow_by)))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del p_slices[int(slice)][-1]
            del p_types[int(slice)][-1]
    p_sizes[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    i = 0
    for char in list(string):
        store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
        i += 1
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        s.append(unichr(int(fetch(slice, i))))
        i += 1
    return ''.join(s)


#
# unused slices can be reclaimed either manually using release_slice(),
# or parable can attempt to identify them and reclaim them automatically.
# the code here implements the garbage collector.
#
# note: this does not scan the stack contents. only invoke it if the
#       stack is empty, or problems may arise.
#

def find_references(s):
    """given a slice, return a list of all references in it"""
    global dictionary_slices
    ptrs = []
    i = 0
    while i < get_last_index(s):
        if fetch(s, i) >= 0:
            ptrs.append(int(fetch(s, i)))
        i += 1
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices"""
    global MAX_SLICES, dictionary_slices, p_map
    maybe = []
    deps = []
    refs = []
    for s in dictionary_slices:
        maybe.append(s)
        deps.append(find_references(s))
    maybe += sum(deps, [])
    maybe = list(set(maybe))
    for s in sorted(maybe):
        if s < MAX_SLICES:
            if p_map[s] == 1:
                refs.append(s)
    return refs


def find_unused():
    """scan memory and return a list of all slices that are not referenced"""
    global p_slices, MAX_SLICES
    i = 0
    map = []
    while i < MAX_SLICES:
        map.append(i)
        i += 1
    refs = seek_all_references()
    unused = list(set(map) ^ set(refs))
    return unused


def collect_unused_slices():
    """scan memory, and collect unused slices"""
    for i in find_unused():
        release_slice(i)


#
# the compiler is pretty trivial.
# we take a string, break it into tokens, then lay down bytecode based on
# single character prefixes.
#
# #  Numbers
# $  Characters
# &  Pointers
# `  Bytecodes
# '  Strings
# "  Comments
#
# the bytecode forms are kept simple:
#
# type           compiled as
# ==========     ===========================
# Functions      BC_FLOW_CALL   pointer
# Strings        BC_PUSH_S      pointer
# Numbers        BC_PUSH_N      VALUE
# Characters     BC_PUSH_C      ASCII_VALUE
# Pointers       BC_PUSH_F      pointer
# Bytecodes      bytecode value
#
# for two functions ([ and ]), new quotes are started or closed. These are
# the only case where the corresponding action is run automatically rather
# than being compiled.
#
# bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#

# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_COMMENT)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('Unable to map ' + name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(0, slice, offset, TYPE_NUMBER)
        report("# prefix expects a NUMBER, received " + number)
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCTION_CALL)
        offset += 1
    else:
        report('Unable to find ' + name + ' in dictionary')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    if (tokens[i].endswith(delimiter) and tokens[i] != delimiter):
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            if (tokens[j].endswith(delimiter)):
                i = j
                j = count
            j += 1
    return i, s


def compile(str, slice):
    nest = []
    cleaned = ' '.join(str.split())
    tokens = cleaned.split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    while i < count:
        s = ""
        if (tokens[i].startswith('"') or tokens[i] == '"'):
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif (tokens[i].startswith('\'') or tokens[i] == '\''):
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif tokens[i].startswith("$"):
            offset = compile_character(ord(tokens[i][1:].encode('utf-8')), slice, offset)
        elif tokens[i].startswith("&"):
            offset = compile_pointer(tokens[i][1:], slice, offset)
        elif tokens[i].startswith("#"):
            offset = compile_number(tokens[i][1:], slice, offset)
        elif tokens[i].startswith("`"):
            offset = compile_bytecode(tokens[i][1:], slice, offset)
        elif tokens[i] == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif tokens[i] == "]":
            old = slice
            store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
            offset = nest.pop()
            slice = nest.pop()
            store(old, slice, offset, TYPE_POINTER)
            offset += 1
        else:
            if is_number(tokens[i]):
                offset = compile_number(tokens[i], slice, offset)
            else:
                offset = compile_function_call(tokens[i], slice, offset)
        i += 1
        store(BC_FLOW_RETURN, slice, offset, TYPE_BYTECODE)
    return slice


def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in f:
        if len(line) > 1:
            s = compile(line, request_slice())
            interpret(s)
#            if len(errors) > 0:
#                print line
#                print errors
#                print p_slices[s]
#                print p_types[s]
#                clear_errors()


#
# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.
#

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    store(BC_QUOTE_NAME, s, 0, TYPE_BYTECODE)
    store(BC_FLOW_RETURN, s, 1, TYPE_BYTECODE)
    add_definition('define', s)


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    global dictionary_names, dictionary_slices
    s = ""
    if ptr in dictionary_slices:
        s = dictionary_names[dictionary_slices.index(ptr)]
    return s
bootstrap = []
bootstrap.append(""" [ "v-b"    `109 ] ':b' define """)
bootstrap.append(""" [ "v-n"    `110 ] ':n' define """)
bootstrap.append(""" [ "v-s"    `111 ] ':s' define """)
bootstrap.append(""" [ "v-c"    `112 ] ':c' define """)
bootstrap.append(""" [ "v-p"    `113 ] ':p' define """)
bootstrap.append(""" [ "v-f"    `114 ] ':f' define """)
bootstrap.append(""" [ "v-vn"   `120 ] 'type?' define """)
bootstrap.append(""" [ "nn-n"   `200 ] '+' define """)
bootstrap.append(""" [ "nn-n"   `201 ] '-' define """)
bootstrap.append(""" [ "nn-n"   `202 ] '*' define """)
bootstrap.append(""" [ "nn-n"   `203 ] '/' define """)
bootstrap.append(""" [ "nn-n"   `204 ] 'rem' define """)
bootstrap.append(""" [ "n-n"    `205 ] 'floor' define """)
bootstrap.append(""" [ "nn-n"   `206 ] '^' define """)
bootstrap.append(""" [ "n-n"    `207 ] 'log' define """)
bootstrap.append(""" [ "n-n"    `208 ] 'log10' define """)
bootstrap.append(""" [ "nn-n"   `209 ] 'log<n>' define """)
bootstrap.append(""" [ "nn-n"   `210 ] 'shift' define """)
bootstrap.append(""" [ "nn-n"   `211 ] 'and' define """)
bootstrap.append(""" [ "nn-n"   `212 ] 'or' define """)
bootstrap.append(""" [ "nn-n"   `213 ] 'xor' define """)
bootstrap.append(""" [ "-n"     `214 ] 'random' define """)
bootstrap.append(""" [ "n-n"    `215 ] 'sqrt' define """)
bootstrap.append(""" [ "nn-f"   `220 ] '<' define """)
bootstrap.append(""" [ "nn-f"   `221 ] '>' define """)
bootstrap.append(""" [ "nn-f"   `222 ] '<=' define """)
bootstrap.append(""" [ "nn-f"   `223 ] '>=' define """)
bootstrap.append(""" [ "vv-f"   `224 ] '=' define """)
bootstrap.append(""" [ "vv-f"   `225 ] '<>' define """)
bootstrap.append(""" [ "fpp-"   `300 ] 'if' define """)
bootstrap.append(""" [ "p-"     `301 ] 'while-true' define """)
bootstrap.append(""" [ "p-"     `302 ] 'while-false' define """)
bootstrap.append(""" [ "np-"    `303 ] 'repeat' define """)
bootstrap.append(""" [ "p-"     `305 ] 'invoke' define """)
bootstrap.append(""" [ "vp-v"   `306 ] 'dip' define """)
bootstrap.append(""" [ "vp-v"   `307 ] 'sip' define """)
bootstrap.append(""" [ "vpp-?"  `308 ] 'bi' define """)
bootstrap.append(""" [ "vppp-?" `309 ] 'tri' define """)
bootstrap.append(""" [ "pp-"    `400 ] 'copy' define """)
bootstrap.append(""" [ "pn-n"   `401 ] 'fetch' define """)
bootstrap.append(""" [ "npn-"   `402 ] 'store' define """)
bootstrap.append(""" [ "-p"     `403 ] 'request' define """)
bootstrap.append(""" [ "p-"     `404 ] 'release' define """)
bootstrap.append(""" [ "-"      `405 ] 'collect-garbage' define """)
bootstrap.append(""" [ "p-n"    `406 ] 'get-last-index' define """)
bootstrap.append(""" [ "np-"    `407 ] 'set-last-index' define """)
bootstrap.append(""" [ "pn-"    `408 ] 'set-stored-type' define """)
bootstrap.append(""" [ "p-n"    `409 ] 'get-stored-type' define """)
bootstrap.append(""" [ "v-vv"   `500 ] 'dup' define """)
bootstrap.append(""" [ "v-"     `501 ] 'drop' define """)
bootstrap.append(""" [ "vV-Vv"  `502 ] 'swap' define """)
bootstrap.append(""" [ "vV-vVv" `503 ] 'over' define """)
bootstrap.append(""" [ "vV-VvV" `504 ] 'tuck' define """)
bootstrap.append(""" [ "vV-V"   `505 ] 'nip' define """)
bootstrap.append(""" [ "-n"     `506 ] 'depth' define """)
bootstrap.append(""" [ "...-"   `507 ] 'reset' define """)
bootstrap.append(""" [ "s-f"    `601 ] 'function-exists?' define """)
bootstrap.append(""" [ "s-p"    `602 ] 'lookup-function' define """)
bootstrap.append(""" [ "s-"     `603 ] 'hide-function' define """)
bootstrap.append(""" [ "ss-n"   `700 ] 'find' define """)
bootstrap.append(""" [ "pnn-p"  `701 ] 'subslice' define """)
bootstrap.append(""" [ "s-f"    `702 ] 'numeric?' define """)
bootstrap.append(""" [ "p-p"    `703 ] 'reverse' define """)
bootstrap.append(""" [ "v-v"    `800 ] 'to-lowercase' define """)
bootstrap.append(""" [ "v-v"    `801 ] 'to-uppercase' define """)
bootstrap.append(""" [ "s-"     `900 ] 'report-error' define """)
bootstrap.append(""" [ "n-n"    `1000 ] 'sin' define """)
bootstrap.append(""" [ "n-n"    `1001 ] 'cos' define """)
bootstrap.append(""" [ "n-n"    `1002 ] 'tan' define """)
bootstrap.append(""" [ "n-n"    `1003 ] 'asin' define """)
bootstrap.append(""" [ "n-n"    `1004 ] 'acos' define """)
bootstrap.append(""" [ "n-n"    `1005 ] 'atan' define """)
bootstrap.append(""" [ "n-n"    `1006 ] 'atan2' define """)
bootstrap.append(""" [ #100 ] 'NUMBER' define """)
bootstrap.append(""" [ #200 ] 'STRING' define """)
bootstrap.append(""" [ #300 ] 'CHARACTER' define """)
bootstrap.append(""" [ #400 ] 'POINTER' define """)
bootstrap.append(""" [ #500 ] 'FLAG' define """)
bootstrap.append(""" "simple, forth-style variables" """)
bootstrap.append(""" [ "s-"   request swap define ] 'variable' define """)
bootstrap.append(""" [ "p-v"  #0 fetch ] '@' define """)
bootstrap.append(""" [ "vp-"  #0 store ] '!' define """)
bootstrap.append(""" "returns the number of cells in a slice" """)
bootstrap.append(""" [ "p-n"  get-last-index #1 + ] 'length?' define """)
bootstrap.append(""" "number functions" """)
bootstrap.append(""" [ "n-n"  over over < [ nip ] [ drop ] if ] 'max' define """)
bootstrap.append(""" [ "n-n"  over over > [ nip ] [ drop ] if ] 'min' define """)
bootstrap.append(""" [ "n-n"  dup #-1 * max ] 'abs' define """)
bootstrap.append(""" "utility functions" """)
bootstrap.append(""" [ "q-...n"  depth [ invoke ] dip depth swap - ] 'invoke<depth?>' define """)
bootstrap.append(""" "The basic bi/tri combinators provided as part of the primitives allow application of multiple quotes to a single data element. Here we add new forms that are very useful." """)
bootstrap.append(""" "We consider the bi/tri variants to consist of one of three types." """)
bootstrap.append(""" "Cleave combinators (bi, tri) apply multiple quotations to a single value (or set of values)." """)
bootstrap.append(""" "Spread combinators (bi*, tri*) apply multiple quotations to multiple values." """)
bootstrap.append(""" [ "vvpp-?"   [ dip ] dip invoke ] 'bi*' define """)
bootstrap.append(""" [ "vvvppp-?" [ [ swap [ dip ] dip ] dip dip ] dip invoke ] 'tri*' define """)
bootstrap.append(""" "Apply combinators (bi@, tri@) apply a single quotation to multiple values." """)
bootstrap.append(""" [ "vvp-?"    dup bi* ] 'bi@' define """)
bootstrap.append(""" [ "vvvp-?"   dup dup tri* ] 'tri@' define """)
bootstrap.append(""" "Stack Flow" """)
bootstrap.append(""" [ "vV-vVvV"  over over ] 'dup-pair' define """)
bootstrap.append(""" [ "vv-"      drop drop ] 'drop-pair' define """)
bootstrap.append(""" "Expand the basic conditionals into a more useful set." """)
bootstrap.append(""" [ "-f"   #-1 :f ] 'true' define """)
bootstrap.append(""" [ "-f"   #0  :f ] 'false' define """)
bootstrap.append(""" [ "f-f"  :f :n #-1 xor :f ] 'not' define """)
bootstrap.append(""" [ "fp-"  [ ] if ] 'if-true' define """)
bootstrap.append(""" [ "fp-"  [ ] swap if ] 'if-false' define """)
bootstrap.append(""" [ "v-f"  #0 = ] 'zero?' define """)
bootstrap.append(""" [ "v-f"  :f :n zero? not ] 'true?' define """)
bootstrap.append(""" [ "v-f"  :f :n zero? ] 'false?' define """)
bootstrap.append(""" [ "n-f"  #2 rem zero? ] 'even?' define """)
bootstrap.append(""" [ "n-f"  #2 rem zero? not ] 'odd?' define """)
bootstrap.append(""" [ "n-f"  #0 < ] 'negative?' define """)
bootstrap.append(""" [ "n-f"  #0 >= ] 'positive?' define """)
bootstrap.append(""" [ "cp-"  [ type? CHARACTER = ] dip if-true ] 'if-character' define """)
bootstrap.append(""" [ "sp-"  [ type? STRING = ] dip if-true ] 'if-string' define """)
bootstrap.append(""" [ "np-"  [ type? NUMBER = ] dip if-true ] 'if-number' define """)
bootstrap.append(""" [ "pp-"  [ type? POINTER = ] dip if-true ] 'if-pointer' define """)
bootstrap.append(""" [ "fp-"  [ type? FLAG = ] dip if-true ] 'if-flag' define """)
bootstrap.append(""" [ "nnn-f"  [ [ :n ] bi@ ] dip :n dup-pair > [ swap ] if-true [ over ] dip <= [ >= ] dip and :f ] 'between?' define """)
bootstrap.append(""" "Simple variables are just named slices, with functions to access the first element. They're useful for holding single values, but don't track data types." """)
bootstrap.append(""" [ "vs-"  request [ swap define ] sip #0 store ] 'variable!' define """)
bootstrap.append(""" [ "p-"   #0 swap ! ] 'off' define """)
bootstrap.append(""" [ "p-"   #-1 swap ! ] 'on' define """)
bootstrap.append(""" [ "p-"   [ @ #1 + ] sip ! ] 'increment' define """)
bootstrap.append(""" [ "p-"   [ @ #1 - ] sip ! ] 'decrement' define """)
bootstrap.append(""" [ "p-"   request swap copy ] 'zero-out' define """)
bootstrap.append(""" [ "pp-"  swap request dup-pair copy swap [ [ invoke ] dip ] dip copy ] 'preserve' define """)
bootstrap.append(""" "numeric ranges" """)
bootstrap.append(""" [ "nn-..."  dup-pair < [ [ [ dup #1 + ] dip dup-pair = ] while-false ] [ [ [ dup #1 - ] dip dup-pair = ] while-false ] if drop ] 'expand-range' define """)
bootstrap.append(""" [ "...n-n"   #1 - [ + ] repeat ] 'sum-range' define """)
bootstrap.append(""" "Misc" """)
bootstrap.append(""" [ "p-pn"  dup get-last-index ] 'slice-last-index' define """)
bootstrap.append(""" [ "p-pn"  slice-last-index #1 + ] 'slice-length' define """)
bootstrap.append(""" [ "np-"   [ get-last-index + ] sip set-last-index ] 'adjust-slice-length' define """)
bootstrap.append(""" [ "?n-"   [ drop ] repeat ] 'drop-multiple' define """)
bootstrap.append(""" [ "p-p"   request [ copy ] sip ] 'slice-duplicate' define """)
bootstrap.append(""" [ "p-"   invoke<depth?> [ hide-function ] repeat ] 'hide-functions' define """)
bootstrap.append(""" [ "ss-"  swap dup function-exists? [ dup lookup-function swap hide-function swap define ] [ drop ] if ] 'rename-function' define """)
bootstrap.append(""" [ "p-"   invoke<depth?> [ variable ] repeat ] 'variables' define """)
bootstrap.append(""" "String and Character" """)
bootstrap.append(""" "Note that this is only supporting the basic ASCII character set presently." """)
bootstrap.append(""" [ "vs-f" swap :s find not true? ] 'string-contains?' define """)
bootstrap.append(""" [ "v-f"  :c $0 $9 between? ] 'digit?' define """)
bootstrap.append(""" [ "v-f"  '`~!@#$%^&*()'"<>,.:;[]{}\|-_=+'                    string-contains? ] 'symbol?' define """)
bootstrap.append(""" [ "v-f"  to-lowercase 'abcdefghijklmnopqrstuvwxyz'           string-contains? ] 'letter?' define """)
bootstrap.append(""" [ "v-f"  to-lowercase 'abcdefghijklmnopqrstuvwxyz1234567890' string-contains? ] 'alphanumeric?' define """)
bootstrap.append(""" [ "v-f"  to-lowercase 'bcdfghjklmnpqrstvwxyz'                string-contains? ] 'consonant?' define """)
bootstrap.append(""" [ "v-f"  to-lowercase 'aeiou'                                string-contains? ] 'vowel?' define """)
bootstrap.append(""" [ "v-f"  dup to-lowercase = ] 'lowercase?' define """)
bootstrap.append(""" [ "v-f"  dup to-uppercase = ] 'uppercase?' define """)
bootstrap.append(""" [ "p-s"  invoke<depth?> #1 - [ [ :s ] bi@ + ] repeat ] 'build-string' define """)
bootstrap.append(""" "Functions for trimming leading and trailing whitespace off of a string. The left side trim is iterative; the right side trim is recursive." """)
bootstrap.append(""" [ "s-s"  :s #0 [ dup-pair fetch #32 = [ #1 + ] dip ] while-true #1 - [ slice-last-index ] dip swap subslice :s ] 'trim-left' define """)
bootstrap.append(""" [ ] 'trim-right' define """)
bootstrap.append(""" [ "s-s"  :s slice-last-index dup-pair #1 - fetch nip #32 = [ slice-last-index #1 - #0 swap subslice :s trim-right ] if-true ] 'trim-right' define """)
bootstrap.append(""" [ "s-s"  trim-left trim-right ] 'trim' define """)
bootstrap.append(""" "Helpful Math" """)
bootstrap.append(""" [ "n-"    #1 swap [ [ * ] sip #1 - dup #1 <> ] while-true drop ] 'factorial' define """)
bootstrap.append(""" "Slice as a linear buffer" """)
bootstrap.append(""" [ '*CURRENT-BUFFER'  '*BUFFER-OFFSET' ] variables """)
bootstrap.append(""" [ "-p"     &*CURRENT-BUFFER @ ] 'current-buffer' define """)
bootstrap.append(""" [ "-pn"    current-buffer &*BUFFER-OFFSET @ ] 'buffer-position' define """)
bootstrap.append(""" [ "-"      &*BUFFER-OFFSET increment ] 'buffer-advance' define """)
bootstrap.append(""" [ "-"      &*BUFFER-OFFSET decrement ] 'buffer-retreat' define """)
bootstrap.append(""" [ "n-"     buffer-position store ] 'buffer-store-current' define """)
bootstrap.append(""" [ "-n"     buffer-position fetch ] 'buffer-fetch-current' define """)
bootstrap.append(""" [ "v-"     buffer-position store buffer-advance "#0 buffer-position store" ] 'buffer-store' define """)
bootstrap.append(""" [ "-n"     buffer-position fetch buffer-advance ] 'buffer-fetch' define """)
bootstrap.append(""" [ "v-"     buffer-retreat buffer-position store ] 'buffer-store-retreat' define """)
bootstrap.append(""" [ "-n"     buffer-retreat buffer-position fetch ] 'buffer-fetch-retreat' define """)
bootstrap.append(""" [ "p-"     &*CURRENT-BUFFER ! &*BUFFER-OFFSET zero-out ] 'set-buffer' define """)
bootstrap.append(""" [ "...n-"  [ buffer-store ] repeat ] 'buffer-store-items' define """)
bootstrap.append(""" [ "-"      request set-buffer ] 'new-buffer' define """)
bootstrap.append(""" [ "p-"     &*CURRENT-BUFFER @ [ &*BUFFER-OFFSET @ [ invoke ] dip &*BUFFER-OFFSET ! ] dip &*CURRENT-BUFFER ! ] 'preserve-buffer' define """)
bootstrap.append(""" [ "s-"     request [ swap define ] sip set-buffer ] 'named-buffer' define """)
bootstrap.append(""" "Curry Combinator" """)
bootstrap.append(""" [ #304 :b buffer-store buffer-store #399 :b buffer-store ] 'compile-call' define """)
bootstrap.append(""" [ "vp-p"  [ request set-buffer swap buffer-store compile-call &*CURRENT-BUFFER @ :p ] preserve-buffer ] 'curry' define """)
bootstrap.append(""" 'compile-call' hide-function """)
bootstrap.append(""" "Values" """)
bootstrap.append(""" '*state*' variable """)
bootstrap.append(""" [ "-" &*state* on ] 'to' define """)
bootstrap.append(""" [ &*state* @ :f [ ! &*state* off ] [ @ ] if ] 'value-handler' define """)
bootstrap.append(""" [ "s-" request "#2 over set-last-index" [ value-handler ] curry swap define ] 'value' define """)
bootstrap.append(""" [ "ns-" [ value ] sip to lookup-function invoke ] 'value!' define """)
bootstrap.append(""" [ "p-" invoke<depth?> [ value ] repeat ] 'values' define """)
bootstrap.append(""" [ '*state*'  'value-handler' ] hide-functions """)
bootstrap.append(""" "arrays" """)
bootstrap.append(""" [ 'source'  'results'  'filter' ] values """)
bootstrap.append(""" [ &source [ &results [ &filter [ invoke ] preserve ] preserve ] preserve ] 'localize' define """)
bootstrap.append(""" [ "vp-"  :p dup length? store ] 'array-push' define """)
bootstrap.append(""" [ "p-v"  :p [ dup get-last-index fetch ] sip dup length? #2 - swap set-last-index ] 'array-pop' define """)
bootstrap.append(""" [ "p-p"    [ request to results invoke<depth?> #0 max [ results array-push ] repeat results #1 over length? subslice :p ] localize ] 'array-from-quote<in-stack-order>' define """)
bootstrap.append(""" [ "p-p" array-from-quote<in-stack-order> reverse ] 'array-from-quote' define """)
bootstrap.append(""" [ "pnp-n"  [ to filter over length? [ over array-pop filter invoke ] repeat nip ] localize ] 'array-reduce' define """)
bootstrap.append(""" [ "pp-?"   [ to filter slice-duplicate dup length? [ [ array-pop filter invoke ] sip ] repeat drop ] localize ] 'for-each' define """)
bootstrap.append(""" [ ] 'array<remap>' define """)
bootstrap.append(""" [ type? STRING <> [ [ ] ] [ [ [ :p :s ] bi@ ] ] if 'array<remap>' define ] 'needs-remap?' define """)
bootstrap.append(""" [ "pv-f"   swap needs-remap? [ swap dup set-buffer slice-last-index #0 swap [ over buffer-fetch array<remap> = or ] repeat ] preserve-buffer nip :f ] 'array-contains?' define """)
bootstrap.append(""" [ 'array<remap>'  'needs-remap?' ] hide-functions """)
bootstrap.append(""" [ [ reverse ] dip request to results to filter [ to source ] [ length? ] bi results array-pop drop ] 'prepare' define """)
bootstrap.append(""" [ "pp-p"   prepare [ source array-pop dup filter invoke [ results array-push ] [ drop ] if ] repeat results request [ copy ] sip ] 'array-filter' define """)
bootstrap.append(""" [ "pp-p"   prepare [ source array-pop filter invoke results array-push ] repeat results request [ copy ] sip ] 'array-map' define """)
bootstrap.append(""" [ "pp-f"   dup-pair [ length? ] bi@ = [ dup length? true swap [ [ dup-pair [ array-pop ] bi@ = ] dip and ] repeat [ drop-pair ] dip :f ] [ drop-pair false ] if ] 'array-compare' define """)
bootstrap.append(""" [ 'prepare'  'localize'  'filter'  'source'  'results' ] hide-functions """)
bootstrap.append(""" [ 'source' 'v' 'i' 'idx' ] values """)
bootstrap.append(""" [ type? STRING = [ [ :p :s ] dip ] [ :n ] if ] 'resolve-types' define """)
bootstrap.append(""" [ "vp-n"  to source to v #0 to i #-1 to idx source length? [ source i fetch v resolve-types = [ i to idx ] if-true i #1 + to i ] repeat idx ] 'array-index-of' define """)
bootstrap.append(""" [ 'source'  'v'  'i'  'idx'  'resolve-types' ] hide-functions """)
bootstrap.append(""" "Text Output Buffer" """)
bootstrap.append(""" 'TOB' variable """)
bootstrap.append(""" [ &TOB array-push ] 'append-value' define """)
bootstrap.append(""" [ "-..." &TOB get-last-index [ &TOB array-pop :p :s ] repeat ] 'show-tob' define """)
bootstrap.append(""" [ "-" #0 &TOB set-last-index ] 'clear-tob' define """)
bootstrap.append(""" 'TOB:Handlers' named-buffer """)
bootstrap.append(""" [ ] buffer-store """)
bootstrap.append(""" [ "number"     :s    append-value ] buffer-store """)
bootstrap.append(""" [ "string"           append-value ] buffer-store """)
bootstrap.append(""" [ "character"  :s    append-value ] buffer-store """)
bootstrap.append(""" [ "pointer"    :n :s append-value ] buffer-store """)
bootstrap.append(""" [ "flag"       :s    append-value ] buffer-store """)
bootstrap.append(""" [ "v-"  type? #100 / &TOB:Handlers swap fetch invoke ] '.' define """)
bootstrap.append(""" [ 'TOB' 'append-value' 'TOB:Handlers' ] hide-functions """)
bootstrap.append(""" "Hashing functions" """)
bootstrap.append(""" [ "s-n" #5381 swap [ :n [ swap ] dip over #-5 shift + + swap ] for-each ] 'hash:djb2' define """)
bootstrap.append(""" [ :n over #-6 shift + over #-16 shift + swap - ] 'hash:sdbm<n>' define """)
bootstrap.append(""" [ "s-n" #0 swap [ :c [ swap ] dip hash:sdbm<n> swap ] for-each ] 'hash:sdbm' define """)
bootstrap.append(""" 'hash-sdbm<n>' hide-function """)
bootstrap.append(""" [ "s-n" #0 swap [ :n [ swap ] dip + #255 and swap ] for-each #255 xor #1 + #255 and ] 'hash:lrc' define """)
bootstrap.append(""" [ "s-n" #0 swap [ :n [ swap ] dip xor swap ] for-each ] 'hash:xor' define """)
bootstrap.append(""" [ "s-b" hash:djb2 ] 'chosen-hash' define """)
bootstrap.append(""" [ #389 ] 'hash-prime' define """)
bootstrap.append(""" [ "s-n" chosen-hash hash-prime rem ] 'hash' define """)
import sys, os

def display_stack(verbose):
    global stack, types
    i = 0
    while i < len(stack):
        if i == len(stack) - 1:
            sys.stdout.write("TOS\t" + unicode(i))
        else:
            sys.stdout.write("\t" + unicode(i))

        if types[i] == TYPE_NUMBER:
            sys.stdout.write("\t#" + unicode(stack[i]))
        elif types[i] == TYPE_CHARACTER:
            sys.stdout.write("\t$" + unicode(unichr(stack[i])))
        elif types[i] == TYPE_STRING:
            sys.stdout.write(("\t'" + slice_to_string(stack[i]) + "'").encode('utf-8'))
            if verbose == True:
                sys.stdout.write("\n\t\tstored at: " + unicode(stack[i]))
        elif types[i] == TYPE_POINTER:
            sys.stdout.write("\t&" + unicode(stack[i]))
            if verbose == True:
                if pointer_to_name(stack[i]) != "":
                    sys.stdout.write("\n\t\tpointer to: " + pointer_to_name(stack[i]))
        elif types[i] == TYPE_FLAG:
            if stack[i] == -1:
                sys.stdout.write("\ttrue")
            elif stack[i] == 0:
                sys.stdout.write("\tfalse")
            else:
                sys.stdout.write("\tmalformed flag")
        else:
            sys.stdout.write("\tunmatched type on stack!")
        sys.stdout.write("\n")
        i += 1


def display_errors():
    for e in errors:
        sys.stdout.write("\n" + e)
    sys.stdout.write("\n")


def display():
    display_stack(False)
    display_errors()
    clear_errors()


def load_file(file):
    f = open(file).readlines()
    for line in f:
        if len(line) > 1:
            if not line.startswith("#!"):
                s = compile(line, request_slice())
                interpret(s)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        MAX_SLICES = 8000
    prepare_slices()
    prepare_dictionary()
    parse_bootstrap(bootstrap)
    collect_unused_slices()

    if len(sys.argv) < 2:
        if os.path.exists('source.p'):
            load_file('source.p')
        else:
            sys.exit('Usage: %s filename(s)' % sys.argv[0])
    else:
        for source in sys.argv:
            if not os.path.exists(source):
                sys.exit('ERROR: source file "%s" was not found!' % source)
            if source != sys.argv[0]:
                load_file(source)

    display()
    sys.stdout.flush()
