#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if math.isnan(opcode):
                opcode == BC_NOP
            else:
                opcode = int(opcode)
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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gqQVIKgXd2QVIKkFQkO3fe7u7uZmZ/SQ5zxBUgqQVIKkFSCpBUgqQVkO3fe+9+95zMzLvxBUgqQVIKkFSCpBUgqQVIfXf33vfvezMzLvxBdLC7SCpBUgqQVIKkFSCpDP7nP7+3f7dzPe964Q5xIKkFSCpBUgqQVIKkFSHnnkqfv0lVVP6d5yqzvleZmL8vyvFUA+Adqrr49b1oAACTKAZmsDKztZnmZmZn1D0B08A+aPAAaBwMvKCquh61MD6zxPofffffbTgJ7wJYWTwJol+mg8CTfO8r2Spfk5+v67offPuqqoAb3uyp555KipBUgqQVIKku7sgqQVIdu+93d3czMz+khzniCpBUgqQVIKkFSCpBUgrIdu+997972XmZl34gqQVIKkFSCpBUgqQVIKkO3f33vfvezMzLvxBUgu2BdpBUgqQVIKkFSCpDP55z+/t39u+zPe8hJziQVIKkFSCpBUgqQVIKkFZD67++973vZmZm85pBUgqQVIKkFSCpBWXRdpBWSQ7d97u7u5mZn8SHOeIKkFSCpBUgqQVIKkFSCsh27733v3vZeZmXfiCpBUgqQVIKkFSCpBUgqQ7d/fe9+97MzMu/SCpBUBaqqqqqqqv195z33M+zJJJmteauwAAN/qqt63rfnte/fZmMAPqu7senh5V3djZ8PgAAkkkmGZmZmYAPAHQAGZmZmZmYABJ3ve96kCjpVVyue/H6qupwlZq6uv3z+4e7V3PZ3MzMySSduwAAJr2q99z3MySSffCn7nJJJIxjWp29d793332XmZlifcre9/ffZkkk+1rzV20Y2AErXnn5d/s/fsyfTUmV555qc4AABd69u/c/ZmffffZ2c4AAB3Wv1V+/d/d72Tkk+155r73ma3sAAN6+qv332bkyVJJVAaPBXs/uc733f3vZmZl3Veis27sisupd3d3VMkFu7tz+ec/v7d/bvszM8BOVxWlRaqq1rWta1p97V3d39yr995v7O5mBNvA+AAAAD0SckkkAAAAAAAAAAk73ve9SAAHfOa5zzjGse5mZmYD9vYAAHN75zMzMkkn7zzzV2AAB32q99zPsyVJJVAAAc3u7kk/fv36qAAAmprLv33MzP379++1rzV2AABN75yb33nAPt7ABlVk5X307575d1rzzXvoAAHfar339mT3339QAAH293f333Oc9oAAD76q5z6T7MzMzJrXmrsAADe0WREMm4j7nLFNQOD5H173nfvr+zMGwcAAAAASSSSQAAAAAAAAACTve971IAAXV1veZdefffb59mbzMzMySSduwAAOb3zmZmZJJP3nnmrsAADvtV77mfZkqSSqAAA5vd3J+kkklUAAB+5mrv33M+/ZmZnfdd7vXnmucAAA93vnO973skk7dgAAc3vnMzMySSVQAAHeVXOZmZkkkqgAAL3u7kkkkkqmnngaePNBe93ckkzM/fv36kTW2BJIQJJf7NhgGd773v377MAAAAAABJJJJAAAAAAAAAHgJ93ve96kAAZn1VdeVzNfffXyYyZmZmSSTt2B3e9615rezeteaqqKV7d97u7u5mZl3VVXoQXau1Wqqn9V2/13/f27ubmZmXdV4Ibd1VqrVVTCC2t9u+93d3czMy7qqrwQXVtaqqqqrq97u7vZJJmteauwAP29h7vfvuZn2SSTt2AABze+czMzJJJVAAAd5Vc5mZmSSSqAAAve7uSSSSSqAAAve7uSSSSTNa81dgAAVz6+efvNa1de/v2ZMkkkkkkkkAFXdeVV0A6AEkkkkAAPAHQAAzMzMzMzAUAhJJJ2aqrqAID7efVV1qqsu+1csElS5quAmuAm34EgfT2d5zm+59M5mZmSSTt2Ad3sA93v33ve97JJKoAADOVXOZmZkkkqgAAL3u7kkkkkqs3sAAOb3eZmZ999kzWvNXYAAF8quZmZn330nbsAADm93mZmfffZKoAADvKq8zMz777JVAAAXvd3JJJJJVAAAXvd3JJJJJmteauwSSSSSST717n0K3XnN80qtCgRVYiqbgABXOAAWqvPe59EVdgqkFWCqxVe52Xaq6BVb+pVcBVgqybkJI6oqvcFXW5yKrSq+9euavXhVrhKFXyq0KtklKrVKfQSUNQk0o6VWxsIVDFVsVdCrdAq0KuHx3xPtVqvalVGffWd4qJw4XLO5Qik7eclEhGVRcLNn3LzM79nyr8qtVVXdVrQHZKu7u13oDoAAElSSAAAElVIAAAqqqoAjRQBJJJJGU1dXdVW6u8+8vzeZmd7maXd1VfwBHGGwSmgBepiAE9CsvM5mZzDJMvMzMzBEWraG7vzUkk72Kqqqqauqqr988AjtHgDQBAAaqrqgCAAoSSSSQB08AAAAAAebhrzw46fmazMCSST7PDYA+qroezUkkk6AAAAAEkkkkHk189NnTF1dXWazMzMzAAAAANAEkkkkgAAAAAAJdXVw4AACqqqmZmZmAAAAAHt3fOHQAAkkkkgABl1dXWZmZmZmAAAAAAAkkkkgAAAAAAAAAAJJJJIAAAAAAAAAAGXV1dYATAAAAAAAAAAAkkkkgABlZmZmZmYAAAAB6B8EkkkkAAAAAAADIckqpU5ypUqSPJfn5VfVAAAAkkkkgAAAAAAAAAAJJJJIAAAADYOAAAAASSSSQAAy8zMzMzMAA/ADAAAR3ve9790A0AJJJJAAAAAAAJO973vUgAAAAABJJJJAB+zMzMzMwAAAAAAAEnay9NAz77MzMzMzMzOG9Sc1WfPQRIoIhdRXZFkFGEs+gT3wJZyOTXCasQRIiJAREtavfDSZtsRCWAjVSBxsIal2KtbiIlgiRmt2NAnNVe/dGAlWiJYq+5zWeVXgKuwFWCq3ria6Cav4E2KJtRYKJwEoEzmqTKNWggatET6eQAwE8CdfPJKnn1t2qAAEAA8kqBJVST9wAm0HAAbBz667q7usnlXNVNXd3meV5q6u6+q5V17uckmYAGwcAAOMqrq6zM5mZmYSSSSQAAAAAAAAAAx0AACqqqr37ufxKq62T3ufZznO+9n3czMySSd7rnAAAN17d++973vZJJVd6VQAAV7Ve+973vZJJVAAAXvd3JJJJ9vYABmt733VVXfbuve973sk+zWvNVQAa0a0eN+G9Vy79973vezM/btHGFKPEIVdxsqqaVeVXfe973sk+3sAADLqs5mZmSSTl2AABze+ckkkkkqgAAL3u7kkkkkzWvNXYAAGsrV9q+853vczAAB8PQAeAOgkkkkgAAAAAAAARoASSSSQAAGcncqVPJVTkX32/rv5TFVQA3vec4AAOb3zmZmZJJKoAADvKrnMzMySSKoAAC97q5JJJJKoAAC97u5JJJJM1rzV2AAA1rjfOZme5kqSduwAAOb3zmZmZJJKoAADvKprXmuczMzJ9JKoAAB5ba7kkk+klUAABe93ckkkkzWvNVqgAJJJPrur0XoPdQpXsEHUVF5B5B7AQH6fRyKB9APiCC/RFB+iqfQQPoqP0EQfoKAP0F+iov0G7zM9rNKAMoD0D4EkkkkAAeKA6AABGgAAAkkkkgABVXWXVXW9KBcAGtUqolwR1AFPo7T77777f2Zkkn3bsAABxvme5mZJJKoAADvKrnMzMySSTzXmrsAADm9ta81xzkkk/SSXYAAHN7rfOVJJPpJmteauwAAOb3zmZmZJJO3qwAAM9qvfeZmZJJKoAAB3m65zMzMkklUAABe93ckkkkk1rzV2AABze+b815rnJLklSTNa81nOAaPA+575755f73d8/ZkxVHe1VVAAAAABVVUAAkAAAAAAAAAAEkkk6kkkgGV5zznN8zlXrXnmZmTGZmSSTt6sBrQOb3zmZmZJJK1Qd3sADee3r328zM++ySqAAA1WrrVyST9+n29gAAZ5q2qzmZmZPsmY81rWuucAAAV7uvPfe973skky7AAA5vnfe973smZKoAACcrjWvNcuST79JKoAADOVXOZmZkkkrVAAAXvd3JJJJJVAAAN/V9nnnnnnvjzVbqFH2/qMXO9TfAPwCgAAKB2qug8khJJJJAAAAAAAAAAbBw1QBFBnATMy8zMzh+4qfkTqpVxdFhNSyfLr7773Xefq+1rXmtdrvMzMzJJJmteauwAAOb3zmZmZJJO3YAAHN75zve9/a15rvcrMyqAAAve7uSSSSStUAABnKrm+ZmZk/SSqAAAve73ckkn6SVQAAHeVquczMzJJJ3WvNXYAAHdV57d++973vZJ3MuwAAHG7vMzMkklUCqqq0FZFdoqi7Ve3fe7u7uZmZd7t3bdtVVUi2tVVWSF2O97nPvd9eVVVR+6GfvvmeczKrFVVMQABtdoAACkkkkgAAAAAAAAAAAAAAD771wh3+va0Ib2e88+3c3czM9mZmXvGtFVVqlu7tqler3u7u7mZmeCHOUtQg77vdb3vW9m97Cvar33ve97JMzLsAADm995zve97mZJVAaAC97u5JJJJKoAADOVXOZmZkkkqgABpe93ckkkklUAABe93ckkkkma15q7AAA5vfOZmZkk7mXYAAHN7u8zMySSS7AGta1rWta81q91dVU+3JMMxAAAUAAIBxQ2JJJJIAAAAAAAAAAAAAAAAAAPntSpySpycu/LcX5VVJJKoAAC97u5JJJJKoAAC97u5JJJJKoAAC97u5JJJJKoAAC8quczMzMkkzzXmrsAADvtV773ve9kklUAABe93ckkkklUAAB3lVzmZmZJJKoAAC97u5JJJJKoAAC8quczMzMkkzzXmrsAAa1re9/vvrrnOfczMzEAABQAAG6ulRQCSSSSAAAAAAA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9/d73uZmZKoAAC97u5JJJJKoAADvKrnMzMySSVQ8PAXvd3JJJJJy7AAA5vfOSSSSSd7oTvOSSSSSSSSSXqH71FxGCrAIQZGRkUJJBNCvotAqmuXr3f379iVVVNfKV/SpU4v6pFVVUAAAAAAAAAAAAAAAAB6B8AFgGZmZmZnwgVsEoD8xP3kTgJO92Anl83rXnXe/Zne973uZmTl2AABze+ckkkkk5dgAAd9qvfczMySScuwAAOb3zkkkkknLsAADm985JJJJJmtea95wAAD3e/e/u973MzMnLsAADm985JJJJJy7AAA77Ve+5mZkkk5dgAAc3vnJJJJJOXYAAHN75ySSSSTPNea95wAACvNeeGvavnuuNc2qqq55ypme9zu7u7YG1VVSqqqAAAAAAAAAAAAADwNDoQAFASSSSQA0qrr3z31+zMz9+zMwJze9AAA77Ve+ySfffffcuwAAO+1Xvua88zMySScuwAAOb3zn3330kknt2Bo8Dm985JPvvvvvs1rzXvOAAAZr9Vfu/d73JJPuXYAAHN75z777777777l2AAB32q997rzzMzLk3JPeWAAB7vfOST7776Se84AAB7vfOST777777Na817zgAGta1rWcnqu7s3RVZWw5D095V/Rdq9VQAAAAAAAAAAAAAAEaAAkkkkgAyq3ve85zMzP379+/fgnnL2AABze+c+++++++++5dgAAd9qvfe688zMySScuwABrjfOfAAK95V13XecVAA96qutTtXXqNh0972Kpz6rr9Vc3z9wAADXPquvfqvv7v7vqu8zMkkjl5p1seNa8023pevP2/1fu973skkb1+n6SL2d5377773ve9gJzYn68gq8nYTkqu+8kxgAAAAAAA8qroB0AAAAAAAAD4e1QKBJJJJPZMzMzNgnfkD0XoJKgon0r5EyszvO9I573ve8qmq59V1zXPuAAAa59V17u+8r1XeZiAZz6rrfN84qoA8+q65rnAJJIZVXXeVdZU3J4v3vYqmq59V1zXPgJJIa59V16u77z1XeZiAZz66rmuc4AAA95VlcrnOZmZ73vegpvQlfBzIGg7F3BkyqFV0KrBVgqzoqwVaq/tAAb2qur7V2KuatVfs529qr0UA7fQVbFWEsIHTtaDp61V5lc1uTV6qVrVVfNal1U7O6AqqJmi5rhe42c4qtqrsVde99eXh7RV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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
#        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
#    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

#    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

