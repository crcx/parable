#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':
            braces = braces + 1
        if t == ']':
            braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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kn29gAaNZze+XmZmskk5rzzW9b8AAPub3zMzJkkub2AABdVdySckklUAAAy63eZmZkkmfePNeaPLsAGtN/u3ffvvvvfpJM3sAAC6q8zMzJJKoAAD697vJJPfffaoAqqqqqqrJGr53j5+4ra/c9+n6SQAAAABJJJJAD4egAAAAAAAAAACSSSSAAAAAZWEmt28+Emvl9n6T74++JJ7777VAAAS2t7uZmZmZ9999era815dgAAVreuXfPvvvvvpJM3sAAC6q8zMzJJKoAAD697vMzMySAAAE3ve5JJJIAAAVVSSSSSffea81vYAAF1X3333330k+qgAAN1WZmZmSSVQAAH173eZmZkklUBVUSSSSc+UX8ovaVXSgm0iParv7QNbs2YAAGpJJSSSSSAAAAAAAAAAAAAAB4A6B44DokkAAHz3WvNR77z3333JMzJJKoAADdVuSSSTMyvPPNb2AABV73eZmZkkn29gAAXVXmZmZJJVAAAfXvd5mZmSeoAABrdVuSSST1AAAN1W5JJJPc1rzysAAAuqvMzMyST7ewAALqte973vd79XarIqGXbcoKLtFqkIVdtlVu73mZmZ3v3fFtUi1SqtVVVXb5evZJV3nn2+a1rWq088cfp+/AAAAABNSSSToAAAAAAAAAAokkkkgAAAGamklzmRJrSTXfJNaM7533pQtySSqAAA3VbkkzMzMzvmvNb2Kpu65ckkgBvU1dXckkgBxNbM7mSS2STKa1jWgAADKa1jWgAALcJNaTV1dySSAG9TV1dySSH3wmtq6u5APu98J935NgEBXkUFPwKwVAOQRUNSyKEIqB2Ar+5QgH7KBXICi/oov6AryKGEGQSEYhFEQ/RBQ/QC4xkYE/Uii/oAiP6iGqkJJlSEmUSAGaYBIFAAZmZ+/fv378aAIBJJJJAAAAAAAAAABJJJJAAAAAOfJfYxhJXCS5httzGrlJtvuE0294YePj4JJMprWNakkkkDCTWk1vG9gT3ve+0mvl93Xe22+972U19vO9yQJJMprCWs61JQABZTWE9Z1oBSSSKpNaTXvvuJ+57X33ovvgBZTXd53sJPe97KZ4/Td7veZme97rQmfEPtUXFIosLg0QZGRhASSDAkVFOb5z7737yi8/J6oBIZjAkmVzEJJmfEAP2iEMzM5+/fv34AAcDckkurqSQAKAAAAAAoAA2Dga9A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mZ2ZiCB5RZCKLIAAZWZmezMRBPKLEBAiixVWQgjAAAe971q5dPX41v3tptv333317bbbbcAAAPQPgAAAAAAAkkkkgAAAdPAAB65Kq6/V+u6u9Xq7q79+399uffffASSS8+4mvvZ977776ySb0mre67222ySJtb0mjWFzXNgBJIt6TRzPOABJJWk+Z2mrtd13lthJJ9zaa7v733Jz774VJJvSa4uZ5ySWIkmtJrdxVrvbbYrJGmtaTW0Z5wJ5SSRb0muGO8K+vfyyd7tVf71+z9vMz3AAAeA+dnskg8AAjQADdVdA4ABJJJJAI0AAbBwJJJPqCGCEO6tCHYQv30g7CCwNa9r35vrVwkUkkqTXNprul3Xeh5NGESSfd7xNb02u67sDyklDm013uecD6xABvSauczJJIoAX1NXV2ACAC+pq6uwAQARprLTWVmSSRABuWmt9z3t3d1QA3p/pw2Lue9vLapJPXaa+zhTu1DjbTerlXXbz8fS3622mAAAgIC2222kkkmHgAOBsAAAAEkk5JPdg4AHoHwAkkkmc++abdaazj5LWG03baF+++BSSGklvG9gApJPGNtLmOcOAKST3zSd4mvvZ9+37d1QAvqaursAEAF9S1KqW0uVSqQWqTjzmZmYZ3ve/BDesxqiqqqoP1fv2fburQD7LTWVmHgEAEaay00e570ySoAPubTXMc5bbJJN6TX3y0otda935bxh39u/aJNbsaS7skmvd3Z+knYAAAAHA2AAAAAAABJJJB4ABQAAAAy68nlVVVde140BuYAm/aut63uSSSSb0mhJczzgASSVJrm0nzHOAEkUn3NprmOcAJJJvSavM84BxJo+psL6mrq7AAAOXSaursAAAiTWW2srMkkhskmdTV1dySQAL6mtW0k2+Z+/d79O959+/ffsz0AAAAAFAAAAAAAASSSSQAAAAAAER2pUkkn0AAGmgvqaursAAA5dJq6uwAACJNZbaysySSGyScTWXy7kkgAcTW3y7kkkAON9rvQAADia7XegAAESay01vue9u7uwAvqaursAAA3pNfTAk0vZbTfOez7F9DZJJIqAAAAGgCJJJJIAAANAOySSSAAAACSSSSDVazqt1V13zd1d3pqtZaTRQfEAAAvqcbara5S9Xvbu7ugF9jTVbXKdNNVyuUvV727u7oBEmsvjTKympUIU0NUEHl85m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2E0ADoESa9bfqzJIQANy01lZkkkADctNZWZJJAA8stNT3PekhIAey01lZgHwAF9TV1dgAAFSa5tNcxzlttAD6xpr3U1nXte9u31DQH19xJ+x3vLSgAe7xNVK9WU0m1MrDxj5rhs99afZWbbbeK4tzbbaBJJJgPY0I74AAAAAAAAAAAACSSffffAABm+6qXE+UtbTZN3t8++aa3u7pJ4AAy01lZmAAAey01neZgHgANSay01lZkkkDoGxJr9ia/V72SEDwH7f2Jr9fPe/SegAGWmp6++92SSAF9UVUFUUacuqaV+/O/2Zn7M7393u9ZUwpppopX6u9/fffffTsk+1rzXbp8oUoUo/Vz99999nvv0+5dPhSlKUo+7ze+85l3680afe9f66dU/b9u7u7utyTqkktpbu7skkX30n4AAAAAAAAAAAAAACSSSSAAA/JNVtptY+y029Xe3S4tnwST77O5vWVdNNNNNROO8zMz332d1eVKwkF5xVTpe5m7u7PvtL6mrq7AAAL6mrq7AAAIk1lprKzJJIAG5bSysySSABW5aayrySSABa6mpnMySSQAvqaursAAAvqa96s/fs7+D374mrd3d3d3QAAAAAAAAAAAAAAAAoABJJJJAAA9Emvmm2/m03Nbt3bboAAGpNZaaysySSBskzqayruSSABfU1uczJJJAC+pq6uwAAC+pq6uwAACJNZaaysySSBskzqayruSSABfU1uczJJJAC+pq6uwAAC+po1b7nF7ueZtsSavMhoAquFbbbbaGABAAAAAAAAAuroAAADKzMzMzMySSSSAABhJrCTVauUmsJNZx1J5WjvUmp3kmSQkgABEmstNZWZJJAA3LTWVm+3d3ZJC+pq6uwAADctNZWZJJAAvqa3OZkkkgBfU1dXYAABe9eatdySSSSXvz58ADrvfvvvvvpJL6401W1yqqlSqq9z3fbu7uyQjTWVaqnTTVbXKdFbV0vs++9v27oBqkikkkgAAAEkkkkAczMzOZmZgAAAAADp4AAAAAHv11db9/a597dXd+nXwmABsma8VKqpVTqnVJV7md3d3QCX1xNUqqk1TSXc5lySSAS+pNXV2AAAX1NzOZkkkgBfU1dXYAABfU1dXYAABEmstNZWZJJAA3LTWVmSSQAL6mtzmZJJIAX1Nfd96/WeD4AAAAAAACSSSSAAAAAAkkkkgAHoHwAAAAmu5Xr0DABv2rrdXYAABEmstNZWZJJAA3LTWVmbu7uyST9lprKzA/AAF9TUzmZJJIAX1NXV2AAAX1NXV2AAAX1NZnMwAPvvvr6mrq5gBJJCNJ5aa197lXvl+9fK+3z9+/fsAAAAOngSSSSQAAAAAAAAABQCSSSSAAOV3VaqmvyTXY02+201J66uft3duSSQAvqaursAAAvqa3OZkkkgBfU1dXYAABfU1dXYAABEk8tNavc97d3dgBfU1dXYAABfU1uczJJJAC+tK6uwAAC+pK6uySSSSbsSa9iav8dris2epJX8VtReTv2+/qUXmcrvs9vde56+a3lgrsFecUXWgVtEJM3N63nM532zWZ6vKLvtFOy0V92e5l+mj9u/SlFii+uve2Ym5cNQsmrK1qaM+z73Yb1VeOG+U65nEUaZABYfEutSF1AkKqVgV9ddzn3vvA+BXEVgK0ICsiosQVgVIEAViiwFZBVgQgkkIEISEYyBCJIkBWKLFFhIpAVkrMzMzMyAIRRYosBWCixRvGACSSSSAHmkkkJNNJGQAAbTSUWBtN5TbWMNJtvOQACQAABVd3YAXdVVXK1dVVXTwBKpoACNNp9Q6Em3O8kk/SfDqkm3TppNi4CiMGhBSAKxgKxWgar++tttxE22YoAQhgAABJNtxpJbyaAPAJpoafsLOA3JJ7MSaSwu5TTbqtc83Jw7Hi7qroDp4kkn0kAD5NvTSjtzbb60aTbAAAAAAAAAAAJJJJIaq6qgCAkkkkgAfD0AHgDoAAAAAoAAAAAAAA83v4PvukkAACSSSSAAAAAAAAAAHNBwAAAAkkkkgAASSSSQAAAAAAAAAABrve9737oAASSSSQAASSSSQAASSSSQAASSSSQAAAAAAAAD0D4AAAAAAAAEmqnlSSSEAdPAT6TySSAAAAAAAAAABJJJJAAAMrurPQMAAAAAAAAAAAAAAAAAAAAAANcknsk7AeAOgAAAAAARoBJP0kkwYAEkkkkA2DgAAAAAAAASSSSQAAAAAABQAAAkkkkgAAAAAA1OSSSSQI5TS9n6j5JrG20+Io/b35D0TcK9bkTUJIEhcaj8aLKLiEkJSVItF+2VATV+hs36jcYgou6BXFUZyHgScBKpE8ibCYCZsFeglCizXdorfyK/InUS0T4E4CfCb+UBT4EuHkVlCb6jqqW8RXLjgJ5UGveOMgIpM4KuvVpFc4iWieEF4CfZetZr6e+9n2ZnszMz2Ty4KsjIorFFxRYotBAFaAAKAFZFQCkFYCLfKrXnodJdXVXXjwCAAyTySetda9kknUwBQAAABJJJJAAAAAAAAAAACSSSSAAK98k1w4WAAAAfxJM6tqqqqpVVUvVmS2kkm9Jo+7rvbbbJJvSa3je5JJJJvSaursQAAESay01lZgB99999uWmsrMAJJJebTXMc592222270mt43ugAAb0mrzPOW24tAOtNc2mvT2veOZng2GZJJJ2PAF1de6A6AAAAAAAAAG6q6BwAAAAAADVVdaqrpSanm1VVycSaknmmpJJADoBnW+07rzZ0Bv2rrvPOcPgG/aut63sAF9TV1dgFAAeaay01lZgfgOgGdTV1dh+AA7xNeM7nQ8AB3iaieqms7m7u7ugRq+prm1VJZ3N3d2t0A801PYnXfN1z7J33e8+xGkkkkkAAAAAAOBsH7MzMzMzAAAAAjQAAAAAA5zjAAWpa1VUnu7u7u7oHplpriWtV7vt3Td0CX1Nfurafr9u79u6ATLaXE1nMySSQAvqaursAoADzTWWmovc96T6SAH7df6vJr9X79um7ADctMpIxL9393d/ft2SSK+prid8vskkkkkd9TXGr5vVttxbba+tNc2mspel7hTs3eyWhJJJJGZmeZmZmZ0AAAASSSSQAAAAAAASSSSQAAD7zzg+j7wZmZmZkPX1NTOcySfSSQfeJr18mST9JJJFfU1dXYAAAr6mrq7AKAA801lprKzDskkkqmEmu8TWUrhfYm5Pj776SS45tNTXdd0cCSSLek1eZ5wAJJN6TW8b3PgAA801zaavNXvF0mvc7feoEkkkkAAGgCAAACSSSSAAAAAAACSSSSAAAAADi366WWmt4Sayk1i3N3fS2ySSElLd1prpTTX7yav9z3d37dABblpr73Pe3d/bsgLsbV1dgAH76uiamczJJmYkr6qutquua5yjoSfbVdc1zh0AUSay0197nvSekABblp5WZJJAA3LT1UlV+77u/t3d2ST5pr5Nr2FVVVVVVVVVVVWtpv2FUeM2ft/fbwA1SSSSSAAAAAAAAAAAAAAAAJJJJIAAAABGmrmJNF5nVttLbbbvdtvdYAAByucz33MySS94AABqT9f79neyfv37e4AABma33uZmZ+/ft7wAACVzfJJJ77+91r9rXmnmvNc5QAAErvZ+n32vvszMnL+AAA7Xe39++k99955ry79AAA/Tf79OeyV+/fr3AAANSuckzJ7777e4AABmu773MzM9999/a15rl4AKqqqqquX9aX7EmufsPuT6S4HQAAANmZmZmZgAAAAAFAAAAAXV0AASpOzEgCyAAAAAHUmspNfaSaqTXPJeXdeXmezO1MkkkkkmRrXmu8oAADtd7n7MzJJP3mvPu8+AAAz3fvv3J99m5JM7dAAAcrnLzPczMzMveAAAe932+5n7MzMye615rl4AABvu+9zmZmSSXvAAANcrnMzMz3333vmvMvAAAJv9f79nfcyvfffZvAAAOK5XnMz3MzMyZ5rXnLoAAD1ru+9zP2Zkknutea+7z4ASSSST1/GvtqrxRYqH0UWtfWIg/QP0AAT9lBkTyCsQQIosVRQ/QFAPv1KI6UWCAjcVF/QBU/QUX9EENgrBUVP0REUpRYgfoqotCiwFf0P0EA/fv1jdXX7VVVX+/fv2ZmJJJJMAAAcDYAA/ZmZmZmYAAAUBJJJJAAAP1VV1V+++1uqs++++8gflRZFFgqsP1IijSizXnmta+9++++++++kknud5QAAHa7vufszMzMn7WvPe8wAANPz9+z97mZuSTmeWAA1O773Oe5mSSXvAAAPe773M7mZJJe8Aa18o1rtd7999999JJnmvNcugAAOVzmZmZkkn3uted58AAB+r9v999799m8zJzeAAAcrnMz3J7777OXQAAH7P27/fsz377Pe9q8kkkkkkkkk3PdvWwStoo/lFia977RsUXICv32hD9+pRf3FFoCSGZlySTKJJMqEkz9ISMDMzNyEkxNtum03u7bab3d3dA++++++0AAAAAAAAAAAAAASSSSQAADeVd1d7pNZJwnm23ycWnjd3d377776+yqqqqqqqqga5XOSST3333utecuAAAdrvZPZ9m5JObwAADzlc5me5mSSZ555rl0AAB73fe5nczJJPuX8AA5VDtb799999kkmcugAAOVzfMzMzMzJ+815y8AAA7Xe5nuZm5JM7dAAAcrnMz3MySS94AAB67vvcz9mZJJe8AAA15555dXYofRFdkFWyM/KLSgp2CKvO1pRYiISJFFnICgd/Uor+gKG1FiosQCAgfv361V0CsFiixRCKLFAIosBICsAiixUX9+/WAq/oIn6C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73+/v4BbbbbQAAAAAAAAAAAAAAAuST44AHZk73oAf2STyZPnnnm7u7ujsyd70AOzJ3vQA7Mne9ADsyd70ANgDJBOjWtNtvbSVEFVSSSSSVRDICYznLbbaSVEE8XAEaNZbfLbSSSW973vdtAAAAFttttAAAAAAttttoAGST9kk9ySd6efQHZk73oAf2STyT78VVVdfffZmZmZbecVVVVVV5zlttttvOKqqqqq8Octttve72qqqqqrecttttt5xVVVVVXnOW22225APvlVVVVVdfffZmZmZbecVVVVVV5zlttttvOKqqqqq85y22223nFVVVVVf7nTJIQnoBGSSSZJPmZJl8v9+9/v7+/gAAAAAAC2222gAAAAFttttAAD+yZJJOc3czMzLbziqqqqqvOctttttyAffKqqqqq6+++zMzMy284qqqqqrrnNW222284qqqqqrznLbbbbeBxVVVXnOW222284qqqqqrznLbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq85y22223nFVVVVVec5bbbbbziqqqqqvoBP70gABqQI9gHe99719AOvreQC22/W222gAAABbbbbQAAAAC2222gACZJuQP0AzRCEwgc3rM/ZmZbZziqqqqquuc1bbbbbkA++VVVVVV1999mZmZlt5xVVVVVXnOW222284qqqqqrznLbbbbecVVVVVV5zlttttvOKqqqinOctttttyAfH0VVVVXX332ZmZmW3nFVVVVVec5bbbawC3m1VVVVVTnOW222284qqqqqrz7Ofu88ECfud97+92+t73ve972gAAAAFtttQ4AAAAAAAAAv9AG3dtttt5xVVVVVXnOW2222+gH3yqqqqquvvvszMzMtvOKqqqqq/x999b9bbbecVVVVVV5zlttttvOKqqqqq85y22223nFVVVVVec5bbbbbkA++VVVVVV1999mZmZlt5xVVVVVXnOW222284qqqqivOcttttt5xVVVVVW/2STPPP37v3d3bpbbbbQAAAAC2222gAAAAAABMkABAAO5JPFVVVVVU5zlttttvoB98qqqqqrr777MzMzLbziqqqqqvOcttttt5xVXCBrSqqr999mZmW23nFVVVVVec5bbbbbziqqqqqv9999b9bbbcgH3yqqqqquvvvszMzMtvOKqqqqq85y22223nFVVVVVec5bbbbbziqqqqqphAnf379mfZu6W2220AAAAAttttoAAAAttttoAtttttuECfiAazMz7MzLbziqv2tKLPvvrbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq85y22223nFVVVVVec5bbbbbziqqqqqvOcttttt5xVVVVVXnOW22225APvlVVVVVdfffZmZmZbecVVVVVV5zlttttvOKqqqqq85y22223nFVVVVVf45+/fnn9/fufffc/uc7r7oQIhAiRZF3C4i5RZFkWhaFukWkXCLQsyL5752++ovUXSL6xF8qXVFgTItJGSk1F+RcqRxF1DlJHJVySMi0kaFyKrIaJWlMQYTtSmpTSjIuCLxFxF0i6xVVxFlFRkWqpMSORLnCLki3EWIsoXIXFI5UskxFaKbUpimUmoHZKTiLUWhYi4i1UWRaSOIsi4ReouqFOkWosCdUXSLlS+w+d9d9Oc7879+fvwAAAAAAAAAAAAAAAAAttttoAAAFttttAAAAAAAAAAC2222gAC2222gAAAAAAAAABbbbbQAAAAAAAAAAttttoAAAAAAAAAAdltt+20AAW2220AAAAAAW2220AAW2220AAAAAAW2220AAW2220AAAAAAAAAALbbbaAAAAAAAAAAAAAAAAAAAAAAAAAAAt/wttt00AAAAAAAAAC2222gAC2222gAAAAAAAAABbbbbQAAAAAALbbbaABbbbbQAAAAAAAAAA7P3JMkxJkg6h+h7DQ6pR7DyHFVGIvhFoch3DpF4pHqL4i+Q7IvYfYfoeJLqi/VK7Uk1JKkrKkqVqSqlSa85sOdVQAAoAAAAAAAAAAAttttoAAB+gDbeW22284qqqqqrznLbbbbecVVVVVV5zlttttvOKqqqqq85y222230A++ViMVXX332ZmZmW3nFVVVVVb999u22222AffKqqqqq6+++3bbbbecVVVVVV5zlttttvOKqqqqq85y22223IB98qqqqqrr777MzMzLbziqqqqqvckyTLkkuST2/Lvu++7p3JIB+AAAAAAAAAAAAttttoAABMk3JDIBd6zeZmZltsA++VVVVVV1999u222284qqqqqrznLbbbbecVVVVVV5zlttttyAc4qqqqqrrPvtZmZmZbvaqqqqqvecu7bbbewDnFUVVVV1zl3bbbbvaqqqqqtOc1bbbbd7VVVVVV3u22223e1VVVVVd7tttttyAc4qqqr8+fPnz5zvnnfv7z7u7v71oAAAAAAttttoAAAABbbbUOAAAGSSzJOcdLbbewDnFVVVVVdc5d222272qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqr3nLu2223IBYB98qqqqqrvf32bzMzMt3tVVVVVXe7bbbbrSqqrhA1pVXOOZmZlt1pwgM0qqq95mbzMy23sA5xVVVVVXRvm3jwW2220AAAAAttttoAAAABbbbbRbbbbbfoBbbylttttt3tVVVVVXe7bbbbd7VVVVVV3u22223IBziqqqqquuczMzMzLd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV7zl3bbbbvaqqqqqu92222272qqqqqrvdtttvcgG9qqqqqfPnN59593d3dW220AAAAAttttoAAAABbbbbQAAD7MknwPoX5yfM+fPnxVVbu2223utKqqqqq/15d22291pVVVVVW7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMtvOKqqqqq85y22223nFVVVVVb999u2223e1VVVVVd7ttttt3tVVVVVXe7bbb3uqqqqqr8+fJ+nZ8zzg+gttttoAAAAW2220AAAAAAAALbbbb+ySfB4FvHz58+Kqqqr3nLu2297/QDdVVVVVV1zl3bbaW5AOcVVVVVHXOZmZmZ3usVVVVVV3u22297qqqqqqq6N222291pVVVVVX+3bu2223sA5xVVVVVXXOXdtttu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq/z9AOfNv63+tttttySPgAAAAAAAAAAAAAAAttttpAyAWAZANuszMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7ttt73t2qqqqqq95y75ALbbbkAsAvyqqqoo6399nMzMuW62qqqqqu92222272qqqqqrvdttttu9qqqqrzWl5y22223e1VVVVVd7ttttt3tVVVVVXmf3379mt5n7L3O9tttttttttAAAAAAAAALbbbaAAAA9ySfDq22272qqqqqrvdttttuQDnFVVVVVdc5mZmZmW72qqq4QNaVV5zMzMy23e1VVVVVd7ttttt3tVVVVVXe7bb3ve72qqqqqrectttve72qqqqqrvfe973ve93tVYjFd773ve973u9qqqqqq733ve9ttu9qqqqqq9v9hAn+AECJAiECJkmfJkmW/v7+9/v7+t/gAAAAFttttAAAAALbbbaAAAAZJNmZMk5zd3d3ct9AOcVVVVVV1zmZmZmZbvaqqqqqrvdttvbbvaqqqqqu92222272qqqqqrvdttttu9qqqqqq73bb3ve9yAc4qqqqqrrPvszMzM73e1VVVVVd773ve973u9qqqqqq733ve0ttu9qqqqqq73bb3ve93tVUVVVdegE8ECd/cu77MzvfWgAAAAttttoAAAABbbbbQAABbawD6Aatt+73ve5AOcVVVVVV1zltuZmW72qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrhA5zMzMzMtyAc4qquiBrSqq6kDnMzMzMy3e1VVwga0qquiBzmZmZmZbvaqqqqqu92222272qqqqqrvdt73ve93tVVVVVWqa2/u/2/ud/vvzzepCSSagWRekWPsLKLzzr3pF55IvYWqR+9UjiL7DJCfMlV9hiUPtS8EXcP6H1F0E8SK7KsCp2EwlYppLYi4i0Ev0OQ0PkP7yGh/Q/Q5+h/Q/Q/Q0OP0Rkk7zj0UAAAAAALbbbaAH3JIHgAAAAAAABMkAAAAAAAHmSQH0AAAAAAAFvvvvvvq0AAAAAO5JAPwAABbbbbQABbbbbQAAAAOZJAHvMkgD0AAC2222gAAAAAAAAAB8ySW2232gAAAAAAAAAB2W237bQAAySAAAAAAAAW2220AAW2220B7kkOAEyQAAAW2220AAW2220AAAAAABckj4AAAttttoAAAAAAAAAAA9ySHAAAD/AAaAAAAAAAAABbbbbQP2SQdAAAAAAAPuSQPAW2220AAW2220AAAAAAAAAALbbbaAAAAAAAAAAHmSTzJJ5kk8ySe5JPuSRg/Q6hyVF+h+h+h+h+Q/Q8h6qF7DRI+Q9RdQ+UHcOQ6JPsNDtF9h8IeqpNUsEvyLSRz/FC6h8kkzJPfmTJkmdzJLfd9t3YcAAAAAAAAAAAAW2220AAAB+ySfD9AMkCE1mZ+zMzvaQgBziqqqqqup/gMgffZme973rd7VVVVVV3u22223e1QVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVXWtd753tSS+nOc4AKqquVJFVeKqAAAAAAAAAAAAAAJkm5JPm7uZmZluQDnFVVVVVdc5mW23vd7VVVVVVznLbbb3u9qqqqqq733ve973vd7VVVVVR3vve97/d73RsYqqq733ttttuQDnFVVVVVdc5mZmZmW72qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqq4QNa59z++5+t+vf697ltttAAAW2220AAAAAAAAAAADsAbq22225AOcVVVVVV1zmW2297vaqqqqquc5bbbe93tVVVVVXe+973ve97vaqqqqqu99pbbbbvaqqqqqu93ve973vd7VVVVVV3vve973ve72qqqqqu99ttvbbvaqqqqqu92222272qqqqqrvdttttuQDnFVVVVVdYkJCE0kJmZ9++bu7u6AAAAC2222gAAAAFttttALbbbbbbbbbbcIEczMzMzLd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd773ve973u9qqqqqq3nLbbb3uQDnFVVVVVdc5mZmZmW72qqqqqrvdttttu9qqqqqLvdttttujaqqqqvqQVclNKDvqJW8bnOc5znOuugAABzJIC/rbbaAAAAAW2220AABbbbbbbAP0AYBptv1ttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdttttuQDnFVVVVVdc5mZmZmW72qqqqqrvdttttu9qvNaVVVV5y22223hA5zU1pVVVVV5bbe97272qqqqqrrdtttvbvaqqqqqu7bbe97d7VVVVVV0fnAgTxAn7fve/ve962222222gAFtttQ4AAAAAAAAAAAD+mEkjbbbb3N7VVVVVV3u22223e9a1rWtVqarMVVFclS7VVFclS7VSjszvz58zvQKOzJzgFG5JPJk+c3d3du67MnOAUdmT4B6OzI+5JPPOh7QAFtvuSS/LaAttttoAAAAAAAAAAAHzJJ8ySbmSSf0ySMF3d3d3aVEEpJJcpKiCUkkuUlcAZmT53u7u7rTuSc4BR2ZOcAo7MjvQVb2ZOcAo7syT5kne7u7u3UqIMYSSS2kqIKzmuHcRBGebu+bbtJJIAAAFttttAAAAFttttAAAAAElZARZAQoAwEBFXebu7u0lAGSCa7wFHZk5wCjcknkyfO93d3dadmTnAKOzJzgFHZk5wCjsyc4BRuSTyZPnO/N3d3WnZk5wCjsyX9Mk88eH5QAAAAAAAAAAFttttAAA7kkA/ALdmSZ9yScD6bp2ZOcAo7Mnvengo9ySeTJ8708FHZk5wCjcknkyfO93d3dadmTnAKOzJzgFHZk5wCjuZzgFG5JPJk+e+e88793d/e7dAAAAAAAAAAAttttoAAAABb5ADIIiI4gCklnhJtKiBkBVNttppVAyAmCSAqm2200qgZATBJAVTbbaaVQMgJC5wQC1q7zd2rScAbgDUGCAkLnBAVOtXeru1aVRDmNGcttvnbSoxgs3vMzMzuW7MYLN7zMzM7luzGCze8zMzO5bkA4LBY974gTZAnO01rt6bd3reNLfNZ3HHK1wljXJqllYOanNPgeecScm94uU1c+3FIEQZAjEgRGQCIaSNGUjMi824uMmaYlve++hLvHiLxFzqizbQtmyp26lOxTJTJK8CYTILUWhZKOSRkWJExFkBiLCLIshZFkWRcRaFxFqlhFoliL5UuCLhFlIxFiLIvUXCLlUpqLFSWRYiyLUXaLVCuEXFI4skz98s87z69qgAC2222gAC2222gAAAAAAAAABbbbbQAAAAAAAAAAAAAAAAAAAAAAAAAAFttttAAAAAttttoA9ySHAALbbbaAALbbbaAAAAAAAAAAFttttAAAAAAAAAAC2222gAAAAH3JIHgAAAA7Lbb9toAAttttoAAAAAAttttoAAttttoAAAAAAttttoAAttttoAAAAAAAAAAW2220AAD/AAaAAAAAAAAAAAAAAAAAAAAAAW2220AAAAAAAAAALbbbaAALbbbaAAAAAAAAC22222yQgcIE5CEiQJ2AdgHYH2HcPqLIvIZF9JX5FqVWRYRZFiL/RUvnzz999/vv7+/AAAAttttoAAAABbbbUOAAAAJJJJJbgBxBER0mAq83d3d2k7kJkAFAkiyQk+IakJJOc973vevrdkNatoo5kk7Mnz3zw8AdmTnAKNySeTJ873d3d1p2ZOcAo7MnOAUdmTnAKOZJOzJ870AOzIv7JJ9++Pp7QAAAdySFt+220AAAAAttttoAAAAAPmST5kkZJNySc5u7uttJwBkgnZAZy3ltppUQcxVJZSW0l2ZOcAo7me96eCjsye96eCjsye96eCjcknkyfL55u+butOzJ73p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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn))
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

