#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    i = 0
    c = 0
    while i < len(code):
        if code[i].endswith(' \\\n'):
            s = s + ' ' + code[i][:-2].strip()
            c = 1
        else:
            c = 0
            s = s + ' ' + code[i]
        if c == 0:
            if s != '' and s != ' \n':
                r.append(s.strip())
            s = ''
        i = i + 1
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = stack_pop()
        while count > 0:
            interpret(quote, more)
            count -= 1
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `" + str(opcode) + " "
    emsg = emsg + "at offset " + str(offset) + " in slice "
    emsg = emsg + str(current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    i = 0
    r = []
    while i < len(stack):
        r.append(parsed_item(a))
        i += 1
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        if original == TYPE_NUMBER:
            a = stack_pop()
            stack_push(a, TYPE_BYTECODE)
    elif desired == TYPE_NUMBER:
        if original == TYPE_STRING:
            a = stack_pop()
            if is_number(slice_to_string(a)):
                stack_push(float(slice_to_string(a)), TYPE_NUMBER)
            else:
                stack_push(float('nan'), TYPE_NUMBER)
        else:
            a = stack_pop()
            stack_push(a, TYPE_NUMBER)
    elif desired == TYPE_STRING:
        if original == TYPE_NUMBER:
            stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
        elif original == TYPE_CHARACTER:
            v = stack_pop()
            if (v >= 32 and v <= 128) or v == 10 or v == 13:
                stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
            else:
                stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
        elif original == TYPE_FLAG:
            s = stack_pop()
            if s == -1:
                stack_push(string_to_slice('true'), TYPE_STRING)
            elif s == 0:
                stack_push(string_to_slice('false'), TYPE_STRING)
            else:
                stack_push(string_to_slice('malformed flag'), TYPE_STRING)
        elif original == TYPE_POINTER or original == TYPE_REMARK:
            a = stack_pop()
            stack_push(a, TYPE_STRING)
        else:
            return 0
    elif desired == TYPE_CHARACTER:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            s = stack_pop()
            stack_push(int(s), TYPE_CHARACTER)
    elif desired == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_POINTER)
    elif desired == TYPE_FLAG:
        if original == TYPE_STRING:
            s = slice_to_string(stack_pop())
            if s == 'true':
                stack_push(-1, TYPE_FLAG)
            elif s == 'false':
                stack_push(0, TYPE_FLAG)
            else:
                stack_push(1, TYPE_FLAG)
        else:
            s = stack_pop()
            stack_push(s, TYPE_FLAG)
    elif desired == TYPE_FUNCALL:
        if original == TYPE_NUMBER or original == TYPE_POINTER:
            a = stack_pop()
            stack_push(a, TYPE_FUNCALL)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: ' + name + ' redefined')
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ]. These
# are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are not
# inlined. This hurts performance, but makes the implementation much simpler.
#
# The compile_ functions take a parameter, a slice, and the current offset
# in that slice. They lay down the appropriate byte codes for the type of
# item they are compiling. When done, they return the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map ' +
                   name + ' to a pointer')
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert " +
               number + " to a number")
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `' + name + '` to a pointer')
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = ' '.join(str.split()).split(' ')
    count = len(tokens)
    i = 0
    offset = 0
    current = ""
    prefix = ""
    while i < count:
        current = tokens[i]
        prefix = tokens[i][:1]
        if prefix in prefixes:
            current = tokens[i][1:]
        else:
            current = tokens[i]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, count, '"')
            offset = compile_comment(s[1:-1], slice, offset)
        elif prefix == "'":
            i, s = parse_string(tokens, i, count, '\'')
            offset = compile_string(s[1:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append(slice)
            nest.append(offset)
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                offset = nest.pop()
                slice = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        i += 1
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0:
            interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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VHM7mTdZmZ73ve967kkkAAW3d97NSSSSqAAAve7uTve973tUAABe/Nea2u+973v7rXe78oAa0K95d3zvZ2SaklUAABe9bu5JJJJKoAAC963dySSSSVQAAF73dySSSSVQAAC27uSSSSSqAAAve7uSSSSSqAAAea1555qPNeLIqG4oqF7pADcVA2ZDLzKyDV3VHl01U1dVV3VtBsEknbq6mpIAAAACgcoU2AFACSSSSAAAAAzMzMzMylEOboQB8CQagKIe7NMbvzzzWta9n79HPNea3JJJJJJVAAAXvd3JJJJJWqAAAvet3ckkkklUAABe9bu5JJJJKoAAC97u5JJJJKoAABbd3JJJJJVAAALbu5JJJJKoAAC97u5JJJJKoAAC9+a81u7kkkkkqgAAL3u7kkkkSboAABrzzWtK35rXnnjVPe0Z6gV9AUB931ooBye9lpmUKt0eWcbqruxzYJJJJIAAAAAAAkklSSAkkkkgB6B8AAAB5VVdzSII+BIIKTwJ5U3DK5vgqo85JHNb7JJJJJKoAA0XvW7uSSSSTeqAAF73dySSSSVQAAC27uSSSST27AAA5vfOSTskklUAABe93ckkkklUAABe93ckkkklUAABe9eea3dySSSSVqgAAW3dySSSSVqgAAL3tdySSdklUASSSSSQAV3AFeQBXPHs0is4jSoBcQEDsBVMz1nYCvoKIhkBBQyCqouQAAcgArkEAMiIqZFVVzlIrkQQMytRAHAkkkkgAAAAAACSSVJICSSSSAAAB8GwAAAAK4km3pLSSbfecDh1t9gAGQBETvsuu5eZmZnMzLuSSSSSQC97u6kkk9klUAABe93ckkkklUAAAtu7kkkkkqgAAL3u7kkkkkqgAAL3rzzW7uSSSSSqAAAve7uSSSSStUAABe93ckkkklUAAAtu7kkkkkqgAAL3u7mZmZmZl3JJJJJJJJJlArIivAOUb++9+8e2OOVdVdGzlVd2GwST7yT2SEAAEkkkkAAEkkqSQAAASqumgAEaZmZnve973veRKwEgnuKUEoElXms0a888nsi/Nea3JJJJJJVAAAXvW7uSSSSSqAAAve7uSSSSSqAAAW3dySSSSVQAAF73dySSSSVQAAF73dySSSSVQAAF73dySSSSVQaAAve7uSSSSSqAAAve7uSSSSSqAAAve7uSSSSSqBJJJJJJNez2w7fb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7+/fv23fiCpBUgqQVIKkFSCpBUgrIe5377v3ve9/f39l36Tau0gqQVIKkFSCpBUgqQVIaXfd3d3+/v7bvxBUgqQVIKkFSCpBUgqQVkPXf3ve97+/sP1BD3OWQVIKkFSCsBXahdpBUgqQVIWVvOd7u7u/v379vOaQVIKkFSCpBUgqQVIKkFSG3fe7u7uZmZd+IKkFSCpBUgqQVIKkFSCsNo7zne7u7uZmZznPEFSCpBUgqQVIKkFSC0JVUJcvnj3e7AV9vBPJm+c7932fZmZgAAASSSSQAAAAAAkkkkgAEklSScg2kkkkgAGq86rz2qut164MugJ73ve973vZmZl34gqQVIKkFSCpBUgqQVIKkPrv773ve9me971whziQVIKkFYC7cC7SCpBUgqQVJDt33u7u7mZmbzmkFSCpBUgqQVIKkFSCpBUh2773d3dzMzL8Q4pCqIVRClILyyF2kFSDvet73yqvmZmZJJKoANGml73dySSSSb1QAAvKrnMzMzJMzN6815dgAAc3vnMzMySSfXYAAHN75zMzMkklUAAB9yq5zMzMkklUAABya3nmv3K3+/e5mZ+kkknuqu7Hp4eVV3YPvhsCgAAAAAAEkkkkBmZmZSgAEqgAAKqqq2Vm7nN355y8zO5kzMzJ3ve9qgAAMzzXmte3fvuZmd73vZrXmrs3vYABze+ckmZJJPrsAADm985JJ3ve9qj7ze9+ZVWRWXUu7u7qkILa2b/c5/f27u/v379+v3F3tvewAOb3zmZmZJJKoAAC8quczMySJJXmteXYAAGV7d++5mZ3ve9+uwAAOb3zkkne972qAM3sA3yq5yST6SSVQAA1rWk024ntJXzd3ckkkkhZegLOgAEVV1rWgB3R6AAAPQZWdvMzMzMlNEkkkkB1poB02BwAo0ARbkkkSamp6cAA6amkloEuwS0+BLmvppNToOAmi2YCTTWv37esfv3ta/Mm8zMzO973tUAABcquckkne97Na15dgAAc3vnJJMkkn12AABze+czMzJJJVAAAfcquczMzJJJVAAAXvd3JJJJJVAc3sDN7PaqvfcySd73s1rzV2AABntV77mZne97367AGgHN75ySTve97VAAAfcquckzPe9713JJJJJJJJJmWqdirqIrY78r33y69u99953vX7AAAAAAAAAAAAAkkkkgAAo8AdaaqSST6QAB40FmeudE2u8nfHcMrckkkADnNaNHgF73dzJJJJO615q7AAA3nt377mZne97367AAA5vfOSSd73vao+3sAA3yq5ySTve97VAAAfa5Vc5JJ3ve9y73rXmt7N615r6qK3tWqqmEFvvDnO99973szOnveskPvlVao3rew3rXmuVRXdfrv9+z77v0kk+/c59vYbhBeLa1VUhBb5P7nP7+3Tf25mZnTnNWgABK/Xf79n7WTJJJVAADWtSueZdeb9++zuZgSSSSQAAAAcDYAkkkkgAakkknYAAAAJJJJIAEmcb9ea81mfsz3veYzMySd73vfdXYBN7AM8/VVfv2ZMkmfZlea81330AAN73+3v33M/feefSST79330AACvP1V+/Znc73ve1QAAH3729377Jyd73vaoAD3ew5vfOd7+73ve9qgAAPeVXOdydkkkzWvNXYAAHN75zMzMkkn12AAfb2e737799999JJPdXYAAGb1r1XvuZzJkuSe3YAa1rWta1nnZ9zvmfdt59999kzAkkkkgBQAB8PQABJJJJAKqAAAqt7Vd1UqqqqBwAHweRVVWuM43dyqvaqqpVfe++AAAc3trXmucknZOyTNa81+5wAB4etvfczO5OyT79zzgAB7vfvuZnckklaoAAD797d++5mdySSe3YAADjfOSTskknt3m9gAaPd799zMmSSTNa81+5wAAD3e3mvNe+5mdydkn12AAB+9qnvuZncnZJ7dgAAfe1XvuZkySSe3q882s0u7gt2XdUwgtrbTS79cqfo1+EFfwKwFYgiElgrAV3nPX7oCvARSArwoFeWCv793fAVgArqYArAV5U8SH3bJrYK9BXVxFYCsu71aK6slArgK9sFdFVbegV1YK60pcElDKqTugVsbYHQVoFeArdIK0Cvpw+99yV9ut0ZqVUZ76zvFUeHD16ntasQWc2SWWfTm+9++++waCKKkmZme933kFbWe972Z3M6CZlAFXVVQAVVXVADMrMzMEuSSYuroUAAAyqu7q/au85zvNVfPlcObm7mfgqvwIAJTHhVVKpd3d6rQAprQAu6u7vuquru703YK3MzWZnsvqivoqplVmZzM9nTHgDXLqqqg2IAAASSSSRQAAB08AAB5JJJ9IAPAodH5mszMzMzxdXQ9HT6SSSSEkkkkAABoAgkkkkgAAGKq7q81mZmZme+74G+d6CSSSSAAAADgbAEkkkkAACVV3VtAFAACSSSSAAAAAAAkkkkgABlXd1eZmZmZmAAA3d+avve+9790AAACgAAAAAASSSSXAAPQPgAACSSSSAAAAAADMzMzMzM2DgAAAAAKUoAAACSSSSAAMrMzMzMzAAAAAAAkkkkgAAAAAAyqu7uqrNVmZmZmZgAAAAAAAAABJJJJAAAAAAAAAAB5JJJ9ID4egAAAASSTLDMzMwAD8AMACSSTs1AHaPAAAAAAAAASSSSQBJJJJAAAAkkqSSAAAAPytVrWeZmZmZgAAAAOarX11da17dXX22UiKO/leEQkEDcAKIaNQOcnQSrMBJkL1l+9Qgo/AoxEUbCyJYRBWJbQa1gJp3sFapFGMoEooEiZ3S69sVGwVmu4ougFaROACtAK63WCPOgl6BR4gJEUd3ov5K9gJo0CrwEggaLRR6Cw0KvfIlIlGvIlYCX2vvvfZmZmZsNhJJJd3VVXlakgQDg+cNszMzOdgSKnYlfUeh6Kv0JH6PIIn1VW9737VXXe9zM+AAAOngFububVVVKqqqqgAAKqqgAAAAABAB4AAA2k15JrZsCSEkkkACKq3ve97AAH73de+5mdySSZrXmv3OAAAe7377mZ3JJJ/D9zgH29gB+3t5rzX7999f0+lySqAAAzev3u799zM7kkk9vVgAAc3vnJJ2SST29WAABze3OSTsnZJmteauwAAP3tar33MzuSST79zgAAHu9++5mdySSe3YAAH2/Ve+5mTJJJVAAGb2fv1c5rzn69/uZmZkkkkkkAAG6q6BwAAAEkkkkAAAAAABoAeSSSfQ9qroD54ntVde+b8yquta71JrfFWtLa2JNaXNJ0p9cnjxJJJAJPbsAADm9ta81zkk7J2Sfs1rzXffQAAP29/v2ZO5JJK+/b4AAB7vfvuZnckklUAAB9v97u/fczO5JJPbsAADm985JOySSe3YAAHN75yTmteanZLkma15q7BrQvez97VX7mZ3JJJX37fPt7AAD9vb9++++n07JKoAADP3t37v3MzuT9JPbsAABVt6zWs8eea1+a1rXlEFeQb5ScigDyfQPooGQD6Co+iiD9EB+ggfRUfoKA/RAAftJuaaabmk25JxSbkkkkkAAPGgAAAAAAAAAHgDoAASSSSQAPJ+/C/oI8gl6BKT9AewEfgSK93uxNtNZpNO9JpNZp5iySSSABzmta1rWtAB7yq5ySdkkkzWvNfuc0aaeAPW/fczO5JJPrsAADm985mZmSSSqAAA+5Vc5mZmSST3V2Bm9gB7vfvuZkySSe3YAAHN75ySdkkkzWvNXYAAHN75zMzMkkn12AABze+czMzWSST3XnmrsAAD72q99zMmSS5LsAADKzXK1VV77Xee8+5mMA4obAAkkkkSSSSAAAAAAAAAABQBJJJIkkAEz1zdywzNznuvfPc3c3avKq8lV6oAAC97u5JJJJM1rzV2ABvew/e1XvuZnckkn12AABeuVXMzMzve93sAAD66rOZmZkkkqgAAPeVXOSTskklUAABmvOKrnMzMzJJmPNa1r5zgAAFe1Xvv33330kky7AAA5vfPvfvvvvszMlUAABlecu+XmZmSSTVUAABlK7Veea88vjVV5rNa/fue+8zuZJAAAAASSSSQAAAAAAAAkkkkgaAIAAAlfv3n66uvfTfP37nPdea81r3z77768zMySSeVQADQ3rWrqruSSSSTyqAAAve7uSSSSTAJzjIrtFUXatVd3dt21VVSdu+93d3czMzaCHOWtVVaSF3VtWqKrVPbvvft3d33ve8XvNtqlaqlqEFtbVF6ve/ffffSSTVVm9gABvlVzmZmZPZJVUBm9gaOb3zmZmZJJNb1QAA+5V3zeZmZJJPta81dgAAfarz2799+++++kn2Zq7AAAqfV+3rX3mt+3788+ffv2zKqsqlVVVVVVUAAkAAAAAAAAJJJJIAAPAHQBKVl/dq/vvufvvvp8zMzJJJVAAAZyq5zMzMkkmqoAAC97u5JJJJKoAADd1V3JJJJJmteauwAN72H3tV7799999JMzLsAADm9/c599999mZJVAAAXvd3JJJJJVAAAZyq5zMzMkklUAABe93ckkkklUAABe93ckkkkma15rOcAAA97+898ver5un79mXMHAAAAAurqSSSTUAQAAAAAACSSSSUAAe0B8PASqumu+Vq5D21CGyQsDgzAh82copqt5e973dzefT99mZkk+zLsAAD72q5z77776SSVQAAGcquczMzJJJVAAAXvd3JJJJJLsAADm985ySSSSVQAALbu5JJJJK1TwAF5qq5zMzMySTNa81dgBvXnmt7+W1Vvt33u7u7mZmXdVoQXW7aVqqqqPd799+++++kklUAABnKrnMzMySSVQAADWXnL4D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arPu/JNXrPZmSSST3uSJq9Xckkh73BpS93ckkgBXElWuAB73g3Wk1yt0AB7wRJq6TW1e6kkh70Muk1eqkknvezJdJq9VUkkACuJqXu7kkkAK4mq1VAAAFcTXTSj4vtPWlrFv3vqSecwzKzM9wAAjQk3JJuQAAEAEDdVdA4CSSSSAAI0AAbBwADVVdb/V6CfYCc17QJm9wEhewSkK+17na+799gAAEaauk1eruSSABl0ms7vvczMyAFcTVaqgAACuJqaV6u5JJAQVxNVqqAAAK4mq1VAWk0AUEaTuk1nXvd3d32ZmPK0Ko2hqipBappWq7Xe7mZmAFcmta/Te29a7rvczMzACuJqLp2lqmk29za2l7Vev8+zJkkkAAAAAkkkzMzAAADhPZJJIAAJJJJIPh6AAoAAAAABv7mJtvnvpPsS+0k2+59hMzMA973OJoWqoADzTXvY01VJqau5JIe97eVtNTVyST3velcbWcvlySSffHOJo1VAAe97nE0aqgAACJNXTd6u5JIAGXSavV3JJAAriay93ckkgBXE190nrxc1ph3DBJqZGkuAEckhkkgIDQACNg4AAJJJJIAAJJJJIAAAAAAAAB1pqJJpqSVJJIAAAVxNVqqAAAIk1dKtJK9buSSGSSXxNVqqkkgAVxNZe7uSSQAriarVUAAAVxNVqqAAAIk1dJq9XckkMkkviarVVJJAAriay93ckkgBXE1M00292Z9V+39vn7v79+SSSSQAAA9A+AAJJO971JIAAAAAAAAkkkkgB9uVV1lSqupKq/M5k39O5gAfXzdXXNc5J2SeySJNdpNTPc++zJk973q4msbavd2AHve9XPV6pUIU01KJDr3um7u7mZnT7m1tSoQlSoxE7Xe/fZ9973vc3r6H0gJKlQOzvfvs9/f39/fgh731wAaWmhpklNNF32+93d3Pe96Ssbet63p6ba1vW9Luu9zMzMAOtNXXyJP1USMkkRJqu33v79+9+/ZeZm7Evs3UzU8qru/vpn3ZmZJJ2akgAAAAAAJJO971JIAAAAAANg4GpJJJ2AB2RNrSbb801uS6npNwAAA0k126TV83VgdAAjTV00t3u7kkkANJNZ9201Xa5zuZmfZJJK4mq1VAAHAM32k13XLkhAAz7tpq+1zneySSAVxNS93ckkgBXE1L3dgB73vaaarial7qwIpADVcTU393i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1SKfwFoRjLQWgrSlYQ1U8d3d3d5716VOlTQu7Q2yyC4VGSqsFpU1U8d3d3d5716gPGxlW20g6UrVU0TFK8d3d3d5718yVH8ojQtC7rkNs0ojiIwhWhaVUZCwWEWVK1JWqpK8d3d3d5718gi8BgCoIAT0AiQA373ve97PXCAG1gMgSSazMzMy5cIEDcYAqDANtqorlTVJlTJQakMi0LERgtRGCwS6/nd3d3nvXzETxLUhVyplVPHd3d3ee9fJROVNKVlTKp7LamQX72Reai9aoojyHkPdJPvn97/f39t0AABbbbUOAAAAC23mSS22noAW2220AAH7JImZMyZuSZkyf2So0KTBZRaCykDAjAIgESSSS223vveuSQISegESF2mpKvXULkC0LUqk0LURsohYLQoYLVB7O7u7vPe99YieJaSleapoLQtC0LQWhaRGhIBMzMz3r72BCQmyCAQhphACZmZmZczAAJsggQCeIEBhCSMgSZC1CyFgsiNoSqyphVMqYFVd3d3d6+9VO70SF/ILCk7TJSnAWUIwWqCwLSI2FGhbQqyFoWVI0LIjSDRPF3d3d3nvXzJUulPZL0KgeiqaJomUGKGpDUVZSrMhYLQtCwLCakd3d3d693mQquVNKVqppQu42wULgLKqtCylK7u7u717vKpXiWRDlUrVKYpWVMqeO7u7u89yp0TSWQuk/nVBdIjIWhYLSmVMqYqm9O7u7u890lPSXpe+e++aqSVl1KlSpU5rMwzEAAVVVS2222gAAAAAAAC2222gAASZJknMgIBAyQCeAJ3ve/u99718QCbIMgQIazMzMy5cISEDcjAJA8QCMAjAJv3ve972euiDuAW22/e26Ib9AJ6ATnve971z1u4eYeIBOc973vevrdkPQCOQBEwBe/Oc5zj4qIGREQFNtttNUQbbbb23RBtttvbdZAF86gwBUOySSvblVKqpOa+++598gACqqqoFttoAAAAAAAAttttoAAPMkiSSTPn79++/fttupkAVIwDWZmZmXLrIAqDAJmYmm222mqHIFNttvbVEEpJJLaVEEpJJLaVEDgCm222mqIHTbbbTcmT4ApyZPgCjJJ2Sb8nOz9kyTJJkn7937u7vq222gAAAAAAAC2222gAAXJJj4AAAZmSZ5kk+ZkkwLwBMBEQRm2b5zlJKiBwBTbbbTVETNZmZmYlypmlVVLlSwAALlSwDe973MFEg4Askkkk1RA6bbbaaqBzBTbbb21RBKSSS2lRBpZACLyEAGfvmZMkySZ7798ev1W21DgAAAAAAABbbbbQAAAAAAmTJJk+ZJPkwIznOc5yklRA4AptttpqiB022201yZPgCnJk84HhTkyfAFOb8wJgCm222mqIHTbbbTVEEpJJLaVEG2229t0Q+fCQhA2kkgEJuAdhJuST3JJ7+3zd31bbbdAAAAAAAALbbbfcklcAAAAAAfskiZMzJJPMAkAAg1q2tayklRA4AptttpqiB022201QDnlQBJNW5znOc5vioglJJJLaiCUkkktogcAU2223tkDptttobkyfACpPvyZwHpUyb33x5PefJkySZ78mZmZkkn7m/dultttAAAAAAAAFttttAAAAAADJJkn79+/fv34XXknoBv3ve9719dEyAKx1mZmZly6yEnz58knN3d3duuTJ8AU5Ml44ClEDgCm222mqIHTbbbTVEOQpttvO5dEG2229t0QeEgBPkAYQCE5sPfQAAAAAC2222gAAAAAAAVQAAGqqqquc5znOKupUypJrMzMzHXJk3m7u7utcmT4ApyZPgCnJDNZmZmZcusFILDyQNSMA373ve96+cmTfs7u7u761yZPgCnJk+AKcmTznzzJJmZM/Z59HnvoAAAAABbbbbQAAAAAAABbbbbfMkiZMkz5+/fs5zve6IE4As222nuiBUkkk01RHCQ5u7u7t1yZPgCnMz4ApyZP7JJzd3d3WuTJvN3d3da5MnwBTkyfAVF1KmTU83d++qvnmvcl6JevOG9+b9OPha3bFsmSaxut51pTa+pvajQQRMAESEBEwLbIjMkq0LUFoWIWwWhYLqFzlF044ZoXYWwXO+oXP9H+330hZEYLsFwI5guQjQsVVyFxC5BaRGqLSVYFiVbJJknzJJM2ZJ73v3+/t/v4AAAAAAAAAAW2220AAAAAAW2220AAAAAAW2220AAAAAAAAAAW2220AAAAAAW2220AAHMkgD0AAAAAAttttoAAAAAAAAAAttttoAAAAAAttttoAAAAAAttttoAAAAAAAAAAttttoAAAAAAttttoAAAAAAAAAAttttoAAAAAAFttttABbbbbQAAAAABbbbbQAAAAH/pAXbbbboAAAAAAAAABbbbbQAAAAABbbbbQHmSQPoAAAAAAAAttttoAAAAAAAAAA9uSTPkySTPmSS0L3D1D7DuHcK8C9BYI9Qz7DsF5RHkL5D3DupMkPvl/e+0AAAAABbbbbQAAAAAAAAACZJM7kk/yMmT/IyTMkkmCwkJ3vfne9971w8JEGKovCDpASYiAtznOc5x8VEDptttpqiCUkkltKpk+AKcmT4ApyZNySc3d3d1rhA6bbbaaqGTEU2229tUQSkkktpUQaxABFpICIAzuANQBrCvpa3tJJJOJJu7u7u7oAABbbbbQAAADmSQB6AAASSSSzACgCAjEATAQEa1bWtZSSogcAU22201RA6bbbaaqHAEzJFNttvbVRBKSS3re6IZIOzbbe3uiBwBSQVeTI4BV5Mny226pzM7PmcBe9t1Azd6/f31hCB+ZCQNoQCfd59zue0AAW2220AAAAAAAttt99W22gABJJJTAGMYxfCSSogcAU22201UAyb83mZmY4alSwAEXUqWqqiypNSpIkkktpUQOAKbbbaaogdNtttNUZPgCnJk+AKcmz5JPZftySbMk2X73vn79uuZJAHoFttttAAAAAAAAFttttAAAD7kk8+eeeeAmScmT5uQJbbbaaogdNtttNUQSkkktpUQSgKcmT4ApyZNySc3d0q8mJ8kvN5mZmOGpUsADoalSwBii6lT1n778mSTOTzvB76AAFttttAAAAAAAAAAAAAAZJPfffff34vJk3JJwCryZHA3da5MnwBTkzZ/fJpIb973ve9fXWEFIKQUgpBSCkFIKQ+a0Q3mZmdy5dYQUgpBSCkFIKQUgpBZCazMzMy5dYQUlsbvRXppbS2ltLaWxeO7u7u9fXWEFIKQUgpBSCkFIKQUhrMzMzLl1hBSCkFIKQUgpBfMmkgpDfve973r66wgpBSCkFIKQUgpBSCkOb+EAnzWZmZ+7lttoBbbbbQAAAAAAAAAAAAAfIBX79+/fv223WEFIKQUgpBSCkFIKQUhpgGZmZmXM1hBYedJBSCkFIKQUgpBZDfve973r66wgpBSCkFIKQUgpBSCkNZmZmZcusIKQUgpBSCwH2gJpkFIKQ373ve96+usIKQUgpBSCkFIKQUgpDWZmZmXLrCCkFIKQUgpBSCkFIKQ0wDMzMzLmaye05k2TZNk2TZNk2TanX8973vevrrCCkFIKQUgpBSCkFIKQ1mZmZly6wgpBSCkFkfagaSCkFIKQ6c973Pe9fXWEFIKQVNk2TZNk2TZOeIW0PJJ50PfVugAAAAAAAFu5JAG7oAPckhwAAAAfskn3JJ9ySfv3e/vxbdYQUgpBSCkFIKQUgpBfMN+1APe973s9mqQUgpBSCkFIKQUgpBZDWZlt7e6pBSCkFIKQUgpBSCkFIZvMzMy53WEFIKQWHmaSCkFIKQUgpDeZnve9fXWEFIKQUgpBSCkFIKQUhrMzMzLl1hBSCkFIKQUgpBYD7Umkhv2oB73ve9fZqkFIKQUgpBSCkFIKQWQ1mZmZly6wgpBSCkFIKQUgoQUhrMzMzLlyl4zs9NLaW0tpbS2ltLx3d3vevrrCCkFIKQUgpBSCkFILIa335b3rAn5CHM1CBNjGAjBJefb7v4tAAAAAAAAFttttAAAABbbbbbbbWAfPnz5z5bbdYQUgpBSCkFILJ50kFIKQ3724B73vevs11Nk2TZNk2TZNk2TanP2ZmZly6wgpBSCkFIKQUgpBSCkNZmZmZcusgKeYaSCkFIKQUgpBSCkN+973vevrrCCkFIKQUgpBSCkFIKQzbmZmZcuQDxi2JsW0tpbLt6aWxNi2Ib97cA973vX2a6QUgpBSCkFILIRZBSCyGszMzMuXWEFILIRZBSCkFILIRZBYGszMzMuXXvQNJBSCkFIKQUgpBSCkN+973vevrrCCkFIKQUgpBSCkFJPnyZPfv0+hboAAAAAAAAAAAAAVVUAABVe1JOc5znFF1kqXcqXctpbOz00tpbS2ltLx3d7FXd719mvxBSCkFIKQUgpBSCkFkMIG3MzMy5abwgpBSCkFIKQUgpBZH2oG+Pve972eusIKQUgpBSCkFIKQUgpDWZmZmXLrCNk2TZNk2TZNk2TZOfv37MzLl1hBSCkF8yaSCkFIKQUgpDfvbgGZmdy6/EFIKQUgpBSCkFIKQWQ9vMzMy53WEFIKQUgpBSCkFh50kFIbzMzM7ndUgpBSCkFIKQUgpBSCkNW229vdUgpBSCkFIKQUgpBSHz5Mnx9n1/bu6tAAAAAAAAAAAAACqqoAACq8qSc5znOKrrJUu6kv2pNJBSCkFIKQUgpD7AOe9732Ae/evs19IKQUgpBSCkFIKQUhw1qQ+TmZmZ9ty6wgoQUgpBSCzzDSQUgpDfve973r66wgpBSCkFIKQUgpBSCkNZmZmZcusIKQUgpBSCkFIKQUgpDWZmZmXLrJH2oGkgpBSCkFIKQUgpDfve98gHvevs19IKQUgpBSCkFIKQUgsh8gG8zMz7ly6wgpBSCkFIL5hpIKQUgpD7z3ve999ffefk2TZNk2TZNk2TZNkazMzMy5dYQUgpBSCkFCRSCkFILDzOd9903ne5mumgCMAiARgjYi9QsFwFgjBYLBeoXIF1BaouBdBdBc+eev557+fNxC8C6hchddAvkLsLuFkLQvaepVXqGQvcNKjwLFSZEekXIfZkj5HfO+/v1oAAAAAAAAAA5Lbbf1oAAfckgPAAAW2220AAAAAAW2220AAAAAAAAAAW2220AAAAAAW2220AAAAABMkAAAALbbbaAAAAAAAAAAOS2239aAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAAAAAAOS2239aAAAAAALbbbaAAAAAtttvq222gAAAAAAAAAC2222gAAD5kkAKALbbbaAAAAAAAAAALbbbaAAAAAAAfckgPAAHJczJM8ySfJB8hguoWQvkOgLgLyH2HyHwF1DKWC9w0O6SMkn6ZJmPf3vvv6gAAAAC2222gAAAAAVAAAVAAAVUqSe1JOXznPvpJJbRstoptC2ktijYk2pLZsKbC2hGyKbVJbNlbUNkrajZDY2VtKtk2NptbVWxFsbUbBsG0NthbJbVbVtLZNiZqmyVtW1DZsK2bFNpbKFtVtA2SNo2JmKzJNpTaNkltJs2NtktibNi22DaG1S2bG0Nlmq2KZpRtWbY2k2W1C2rYW1TYjZtVNto2E2bKbFtVbLaGyG1K2toLYjMGyW1JsGZLaEbU2UtgtkWwbVsJtDbZFrStg2bTYraTattlWxNZGy2S22UbJNg2pbUTYhsLa2RbBNrWk2oraFsM1W1sNkla1tG1UtoTZGxsbK2rZtRsraRshtDZLZNosppGzaobBNtkraTYVsbC2C2bFWw2hbLZVNoTYLak2FbNpNlDaqGzaNobGYWyqbKTbMDYWylWyGxNqNlVbBtStg2k2qmw2hWxS2hG1DYJsqymUrZsJNSYVbINqLZVpMg0WUbBsRW1C0WqpsQtJqTKbSZTFNRJlMKMpkpbVBsq0mKWFosK0WrCWS0jaJslVpNA0mqZTUDUmUmwLDUtqtojYTYGaGUwGU1JZqmpMpkWRNFkqbW1Q2ki0NYDSZTapiDKaKMlktFiWiwkttraRosEapotFktFosllFlMIMpoGU0DSYhsSmwtgtmZmqQ1TIWiyVWqZVWFgmEtCtFlBosJaLItZmlVWas2yJWSyiwsiaLKYWiwtRZTJZFpFlMplMplMplNA1JlNJlNJooymgaTRRlNVLGkDYSm0mU1TKaoWwkZTFNSYUyTKaTUmU0DSZTKagtJhTSaTSakymoLRYWi1RtQq2oVksRak1imFNJkplMqDSZCMphRpMpMpimpNSZTUmk1JlMBpNQMpkDKaTKaTSYFoslkslTJYjYlbFU22ZrW2VmqGU0UNkG1KNpTYUbIsLKlmENaUymqTSYpjVJksEmJaLRaKtFhMlqlNFksloRksS0WgNJqVbNbbaSG0bNtmwjSapLSaKZTUGUyoNFqLRYUrJYlktBDSYplMpMpiBlMppNA0k1JpMpMUxLJaLJYI0WJZLVVZLItFiWS0Wi0ZptKNqKbJZbbNNmbTaa2bNGmMpmpNillNJsCmiwtFilLRYoWSyhpMFLKZQWSaBpMlosSxLJaLEtFokyTQMplNJimKaTUmFGUympMk0mpNJoTJaJaLJbbDbW1qtmtsI2UNqDYptsVts2xhGLEVRgsBgxIsEVVBGOWW2yW221bG2bRTKYhNhVGUyhLSaKGU1FVpNSbJMU1JZTQGk0DSZSaTSZTSkaTKaTIGUyTSZTYg0mA1JkmpNJlMBpNJpNQaTSZJgNJkAFVYRFUFUVYIxGIxIszS2VWYg2qW0mzZsMikVVCRGQUgsWKKAsFAzGym221bbJm2zVDak2qbSZTKTKYpMplMM2IaTEhWk1IlpMSRiWVVktKoyWBilJIQFUigQURVQWKREDvr73vv4E4kFIKQUgpBSCkFIKmyU5qi2iWy2ibIbC2W2202bJbKbFA2VRslTRYImyKVZLRZLUoWU0KGk0AaTVIymolsk1JimSaVsiyQUgLAm/e9732Ae9ns18IKQUgpBSCkFIKQUgshrMzMzLl1hDZNk2jfzlcybJsmybJ6hz3ve999fXWEFIKQUgpBSCkFIKQUh83mZmfcuXWEFIKQUgpBSCkFILPM0kN+973vevrrCCkFIKQUgpBSCkFIKQ1mZmfYBmXP3PE2TZNk2TZNk2TZNqNZmZmZcusIKQWTzpIKQUgpBSCkFIb9mZmdzuqQUgpBSCkFIKQUgpBSHt5mZmXO6wgpBSDk2TZNo2fzTmTZP3z36+Q5C98/v7+tugAAAALbbbaAAAAAAWskgF6oAAxdK5UkztST2pJ3ve8zMTWSmybJsmybJsmybJsnkG7hmZ9/QDLma4QUgpBSCkFIKQUgpBZD5vLb8vb3VILDzpIKQUgpBSCkFIKQ3mZmZ3O6pBSCkFIKQUgpBSCkFIavszMy595+TZNk2TZNo385HMmybIb973ve9fXWEFIKQUgpBSCkFIKQUh8gG8zMz7+gGXM1wgpBSChBQgjJJ83mZmfcuXWTzNJBSCkFIKQUgpBSCkN+973vevrrCCkFIKQUgpBSCkFIKQ1mZmZly6wgpBSCkFkfagaSCkFILmT75+3z77/ff7+/qAAAAAAAAAAABbbbatoAKgAAKr7Uk3Ukv33fvqq6yVLsgpBSCkFIKQUgpBSGszMzP3yH39+50mybJsnnOJsmybIpBfIHPe9719nrrCCkFIKQUgpBSCkFIKQ1mZmZly6wgpBSCkFIKQUgpBSCkNZmZmZcusIKQUgsPOkgpBSCkFIKQ373ve96+usIKQUgpBSCkFIKQUgpDWZmZmdgFzNbIKQUgpBSCkFILAfak0yG/e973vX11hBSCkFIKQUgpBSCkFIazMzMy5f0A6/JsmybJsmybJsmybJreZvMzLl1hBSCzzDSQUgpBSCkFIKQ3fnCDv3vnve9bbbbbbbbbaAAAAAAAAIAAIAALKkQAAFVupJ777757b3twgpBSCkFIKQUgpBSCkNZmZmZ2AZc2QUgpBSCkFILI+1A0kFkN+973ve93MIKQUgpBSCkFIKQUgpBIazMzMzO4ECPe973vf2UgvmGkgpBSCkFIKQUgpD3Pe973vfswgpBSCkFIKQUgpBSCkNZmZmZ2AZc2QUgpBSCkFh5mkgpBSCyG/e973ve7mE2TZNk2TZNk2TZNk5+/ZmZmdzCCkFIKQUgpBSCkFILA1mZmZmdz3pNJBSCkFIKQUgpBSCkOd1AJo+e97773sttttve97220AAAAAAAFVAABAABVVVVVXlSTnOc59ttusIKQUgpBSCkFIKQUgpDWZmZmXLhDaSRZ5mkgpBSCkFIb973ve9fZAM3ogpBSCkFIKQUgpBSCyGszMzMuVgGsIKQ2ltRtLaW0tpbHb00vHs7u7u9lusIKQUgpBSChIpBSCkFIazMzMy5dYQUgpBSCkFIKQUgpBSGszMzMuXWEFILAU8w0kFIKQUgpBSG/e973vX11hBSCkFIKQUgpBSCkFIazMzMy5+h+64mybJsmybJsm0/m5kFkN+973vevrrCCkFIKQUgpBZUu5Uu5Uu5U3q95mZmYqqqgAAKAAAAAAAAtttqPltttoAAHnnnnngObJsmybJsmybJsmybJz9+zMzLl1hBYD7UDSQUgpBSCkFIKQ373ve96+usIKQUgpBSCkFIKQUgpDWZmZmXLkA2kFIKQUgpBSCzzNJBSCyG/e973vX11ibJsmybJsmybJsmyc/ZmZmXLrCCkFIKQUgpBSCkFIKQ1mZmZly6yR9qBpIKQUgpBSCkFIKQ373ve96+usIKQUgpBSCkFIKQUgpDMzMzO5msIKS2ltLaW3Y9NLaW0tpeO7u7uvrkA2kFIKQUgpBSCkFILMnz5mTzJJ5kk883d3bdAAAAAAAAttttoAFtttq222skj4AADcknuSTzIH1+/fuZnWkFIKQUgpBSCkFIKQWGZmZmZcZ72pPe973ve75IW2229JyZPgCvkyAFfOT5JAFpsAWIkgJCabbbaaoZASBTbbb21UyfAFOTJz79u+d8/b+3d2gAAAmSAAAAFttttAAttttW222gAAfcknnzGMYSSVEEpJJLaTgCxBNNtttNUQSApyZPgCnJk+AKcmT4ApuSTsyfObu7u61yZPgCnJk+AKcmT4/ZJPvej8AAAAAAAALbbbaAAALbbbaAABzJJ5553zwHJk+AKbkk7Mnzm7u7utcmTk4AHJk+AKcmT4ApyZOcALuSTkyfNnd3d3d2/JkcADkyfu9HgHMk9/fZ9PH4AAAAAAAAW221DgAABbbbbQAAPMkjJJ7Mk5777776EyAsBazbbbSTgCxBNrNtttpUQVQAcmTnAA5MnOAByZOcADcknZk+d7u7u7unMk+/O9BQ5IKpJJJJKiCb2qZ0tUlraLYtYxk0EAFtAtC5C4iOtRV1CwlWRe+QvIWhdkXbgL6FiI5C48BK5CxSTQsINCNCwWlBfcRcUtURoWhaFiqjQtTMmTL8+28T948qrbaAAAAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAAAAAALbbbaA/wANAAAFttttAAAAXJJj4ABbbbbQAAC2222gAAAAC2222gAAAAAC2222gAAAAAAAAAD9ckmXJJnzJJnyZkz5kkzkO4cojuH2HIHlFaFgWhYLQtC+Q+Q+Q9w9hHqH2HqHyHUOwvkO4dw+Q6gvIWUtIjIR318+e/ffQAAAAttttoAFttttAAAAAAFttttvgP4MFWKIKkFBRGCTWbaW2ZbGaZjaJrVmKZO973ve+963JPQIARQCAAoAsItGqlrW2tDNNrdpynMl785znOc4k4AsQTazbbbaVEFUkkkklyZOcADkyc4AHJk5wANySdmT53u7u7u6cmTnAA5MnOAByZPPMkn375kkC38AAAALbbbaABbbbbQAAAAAAAH7JJuSTzJJ9yBbWr6xpve3EFUkkkt7cAMgm1m223vbmTnAFqZOcADmZzgAcmTnAA3JJ2ZPne7u7u7pyZOcADkyc4AHJk5q+++e7+33bdAAAALbbbaAAAAAAAALbbfuSS2ngD9+/fv378Dkyc4AG5JOzJ873d3d3dOTJzgAcmTnAA5MnOAByZOcADcknZk+d7u7u7unJk5wAOTDu93dtttvYBsguQCeAJ+1AJogT9+/vf7+/n9/AAAAFtttQ4AAAAAAAAW2220APcknvvvvvvoOTJzgAfVJNype95mZmIalTN7VVS6khdVO72dtttvuSTsmzJPkzn366GwcmTnAAMqSblS97VVQ1KmtAAYrqty6u7ivecu7bbbewDnFVVVVVdPgCfJu/c3mZmYqgAAKqqqgAAKoAAAAAAALfe973qCqrqpJypJdSS+c55ziq73d3d2qqqrvdttttvoBziqqqqquuczMzMzLd7VVVVVV3u22223e1VVVVVdneXVttvf0A3tVVVVVXV5d22226gG1VVVVVU3u22223IBziqqqqquuczMzMzLd7VVVVVV3u22223e1VVVVVXvOXdtvbb2Ac4qqqqqrrp8ckCE8AVdVVSVJJcqSt9+5z77775VAAAVVULbbbaAAAAAAAALbbbaAH7JJ/SSSSfPff379+zMt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXvOXdtttvYBziqqqqquucu7bbbd7VVVVVV4c5bbf1tu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq73bbe973e1VVVVVbzlttt73e1VVVVVd+AJ6QCVVypKv6pJvn333331SQv5VAAAVVQAAAAAAC2222gAAAAH7JJuST3JJ9gGgITe/3P379mZbvaqqqqqvecu7bbbcgHOKqqqqq65zMzMzMt3tVVVFN7ttttt2bGKqqrvdttttu9qqqqqq73bbbbbvaqqqqqvecu7bbbcgHOKqqqqq65zMzMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd9+fM+98BMZJL+/n97+1/BbbbUOAAAAAAAAFttttAFVVVVVVVbqSc5znPeKrvd3d3dqqqr3nLu22230A5xVVVVVXXOZmZmZlu9qqqqqq73bbbbbvaqqqqqu92222272qrzWlVVXvz5d22229gHOKqqqqq65y7ttttyAc4qqqqqrrnMzMzMy3e1VVVVVd7ttttt3tVVVXCBrSrzmZmZltu9qqqqqq/fvgCX9+zefv2Zltve2220AAAAAAAAW2220AAABMkC27IH37939+/bbb2Ac4qqqqqrrnLu22230A5xVVVVVXXOZmZbe93tVVVVVXOctttve72qqqqqrvfe973ve93tVVVVVXe+973ve97vaqqqqqu9973tttuQDnFVVVVVdc5mZmZmW62qqoK95y7tttt7AOcVVVVVV1zl3bbbbvaqqqqqvXISZ5nm+bu7uhbbbbQAAAAAAABbbbbQAAAADckmdySe5JPmST57779993dt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVX9zlvLbbbvaqqqqqu92222272qqqqqr+OY2/P2r+pr7c+079PwC0LYLQtC7C5C4i0L3yFwLBeoXILiFgvfHAt657+/O/nz3oXuFyF125Be1LtFpUaFoRkSZF3C4SOQshGKukRoWRGC4SrQtRGhairuHFLpCyFgrQukF5C4F1C6yKrkLJFGhZSTQjlRc4hcoW5CwLQLgXKI4paFlIxFshZFqi1SrhJOQsiwWQuQtSLQsiOBYLiF8hdUpOgsi0qOoXULkzJn75+nvnfL7+tAAAAAAAAAAFttttAAAAAC2222gAAOS2239aAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAAAAAAOS2239aAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAAAAAAOS2239aA/wANAAAFttttAAAAAAFttttAHckgH4AAAAAAAFttttAAAAAAFttttAFttttAAAAAAAPuSTuSSzJJlmZkmXJJ1DhVLpC4C9QwXoI4F6hdAvIdQ9e4eCXaL2LMzmZkmfMySZJ7kk5999+v3tAAAD3JIcAAAW2220AAAAAAAAW9ySefNfL9+223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u222230A5xVVVVVXXOZmW297vaqqqqquc5bbbe93tVVVVVXe+973ve97vaqqqqqu9972lttu9qqqqqq73be973vcgHOKqqqqq6/c+NvLbe93tVVVVVX7+7YATe+wDh28++bvu6dySAfgAAAAAttttoAAAAAAAAt8ySbkk+5JOfv3d993dO9+fFVVVVX9zlvLbbbvaiiMV/c5by29tu9qqqqqq/uct5bbbcgHOKqqqqq678+ZnMzMy3e1VVVVVf3OW8tttu9qqqqqq/uct5bbbd7VVVVVV/c5by22272qqqqqr+5y3lttt3tVVVVVX9zlvLbbbkA5xVVVVVXXfnN/bz9m/2Z+uW222222gFySPgAAC2222gAAAAAAAAeZA+v379+/bbbvaqqqqqv7nLeW223e1VVVVVf3OW8tttu9qqrhA1pVVe/PmZzMy23e8IGtKqqqqvfnzM5mZbbvaqqqqqv7nLeW223IBziqqqqquu/PmZzMzMt3tVVVVVX8QOct5bbbd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXvfs+OgAAAAAAALbbbaAAAAAAqqqqq+1JF7Kk73vvqgb3d3d3d3aqq3nLbbb3u9qqqqqq733ttttuQDnFVVVVVdc5mZmZmW72qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqi73bbbbbrYjFVXe7yAW235bd7VVVVVVd7ttt7bd7VVVVVV3u22223IBziqqqt3d3er89v3MzM7iqqqqqqqAAAAAAAAAAAIAACqqqqupUk5znPOcVXe7u7tVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVu7u7vs23O1JOVrb68VQAAFVVUttttAAAAAAAVVVAAAVVVAC6knrznPeKrvaqqqqrzWucttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXe73ve973u9qqqqqq3Zy222/taVVVVVV13ve973ve72qqqqqrvfe973ve93tVVVVVXe+22223IBziqqqqquuczMzMzLd7VVVVVV+/X7APv22/f3622229gFaAC2222gAAAAAAAAAAAB+yQyAfYBr9r9+/fszLd7UVVVm92229tu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdttttu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq73bbbbbveEDWlVVVVXnMzMzLbd7VVVVVV3u22223e1VVVVVeZn34/d5mZboAAAttttoAAAAAAAAAABbbbb9+/fv379ttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdttttu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq733ve973vd7VVVVVVvOW223vd7VVVVVV3vve973ve72qqqqqrvdLbbbbkA5xVVVVVXRAn8AAIwCIARgEQCfPnve973u973ve97620AJkgAAAAAFttttAAAAAAeZIZAIH7X379+5md7vaqqqqqu9973ve973e1VVVVVd7y222272qqqqqrvdttttu9qqqqqq73bbbbb6Ac4qqKIzXOZmZmZlu9oqqqqrvdttttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdttttuQDnFXRA1pVVdEDWl1eeAlblSSvOe8mufeffffAAACqqqqqoAAAAAttttoAAAAAD3JJ3JJ7777999C72q4QNaVVXRA1peczMzMtt3tVwga0qqqrzmZmZltu9qqqqqq73bbbbbvaqqqqqv7nLeW223IB2AfPiqqqqqut/PmZ8zMzLd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223IBziqqqqqunpv58+/X793x3VUvwWC9oXfnR7C5wi9hZC9BYke/IRwLyGqRTxS6CP0PULhS7UjkMUFxSxIyLUWyFyFlIviP0O4fYfYeIfIGnADgC8AWgCYAUAKAMYxjGEkkgALbbbaAAAAAAeZJFvbbbQAAAAAAAAABbbbbQAA+5JAeAAAAAAAttttW222gAAAAW1kkA/AAAAAAFttttAAAAAAAHMkgD0ALbbbaAAAAAALbbbaAAAD5kkAKAAAAAttttoAAAAAAABMkAAW2220AAAAAAW2220AAD3JIcAJkgAW2220AAAAAAAAAAW2220C5JHwAAAABbbbbQAAAAAAAAB7kkOC2222gP8ADQAAAAAABbbbbQAAB+ySDoABbbbbQAAAAABbbbbQAAAAAAAAABbbbbQAAAAABzJJzIch9h6h9h9h9h1DhIvsPsPsPsPsPsPIchoeiC9QyEeBch6ROofIfIeoeoHUPsPQXyHkL3QjKWKLuFoRz+ILqGCk599X3fattttugAAAAAAAAAAAAAKqAAZKqpK73ve96uLkkqqrzy7u7u7VVVdH8BkD58973ve963e1VVVVVd22297272qqqqqrrdtttvbvaqqqqqu9222225AOcVVVVVV1zmZmZmZbvaqqqqqv7nLeW22/YBvaqqqqqurxt5bbb2Ab2qqqqqrrd1bbbbrSqqqqqurbbbVypJrdy5cuTW/fPakm8zMw7gAACu6kgH4AAAAAAAAAAAAAtttv7JJuSTzJJz33vvvpp2ZOcAo7MnOAUdyd+fPknegUdmTZkne7u7utNySfZk+d7u7u607MnOAUdmTnAKOzJzgFHZk5wCjsyc+6+/fN+7uroAAAAABbbbbQAAAAAAABAALqSc5znPeAruVNaVVFdyprSoo7MnsyTvT6KNySfZk+XPv3d+7utOzJzgFHZk+Aejsyc4BR2p5dTSq96mpuVJd1dU7VUE1KnuSSSZM58yZMzN+7u+7rQAAAAAC2222gAAAAAAAC222puSTPuSS237bu7dySdmT5vd3d3Wo7MnOAVeTI4BV5kjgFHZk5wCjsyc4BR2ZOcAo3JJ9mT53u7u7rTsyc4W29tuyH7AkhAPQCMhACfPnvffe9ngAAAAAAAAAAAAW2220AC0ANVJOc5zznAV3KmtKqiu5U1pVWjsyc4BR2ZOcAo7MnOAUdmTnAKOzJzgFHZk5wCixBVJJJbSViDTgCMzAEcgCM55zXOJ8AAAAAAAAAAAABbbbbQALd73vd4AxAHACIjVW1rWkmk4AuQTcvd7u7ujsyc4BR2ZOcAo7MnOBUDUqO9qqoalTWgABXKknkqXve7u7rTuSc4BR2Sc4BR2ZHe88ySd70PaAAtv7JJ78999W0AAAAAAAAW2220AAA9ySe5JP2STckkn9JCLK6SXOcSsBwgJLWbbb20rEFUkklsdmTnAKOzJzgFHZk5wCiqALEEq90kklvbgC5BNrNttppWIK4BR2ZOcAo7Mnfv3rff6Zkzy+f39/e7v8AAFtttmSWgAAAAAAAC222ocBVVVVX6SSvpJKuSSUAAfffLKksQTUpJJbSVQA4AuQTV7ttttJWIK4BR2ZOcAo7MnOAUdmTnAKOzJzgFHZk5wBbuSTZk+fO93d3d21Ml710KAAAAAAAAAW2220AC2222gAAGySZ7777777q3Zk5wBamTnAKO5nOAUbkkuQTi9223pNK0DICYJIC1m2200rQMgJgkgLWbbbTStAyAmCSAtZtttO3YefEBDTogc573ve9fW5AOSLHe8zd3WnZvzJ8+Z79+7u+bt0AAAAAAAABbbbbQALbbbaAAAbJJncknySSEa1rWNabaVhzBMxazbbe2lYcwTMWs223tpWHMEzFrNtt7aTgC5BNrNttppWmTnAKOzJzgFHZk5wCjswqkkktpJwBcgm1m2200rEGuQBHACLanZNa3pPnCy0WxkUqlW9XSM6M2zecVO397vubfud+/Nz981tiwCIJAiJAIjAWNBaMSM0LLMmaYL9+9ffXrnznzCXzK9hb2FjpFm2C22C53C4i1CyI+KWUtEWhchuBapHAWhairyGCLiFpVWgtQWCwLQtCwXQWC5CylqCyiwL4pcoLiFkRgWC0LIWqKZFhEtC0FoWRdQtSsmcmSTOTJJnMmTMufOd9vqgAC2222gAAAAAC2222gAAAAAAAAAC2222gAAAAAAAAADkttt/WgAAAAAC2222gAAAAB+ySDq2222gH7JIO22220AAAAAAFttttAAAAAAFttttAAAAAAAAAAFttttAAAAAAAAAAHJbbb+tAAAAAAFttttAAAAAAFttttAAAAAAAAAAFttttAAAAAAFttttAAAAAAAAAAFttttAf4AGgAAAAAADkttt/WgAAAAAC2222gAAAAAC2222gAAAAAAAAAC2222gAAAAACzJJiGgdhdhe4YLqHQXgWBfIfIe4L6FlKtCxJM+SSZ8kkmf4mZM7v549u226AAAAAAAAW2220AAAAAAD7kk2STPMGC8h5DlT+mj589+/fv5+/fPn39jaqLJCRSQk+ENASSe+fPe97193uyGtd70OgbbqTe1VIK7lTWlV6BlSTyVL70FW9mTnLbbtHck5wCjsyc4BR2ZOcAo7Min7tySc9/fvz9VtoAAHckgH4AAAAtttqHAAAAAAAe5JPMknuST5kk3JJy9tt3dNySfZk+d7u7u607MnOAUdmTnAKOzJzgFHZk5wCjsyfcknegtbSTgC5BOL3bbek0rQOYLWbbb20rGTnAKOzJ19+b+85JJM+/vN3dNAAAAAFttttAAttttoAAAAAAGySV9UkoAA+++XcqeVJN7VXor9Uk8lT559+7u7vrTsyeTvQ/KOzJzgFHZk5wCjsyc4F9tu5JPsyfN+/d3d1tvZk5y20o7MnOAUdmS/skn36+n5QAAAEyQAW2220AC2222gAAAAAAbMyZJ7777777u6dyTnAKNySfZJ873d3d1p2ZOcAo7MnOAUdmTnAKOzJzgFG5JPsyfO93d3dadmTnAKOzJzgFHZkv7ckmP37f33fdaAAAAALbbbaAAAAAAACqgAAK+1JN1JOa5zznFV3KmtKqtpJwBcgm1m2200rQHJ4QF785znOLiWw8+ICGnRA4c973vevrdh58QENOiBznve9719buefEBJznve973fW5AOLBkJtZtttNKzkOTRASDxjluc5zfEtwBzHCAmIqaICbYxy3Oc5viViDVVWHAEYMN/t2tAAAAAFtttQ4AAAAAAAAQAAFeVJMkkrypJrvWpIe9zzA3VTN7VUQypJ5Kl72+VJFXxDdVNaADpb2ZOctulHZk5wCjuZzgFHZk5wCjsyc47kkB4O5kveuhVdyp3eSSV9KqV2pJvn33fvu58qqqoFttoFySPgW2220AAAAAAAAW2220e5JO1JPqklVYAGZi7lTWlVRXKknkqX3u7u7rTsyc4BR2ZOcAo7MnOAUdmTnAKOzJzjuSQHg7mTnAKOzJzgFHZk737v3zkkmPO73MxcVVVUAABQAAAAAFUAAAAAAAFtAAVySSV3ve973MxcqSeSpe95mZmOLuVNaUDoG5Ud7X2pIrtDdVNaADoG5J9f0qS/PMz6fffHy7qTy97UO9A3Knd7tt9vvvZk5z2n7JIcHcyc4BR3JPMkneh+UAC2222gAAAfMkgBQAALbbbaAAAA2STPMknySSTP6STPuSS3y3y/39/HZk5wCjsyc4BR2ZOcAo/skn2ZPne7u7utOzJzgFHZk5wCj5kk7MnycAo7MnOBb227Ia1bbb225AOEH9mXgBNpITm2+e/fPdaAC222ocAAAAAAAALbbbaAAAA8ySbJJM+5JPkkme9998993dOzJzgFHZk5wCjsyc4BR2ZOcAo3JJ9mT53u7u7rTsyc4BR2ZOcAo7MnOLbfbb2ZHegr586T3z14+eevnnOXPmCwXQXz5C7gp3BeBYLglyFjhIyRaFiLQ6C+Q6hdQtCyloXaFqKsFpSOQRyF2FoXSI6EXIXKI0FuQtCMQtC6C6UtBcojgXAtC4grQtzJJknJmSZIySe+zvn639QAAttttoAAAAAAAAAAttttoAAAAAAttttoAAAAAAAAAAttttoAAAAAAAAAAttttoAAAA+ZJACi2222gAAAAAC2222gAAAAAAAFttttFttttAAAAAAFttttAAAAAB7kkOAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaAAAAAALbbbaAAAAAAAAAALbbbaAAAAAALbbbaA/wANAAAAAAAFttttAAAAAAAAAAFttttAAAAAAFttttAHmSQPoAAAC2222gAAAAACySTEyFoeIMiO4HcPAvIdAuoYL1DBe4YL5DuHgXsL7VVYkeQ+gv5C+ufu/nz3WgAttttoAAAAAAAAttttoAALbbbf4QCfoAgE8SEWEiqqkUHXe9739O+97M+w8qLIoRQIskUCWZRsa1KNrNtWxtZkZiTajZDYmNNljTbZNjZrNbZV4m5Y2s02ZtmzGKrERGKwRVUVixZIgkigLBBgpGIsREURVGJznve972et3Dz4gIc573ve931uyGtW229tuzJzgFG5JPuZ873d3d1p2ZOcAo7MnOAUdmTnAKOzJzgFG1JPJUvftSS/MzMzriqqqgAAKqB3JIB+AAAAAFttttAAAAe5JPckm5JPlttu7p2ZOcAo7MnOAUdmTnAKOzJzgFG5JPsyfO93d3dadmTnAKOzJzgFHZk5wCjsyc4BR2ZO7559zJPnm7u7boAAAAAAABbbbbQAAAAAAAbJJn9IESAEMSSSXN8ScAXIJtZtttNKxBrQAdA3KjvaqiG5U1oAOgblTWgtvtt7MnOAUbkk+zJ873d3d1p2ZOcAo7mc4BR3MnNkkyT53d3dTd4AAAAAAAAW2220AAAAAAEkkleALwBwAjEAa1jF9abaViCqSSKOzJzgFH9kk+5J8mSfPne7u7utOzJzgFHZk5wCjsyc4BR2ZOcAo7MnOAUbkk+zJ873d3d1p2ZPT555zv0UAAAAAAAAW2220AAAAAAAHmSTZJJM9577777u6dmTnAKOzJzgFHZk5wCjsycA9UySbkk8mTnO/e7u7ra7MnAPVdmTnIBR2ZOAeq7MnAPVMkm5JPJJ++Tvfvnzu7umgAAAAAAAFttttAAAAAAABskkz+kCbgHe973533vXUDa3bbbf3bdbVVVVVV1bbb+7bd8VVVVIDN7ttve1K0BVJJJbSSgDkAYIJq96bbaaViDnAKOzJzgFHZk5wCjsyc4qqKtSTyT6/pUl1NpUkA9++78KqgAAAW222skj4AAAAAAAAW2220SSS1AGoAxADgCt7vve22lYjk8ICY5z3ve97vrdkNattt7bdzIB7Wok5z3ve97fEnAFyCbWbbbTSUAXIJtakkltJWMnOAUdmTnAKOzJzgFHZk1pVUVaknkqX4c85mb57L9DhmCqqgAABbbbbQAAAAAAABbbbbQDQCM5znOW204AuQTazbbaaViCqSSSo7MnOAUdmR3vAVbkk7MnxO8BV3JJ2ZPm93d3dbeTI4BV5mOAUdmR3vAUMkn2ZPl++fPPrwAAAAAW23331bbQAAAAAAAAAB9ySfskn3JJ8/d/ff34HZk5wCjsyc4BR2ZOcAo3JJ9mT53u7u7rTsyc4BR2ZOcAo7MjveAo7Mnvegq3ckn2ZPnem7utOzJxfJ3z68AAAAAFttttAAAAAAAAAAAHmST7kk2STPe+/fffd3Tsyc4BR2ZHe8BRMk7MnznwCjckn2ZPne7u7utOzJzgFHZk5wC28lQfPNqqhKk1Kl6sAADUqa0AAMSsQbq1rZvrWtm5rWZMwBGbAEaIAiYAvcLgXcLqFgvAvPnf3znfnp26haFoXKSrQWQuBZSNC1RfdyFoWhZFoLEuoLlCOQuELgpMFiSapJwI4pGhYhcuSVKku6qSpPJVSi/OD775OwDYHVVQAttttoAAAAAAAAAAttttoAAAAAAttttoAAAAAAAAAAttttoAAAAAAAAAA5Lbbf1oAAAAAAttttoAAAAAAttttoAAAAAAAAAAttttoAAAAAAttttoAAAAAAttttoABbbbbQAAAAAAAAAByW22/rQAAAAABbbbbQAAAAABbbbbQAAAAAAAAABbbbbQAAAAABbbbbQH+ABoAAAAAAAttttoAAAAAAAAAA5Lbbf1oAAAAAAttttoAAAAAAttttoAAAAAA7kkuQLyF8h7h6h6h9h6h4pcgvIfAvQXuHyHUOoH2HkPIdhfYfYcCOBdQ9BfER4F9CyIxFyhHESrkqSVdSSV31OneiqqgAAKqoAAAAAABbbbbQAAAAP379+/fvxbyZOcAAAakm6kdeebVVVlSbkl6tVUHZk5wCjsyc4BR2ZOcAo7MjveAomSdmT5z4BR2ZOcAiu5U991UkupJyc5xXiKqqAAAgAAAO5JAPwAAFttttAAAAA9ySe5JP7JJ8ttt3dOzJzgFHZkd7wFEyTsyfOfAKOzJzgFHZk5wCjsyc4BR2ZHe8BR2ZOcBRXcqe3N7VeoruVN+YecuvdczOZmKoW2220AAAAAAAAAAAAAAD5kk+ZJPPPPPPAOzJzgFHZkd7wC3ckmzJ8+d7u7u7tqZOcAo7MnOAUdyT7PnegtHckd7wFG5AuQTazbbaaViCqSSS2krEGtaznKWtaAFttttAAAAAAAAAAAAAAA7kk5kk887598A7MnOAUdmTnAKOzJzgFG5JPsyfO93d3dadmTnAKOzJzgFHZk5wCjsyc4BR3JP8fO93d3dunZkXvnnPrwAAAAAAAAttttoAAAAAAAA+5JO5JPmSTz553zwDsyc4BR/ZJPsyfO93d3dadmTnAKOzJzgFHZk5wCjsyc4D229mR3oKt2pJ5Kl72qohuVNaADoG5Uud+kkrvP3j8/P7QAAAAAAAttttoAAAAAdySAfgA888888A7mc4BR2ZOcAo7MnOAUdmTnAKOzJzgFH9kk+zJ8ne7u7utOzJzgFHZk5wCjsyc4BR2ZP36bkk9ySe++7ul0AAAAAAAC5JHwAAAAAFAABVVVXlSTkqTnOc4qruVNaVFHZk5wCjckn2ZPne7u7utOzJzgFHZk5wCjsyc4BR2ZOcAo7MnOBfbb2ZHegq3syd+d3z1yF/IWRfIaiThSwLQtQJgsqSZSxKhgRCSEEAIwhA+wD9+7mW+9bbbbaAAAAAAAAAAAAFttttAA+ZD+Ij+RCwWC9+/fv17/fv3z59h2pe9qv0xxdyprSqdA3KmtAB0Dcqa5baUdmTnAKO5nOAUdmTnAKOzJzgFG5JPsyfPv37u7u7o7Me977/BfygtC0LRI1EZkkz5kkz5kkz3vv9/L/f38AAABbbbbQAAAAAAABbbbbQANmSTPuST5JJn7939+/bu6dmTnAKOzJzgFHZk5wCjsyc4BR2ZOcAo3JJ9mT53u7u7rTsyc4BR2ZOcAo7MmtW229tuyFwgQMb6ATQQIDAIwWC1FWhZC2QsiNAIwCAkCEBIBGATve/v3u+9620AAAttttoAFttttAAAABbbbUOAC3kAyAQPEAjJAkn7f79+/e971uyH030eFHZk5wCjckn2ZPne7u7utOyprSodA3KjvaqjdSQNVU1oBUVWIHAFrNttppWIHazbbaaViDNrJJLa3u1yQKYBF9bvq8vdWvnKcuSAIQBFoAIoAhTAEd0d/7aj4ZgmSbe09ZJ529nncvjFqM1eSxixmfZbz+Sco+H4rfrS/SL/PdyT2X+L9nTudfHkrtorGO/XOlraKMdWvlPq+j8P+vx75n65+j+df0/Gvy5/Si0b1y39dLwrXv9n9Wuv8//J+6f51js7Ol7nT8XHL91V/Zr+09mPDx+mA+qQohL29CCT00lCv1XtPa3uvc/H7NeomZi301a30VbOMn03xMkzmb5+q+LSYk1O9GrfXU5zVzU1etY1m5M5nGtWN1V6okmVVbVqLUYxrW81mr50LeIvO6tdVu+zQtXmr4za2bzhYsXzV+6q7nl+u54c50nJur7c1N6dzhZs5d6jp9Jte9YBGL4viJzNazU2vq5OVM2mTG72veN5zWPW1HmIRDdBdQtC9QugvfsF2FoXYXAvUeQuoLoLiLrzuFwLuFwLuFoLQvTQvWcJd99BYFkLsLui486haFyFyFoXULsL3C6QvQXyF46+d8heIXyF1C8hdwvaF8C0LyFkR2FyF1C7hdO/O/ULvkLfOu/IXwLsL3BcC0LqF7heQt8C4F0F1C0L5C9wvkL3C6C7C+BdQuQtCPYXfiLsLv1C6hewu4XoKt8hfQuguwvULwLQtC8C7C5C+OntFz5Cz510i0L2F26hZoLyFxC9wvkL0F8hdQuvWC6hcguwuBcC0LQuguwvQWBdwuQvIXpF0i29ZC9QvQWheQu0XULdBeQvIXcL5C5C+Qsi79++ue+viHl23GPG7bMdF/TG0SthCU6dfW9Mdt23tvG3aR5C+QvgLiLBdwueBcBdhfQvQL2F2F8gjABGgCL1iqxa1amS1rly96va973ve973vfm75zvnOdu+mhdwvQW3rlFwLOoWebyFugvAugo5C6TziL10i9wugvKX3EnfYXYXKL50F3C6ZqLm+It9haF2i+8cBdhfYWC5BeQuQvkF1C6hdIsF1C7he4XQXkL3C4hdwvYXYXuFqICAoLz2en7z902if3/suX/hY+22PtzH2Hziyf2n7o/WMBo5NY6Ff6/x+84Iv9vzLu0bOHM9OAz6Jhwu/Ez/Dq+vGP0Pvk/Xrww/lNGD7Z/K/rJiywfcHrwML3nM7nE+V5LF7HutM78qj1TGK9eMTIoxWTq6BkMVPd26nvv2dfCuGpOPh0i51T28xaM7mSoXd7e379dvl51Gq8p9vj6vVzcx/ecWqk+7mOczbeDeb9CS+eFdUY6ysVjaZIvH2OxzZVrT4E9Zv3a1eY7NY1mYjrDnOvnUtZ4eKgtcZ14vVzdY9+o6ukyjwLiN9Rju1Uydu+kYJjr14EzMe+WOvtz2nWeP2e72P0sLUxaKIqD3E+cxbJbN/TXSiaKj271VsxovFjVyj1+U95JNTRMVUz508wekmaq+fLxczM/yk9UHqj2iib2vvs7vXrxIPnlBoO08vb55OuJnxrce7srzOweyOnd1e7W9mHP4HPVn1gzhJrpPr9UmuwPZ39t7l47Trtv2eFisgOQtWMuYnpm9a6gxqzUn1y9wc1u2NTFHPQzeOX9vVux5ELzwctz4DmxVXwxnZ4SbMZmcXgtaqqff3U5nBasHDzrBg6VgWt5CdZsVOIkipLHkXxmjXw5vokozMbsXi+i+Lh3etzPcHlvx8ey0l4+L16DsNWOK3p8HOvzNde/qmOuLevpQsV73XevaX9IPCTxO9zXvHwBPQ6/DR2enTOOnZn1IryF3+lj3WLdMFsVV2e8Fusoft9e56+E3VYJ965w8L9LgpOzNy3Z2Fryd+KiYLbPKrBeA6E41MHVsKg7iSxO48oReo+OYPPAYF7o8BdWAma6tfhNDj3sltzBiS0ndXwd/tOrVULx561HoWzYKMHZ0fXIjrmjxso0e4wd8hYmcGfZ3UVd9DxscHq1qokmLk2Jgnnuzv2azlGc9LUY1Ney1rxJaL0bv2eXls6sE9xY2UcVrHlKZ0fjJv2Z1Yq1X6eElszR1CoioJ8J4WOq0MqehlmP7z6t+en4Ekz6Hryd0Y8/Lkzp+kzPZfodO/u+FmtTJ08vI8szftzEfrJQTjv/R9l4xHmTVwomfV1dAq3Z1XxXeyib1HqiTvK6zBElX7mTJae6T7PZr/8xQVkmU1nwG2xmBOaWGgBABFxAAApgDB4+EgRSAPswBQFaBoUpSlKVQAEGTEEGTEEGTECT1VAAmpUJp6BSUU0aYpEFLpCqFK5ESqWQqhSvEICvU2ttpsZJa9EiVDIKjvKiS651Sd/bcknzFVWwSNkkthJbIBtsAWySTYzVQWtJQ2UhbJRTNNNQlNiittiBM0KStgQraUorYkJklqA7DI628iJVLk5EwyrKGFSqGahFZlEYkxKprEmUmKTCTCmJNKqxJpJMSZJNtspMJMJMGJNIYkwSbLEmSBiTSlWzZSYkxJtKqzSTCWGqSykNSWUlts2bQGpLQGpLbJLbTUloVgS1SWAq2m1bZI0qrEmiS2kmJNiTGkWRJqSyhTZay2WwUmpLWgMktIsSTSTVAaSaKMSYSYkwSbTaNlskmJNIlasSYk0kxJiTSTSUxJikrEmgTEmKqxJkBtbY1bVmiqrLBTEmSqspMVMDEmLJTZasSYWJMKa2W0hhJiTNQswxJhE2JNkE2CTEmCTFaataNkqmAADakaS2UltQNklsqS2iW220yS0S2hLbGSk1JYk2ZYk1YqYU1SstiTULWLEmEsSZs1pJiTEmkmKqySYkxJmmqxJlJppEtiTEm2iTMSZlDEmEmxVWwkxJiTYk2JNYKZmYmym0kJiTLEmAJiTBTEmpiTEWxVWJNiTEmJMJMktAaktSWSWQS1I0kmJMpNJMFWJNUqmJNJMSaSmyY1WmFpgUYk2ySWEmaSbEmUDEmIGJNVUmJMkm0UTSTRKMSYJMSaJMFNEmJMJMSYKZSapTEmqJa1SWGANSWEtVkjVpJiTQkxJiTEm1bbaVrTa1pMYzNQRTI2Q2qBiTRSTaklsUk1qU20VZYGpTGJM0k2SixJqUmJNVAxJoSbKiGxAxJsSYNVpAykyVWJMKkxJiTSTQStJNUlqSygZJaSTYtqLMRmUDEmSTYSTEmkkxJqpMSZIFiTVSYk0hLEmFTEmkkGkmEmkmEWJMQjUlqSyS1rIGgNaSYSaSYkmJNiTCTEmJNJNVRWJMJMktAZJZSWpLElqUxJpJltTYpsJtSSYk0kixJlpJoJViLCItSWQNSWlRTUTBUmJNiTFVYk0kxJqSaJNJMSYSYpZJLZQNUlkDUlkpiTCTCTEmEmVEYkxJhJkk0kwkxFhSZJYpLUlgW0TZJtYkxJMSYAliTBJTSTBIYk0kpaktElqkslJklkBlJiqtJMiTEmFMSalEYkxJiTCqsSaSWSWSW1QMktQNUpqSYSYkxJpVWJNEsksgaksksktklqqrSTSQ2SbFNokmJNCTEmiSYkxJMSYSQsSalAtJNVVFaJMJNpJpJqUU2CTEmgGKI0SjYVUWJNVQpYkxJpJiqCxJlQhpJklVaSYJGJNJVWiTCTJJqK0Ghm2mrabTZaKqqbES2FLMKEJxSkE/mKCskyms4MsQXIBRXA3AKAI+KAAFVQVuETADL59XwANqYCaba2m2m0UAA0DJkFAANAyZBQADQMmQJPVVQ0DE0ZAwmpUpkGmQAAUlUahqY0g2UfqnRVSUT8YFTff74d3bsjZVRtJbGYtpVtSGwmyjZJC2UtlNqVtFbA2RLYqNimyi2RtQbJWyhsEkrYNg2itirarZJENBpkkao1ZMzZZTWjFi0FqStUhWTbGU1hNRmUQbFiTECDUFrMtbUVoNRVioDJEam0y1axraCGRbWDFjVtRVoA0AajERmZoYxhoxMg1ViNqMhRCESySQmwamZAjUGDZkBMM1ljMgktTSTEZmC0ZIomIgkYxGxsmJDTGbbRq1UJZVQXOhEOoEnFRKVcQopdKqHXqBFWgjSFsrZQbJKdGV03fr067rcXPn6AlaqhbgEraJEk1lUM0NWNMzSzJmmLLGZlZm1M1pKxTUtTNZlplFMrLNaU2ZrTGzbMrbMalKaplqUsyzNqZqozKZmaMzaplZmpmpNajZlaU0ZMbMyyzK2KzKzLJFtTLRVM0ZKU0pszKZmZqGaZLNGZLMraRmzSM00yaZmmaWZq1TMmZmTWpa1rAzQ0smsmtRmpWrRZqZpljNMxlpmptNisys1MzNRmNoZarKJbZmszamVjVZiyY0a1LWs0GZayMwWZbCzRmM0GYzUrNNZUZljDWI1rMmjLMpjLMyVUyyVJZmzMkM1DNq0pZkmaWahmtWYzUyZppMsytllTMyyzLK0zLNJZmsmsymtLWgNaqWYTWgZi00asNZWtLNZpLMzSsaTWk1LKWZlTJNTJNZWsKzUzKZkzVQzQmsgy02taRmMllSs0Qa1mUWtSM0DNRrVU0sppKtrBtqNbEUGjb6ZBJ24QScc8+fvePHv549P7xzz3/4u5IpwoSGN5V8EA="
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            done = True
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
