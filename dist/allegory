#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':
            braces = braces + 1
        if t == ']':
            braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.log(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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kFSH139973vezMzLv0NqXaQVIKkFSCpBUgqQVIKyHbvvd3d3Mzx6gh7nLIKkFSCpBUgqQVIKkFSCpDSu853u7u7mZmbzmkFSCpBUgqArdEu0gqQVIKkO3fe7u7uZmZd+IKkFSCpBUgqQVIKkFSCsh9d/fe973szMXxBUgqQVIKkFSCpBUgqQXdKamuh37qSqqs1dK0e+9cl5gNtttsAAAaAIAAABdXQAAAAAA44OOEne973qQAedzz6qv3Tw386ZmZnszMXxBUgqQVIKkFSCpBUgqQVIQnLvnve972Z73vXCHOJBUgqQVIKkFSCpBUgqQVIfXf33ve97MzM3nNIKkFSCpBbsC7SCpBUgqQVJDt33u7u7mZmXfiCpBUgqQVIKwFqqqqfrv773ve9mZJdgABlVyq5zMzMkkl2AAB3mb99z3MydzMytea83sAADXK5zMzM72Sfb2AABnmvbv33mZmSSSb2AAB97d+++5mZJJLsBJJJJJMnyc1dInOVz7777ee973tgr73rx4eVV3YOaaAd0AQAAAAAAAAzM9zMzMzoAEne973qQAZWeffZV3XM917rM5ziiqoAEqpu9TU1Wta1rWtZ99mYABJM1rzWc4AABfmvNa9u9++1mZkkk+3sPqoa0Par3377776SSXYAAGZ7vfvvMzMkkl2AGeVVefXd68qq8upd3fec73d3dzMzLuq8EF1baVWlaqlerv3377777JmszL8881mteac4AABXt3777mZkkk+znOVQAAe1V79ZmZJJLsAAD7l3zmZmZJO1QCSfVUkkmfWIrodAfB2jU33ve/ffffffffN6B8AKq68eaUknZqSQIAAHoMrO39VXWZmbzMlNAAA600A6eD0NtDK0BVXTWe+vMzMzmT6BqBQJrQJafAlzX009CpqsWSpkutdZKmvsud++rnO8tPhVUDtUAABeXeczMzMk7mta8uwAAN1WczMzJJ367AAA3VZzMzMkkl2AAB9y75zMzMkkl2AABuq3uSSSSS7A5VABzLv33MzMySTNa81vYAAFcu+czMzJJJ9vYAAHKreZmZ3vcl2AAB9vm98zMzO97JdgAAfUryKhcH6KjqFxKX49eve7z777MzMAAAJJJ9J5AAAAAACSSSSAAAAAAbu7u7GwAZoPffGpz7LzWt667lyb+kkne9yXYAAG6retzMzMzMzJrXmt7AAArl3vMzM73uT7ewAAOVW8zMzve5LsAAD7l3zmZmZJJLsMqgAOVXOZmZkkkuwADRvNXfOZnuZmZn37X31a881vXAVShBapCH13Vvbe93d3cz+/tva2qqmEFtbVWqqkrtve7u7uZ/fzlVVeCG3dVaq1VUwgt33nO93d3cz+/nPLVVSEF1b881rWtazveXXtV7znO/vv378B4A6ACSSSSAcDYAAAAkkkkgAAAAJJJJISSSSSY5XdfpUvnOxJmZmZJJLsAADdVvckkk++zK815rfwAFVR2q/VXvv333fpO9+vAAAOVXOZmZkkkuwAAPuXfOZmZkkkuwAPaoOVXOSTskkl2AABuq3uSSSSTNa81vYAAHKrnMzMySSfb2AAByq5zMzMkkl2AAB9rl3zmZmZJJLsAADuXOc7+3z6+1U979M+mYAAAAkkkkgAAAAAAAAJgBmAASSSSQADeedrzXlvNealyb9kkzMzMkkl2AABuq3uSSSSTNa81vYAAHKrnMzMySSfb2AAByq5zMzMkkl2AAB9y75mZmd73uXYAAFbu9ySTve9l2AABuq3JJO972ZrXmt7AqqABrXFczN5md33ufb2AAByq5zMzMkkl2AAB9y7a15rnMzMyTvZYAADU95+rWpVBrbb5qcMtRegrFFgiITVRFYou/vtE+4ouRReoCkUWKLFF0CtIovuKL6ArYK7qHISitc2CsUW9RFYCvNZ7vd9lcFW+kpEDYK0CtWVKBWwVu1OQSUNSS1F7Y700HAVpRbBW6AVoFdGd+3K+3W6PalVGffWd4ALw4evWkK93diElcrP7qNFxURarh8J6u9+z97PYRCquru61oBCqq7v270B0ABVSSAAAEkqQAABYqqqUAAFAAAMqru6v2rvOeX5mZmd7maVdXdV/AEMkkknamgBVKu7vVaAFNaAF3d3de6u6u+6qru737bfapVW+72dAbGqVVRqqqqXN7G27fyb2ANcuqqqDYkkkkkAAAFAAAHZqSSSAB4A6AAAofmazMzMzDQBAPqk8k73qSSAAA0AQASSSSQADFVd1eazMzMzPd94en3egAAAAAAAAAAAABKq7q2gklbkk3AAAAAAASSSSQAAJJJJIAyru6vMzMzMzAAAAO973ve9AABQAAAAAAAEuSSSQAAAAAAAAAAPakknJIAzMzMzMeySTkmAAAAAAEqV3ve96kAAAAAyszMzMzMAAAAAAAAAAAAAAAy7u7uqpm/MzMz5JJJMAAAAAAAAAAAAAD0D4AAAAAAAEkk5JPQAAAAAMvMzMzMzAAPwAwAAEaAAAAAAAASSSSQAAAJJJJIAAAAKAAAAAAAAPKqqvYzWn5VVQAAAAD79PjeFSo1KqqqpxkqDVVk1QSCBqAFE2Pz92ygSfIkfey1BRtFGIij4NxLCIKxLaDdGprQK0KjSKMZQJRQJE5Y0KjFFn2wVsBXqJwFFoBXW88I4CWijxASIo/WVSVR4EtRXYJBAotFHYLK+r7M15Ffu7ROImkay6uuU1J9ne/dACjp4FXdVVeaA8QHQBvySTn32qrWru6auvM8qaPRV+hI/R5BE4BrWtWCd73777mZmZmAAKAGXV3V5mZmZmYASSSSQAAAACST2SSPgAA5QbAAd3zXlVdezyT7P0iZmZmSd7ms2ABXlVXn8NXd+aqrvXec73d3dzMzPBDhyqYQdtsqlaqmq6vvv33330kk+3sAABxXOZmZkkkuwAPqoK5d85mZmSSS7AAA3VPNea3uSSTskXYAAG6pe5JJOyTNa81vYAAHKrnMzMySSfb1sAADlVzmZmZJJLsAAD6uL5zMzMkkl2AAB7mr8+3yvfvMzGAAAAG6q6BwAAJJJJIAEkkkkAAAAPqq6PvGzgj0D4ywTMzMzmVnrBL1PgSbBKouSugk5ua15prjXnuc5nedzszmZmZJJLsAADdU815re5JySXJM1rzW91VAAA1xXOZmZkkk+3rYAAHKrnMzMySSXqwAAPuXbnMzMydkl2AAB7rl6vnJJ2SST3ewAAK85d85JOySSZrXmv2ucAAAeq99zM7kkk+3sAADlVzkkne9733W9gfVQAV9+3trXmv37Mme/v37m9gSSSSSSe4Xzfu6PgiRQ7ABqAK+g32h3FAH6dj9FAyAfQVH0BQfogP0ED6Kj9FQH6KAD9FADNVd2PaPBmZmZgAAAEkkkkACSSSSAAeAOg0AQAAAPPv36rv9qrq/tVZf4Ey0/QHKoFqKn4Eiu9UKomNea8215rXmvXn32T7MzM73vb42AABKrnJJ2d73ua15rewAAHuVV++5me53ve/b2AABlVzmZmZJJLsAAD373e/fczmteayZNyS7AAA3Vb3JJJJJerAAMqjlU5zFU6AyVP0yTNa1rWtamtc++59xV7zve+bzTwACvb1fvuZmd73vZvYAAH3t377mZMkknu9gAAM117prWu9pXrfbzGYAB4TfG22wAG2222AABJJJJAAkkkkgAAAAUAACSSSSPOZV9815qJye688155OyZmZmSST3ewA3VAcqr5JOySSZrXmt7AAA/e3fvuZnckkn37nAAAOa9u/czO53ve8u/qoAAK5d57mZMkknu9gAAcqucknZJJLsAAD3Neet799zMmZJMx5555+a+e+gAAX+u/37777O973s95wAAD79d/vu/ffZJJ27AAA5y75zvf379+/fub2AADQa5vNfdSqq9e1XnfvfZhgAANtttsAAAAAAAACSSSKPAAAAPQPqmqkkbdgAAABJl1S5x89m1VKXyfetUqSn32Zne/v379+93sA7VAGfrv9+nfffffbsAADnLvnPffffffe615r3nAAAPar339n7O973v37nAADNaqq88qq+13e+99++n0kk+zRrnKqi7u7q7oFaqrqvdu+9++7973ve5rUnwp9cupdVRVVVSVV3d0/rv9+9u+3MzM7znlqqWoQXVtUWqV/VX7999r7PpJJdgAGVRO/d5zvfu6+n0kk+1rzX7nAAAJ9rnnec7377Pu97kn7nAAAPta/fGtN7/fvv30+zWszMzKwkkmUeAAAAAAAAEkkkkAADYOAAA2222wAAAA2qpezf2t601NSbne/vp9++zMzJJ3vu9gDQDPbv32TueeZJJPd7AAA/X57vfvsnZ3ve993sANHnKrnO9/d73ve5rXmv3OAAAffrv9+zO53vZJvYAAH727z33Pvp9mZJ7vZlUAAe1XvuZkySSXYAAGfvd799zM7kkk93sAADlVzkk7JJJdgAAe8u+cknZJJmtean7nAAAK5rXPLrXvLvWfsycySbEkkkkAAS6upJOST0AAAAJJJJIAAAA1QUED2gPh4CVV013ytXdntqENkhYH4IfHuTwQ/PDsoWt53ne72fb+/ffZmZJPsuwAAM85d73mZmSSS7AAA+vWub3zeZmZJJNe63sAyqAN61r2793mZMkkmvd7AAA5Vc5JOySSqAAAuquSSSSS5rXmt7AAAvNXfOZmZrMkma15rP2vPNc4AAB9+u/3v330+km5N7AAA5Vc5ySck9klUAfa881VatqrVPbv7u7u7mZmXfggut20rVVVA7Wr9+7v0Gp75pu9+zetea/f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vQIVtKZmbZtbQvDQ20yRXDASZUwIZUySFaFikd9/v379/ff758+ylK7TISn8haiMZZC1EaiMlJGATvd3d2799pAJpAIwCf0GALjELkqNSqtCyFoXff9u772+t8AAB1SMAVEhJJ6QIChZS1Ed9/v379+/f3779/iiP1EaFoXk5DbGhI5RGpCtC1VUZC0LRFqIxIwkjvv9+/fv37+/ffv8RU7NDbQSAT0AiQA733ve97fW7AJ0YAqDAFRhCSTM3d3du27IEDpBgEj9CwloWlKrSVZFoWURoWojQsEu+/379+/fv799+/1IrvY0NsalUP0LELvv9+/fv37+/ffv9FS/QtRGhZC8oqEAnd9YBCEgf0A/oBYBf1/fe9t0AAAAAAAALbffffeZJFtp6AAAPuSCq+Ktttt5AMwJIToSQh9CSBhFJoWqLIWSIaFoIwCMkkk9u7u/b71ukkISegEYQF5GCq99QuELQtClNC1EbSULQtRQ0LJVeefv379+/v3z59ipdpqoj+hZC0LItCyFoWURoWga1kkt7W6pDDMw1hh2ZmYZiZSSSpVSIXaaIX6iNJVqkmQsRZC0LURslKmhaIWhaRB33+/fv379/fYX7+/upQvyFipPE0FTiFpRGhYQshYSNhRoW0g0qZU0JWVMUrANJd9/v379+/f3779/pQn5F4nAQOKpomiYgyQyQyQ1SrMhaFoWhZC0LSV33+/fv379/fvv3+kIfoWojQsEXiYVC4haqq0LSiO+/379+/fv799+/1EdmywVX5RGiLURoWhd9/v379+/f3779/QvyllLIXicIXKIyFoWhZFoWhYhbvv9+/f399/vnz+pF2n95z9798+9kkyTMl/W7vj3QAAAAAAAAW2220AAAAAAW2235JMyZO5IyF/UL9C/ffv337+fv3z5/IXaaKEMy2+3btuwkhA6QSBIHiARIEYBO9973ve31uEOcttt+tuEPQCegE733ve97fW4Q0gEzN3d3btueYDAJ6AM7AWtve972t1UjCGZmCZSSSpVUjEcAo7MnOAUdyTcknz5/fFzMzJmT333+/v397/fwAAAAAAAAAAAAAAAAAD3JJyTJJnz3333396Hcm4AqDAMzd3d27bmwBWRgCmZu7qVKqkEwDu7O5MpJJaVVIxEVVVVaqqlmizATVVVY1VVIxZMBaySS1SqpGFMpbu607Mn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973ve977dJsmybJsmybJsmybJ5Azd3d/20280gpBSCkFIKQUgpBQg/2bu7v0A/bt6Q33CcSCkFIKQUgpBSCyGe973ve99ukFIKQUgpBSCkFIKQUhzd3d3bt5pNk2TZNk2n7XMmybJsnXve973r680gpBSCkFIKQUgpDGCGMEO885AOwCwDV9723nbaqqqgAAAAttttoAAAAtZJAHoAAbkhu7YB/QD9ALeXv332280gpBSCkFIKQUgpBSCgf0Azd3d/36Abd/udv2XMmybJsmybJsmybSH+773ve/3r680gpBSCkFIKQUgpBSCkObu7u7dvNIKQUgpBYeeJBSCkFIKQz3ve9719eaQUgpBSCkFIKQUgpBSHN3d3du3n8mybJsmybJsmybJv3Bnve9736Ae3286QUgpBSCkFIKQUgpBZDm7u7u3bzSCkFIKQUgpBSCkFIKQ5u7u7t280gpBU2n7cybJsmybJsnqHf79+/fv96+vNIKQUgpBSCkFIKQUh8+TJ58++dX5+893f21baAAAAAALbbbaABbbbbQW2220AAA9ySeZJPnvvffffRz+TZNk2TZNk2TZN+4uZM973ve99AL7eYQUgpBSCkFIKQUgpBZDm7u7u3bzSCkFIKQUgpBSCkFIKQ5u7u7t280gpBZ+1zJsmybJsmybJ6h3+/fv3718/vnPqbJsmybJsmybJsikO+7u7u/rv3NIKQUgpBSCkFAU8k4kFIZu7u776AX28wgpBSCkFIKQUgpBSCyHN3d3du3mkec4mybJsmybJsmybJ1/f27v23bzSCw88SCkFIKQUgpBSCkM973ve9fXmkFIKQUgpBSCkFIKQUhz4whv93m/27u2222220AAAAAAAALbbbaC2222gAAH7JJ+f379+/fvvrpBQgoQRIeSBxIKQz3ve9730A9dwgpBSCkFIKQUgpBSCyHN3d3d37dIKQUgpBSCkFIKQUgpBIc3d3d3fth5kJDm7u7u797SCkFIKQUgpBSCkFIKQ5u7u7u/bpBSCkFIKQfcJxIKQUgpDPe973vfQD13CCkFIKQUgpBSCkFILIc3d3d3ft0g5Nk2TZNk2TZNk2n7XX79+973vfe0gpBSCkFIKQUgpBSCkObu7u7v26QUgpBSCkFIKQUgpBSGsAl/v7u93d3bbbbbbbb9bbbaAAAAAALbbbaC2222gAAHcyT33337+/frbzSCkFIKAp5JxIKQUgpBSGe973vevrzSCkFIKQUgpBSCkFIKQ5u7u7t3YBucIKQUgpBSCkFIKQWHnjIZ73ve96+vNJsmybJsmybJsmybJ/dbd3b9fuUgpBSCkFIKQUgpBSCkNzd3d279zSChIpB9wDiQUgpBSCkFIZu7u79v3KQUgpBQkUgpBSCkFIKQ5bbb9fuUgpBSCkFIKQUgsNeJBSGbu7vvX2wDc4QUgpBSCkFIKQUgpBZDm7u7u3bzSCkFIKQUgpBSCkFIKQ/S/39ub/bu7cgFttv+ttFttttAAAAAAFtttQ4FttttAAAPffff379+tvNIKQfcJxIKQUgpBSCkFIeIHX3ve96+tM0gpBSCkFIKQUgpBSCkOY7u7u3bzSCkFIKQUgpBYeZxIKQUhnve973r6/0OsmybJsmybJsmybIshzd3d3bt5pBSCkFIKQUgpBSChB5u7u7v23SHkA6kFIKQUgpBSCkM973ve9fXmkFIKQUgpBSCkFIKQUhzd3d3bt5pBSCkFIKQWHniQUgpBSGe973vevrzSCkFIKQUgpBSCkFIKQzN3d3d23YBiQUgpBSCkFIKQUgpBZD+IH9AP7+3d3fvttttttBbbbbQAAAAABbbbbQW222skj4AABdgFgH9AP0A5bl/rbtvPeA4kFIKQUgpBSCkFIKQ733ve972280gpBSCkFIKQUgpBSCkMzd3bb99ykFIKQUgsGe5w9/f3ve971++4Qzm22225IZzbaiq4gGSGDKrbbewDkA2Qzne12q25IZzbb1Vcw6MDsTKSSSqqhDA7BN71fWNMBnSys4SoAAW2220AAAAAAW2220Fttvvq220AB+ySW8tttHJk5wANySdmT53u7u7u6cmTnAA5MnOAByZOcADs7MnegBuSTsyfO93d3d3Tkyc4AHJk5wAOZI/T796PwAAAAAAAAAAAAAW22++rbbQAq7gFtu7bVckM5VVVewDRDGtd3d3d05MnOAByZOcFttvJkd6At5MnOW0BuSTsyfO93d3d3Tkyc4AHJk5wAOTJ7++/Tx+AAAAAAC2222gAAAAFttvvq220AB7gHIBc5tttVyQzlVVV7ANEMa13u7u7pybMk+STvd3d3dHJk5wAOTJzgAcmTnAA3JJ2ZPne7u7u7pyZOcADkyc4AHJkc9/c+3yeXrr39d9eehC2IWheoXJKvuojqFqSrItC+QtC9oXTiF3C9cUR1C6fCJXIWhSaFqi0MhNRGhaFqpJ9hlC4pakjQtC0LAJoWqpLeoe/Xz65zj9777bfffffVtAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFttttAAAAAAFv+LbbdNAAAAABbbbbQAXJJj4AAAAW2220C2222gAAAttttoAAAAAAttttoAAAAAAttttoAAAFVVVVX32AeQCeQCYgEwSExAXUNRHUPUOIO6K0LIWhaFoWhdURyHuHkOoeQ0O4aF5D7D7D5DQ6QvIWUsojKI6d9/Pnv58+ffv0AAAAAC2222gAAAAAC222ocC2223IB4D/gYKoiIKkFBRGMtZtpbZlsZpmNomtWYJGTd3d/bu+t2TxJIEIskUAIwNVLWttaGabW7TlOZO+/379+/ft7qkwEjDzKSSSVVAxEVVVVVVVAFpmm3223MB1pVVtyQzm22229gGiGNdAW8mTnLdAcmTnAA5Mn7zJJ9++ZJB6v4AAAAAAttttoAAAAAAttttoAC5JNySeZJPcknTrwacmTnAA3JJ2ZPne7u7u7pyZOcADkyc4AHJk5wAOTJzgAbkk7Mnzvd3d3d05MnOAByZOcADkyc1+/Xz3f2+bboAAAAAC2222gAAAAAC222/cklo8APfffffffQ5MnOABuSTsyfO90C3kyb3oC3kyc5bbbbeTJzlQA5MnOLbbbdySdmT53oC3kyc5dAOZnOC2228kNgE9AJ/cgE4QJ/f3ve972+ttAAAAAAAAAAAAAAAABV5znOc5xVyQ91pXxVX6AaIY1rve97u6cmTnAA5MnOAByZOcAW3kDHMttttt2Ad6qqq8IHOKq873d3d3dtzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVU9kkz7Pu7u7u6AFttttAAAAAAFttttAAAq22221VVdQDnOc3znFXWsYxjGMYxhVVcy222230A71VVVVVXne7u7u7tuYqqqqqrmW22225iqqqqquGffffffffucVVVVVVt7bbbfvsxVVVVVXMttttt2Ad6qqqqqrzvd3d3d23MVVVVVVzLbbbbcxRRGKuZbbbbbmKqqqq7b1755/US/QtIV9hiRLiTP5PPnP6r/f38AFttttAAAAAAFttttAAAAAAH9kkz9kk+ZmZJlvbbbu25iqqqqquZbbbbWAXYB3FVVVVVTne7u7u7tuYqqqqqrmW22224Yqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbsA71VVVVVXne7u7u7tuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqq3/Z6AR8BAk4QmfLkkt9/v7+3ckl+fwAAAAAAAAALbbbaAAAAAAPckm5JLkk9yScAhMz7v33327bmKqqqqq5lttttuwDvVVVVVVed7u7u7u25iqqqqquZbbbbbyAYqqqqqqn3by23776/QDvVVVVVVeZ25bbb9cxVVVVVXLbbfvvrsA71VVVVVXnd3d3bftzFVVVVVcy22223MVVVVVV+725bbbb9AO9VVVVcYxjGd488779AJ7v7n333X5VVVVVVVAAAAAAW2220AAAAAAe+++++++h3vxVVVVVcy222230A71VVVVVXne7u7u7tuYqqqqqjmW22/W3kxVVVV+725bbbb9AO9VVVVVV53ty2223MVVVVVVzLbbbbdgHeqqqqqq873d3d3dtzFViMVzLbbbbcxVVVVVX7vbltttv0A71VVVVVXnoBP7+3u7u7ttttttoAAAAAAAAAAAAAATJADkA/fv379/fv1tuYqqqr3nFXvbbbbbfQDveEDnFVVVVXmbu7u27cxVVVVVXMtttttzFVVVVVfsvLbfvrfoB3qqqqqqvOnbltttuYqqqqqry223763YB3qqqqqqvM3d3dt25iqqqqqv3e3LbbbfoB3qqqqqqvO9uW2225iqqqq/Pnz5++bkkzzzd33d3QAAAAC2222gAAAAAC2222gAA3JJn3JJbb9tu6uYqqqqqrmW22227AO9VVVVVV53u7u7u7bmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqq/d7ctttt2Ad6qqqqqrzvd3d3d23MVVFVVXMtttttzFVVVVVcy22223MVVVVVV/fr/fd5/f3cz9y/4p/svfr++/v18QshaFoXqFyFxFoWhaFoXPULqhdIWha0BOe888u/ffbbz1YBuATUAmYBOGCAvql0i0qNC1EapJkXqFwkchZRGKuqI0LURoXyHUlXIWojQtUq1Q6QshaFaFwheoXIXULrEquQsEo0LCk1EcqLnELlC3IWQsQuQuURxS0LCjEW0qaUwphDgJLgqaU0LIXIWpFoWojkLQuIXcLoqTqFkWlR0ic3AJokIwDcA5r3Jgyc14++ctVttttoAAAAAAttttoAA7APwAALbf2SS3lW222gAAAAW2220AAAAAAW2220AAdgH4AAFttttAAAAAAFttttAAEyQAAAC2222gADsA/AAAttttoAAAAAAttttoAAAAAAttttoAA7APwAALbbbaAAAAAALbbbaAAAAAALbbbaAAOwD8AAC2222gAAAAAC2222gAAAAAC2222gADsA/AAAttttoAAAAAAt/xbbbpoAAAAALbbbaAAOwD8AAC2222gAAAAAC2222gAAAAAC2222gADsC+W220ALbbbaAAAVVVVVVXRAJokgTkA3AMQDlVS6QuIXIaF6oj3C+wukLQ4jCXaLxKrlRaZkmSeZJOfY/c+v3tAAAAAFttttAAAAAAFttttAAAySfsklvLbbbbmKqqqqq/d7cttttzFVVVVVcy22223AxVVVVzLbbfrb6Ad6qqqqqrzvd3d3d23MVVVVVVzLbbbbcxVVVVVX7vbltttuYqqqqqrmW2223nFVVVVVbjbbbbdgGYqqqqqrzN3d3d3bziqqqqqr9pAJ/QDpA/t/t3d+213JIB+AATJAAAAAAAAAAW22218ySAFAe5JNySfskifOnQ0H0A71VVVVVXne3LbbbziqqqqqvLbbbbecVVVVVV5bbbbbdgHeqqqqqq873d3d3dtzFVVVVVfu9uW222/QDvVVVVVVed7cttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMttttt2Ad6qqqqqrzOnc7/X9/v293f9+0C2222gAAAAAAAAAAW2220ALbbb/oByAfufv379/v1tuYqqqqqrmW22225iqqqopmW22224ZFVVVV+725bbbb9AO9VVVVVV53ty2223MVVVVVVzLbbbbdgHe8IHOKqqvCBzirzvd3d3d23MVVVFVXMtttttzFVVVVVcy22223MVVVVVVzLbbbfucVVVVX58+fHn393g8/AFttttAAAAAAAAAAAAAAA8ySC22+++l5z58+fPnz4qqqty22223MVVVVVVzLbbbbdgHeqqqqqq873d3d3dtzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMttttt2Ad6qqvz58+fPnz58+c+fsknnm7u/t0C2222gAAAAAC2222gAAAAAC23uSTuST9+/PPPfbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVene2239bbmKqqqqq5lttttuwDvVVRYq873d3d3dtzFVVVVVcy22223MVVVVVVzLbbb99yqqqqqqn78fvs/x+b3v+/1tv33379+/fr9S3gAAAAABbbbbQAAAAAF99998fnvvvq3lVVVVVMy3sAtt799yjFVVVVzLbbfvvtgGaqqqqqrzvd3d3d23MVVVVVVzLbbbbcxVVVVVXhltttv3OKqqqqq8tttttuYqqqqqrmW22225iqq95xVVe9ttttt2Ad6qqqqqrzvd3d3d23MVVVVVV7AO9ttv6222/foB8/W20AAAAAAAAAAAAAALbf2QPoBsA/QDPubbbdtzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbdgHeqqqqqq873d3d3dtzFVVVVVcy2237764qqqqqq5lttt++uKqqqqq5lttv331xVVVVV0gc5/Zv+8nz93d3V0FttttAAttttoAAAAAAAALbbbbbb9999/v9/r+/fv1LbmKqqqqo5lttt++5VVVVVVzLbbfvvriqqqqquZbbbbbmKqqqqq5lttttuwDvVVVVVVeZ13d3d3bcxVVUFf3e29tttuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqq5lttttuwDvVVVVVVefzAJ/wBAIwCJAIwCMAn+/3ve96+9bbQAAAttttoAAAAAAAAAAAt/0A2QIH3Pvvvvvt23MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbfQDvVVVVVVed7u7u7u25iqqqqquZbbbbbmKqqqqq/u9t7bbbcxVVVVVX93tvbbbbmKqqqqq/u9t7b9999sA71VVVVVXm3z6ATZAJ5zf33Pvu/KqqqqqqqottttoAAAAAAttttoAAAXJJbbbVt71VVVVVX/d799376225iqqqqqv7vbe2223MXSBziqq8IHOKv39/bvd3bbcxdIHOKqrwgc4q/f39u93dtt2Ad6vCBziqqqq8+/v7d7u7u25iiiMVf3e29tttuYqqqqqr+723ttttzFVVVVVf3e29tttuYqqqqqr+723tttt2Ad6qqqqqrz7mtK2IVSsTnE51g07ANhxmZmGuwDOwDaIXzhkWIvIWoXcLEj53RHIXqGqop4pdUR9h6hcKXYo5DBC4pYkZFqLZC5C1KL3D5DuH9D7DuHyH9D+h8h9hoeQ+5JPfffffffQttttoAAAAAAAAeZJA+gAAAALbbbaAAAAAALbbbaD7kkB4AAAAAAAAW2220AAFttttAdySAfgAAAFttttAAAAAAAAADmSQB6AAAFttttAAAAAAFttttAB8ySAFAAAAAAAAAAALbbbaAAmSAAAAFttttAAAAAAAAA9ySHACZIAAAC2222gAAAAAC2222gAAuSR8AAAAAAAAAAAFttttAAAe5JDgAALf8W226aAAAAAAAAAAAAH7JIOhbbbbQAAAAABbbbbQAAAAAAAAAAAAAAttttoAAAAAA9ySe5JPcknuST7g9w9w9w6hypF9h9h9h9h9h9h4h5D5D5D4IXUMoj3C5D5ROoeQ8h6h6QdQ8QfIdwvSiMpYovskz5mSZJz+kzMzJl49XTQAAAAtttqHAAAAAAC2222gAABuZmSZfvvvvvvt23QJJOnVVVVVXh/wCSVh/v973973vetzFVVVVVf3e29tttuYqqqqqr+723ttttzFVVVVVf3e29tttuwDvVVVVVVfsYB/f273d3dtzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy2377777YB3qqqq/Pnz58+fOb+ySd/ft3dt0AB3JIB+ALbbbaAAAAAAAAAAAD3JJuST9kDn32ffft377MVVVVVVzPvvvvvvvvsxVVVVVXM+++++++++zFVVVVVcz7777bbbmKqqqqq5lttttuwDvVVVVVVed7u7u7u25iqqqqquZbbbbbmKqqqqq6QO93d3d3bcxVVVVVXMtttttzFVVVVVcy22223MVVVVVRzu3v6AaQP377P9u+6AAAAC2222gAW2220AAAAABbbbbbbyAfv379+/v3623kxVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223YB3qqqqqqv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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def get_tags_for(pat, textmate=False):
    tags = []
    matches = []
    for root, dir, filenames in os.walk('.'):
        for filename in fnmatch.filter(filenames, pat):
            matches.append(os.path.join(root, filename))
    for f in matches:
        print('Scanning ' + f + '...')
        s = open(f, 'r').readlines()
        i = 1
        for l in s:
#            if l.endswith('\' :\n'): tags.append(tag_for_colon(l, f, i, textmate))
#            if l.strip().startswith('\'') and l.endswith(' .\n'): tags.append(tag_for_dot(l, f, i, textmate))
            i = i + 1
    return tags

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
