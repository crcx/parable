#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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QVkHM++4BJHv7+h3k/d/n+5hM6AAAAAACSSSSAAAAAAAAAUBJ3ve96kAHmZXnt3Vcuw/e8+9nf3s973vezMzLvxBUgqQVIKkFSCoC7YF2kFSGf3Of39u/27me971hDnEgqQVIKkFSCpBUgqQVIKkPrv773ve9mZmbzmkFSCpBUgqQVIKkFSCpBUh2773d3dzMzP4kOc8QVIKi1VVVVVVVPbvvfZ9mS5JLsAADPbvnMz7Mkkl2AAZVH1+a81r1vfvuZ9mZJmZXnmvN7AAA5Vc5mZmSSTu9gAAcquczMzJJJ+815rewAAO69u/fcz7MlySXYAAG2ea3rWveb93mfZkAfVV3Y9PDyqu7BXC6ugAAJJJJIAAAAAAZmZmZmZgAEne973qQAypqea81XK1MzNZ+155+zP2ZmZkkkuwAAP3LvnJP0kkkzWvNb2ADx4rlXziqgBtyprP3f379vu7oAffVKmVnHnnJzgK2815+3v9+z99mS5JLsAADPbvnMz7Mkkn3nmtb2AAB9nmvze/2fv2ZPpqTL155qc5eqoAAN37vfufszPvvvs7OcADR539d/v3f3e9k5JPvNea5sFeis27sisupd3YXarCH67/v37XN3LzMy71dGmmlpWqqqqqohJNslgfuMe9+/J+/TMzM9zA+AF3VTTzWgAAJMoBmY9BlZ28zMzMyU0AADrTQDp4PQcGXoMxQyZ768zMzOH0EihXyhafKFzX01I1UnM5fKKqTPJ3HLpf3fe/dV9VADveAAA/cze/fcz7MySTPPPNb2AABL81rzXu9++5+zMkknd7AAA5Vc5mZmSST9rzzW9gAAd9u/fcz7MlySXYAAHKre5JP379+uwN1QATU1m9/v2Zmfv379955rW9gAASq5yVXecAAAZLycv76d8983u/Nea99AAA77d++/sye++/rAEkkkkylQPog3dFQKX6r5z77M+zMzMAAHA2AAEkkkkAAAbBwAAAAFVUJJJEFVHSd577d1TjRqquvc83+zs+7XuZn3Oc9sAADPrvnPpPszMzMnnmtb2AABXLvnMzMySSd3sAADlVzmZmZJJP2vPNb2AAB32799zPsyXJJdgAAcqt7k/SSSS7AAA/czW9++5n37MzM77rva815rnAAAParnO973skk7vYAAHKrnMzMySSXYNNeBp487y75xVQA73nJyuVznOTlXbJ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vMzMyfZM81rWut7AAAuuL853ve97JJl2AABut973ve9kzKoAAD7d7eea1NySffpKoAADNVlea888veq819+uq7377uZMUAAk1JJJFQBwNgkkkkgADxQHQAAI0AAAEkkkkAN+ea13s+qpfJzWtea1JO9zMzJJK1QAAF1VySSSSVQAAC1XJJJJJnnmtXYAAG6reZmZkknbsAADdVvO973955rXe5eZVAAAXVXkkkkkrVAAAZu73WZmZk/SVQAAF1V1JJJP0lUAAB3d6veZmZkknfPNauwACgVkV0qfc59u7u7mZvq0qjnFaq7u7bvznOc55PPO+ec/XnJPby93dNZFVY9VABJJIAAAkkkkgAAAAAAAAAAkkkkgBvL+HvHwzMzMwPPNay6uv11bViqq1S3d2v139u7u7mZi+WqpaCC6tqi1Svy/bu7u5mYtVVVVVVVVAuquSSSSTPPNauwA0B3l3zve972SZl2AABuq7vve973MyVQAAF1VySSSSVqgAAzd3vMzMySSqAAAuquSSSSSqAAAuquSSSSTPPNam9gASSSZM48bRaIPfdlzR9mZ9zmer3u+nvexAAAUACqugFAAAVVVVUAAAAAAAOBsPaA+HgJd1TWq7V3WVV1lXdefnnm9XrTVafl33vfeufqnb7zMzMySdy7AAA3VXmZmZJJVAAAd3d7zMzMkkqgAALqrkkkkkqgAALqrkkkkkqgAALqrkkkkkqgAALzV3vMzMzJJnnmtXYAAHeXfO973vZJKoAAC6q5JJJJKoAADu7veZmZkklUAAA1lxn3JyX8DX3lPnqzHMQAAFAAG18QAAFAkkkAAAAAAAAAAAAAANPqq6b7955rX3ffO9rm+9neySZJJVAAAXmrveZmZmSTPPNauwAAN1W8zMzO5mZVAAAXVXmZmZJJVAFVVVWwgurZ9d/bu7u5mYvlqqpkBdbulVQcqud73veySVQAAF5qt5mZmTJM881q7AAAbreZmZn0k7dgaNPHm6reZmZkklUAAB3d3vMzMySSqAAA91mvNc3vmZn2YgAAKAAAqqs8X1UgAAqAAAAAAAAAAAAADfM9qrry7qtVqfVz73777MzMzJJKoAAC81d7zMzMySZ55rU3seHgOVXM5mZkknbsAADdVvMzMySS7sAADt3e8zMzJJKoAAC6q5JJJJKoAAC81d7zMzMySZ55rV2AA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2VL5dqqqrfZUvl2AAAX2VL5dgAAF9qmuVnMxVUAalTL3nec5znOADzynt++973veySd5voAAHte+973vckk3eAAAa5XOZmZmSSbvAAAO61555m+yefpOfu9n33333330gAKAASSSSQAAAAAAAAAAAAAAH7t3VHgoYAG7wAADXK5zMzMyZjXe9vWvNe8oA0aeNe1zne973JJO87wAAHte+773ve5mZm7wAADlc5mZmZJJu8AAA1yuczMzMkk3eAAAcrnMzMzJJN3gAAHK5zMzMySTPPNa5ugAAOVzmZmZkkneb6AAB7Xvve973JJM5ugABrWpDdH13VeBmeRz1D0AxADqrmKkkkxJJJJJJJJIAUAAAABVXQAAEaBJJJ998AB7yqkKqQqpCqk37vVtQ+BVXM3cAAA5XObzMzMzMzd4AAByuczMzMkk3eAAAa5XOZmZmSSbvAAAL1rl8vMzMySTW7wAAC9ecvm95mZmZmTNNNeea5ugAAL81y+XmZne9zMzzd9AAA5XOb73vczMzN3gAAHK5zMzMySTzd4AABrlc5mZmZJJrd4SSSSSR+3nc+3XUAPyKwUDcBWvesQQ+gdgiCeygyACHgViAKP0QRoFYgiPwJFFfoIqfRBX6IjsBIqov0BBUpFYAfQQEaEViK/n9R+gq3+pQT6I/ffYH7WSSSdkJJJIsB0NgAD9mZmZmZgAAAAAVQAAFVfe3V1VX67zz67qtYyqqu3VKyArFVYfUKINIrAEOfffffffu9kkmt310AAPa9973ve9kkzWvNc3QAAHK5zMzMySTvN9AAA9r33ve97kkms5ugAAL5fL3mZmZmZmv3nmtc3gAAHte37mfZmZmTd4AAByuckkn33327gAGjzPb99zMzPvvvta81+1rzXM4AADft+3mfZmSSa/c3gAAHqva89zPszMzM+ZETeqkkkkkkkkk9GVy0BfwKxL739o2Ar+gK+/aQPoCv2wVpRU++++0IqfQVfugrQH379+2grtAA1VXd973dVd33ve973EAAMQAAAACQAAAAAAAAAASSSSQDyplVV3fK8e1VVWvvq1339J3M73sn6Ss5voAAHte+973vckk1nN0AAByuc2zMzMzMn7WvNc3gAAHte+5n2Zkkmv3N4AABr2vfcz7MySTW7wAAD72/fcz3MySTd4AABbzl83mZmZJJmtea5ugAAO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3798lIdmDbTKhJA2SEogQDve93ddzMxACAbJCxE1S0pfKwbGYIefu+JIT9QEISEKANAN3e7nzmrmd9r3331xVVAABVVcVVVV9zMyqjgAAAAAFVZmYqqqqqvgBcgEPACpITADSQ/SVP6gaiiylkVpS1SoZS1SyloQ79/3f9/F9+T+/v79+/fvgkH9UtVS+MG3HK/dRSP3qpcKllLVEptVLKWqi1SxUpZSwpTKWAPvr79+/39+/vvz588qlXaZIL8pYK1SwVqlqpaKwiapZS77778/v3n779+/fAkdpiBD6oBAKohITve93ddzMxAkJ0hRVS/qlmlLQhillLKlmoTBWorKllLETVLIhWUsqVapYpQ7777/fu37zil+88889yUv0paFT4moSuFLCKZS1SlilqqDVLVS1S0DKWqWillS1SyVTVLSJpVTUp3333+/v75P79/fv3798VL+mqqjSr4nJFH7VSK6lLVLVLKiaEMiGRDUiaSsispapapaUspair58+fP72/tf37+8888+Epf2RFf1SyiZSySr6mqKXWQldFLQhqkoCSSHvvvv3sh99vyrskgB0g+SEIH9ITJS1S2VLVLVL58+fP7+/v399+/fv6pfqlqlil8TlKXCJlS1S/uVLiVqlrapalEqSE9999+++37MzNIQJ0h2r9zvfJITx+/ECEh2oASSfs3m+3766uZ7777765iqoAAFVVxVVAAAAAAAAKqqgBVVWwCEDSQIfEhK5z7773d3MzEkhOkKkhPiggEh3ve7vYa6q+wkhJ2mVUv5UtKWqXffff7+/v79/eeeee4HOc4q4qtkPpIT6SE73vfvvvt+VbIaSQl3d7u66q2Q+khPpISgDve9++++35VshoEgF3d7u66q2Q5znFXFVshznOKuKrZD2ASBLAO13vV9VVznOc4oAAAAAqqqAAAAAABVVmYqqqrgA0qqqtAFgSErxV6qq2Q0Auru93dd1W4GgFVJd3e7uuqtw0AqqC7u93dzVW9AKoqSgCq+73vfvvvt+VbD4Aqqhd3e7u5qrZDQC7u93ddVbIbd3e7uuqtkOc5xVxVbIc5zirirwg8jZ7kIEhCF57nl945CqqoAAG8zMK3VUBVVUALHwAACzWs0+ABVVUAAAFWySE6AVCBAn78r3qqvCGgHOc3d3XVeEN5zm7u66rwh+/flVxVbIc5ziriq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2TZNkqiFUQqpC7u93ddVb0hVEKohVEKohVEKohVEKqBX3gHvvvvv3333yq3pDZNk2TZNk2TZNk2Tvt333+/fv37zzzzzoPf5Nk2TZNk2TZFUQqiFUQ8wA989993fd1Vb0hVEKomybJsf2cybJsmyeffv379/v75/eB+/fv37977TZNk2TZNk2TZKohVSHe973d3dVW9IVRCqIVRCqIVRCqIVRCqIVRDve97u7uqrekKohv7g5k2TZNk2TZNk+fPnz5/f39/fvPPPPPf5Nk2TZNk2TZNk2RVELqeSHf3e93d1VWlVVxVVVUAAAAAAAAFVVQAAAAAAqrwAQDQu75u7rmZmfgDdIVRCqTZNk2TZNk2r+5xOvA+8+/fv9/fP7wPPPPPP3abJsmybJsmybEKohVSGHvvvvu77uZmZukKohVEKohWTZNk2TZNkyd9999/v3799+/fv38S/sU77777/fv3779+/fv9+TZNk2TZNk2TZNk2Tv379/v3798/ffv39+Jsq1EKohVEKohVEL73vd3dQDFXekKof3OJsmybJsmybJtT5333/f39/fP779+/vybJsmybJsmybJsmyd+/fv9+/fvn779+/vybJsmybJslUQqiFVD6jyiHRAMzM++797mZm6QqibJsmybJsmybJsn1999KzX988Hr+/v7+AAAAAAAABzMzD6AAABVVUAAAAAAAun7zd3d3c1W9IVRCqIVRCqIVRCqIVRCqIVRDt3e7uua5zSFUQqiFURsm/uLmTZNk2T++d87/v7+/vPvgf37z36TZNk2TZNk2TZNk2pfNvd3XNc5pCqIVRCqIVRCqIVRCqIVRCqIegHb3u73XNc5pCqJ9R5RCqIVRCqIVRCqIVRCqIZ737377vznyt6mybJsmybJsmybJsnfu73d1zVb0hVEKohVEKohVEKohVEKqfUHlEO++++/fffbirekKohVEKohWTZNk2TZNk99999/v379++/g/fv37v2mybJsmybJsmybJtTu7vd3XNVvSFUQqiFUQqgK+8A8ohVEKohVEP379777737777MzMzMxVVVVUAAAAAAD+73ve973vRVVUAAAAABVVXzzxVVVW9IVUhKohVEKohsmybJsmyd9999/v3799+/fv39+TZNk2pbJsmybJsmybvvvvv9+/fvv379++fk2P7HMmybJsmybJsQqiHvvvvv3332YgCu8IVRCqIVRCqJsmybJsm1O++++/379++/fv37+/JsmybJsmybJsNr+y5k+fPnz5/f39/fvPPPPPf5Nk2TZNk2TZNk2IVRDve97u7uqrekKohVEKohVEKohVEKohVEKoh3ve93d3VVvSFUQqk2TZf3OJsmybJsnz58+fP7+/v79555557/JsmybJsmybJsmybEO973u7u6roBu9/EKohVEKohVEKohVEKohVEKqQrAD5APyq/fa5mZlUAAAAAAAAAAAFVVMzMfAAKqqqqqqqu/fffffffegH4Ayuc++/v7+/v7zzzzz3/Js/suZNk2TZNk2QqiFUQ99999++++1Vb0hVEKohVEKohVEKoIVRCqId73vd3d1Vb0hVEKpNk2TZNk2jf3BzJ8+fPnz+/v7+/eeeeee/ybJsmybJsmybJsmoh3ve93d3VVvSFUQqiFUQqiFUQqiFUQqiFUQ73ve7u7qq3pCqIVRCsmx/ZzJsmybJsnz58+fP7+/v79555+D9+76TZNk2TZNk2TZNkVUh3ve93d3VVvSFUQqiFUQqiFUQqiFUQqiFUQ73ve7u7qq3pCvvAPKJsmybJsmybJsnz58+fP7+/v79555557/JsmybJsmybJsmybNZ7X7ebqu972qqoAAAAAAAAAAAKqqgAAAAHuZmD8BVwA/fvzxVVVvSFUQqiFUQqiFUQqiFVJ954QqiHvvvvv3332qugG98IVk2TZNk2TZNk2Tanfffff79+/fvPPPPPf5Nk2TZNk2TZNk1EKoh3ve93d3VVvSFUQqiFUQqj6g8ohVEKqQlUQqiHvvvvv3332qrekKomybUtk2TZNk2TZO++++/379+/eeeeee/ybJsmybJsmybJsQqiHe973d3dVdAN74B954QqiFUQqiFUQqiFUQqiFVIe++++/fffaqt6QrJsmybJsmybJsmyd9999/v379+888889/k2TZNk2TZNk2n9jyiFUQ99999++++1Vb0hVEKohVEKohVEKohVEKohVEPP37ve8vd3czMzMzFQAAAAAAAAO53ve973veiqqoAAAAAAA3mZjMzN73+CA87k2TZNk2TZNk2TZNk77773VczMxAO0QqiFUQqiHp59+J5RCqIVRCqIVUh8qv3325mZl6QqiFUQqiFUQqiFUQqiFUQqiHe9712buqrf5Nk2TZNk2TZNk2TZPPffffd3dzMzL0n1HlEKohVEKohVEKohVEKohVEPszMz777czMy9IVRCqIVRCqIVRCqIVRCqIVRDve96q5mZiAd5Nk2TZNk2TZNrN333335+ft1VbIXd3aqqrYGd73vVXMzMsh579zWZ/f32rl3+/v6qqoAAAAAAAAAd73ve973vRVVUAAAAAAVVQB9+8/K6uZmZZC7u7zQiqq/AHSFM999993d3MzMshd3d4qqrZDO973qrmZmWQu7u8VVVshne971VzMzNAOkK333333d3czMywNgFHe9713dVVshl73vfWtaznOc2IKRh3wTjEze1tPCs8VnF5wRCR71S5UuVLckpape+KqnWRDqpe1LlS+ql19e3D05il8UvXXx9+evXv4cwPgiapdPVCvA1JS6qWKl9qWqC4alLVLIhqE0papZSi+hpE6DIrqpZQmqWUtUtEh60pcUtFapaip01UR8Dgeg7D315m1M3pn7yXOQqqqHmVfqqAAAAAABVVUAAFVVQAAc+a+c5znOcAABXPfffXOIAAGZVVUAAHmtYGwAAAAAAAAAAAKqqgAAqqqAAAAAAAAAAB8zMwAgAAFVVQAAc5znOc4AACqqoAAAAAAAAAAAAAAAGfPfffffPQAAHvvvvvvoD5mZgBAyqqoAAAAAABVVUAAAAAAAAAAAWe+vx54AAAAAAAAqqqAAAAAAAVVVAAD/BVVdugAAAAAAVVVFmtZr6+gQAAAAAKqqgABoAAAAAAAAKqqgAAAAAAAAAAAAAAAAAAABVVUAAAAAAAqqqAABVVUAAAAAAAqqqAAAAAAAAAAABplrWsvtS1S1S1S+h8DsOqSvQegypcUsUtUspZS1S+B2hPgapfMR6lL2KyQqBAhUkAhh8Vfrmau5mZmZmKqoCqqoAAAAAAAAAAAAABVVVzMzIBsD+CoVVUUUUFVRCqCszTLWbaW2ZbGaZjaRqoUUElQ5zm7v27mZmIaBAJKogSFQklCIhCBKFggcboJTznOc77775znOdgDpCu973qrmZmWQu7u8zMzMzLIXd3eZmZmZlkLu7vNVVeEG7u+Kqq6AWQq7u93d3VVshd3dqqqtkLu7tVA8zWfv3MzM/e+8zMz33g9qqqAAKqqhVVUAAAAAAAAAAAAszMzPXMzwA2AV+/Ku7qq2Qu7u1VVXQDpCu973u7u6qtkLu7tVVVshd3dqqqtkLu7tVczM5I7Xe97u7u5mZoBZCt73vd3d1VbIXd3aqqrZC7u7VVVbIXuY3w8APLVd93czMyqAAAAFVVQfgPQAAAAAG8zMB4AAAqquKvv37VAHmay7u7VVVdAOkK73ve7u7qq2Qu7u1VVWyF3d2qqq2Qu7u1VVWyF3d2qqq6AdIV3ve93d3VV4AWQou7tVVVshd3dqqqtkMrZIT4ms181rWa+azNa+1V/P7+qqqAAAAcPp9Ac1rAAAAAAAAAAAqquMzMzMVUA+hCToB4AaAd73nN3c1VbIXd3aqqroB0hXe973d3dVW50ABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVXvOc554AAB98888899999qrdAAA3d3aqqrdAAA3d3aqqrdCqqqqqqqqqz9w58SE9w9gHmd913XMzMzMAAAAFVVQAAB/d73ve973oABVVUACqq4qqg+ZmZ7++/h6Ae+/Pnz58+AAbu7tVVV7znOeeAA4D75555577777VW6AAe/Oc59+nnnnnnvvtVVugAAbzd3aq73vcwAAC3d2qqq3QAAN3fm7VVVe85znngAAH3PPPvzzz33332qt0AAD93d2qu9q3QAAP3nN3dqrvat0AADGhIE+JCUSEkJCpITzOZmffffZmZmZkAAAAKqqgAAAAAAAABVVnrmZmZiqqqvxPpUIATznPJD7777776qt0AAD95zd3aq72r3nOc88AAA++ebvvvtd77W6AABu5lXe97VugAAbu7tVVVugAAbu7tVVVugAAbu7tVVV7znOeeAAAff7ve97/f39/f1VbocOOPhu7u1VVW6AABu7u1VVW6AAB75/OWspd466kTmEjVLFX5mZ53vbv93+zMx8qqqNAAAAKqqgAAAAAAAABVVcVVQAH0A0AwAqSBDznN3u7uqr3tVVVVVVUA3d3aqqr3nOc88AAA+/3e973+/v7+/qq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq/uc5zzwAAD7/d73vf7+/v7+qrdAAA3d3aqqrfm/HwAbu7tVVVugAAb5/fvv7n9z5858/uc5zfua1mvv7f9/f385/f1VVRoAAABVVUAAAAAAAAqquKqoAAA785znPz8++++++++1VugAAbu7tVVV/c5znngAAH3+73ve/39/f39VW6AABu7u1VVW6AABnOc5rd2/aqyrdAAAzW7tVVVugAAbu7tVVV/c5znngAAH3+73ve/39/f39d73MAAAtbu1Vd73MAAAuc5zW7tVXe9zAAALO+8+fOfO+/3nPzzz33y/v6qqpVVUAAFVVQAAAAAAACq1mZVxVVAAAHc8zMzuZmeeefvfffe+18q3QAAN3d2qrve+85zm6AAB9/vP7vn9/f3vvfP7uYAAHH5lu1du97WfNAAZznOa3Ku973tboAAGa3Ku973tboAAG7u7VVVf3Oc554AAB9/u973v9/e+973vd0AAPfnOc+/f7ve9777Xe973dAAAznOc1u73ve973vd0AADPv7+e/Pnznzvec/G93t5773ve973vaqqoAAKqqgAAAAAAVVXFVUAFVVVVVXYEiAc5zebuzdVXvaoAAN3d2u973ve+85znngAAH3+73ve++++973vd0AADd3d73+qqt0AADOc5zW7tVVVugADma3dq7VVvNAADd3dqqqv7nOc88AAA++eeeee++++1VugAAbu7tVVVugAAZznOa3dqqqt0AAC/2Y+/m+9O+Y552/X9jQSEoJCVJCVJC9qXTqpdQZSwrKWUvtS4ROKllLquMzetx0pbbj1UulLqpeN665KXypcVLKpmqWqWoTKqmVLypclS5UsoTQF0RNUucSlxS4iGqWkTVLSqmqXKpaUsSJqlwhO1JxS6qXVSxEOVL3yAW0InKlkk6yUuSJjlS1S4qXKpNUuVLFLRS4pckTlS1S1CYqWgZUsqXxyqnOqlqBZVU5UsqWUuclLVLlJypLlSxE4pZCcVLypdALpS1S0ifoSE/SQnkhIVAPXjz9389XFVVVQqqqAAAAAAAAAAA5znOc5wACq5znFUAABm973sAAAZgAAAAAAAAAAAAAAAACqqoAAKqqgAAAAAAOaPoAAAAAAAFVVQAAc5znOc4AACqqoAAKqqgAAAAAAAAAABVVUAAAqqqAej8AZllVVAAAAAAAAAAAAAAAAFVVQAAtZx9fgAAAKqqgAAVVVAAAAAAAKqqgAB/gAOgAAAAAAFVVQAAAAAACqqoAAAAAAAA8zMwNgAAAAAAAKqqgBVVUAAAAAAAqqqAABVVUAAAAAAAqqqAAAAAAAAAAACqqoAAAAAABVVUAAD1UukV3BW7DwOoQelS9qXYfQ6DpS9Bql4hO1L7Uuil8DsOw9ErnJVnoMk6YhMqWSJvN79d/Pvz75555qwAVVUAAAAAAAAAAAqquKqoAAAAP7P3793ve970Hvvz4AAG7u7VU5znKrcAAA5u7u1VVW6AABnOc5rd2qqq95znPPAAAPu+PPPPffffaq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAM5znNbu1VVXvOc554HAAPu+PPPPffffaq3QCqqqqqqu7CQlRQCiTn5V33NV/ACmHqqqoAAAAAeBsAAAVVXFVUAKqqqqqqqqu/gCgDADznN2/fffaq3QAAN3d2qqq3QAAN3d2qqq3QAAM5znNbu1VV+c5zle85znn6AABr88/PPPffa73vfd0AAD7u7tVd73tugAAbu7tVVVugAAbu7tVVVugAAbu7tVVVugAAbu7tVVV7znOeeAAAfffbP3395vec5xvvv777532qqoqqqAAAAAAAAABVVcVVQABVVVVVVVOc5z6+1VVVboAAG7u7VVVboDgA3d3aqqrdAAA/Oc5zd382qqq3QAAPzd382qqq3QAAN3d2qqq95znPPAAAPvnnnnnvvvvtVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAGfvPu/m/u1AAVVVAAAAAAAACqq4qqgAA8zMwNgAAA3mZjMzN73+VXaqt0AADd3dqqqt0AADd3dqqqvec5zzwB9+vnOc+/QD75555577777VW7785zn36Bw+OPPPPPPffaqrPnzRzd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqvec5zzwAA+fPnz78+79ZmZu/Xl3nQAAAAAAAAAADve970KudqqgAAAAAFVV85zn379qqqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qq73MAAAt37u1VXe+85zm6AAB93ffPPffffa73MAAAzLdqqu9zAAAMy3aqqrdA85znPr6+/QfeAJYxjGNaxnWta1q94ULAA220kkmANvGMYxrWNa1rWtXukklgAbbaSSTAG3bOM+bv26chVVUAAAAAAAAFVVxVVAABrMwKqqgAAA3mYYAc5x4riqve1VV6AeeeeeVVVVeAHnn37988888qqqt0POc5z79+/foAeeeeeVVVXvOc554AAB988888999u973vugAAN3d2q73ve2gAAZzd3au+eeeWAAAZbu1d73ve2gAAbu7tVVVugAAbu7tVVV7znOeeAAAffPPPPPffffaq3QAAH3v73nOczve55dgHp9zMx8AAAVVVAAAAKqriqqAAAAAAAAD7mZnczM+fv27u7uqrfaoAqiiiigCqKK73veq9qq3eHHAAbu7tVVVugAAbu7tVVVugAAbu7tVVV7znOeeAAAffPPPPPffffaq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d3ve973ve+85znngAAH32+2HnOc5v5X7XvtVVVQAAFVVQAAKqriqqAAAAAACqqqqqqvOc5z8/Pyqrve97ugAAbu7ve973ve93QAAN3d3ve973ve7oAAGZmVd7VW6AABu7u1VVW6ADnGZmVd7VXvOc554AAB985555577777VW6AB5znOffv379N3drve1VugAB785zn37u7vvvve+1W6AABu7u1VVW6AAB+R78+fOfP/tznPnznypISgkJUkJRITivrn33yqqqqoABVVUAACqq4qqh/d73ve973oAAAACqqqqq0AfSQlgGgHgSEvl833329qrdAAA3d3aqqrdAAA3d3aqqr+5znPPAAAPvPPPPPPffffaq3QAAN3d2qqq3QAAN3d2qqq3QAAP7nnnnnnu+++++++++7oAHDjd3d9rtVW7x8PgcBxxu7u1VVWbxxwAccbu7nOc5tX7VVunHCiiqooqi+aSE+JIS8vO59998qqqqAACqqoAAFVVQAAAAAAAPoAqq+qqqqvnniqqqvelFVRXAccbu7tVVV7znOeeccccccHHHnvvvvu7u6qve1RUAqiqooqd73vVVVrNAABu7u1VVW6AABu7u1VVW6AABu7u1VVXvOc554AAB98888899999qrdAAA3d3aqqrdAAA3d3aqqrdAAA5n3z7375+fl3e15kKthXtSyl0qW6Y1o22bVlLCXvKX33599dffnUbilzjQb3xS9KWVLeOnoielL6GKhXdR1In4PlS4qPVCcDFL064AWqWUTapZSxSYq699IriloqH4Pwew/B+D6H4PA+h4HnBj5r7mZn3MzPnwAAAFVVQAAAAAADzMzA2AAB5nOfec5zgAAKqqgAAfHgrlc5wAbzMwHgzAAAADQAAAqqqAAAKqqg/ZmYB6CqqoAAAAAAAAAABVVXMzMn7MzPwHAFVVQAAAAAAHOc5znOAAAqr5mZlUEACqqoAAAAAAAAAAAMzMvtVXsAAB7z5znOc4AAAyyqqgAAAczMw+gGszAAAAAAAAAAAqqqAAGWvz6DhZmY+AABVVUAACqqoAAAAAABe5mZX2qgAB/gAOgAAAAAADQAAAAD3MzB+AABVVUAAAAAAAAAAAAAAAAAAAAKqqgAAAAAAFVVQAAKqqiqqoAAAABX3MzKqvQAAAAAAAAAAAaAA9wfgPuZmAOAAABVVUABVXADACwDADADAD8AeBCQn0PofQ8DwPA9h2SlwOw8DoSvAxUvil9UOUcqHoPQelD6H0PNUvhKmqWhDupahORXoP6Ug9/nHvToAAAAAAAABVVUAAAAAAAAAAAd1mszWv3m7u7u5qukISe+1VVVVXkA88qqqqqvJA4CgjCgznOd999987a1rYAxhJCScANpKqqq8IHvoB777u7uqr3tVVVVVsA88qqoN55555777XardAAA3Myrve1W6AABnN3dqrtVugAAbmZV3var3nOc88AAA++ec5znnnnvvvvtXcwAAD9m7+bVXa7mAAAZ+2Vd72q3QAqqqqqr9APPf3vvq4qqqqv4AVV6gAAAAAAAAAAAAAAAAqqqq+AGgCAc/c3m7u7ir3tVVUAA3Myrve1XvOc554AAB93zzzz33333tVugAAbmZV3vardAAAzm7u1V2q3QAAN3d2qqq3QAAN3d2qqq95znPPAAAPvnnnnnvvvve973PQAAObu7tV3ve9yAc4c4c4c4cOHN3d2rtVWfOaAN89/c/bMzPfo97zoAAAAAAAAAAAAAAAAAAAAAA+/ftVVVW6AABu7u1VVXvOc554AAB955555577777VW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AHvznOffoHnnnnnvvtVV7znOeeAAAffPPPPPffffaq3QAfHxu7u1dqq3mgABu7u1VVW6BVVVVVVVVmyQAIeZmZm5uqqqqqoAAAAAAAAAAAAAAAAKqqqqq6SEsA0Au7/bu7mqr3QAAN3d2qqq95znPPAAAPvnnnnnvvvvtVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAH5995z58+c4Q+khKCQkJzMz3PvvvlVVVVVVQAAAAAAAAAAAAAAAAqqqqnOc59faqqqvec5zzwAAD75555577777VW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AD4c4HON3d2qqq3nPmucfAAN3d2qqq3QAAN3d2qqq95znPPAAAPvnnnnnvvvvtVboAAG7u7VVVboAAGe8+fPnPn9z585rP1ur+/v7+AAAAAAAAAzAAAAAAAAAAAAAD+18+fOc5zvOc5+/v777nvvvtVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVe85znngDnAffPPPPPffffaq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAALOd5znPzvf3vfLtVVVVd75vMzOfOc4oAAAAMAAAAAAAAABZmdAMzzMVVVXwA0kAQD4kJ+u/7P7+/v7+qrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3a5yqqt0AAD95u7tcq73vcwAADzm7eeVXe973+5znPPAAAPvvO973vvvvve973dAAA3d3e973ve9zAAKqqqsqvfeb6fn8YAZx7x93dVXoBmeZmVKqqgAAABVVUAAAAAAAAFVVVVVV2SEoA+JCeBITnOfffe++973uYAAcMzM73ve973v7zAABmZne/3OfKqrMAAAvnfPPPMtqqvec5zdPvznOffoAB93d3333332qzAAAPN3dqrve9zAAAMzM73ve973uYAABc3d2qu973MAAAzMzve973ve5gAAGZmd7Vd739/QAAL8/dXz+zMzXvtvnveugqqqAAAAAAKqqgAAAAAAAAAAAfxEEWANgC1rTttsbZ2znNUkkkkkkkkle3dreVd7395+gABtu7W8qvlWYAAB5u7tbyrve+85zmYAAB989888993nvvve9/f0AADbd2t5VVZgAAHm7u1vKqrMAAA83d2t5VVZgAAHm7u1vKqr3nOc3QAAPvfPPPPffffe973MAAAvn38/ufvnnme+3vtUqqqAAAAFVVSqqoAAAAAAAVVVVVVVVWAfBITKIBD3nN933333ve9zAAALd3aq73vcwAAC+fObu7VXe97mAAAZmZ3ve973vcwAADMzO973ve97mAAAZmZ3tVVe85zm6AAB93d3333332qzAA4BmZlVSrd1VVVVWwDzyqr7z9AP3lV77779998qrdklu94AlpJJKXMAMJlLGMY33331rWtatZJbPeAJaSSSlzAEtK5e0RBFiIItnUN6zvvvtuTrFWuZ1p5vm9kVJbJLvOMTnbD2uK89fXzRXEWqWqWqWapZDKWpWlLN1xxUtapZqlzlxQKRwPZNF3SCINJZdkkoiCL2q9ARFe9u1L4pc9IZrZSzKXG5zndS0qyiYiforVLUpapZS0icUtVNIPrlS5CHYaKLipaEMqWKllLBWUtUspeqllLlS1S1KWUsGqWKXXEpcCtCWKWUtUuKXFS5AWRWlCtUtKWUsVdVLEVcVLkUckp16Dn0Pnnvr398+fQAAqqqAAAAAAAAAAA5znOc5wAAAAAABTMzDWtc5zznOcAAAzAAAAH5oHoAAAAAAAqqqAACqqoAAAAAAAVVVAAVVVAABVVUAAAAAABVVUAACqqoAAKqqgAAAAAAAAAADzzzzzwAAAZzNZfKqoAAFXPufb9VAAAKqqgAAAAAAFVVQAAKqqgABmgAAAAqqqAAAAAAAAAAACqqoAAf4ADoAAKqqgAAAAAAAAAAAAAAAAAAABVVUAAAAAAAqqqAABVVUAAAAAAAqqqAAAAAAAAAAACqqoAAAAazMAACqqoBVVUAAAAAAAAAAqqqqqqqAekkJzoB4SE5JCelL0GUuBg8Dil7DilxSweBxS+h0H0PSpeITBJqlipZS0pef4Fd/u/v7ynQAAAAAqquKqpVVUAAAAAAAAAAAHdazMzP8Pmsz9+/v7+/v7+/v7zzzz9/Y2pbSpgwbFL58AAA/Pxz5z5z588888/v7+/v7+qswAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqr3nOc3QAAPu7u++++++1WYAABmZlVVVmAPj4+Mz9qu972swAAD8zMqq72swAAD75znOec5zn5555pQFVVQB+zMwD0KqriqqVVVAAAAAAAAAAfczMKr2vmZmdwDQDAD9x5xVzNdAO9qqqqqqqqqqqn3dz3332u99swAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqr3nOc3QAAPu7u++++++1WYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYCqqqqqqqqh6677fbCQlT39u7eu6quZlVQAACqq4qqjM0AAAAAAAAAqqqqquZmZmaSE+khP37d++++++VcwAADMzKqqr+5znN0AAD7u7vvvvvvtVmHDj4+BmZlVVVmAe/Oc59+gH35znPv3d3ffffaqswD35znPv0A+/Oc59+7u77777VVmAbAPPKqqqqryAeed73u7uqq3dVVVWwDzyqqqqq8gHnne97u7qqugHe1VVXh5RA+/QA+7u7777777VZgAAGZmVVVWYAAB+c5fPu/mftXe9qqqqAAAVVVBY+AAAAAAAAAAAKqriqjMzPMzM7rWZms883333329qswAADMzKqqpznOZgAAH3M+5VVVZgAAGZ7u++++++++17znOboAAH3d3ffffffarMHOADMzKqqrMAAAzMyqqqzAAAMzMqqq/Oc5yz6AABzMzKqqr3nOc3QAAPu7u++++++1WYABVVVV+8++khPLnW8AMrO/fe/bmauZmZmZiAABVVUHo/AAAAAAAAAAA5mZmZ65mZjPQD9+eczMzMxu6qqqqqqqqB9zMqq73tmAAAZmZVVVZgAAGZmVVVX7znOf3Oc5v0AAD63d333332qswAADMzKqrvf39AAAsZlVV3v7+gAAftmVVXe/v6AAB+2ZVVd77znOZhw+AH3Pd3333332qzAAAO778+fOfN/fz7vu++3e+1cqAAAAVVVACqqoAAAAAAAKzMzPXMzM9czMyAaSE88Xd3d1Vu6qqoABmZlVVVmAAAbznObu7V5VVmB7znOffv379ADznnnnnvvvlVXvOc5ugAAfd3d999999qswAADMzKu973vcwAAC3d2qu973MAAAuc5zd3aq73vcwAAC5u7tVd73vvOc5ugAAfd3dq999qswAAD9+6SE+gQwAvMz7773fhfFVVVVVUCzMx8CqqoAVVVB/d73ve973oAAAABVVcZmZjMroBmeZlAGwkkrxd3d3VW7qqAA4zMyqqqzAAAMzMqqqswAADMzKqqr3nOc3QAAPu7u++++++1WYAABmZlVVVmAAAZmZVVVZgAAH7znOYzKqqrMAAA/cZlVVV7znOboAAH3d3ffffffarMAAA5m+/u/v5z585r3P3u/v7veldAAAFVVVVVQA9r7VUAAAAAAVVXFVcVXOKq9zMzuZrXPjnOc/Py9/arve9zAAAPd3dqrve9zAAAMzM73ve973uYAABmZne973ve9zAAAL5u7tVd73v7gAAMzM73ve973uYAABmZne973ve9zAAAPvMzO973uMYqkkkkkkkkkqqs5znOc5zlgGwBe6QAAfn5v3dqrve9zAAAfLPfvzzzvhUKqqgAAFVVQAqqqAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return t[0] + '\t' + t[1] + '\t' + t[2]

def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l))


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):  load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):  load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

