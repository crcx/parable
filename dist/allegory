#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if math.isnan(opcode):
                opcode == BC_NOP
            else:
                opcode = int(opcode)
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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nx63rQAAF3kAZmsDJnZmeZmZmfQegOngHzR4ADQOBlZAqpB61eB9R5M1VaUK+ULC58oaJf00HyhNzUcUN0Xv33Jnv5/c973ve9mZmbzmkFSCpBUgqQVIKku7sgqQVIdu+93d3czMz+JDnPEFSCpBUgqQVIKkFSCpBWQ7d977373svMzLvxBUgqQVIKkFSCpBUgqQVIdu/vve/e9kkl3vOuVVc65VAAHvmZnnm77u7Ju7XXXOswAACu7vvvd3dkkn2YAAfVRXXOuc8u/PPvvvvpJJ+651zMAAA3y7883fd2XJJdgAAd1WZJ+kkkl2AAB+3zM883fd2SSb11zmYAABX67uuVyuueXfnm7s2SSD6Sqoenh5JVUNnw+AACqqoAAHgDAAOZmZmZmYABd973versFtMj93ftVI9xhqSpebv2fpVfsflVQAy71rWta1oAJzy7883zd2SSe+9c65954A6dOqzX7l/vz+8pwA5Kj9vver5QA9VSXeprTqgAl866/Mz9v79uz2ck2+ddcnfYAAGZzzM839u77777v077AAA+5z9d/v337776TuSe9c653m8qgAAr9d+fv217uy5JLsDh0G8n7M883z3dkkl2eis27sisupd3d3VJILd3bn885/f27+399mZnypqaqqlVRVSSSSSSZyxFef/HB3v7nf1/v34L28D4AAAAPYr7VUAAAAAAAAABW22ygD19vVee+77JW7u7uyST+ZgAAH3XOdc8u/PPvvvvpJJ+511zMAAA3y7883fd2XJJdgAAd1WZJJ+/fv12AABOTm5nnm7u/v379711zmYAABKrvuVX3fYHtUADbvZ3fvs+686zL651zzwAAD7y788/bs888/WAAB7VZnvvvffflgAAe+3fffsnu7u7v2KGtSSSSSSSSSVSjIoGTcB9zl1Km9SfVV1Kv3nHcz3ANg4AAAAAqqqAAAAAAAAAArbbZQAAuSp731TXvdt/BtVVADLvWta1rWgA7qu+93d2SSfuddczAAAPvLvzzd93Zckl2AAB3VZkn6SSSXYAAH7veZnnm77+3d3fvOffV1zrnfYAAHlV3399999JJPswAADuq773d3ZJJdgAAfd3ffe7u7JJLsAADKrMkkkkku3HOg46dBlVmSSSSffffVznXM76dBxzg+9kuSXzne9/fvwAAAAAACqqoAAAAAAAAB4C/b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TU1qT7X33czMzFW+SpervFVVW+SpersAAAvlU933qqoBfJUvV2AAAXyVL1dgAAF8lRnck599lypmZmPyq59MzMzMzMAA74egsAXd3dVVbbKqq22VVVtsqqrbdXd2AAu/3dSSSb1L9u7+wwABfJUuauwAFVuqk7cqbnd96qqYr3kqd1dqqAF8lTO771VUAvkqXq7AAAL5Kl6uwAABqpO3Kndd6qoYr3kqd1dqqAF8lTO771VUAvkqc/MnK+1L+i/vqqR0uTitq5ncy+ampMzMzP379+B6Hp8PgB6HTvoAPKqQB0AtoAAAAA8AdAB5qqk/TeVUmfb8qpIqtepVAPKF7gG/vuPlD3q+999999mA37Km9b2AG/ZU3rewA37Km9XYAAA1UnblTfd96qqAZyVO933qqgBuVMvd2qqAblTmucAAAN01UKlBCtpo+r77d3d3MzN2QO/IQq6alBCmmint97u7u7mZnL0IVtNSghTTRX1FWCtUiu6/BJIGQKgEQqUQInCgVg+gUQIoEWSArCArICuZ9797vfe9d6RaQYO/WCupud4d9uzaKwfcordHdgK1AVznD187nu+zXde2a5kGwViRjCJRNT04a72c9ndb++RX3PVagS4Kt7riK7BXshAVnM1ffs9rxqr7LuVMq65UzvdaUFx0WOBCFUmvkVtVYyKAHa199n332IrhLxUAtggEESKgQCQkkIAwIoMRUYCsmZahmZmeU4CsVUJPe9diVVVc1UqVHgBU7t5d3y/btJVVqVKkqPD4AA0qALLlakkoMdlKKBYABBBUi3NqGZme3mAeEVjIKASKqxRHJmZmZma+VBaAAwijILCArBVigEFX5FYABQSArIhEEgKyCkgSIoSCKxVan333fvvpnkkUCCK6VpRSzP6+zO8zMFWRRWKKwkRFIiuV77MzMwVfIrAVyszMzMxNgrA8RgCu2hFdRBAsRFggJUFAKGJlZnc9mZ2ArmNAKhCEiAoQFYCsSIrCJIEhAViVUl5mZmYiuArlAIRJAgSQiipIshGASKASEgQiCpWZmC0kqq98SpVVrXoLKqqq40Lu7u7uwABJUqABKoABdVVAPgPqqqoAAAAAAqqqx4PZ67766D90tVVC7766egAAAABVVUPfX76Pj7+CqqoAAAAAAqqqAAKqqgAAAAADbbbYAAHXXbrrt113tttsAAM7r355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aHzYwcccY1AnBEyVC1S1SzCKZUsKyUtQmpJpVRddddeeed+ffv372VFdMG2rFLypapddddefv37z933335UOthg27wUOuuuvPPO/Pv3797VLzKXysG2ZUuNSJ+qWqJqlpUq2pFMRMwq0papYRMpaRMpZKHz58+fvlP37z933335KQ6YNtXfCpUfqlkI+fPnz9+/efvv3797BDypYiapaUvkwbGMiHZUu/vPMSonGZmPg7/cdK5znOcUAAAAAVVVc5znOc4AAAAAAAVVUzMx8AB7rWE4DFE8kqfqBpKLKWRX3iUuBVDKWqWUtCHr3+/fvvU/fv3ffffxRB5UtCr5uHEcJSO+alwVLVLEqpqllSapYqUspYRTKWAPnz588878+fPnz7VKuk/cVLaiU8UsFapYK1S1UtFYRNUspfPnz55+/efvv3797KQ6TVSL379++/3nnfnffffgpdJlVL9Us0paiGKWqWVLNQmCtRWVLKWImqWohWUsqVapalUOuuuv37r9n7zipfvPPPPclL9KWCp8TVErgpYRTKWqUsUtQhqlqpapaBlLVLRSypapaKpqlpE1VU1Kddddfv375P3n7zzzz4qX6aqqNKvicVIo4lLVLVLKiaEMiGRDUiaSsFZS1S1S0pZSyFddddfv375fvP3nnnnyJE/VLKJlLCVfE0gVwUsiGqWUlOuuuv379+8/d999+Qh0mpIfpCZKWqWypapapddddfv3795+7777/VL9UtUsqXxOKUuCJlS1S1SyVqlrapalLVLB1111+/fv3n7vvvvxIuk3u+ivPnHz5mazWs1mrfM3ff3ed6VVVAAB5mZgr2qoCqqoAAAAAAAACqqoFVVsCAToBQQIaSBD4kJV3999mfffKukkJ0hUhCSF3d7u+w13d3fSVKdRpVL8qWlLVLrrrr9+/fvPyrZDnOcVcVWyH0kJ9JCUAd73v3332/KtkN+JITve9++++3MzOENkhNkhPvffffvvvvszM4Q+khALu7VXMzOEOc5zMzMzMzhBALq7tVd1WyG+KQkkPahM1rNX2v3ec70FVVQAAVVVAAAAAAAAAAABVVUAB7mZqEQDADnPzx6qq2Q5znFXFVuTQCqJRd3e7u5qrc0AqqhQBVF3d7u66q3JoBVfeHgB3ve/fffPyrZoBVVJV3d7u66q2Q5znFXFVshznOKuKrZDnOcVc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TZNk/YOuOuv379+7/d/fvrxNk2TZNk2TZNk2Tanrz378888787+/fXibJsmybJsmybH7OMmye/3XX79+/d/u+7vvB78TZNk2TZNk2TZNk2Tj3749+eeed+d/fvrxNk2TZNk2TZFUQqiFUQ5t3u7rrmc0hVEKoCvvAOMmybJsmybJ7wfuuv379+7/ed99+/E2TZNk2TZNk2TZNi65+9v3c+5rWs19/PznOwCqqoVVVAAAAAAAAAAqqqAAAAAKr4AIB+/eKqqrekKohVEKohWTZNk2TZ+y4yddddfv3793+7777we/E2TZNk2TZNk2TZNk8u/L3d11VvSFUQqiFUQqiFUQqiFUQqiFUQu7vd3XVXwAvSFUQqiFZb9cU4yrZOeuIcdfv3799/d/fv734mybJsmybJsmybJtTj379+eeed+ffv3v34mybJsmybJsmybJlAVrXWtaxrGMaQBXeyISSEiISSGwZHGTZNk2TZNk2TZOeuuP379++/vv37+9+JsmybJsmybJsmyaiF3d7u66q3pCqIVRCqIVRCqIVRGxQA0Q4SSQ0xISSbGhIStZgFrb3vet61nNdbSSQk20khCbGAJQmyGybJsmybJtT577ql65+/ff39++/gKqqgAAAAAAAAAAAKqqgAAAAAPnwAD3uabJsmybJsmybJsmye/fv35555353333g9+JsmybJsmybIkQJG0hEA2yJtZ23ve9bznOa6IEiBImybJsmybJsmye/fv3555535333378TZNk2TZNk2TZNk2Rd+AF3u7ru6t6QqiFUQqiFUHxRDarjjiuMmybJtTrrrr9+/fu/3ffffvxNk2TZNk2TZNk2TZPfv378888787777we/E2TZNk2TZNk2IVRCqIeXfl7u66q3slfeQPKIVRCqTZNk2TZNk6666/fv33z79+/ffabJsmybJsmybJsmyfuuuvQdeeed+d99/ffabJsmybJsm0/a4yFUQqpDJIQDzMzN337MzM+zMzMzMVUAbzMwHoAqqqAAAAAFVVQAAAqqqqq1Sq5mZmXpCqIVRCqIVRCqIVRCqIVRCqIXd2rsdVaAL8TZNk2TZNk2TZNk2Tgu/L3dxzMy0hVEKr4KnlEKohVEKojZNk2Trrrrzzz759+/fvvtNk2TZNRCqIVRCqIVRCqIXd/gC1fnd3W9TZNk2TZNk2TZNv2nGp1111+/fv3f7vvvv34mybJsmybJsmxCqIVRC7u93ddVb0hVEKohVEKohVEKohVEKohVELu73d11VvSFURsm0b9xHGTZNk2TZOuuuv379+7/d999+/E2T4pxrhNTjhNk2TZDyAeeEPDzwhVEO973gBu6u7u7ekKpPkOOE4ccJsmybJsmybR5r7znOd73tVKqqgAAAAVVVAAAAACqqoAAAAAH3MzPg7777+99999/v0fMmybJbU2S2psmybJ1111+/fv3f7vvvv34myW1Nk2QqiFUQqiFUQqiF3d7u66q3pCVUmybJsm0/bjJbU2TZOuuuv379+7/d999+/E2S2psmybJsmyaiFUQu7vgBu7ru7u3pCqIVRCqIVRCqIVRCqIVRCqkLu73d11VvSFVP2nGTZNk2TZNk2TZOuuuv379+7/d999+/E2TZNk2TZNk2TYhVELu73d11VvSFUQqiFUQqiFUTaNr9xjhscZOuuuv379+7/d999+/E2TZNk2TZNk2TZNk9+/fvz2HnnnfnnnnnvtNk2TZNk2TZNk1EKqQrnvgBgB4AeZl5u5mZmZvfV8/KAAAAAAAAAAANZmAdzMzve973ve9AVVVVVVVVVVoAQBAEA5+/flVVW9IVRCqIVRCvjyqKryiFUmybJsnXXXX79+/d/u+++/fibJsmyFUQqiFUQqiFUQqiF3d7u66q3pGybJsmybJsmybJsnv3797u66q3ofUE888A8ohVEKohVEKohsmybJ1111+9h+/fu/3nnnnvtNk2TUQqiFUQqiFUQqiFVIXd3u7rqrepsmybJsmybDfuBxk2Trrrr9+/fu/3ffffvxNk2TZNk2TZNiFUQqiF3d7u66q3pCqIVRCqIVRCqIVRCqIVRCqIXd3u7rqrekKojYfuOE2TZNk2TZNk6666/fug/fu/3nnnnv6mybJsmybJsmyKohVBO89zvvs3u53cO+Lnnb9f3TCQlSRc6cKWQnGlLlu6llLelL7lLlCZS0pZS6qXAQ9Slql11XnPDN93t0pfFLhS3uUPSlxUsUuEW9VLlS5qWVLVL5XuSD3pE9valxQlQQIeSQn6SE/SSDAK3zt/vd9cVVUAqqqAAAAAAAAAAA5znOc5wAAFVVQAAGb3vewAABmAAAAAAAAAAAAAAAAAKqqgAAqqqAAAAAAA5o+gAAAAAAAVVVAABznOc5zgAAKqqgAAqqqAAAAAAAAAAAHOc5znOAAAHzKqrkGwegDKqqgAAAAAAAAAABVVUAACqqoAAGffgCAAAqqqAAAAAAAAAAAFVVQAAKqqgAAAAAAFVVQAAAAAAAAAAAqqqAABVV5mZlQ/AAAAAACqqoAAAAAAAAAAAVVVAAAqqqAAAAAAAVVVAAAAAAAAAAACqqoAAFVVQAAAAAACzRXKpa1S4DoOFL4pZUvYpYpfQ+BwHIe6E+qXsDgBwA6AeQkIwb57nfXMzMVVVQAAAAAAAAAAVVVAAAACqqqqqkBV++ACFUSVUKokC2VNkm1FbAti2NgGwLZLYqNqqm1BbTYbVVtUbKtgNq2pshtVstls2RtKm1bStgbA2BtspspsNjYti2pbZhbKNjaVbWwm1sS2TZItqtkG0o2jajNK2ktkWytlJtFtbVtspsTZsW0NobCtjaGym0TMkbLNsbKbWwLatqm0myG1tKbbDZRtbC2ptVsbKtq2JbIbNqS2IzBtFtE2SbSWyk2ptJbSm0Lapso2DbYpmRtGyNratkbJbTYNqWaVs2U22UtpLaVslsE2QbC2bQtpNhW1rSLak2q1hs2qozW0bJLYo2htNjZW1bbItqNkNlG1NosWobCNqRtsg2qW1bI2qm1sGyDa2bUpsobSmyTai2bSbQLZtG0tjYzKLaE2zEthbKq2VW1WwptDZQ2k2lNkltUWyqtoNpRtAbNkDRYK2pW0RpaLFqpshsSNqTFkG1BaWiyjVUMrVVpahNqkaWUaWlotVWlqpGlotLFGiyWlkphitg2kNpG0GapYsBmliWi0tSGzZUtqKtLVZRpYaWmAxZFpaWlqjFiI2SxYI0sWLS0WqMWkTFkWlqIbNtqqNLVGlqqyso0siyjRaLFDFqRm2CrMzFJpYlpaFi1WlpaWiytLRZRpaLSxaWqNLFktSNLJaWFGxRWLS0sAYslktIyWlpaWlqjS0i0so0tLFktLVJiyWS0rZAbImS1FparSxLS1FiwDSyUxYUaWqNLJaWS0tFotLFpaWKGLRaWotLKq0sDZFW2zMWaqxYqNqjZKbVVZWqrNKMwGlpbItLKjFpQ0sWllWLE0tUWlpYtVVotFixbVViwrZrZkqtq222bAmlomLCaWoDSylNLJaWqI0tFiyWllVaWliyWRZLFiMo1Ri0tLJDS0WLKMWli0Wli0tWttNqpWytsttmNs2m01ttaNMtFlai0tLYVWLKpNLSU0slpZFWLSJpaLSyWlpaWi0WLRZLSwVqjUWLSyWotLVJpYslosWS0tCxZFixbbDbNrRtrbQNqSbbI22bYzNbWtmNo01lsZts2s1ssttg222rY2zaJiyC2IbQDFiksWUTS0qrFotpaLEsWpGLKMWVWlotLAWlotLVGlosWLakYtUZLCyWlpZRpYsWi0sWFlGLSNttlm2xts22mtZtmZlsbEM0VbKW0tmw2bLbbZLNTaNrY2bVtNhmNi2bVtsmzNVbRbS2A0tSmLJYZtS0tSpWlkqWLJUMLSMWVVaWI1KZSbbLZDZttttbWxfv379+/fv37t1k2TZNk2TZNk2TZeOM4TbaobILaottlNlNpEbImyixZAGlpYsiVi1ImLKkYtSMWijCwsLE2VNiddddfv3795+77779/vybbNpbccHC4ybJsmybJsmybJ1111+/fv3f7vvvv34mybJsmybJsmybJsnv379999/e/v37999psmybJsmybJs/ZtrccMgSQgSGhoNl73vuwBvet5znNcECRDZNk2TZNk+ccJxxwnFXHCcW666677+fe/v3567TZNqbUtk2TZNiFUQqiDd+Wrjme8SFUQqghVEn1Uy4uHFNjWlbU2nGT3786/J+/fu/3ff314mybJsmybJsmybJsnb378688878+/fnrxNk2TZNk2TZCqIVRCqIc42vQBxVb9IVRCqIJECRG2yBIgSIEiBKILO7ve+973nOcnwAgAAAAAAAAAAVVVAAAAAAAPMzMszM+vqv1V9++/E2TZNk2TZNk2TZNkLu73d11VvSFUQqiFUQqiFUQqiFUQqiFUQu7vd3XVW9IVX1SeUQqiNk2TZNk2TZOuuuv379+7/d999+/E2TZNk2TZNk2TZNk9+/fvzzz4Hnfnnnnnv4mybJsmybJsmx+OOE2p1111+/fv3f7vvvv34mybJslUQqiFUQqiFUQqiF3d7u66q3pCsmybJsmybJsmybJ9Drrrrzzrzvzvvvv34mybJsm37TjJsmohVEKogk9999++78/Kt6QqiFUQqiNk2TZNk2TZPfv378888+h35555576TZNk2TZNk2TZNk2pzfuvNa1mb5zfvO970AAAAAAAAP2ZmDwAH9/Zn9/f38ZmZmEAAiIiJllkERERAAAAAAAAAAAEqqqqrsJW7u7u7qrek+o8ohVENk2TZNk2TZNk+fPnz5+/fv3nfffffvxNk2TZNk2TZNk2TZO9O97u7uqr+AL0hVEKohVEKohVEKqBVT6oeUQqiH5AM8zM++9+1Vb0hWTZNk2TZNk2TZNk+/Pnz5888+edh55555576TZNk2TZNk2SqIVRCqkO973u7u6qt6QqiFUQqifeeEKohVEKohVEKoh777779999qq3pDZNk2TZNk2TZNk2Trrrrrzzzzzvvvvv34mybJsmybJsmyVRCqId73vd3d1VfwBe/VJ5RCqIVRGybJsmybJsnPYfePv37+/fP3ngeeeeeddJsmybJsmybJsmzWfPmtZZ5915mZznOfu9dqqqAAAAAAAAAAACqqoAAAAAFZmZmh54u7u7mZmbpCqIVRCqIVRCqIEojbZAkQJEF73vfe97xjGMa0QJECRDZNk2TZNk2TZOuuuuvPPPPv379++eJsmybJsmybJsmybJUnbu93d93MzZJPqgAX3ve7u6gGKv3U2TZNk2TZNk2TZNqde/fvzzzz559+/fPE2TZNk2TZNk2TZNl+z5111+/fv3z99+/f3ibJsmybIqiFUQqiFUQqiFmAHvvvu73fczM3SNk2TZNk2TZNk2TZPr5111551588+/fvnibJsmybJtG1+04ybJsnzrrr9+/fvn779++eJsmybJsmybJsmybQNx9D967D333333+/v5VVUAAAAAAAAAAAFVTMzB4AAAAAFVV3MzPuZmfM3ffnnnnnn3sPPPPOvabJsmybJsmohVEKohVSHbu93dc1W9IVRCqJ954mybJsmybJsnYffnz5+/dfu/v7vvv34mybJsmybJsmybJshnve93e65qt6QqiFUQqiFUQqiFUTZNk2/avnXXX79+/eff3fffvxNk2TZCqIVRCqIVRCqIVRC+973d3dxVvSbJsmybJsmybJsmye+uuuvPPPPPvgeeeede02TZNk2Tav3HCbJsm1PnXXX79+/d/f3fffvxNk2TZFUQqiFUQqiFUQqiHe973d3dVW9I2TZNk2TZNk2TZNk6666688888777779+Jsm37TjJsmybJshVEKqQnq/uXVqv3332ZmZmZiqqqoAAAAAAA/u973oVc7VVAAAAAP2AK/szMzMQDzxeKqqt6QqiFUQrJsmybJsmybJ1111155555334HnnnXpNqWybJsmybJsmy/UeVIe++++/fffaqt6QqiFUQqiFUQqiFUQqiFUQqiHe973d3dVW9IVRCqJsmybJsmybJsnXXXXXnnnnnfffffvxNk2TZNo2v2nGTZNk1EPfffffvvvtVW9IVRCqIVRCqIVRCqIVRCqIVRDve97u7uqrekKohVEKybJsmybJsmydddddeeeeed99+B551ymy/ccJsmybJsmybJqkPfffffvvvtVW9IVRCqIVRCqIVRCqIVRCqIVRDve97u7uqrekKohVEKRAkECRAkQJbUQ0QTS1a3m9bb3veMYxiqAAAAAAAAAAKqriqqAAAVVVVVXN+3d3d+nADQBu/ud+3XXvvvv3+TZNk2TZNk2TZNk1EO973u7u6qt6QqiFUQqiFUQqiFUQqiFUQqiHe973d3dVW9IVRCqIVRCqk+88IVRCqIVRCqIe++++/fffaqt+JsmybJsmybJsmybJ11111555553334HnnXKbJsmybJsmybJsm1OuuuuvPPPPO+++/XibftOMmybJsmybJsmyfvnz589fv3795333368TZNk2TZNk2TZNk2T3d3u7u6qt6QqiFUQqiFUQqiFUQqifUeUQqiHvvvvv3332qrekKohVEKojZNk2TZNk2TrrrrrzzzzzvvvvwPOuE2TZNk2TZNk2TZNqzznmtZnOc953vVVVQAAAAAAAAABVVcVVQAAAAAKqrWZlVmKqqrekKohVEKqBVT6oeUQqiFUQqiFUQ99999+3XMzMtIVRCqIVRBIgSIEiBIgSIEiDd73vfWtaxjGMV0Q2TZNk2TZNk2TZNk6666678vPPO++++/fi/ccJsmybJtS2TZNk2Tz79+/fv79+8+/fv3wO+uE2pbJkQJECRAkQJECRAlEGr3ve+ta1jGMYr4mybJsmybJsm37Vxk2T33333d1zMzLSFUQqiFUQqiFUQqiFUQqiFUQ73vevxu6qt6QqiFUQqiFUQqiFUQqiFUQqiHe973d3dVW9IbJsm1fuOE2TZNk2TZPPv379+/v37z79+/fvgdZNk2TZNk2TZKohVEKqQvyd873ru7mZmZmYqqqqtVVQAAAAA7ne970KudqqgAAABVVcczMzADzzzFzMzMzL0hVEKohVEKohVEKohVEKohVEO973roTd1Vb36oeZPrjhNk2TZNk2TZNk8u++++/37zz79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KqqgAAABVVUBVVUAAAAAAAqqqAAAAAAAVVVAAAAAAAKqqnMzMPoAAAAAAqqqAAAAAAAVVVAAB3wqX1FdB6gr0HPEIPSpcB8UPYfA4Uug1S4QnKlg9VL4Hopdh6DsPZK+9yrFOGETKlqRPodc+/nr5cgAKqqgAAAAAAAAAAAACqqoAAAP7PmZmffne973vvVVugAAZznOa3dqqqvc5zn36AAB836+/fvve96qt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADOc5zW7tVVV7nOc+/QAAPm/X379973vVVugAAbu7tVVVu8AADd3dqqqt0VVVVVVVVVVXzYSEr97z3nu7uqqqrmZlVAAAAAAAAAAAAAFfczMqpp74qqqqqqrvABAOc39u7uauZdgAAWc5zmvm7VVfOc5zvfc5zm/oAAGP9v+99971d799mAAAfMy2qu9+2YAABmW7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVe5znPv0AAD59+/fv33ve9VW6ADgN3d2qqq3QAB8+fM+eWZmec5z3jgAAAAAAAAAAAAAAAACqqoAABVc5znz58qqqq3QAAP9znObu/7aqqrdAAA/27v+2qqq3QAAN3d2qqq9znOffoAAHz79+/fvve96qt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AAD97z59+/v37faqqqqqoAAAAAAAAAAAAKrWZlXFVUAAAHmZmczMzzw2IDuZmc4AAB8+/fv3773veqrdAAA3d3aqqrdHvj85znz4AHz85znz59+/fv33vVVW6HD8cfm7u7VVVZ+c0cDd3dq73ve9tAAAbu7tV3ve9tAAA3d3au973vfc5znvoAAHz79+/fvveu973vtAAA3d3aqqrdAAAfO53nOczvf3v2oB+1mYPAAAFVVQAAzAAHe973ve970AAKqqgAAAAPmZmdzOcfPe973veqrdAAA3d3aqqrdAAA3d3aqqr3Oc59+gAAfPv379++973qq3QAAN3d2qqq3QAAbu7tXaqt5v4/AAbu7tVVVugAAb3veqqqve1XoB55555VVVV4AeeeeeVXvvvvqqqr3tV6AeeeeeVVVVeAHnnnnlV77776uc5znOc2slcAbbaSSTAG22k9YolguZmft+W7veiqqoAAFVVQAAwAAAAAAVVUqqoAAAfszM+/VbVVV0A99wA88888qqqq8APPPPPKqq/ZmZm7u6qve+gHnnnnlVVVVVVVVV77776rVVboAAG7u7VVVboAAG7u7VVVboAAGc3d2qu973MAAAy3dqqqvc5zn36AAB8+/fv3773veqrdAAA3d3aqqrdAAA3d3aqqrdAAOH+mc/337/v37tVVVAAACqqoAAqqqAAAAAqqmj6AAAADWZnmZmWZmeePAgr0A7RRRRQBVFFFHe971VVV70rgAA3d3aqqr3Oc59+gAAfPv379++973qq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d3ve973ve+5znPv0AAD57ve9773vd73vd0AADd3d73ve973u6AAAz9zn7v7/v3aqqqqqqqqqqqqqgACqqoAAAACqqoA1mYAACqirve973v3MAAA7mfMq72ruYADnGZltVVVugAAZmZV3tVe5znPv0AAD5959+/fvve96qt0AADMzKu9qrdAAAzMyrvaq3QD7znOfPnz58A+/fv37VVVboAHvznOfPgffv379971VVugAAbu7tVVVug222222zypfwFLVLFLVLLWa+1V/f39/AAAAAAAAAqqqAAP7ve973vVVXO1VQAAAAH9rWZn5z58973ve96qv7nOc+/QAAPnPv379++973qq3QAAN3d2qqq3QAAN3d2qqq3QAAP7n379+/fb73ve973t0AADd3d9VVVugAAbu7tVVVugHDjjjd3f3nOc2r9qq3mvwOA4444bu7tXaqs3gA44Dd3dqqqvwdfG2ZtmbZuPylql61S7D0Of39fwAPmZmAEAAAAAKqqgAAAqqqAAAAAAPmZhoBgB5+3ebu7qq97VFFVVUUVVFd73u1dqq3eOOODjgN3d2qqqzfznOHBxxzhu7u1VVW6AABu7u1VVXuc5z79AAA+ffv379973u973ueAAA5u7u1Xe973IAADd3dqqqt0AADczKu97VbrgAAzd3aq7Ve5znPv0AAD5978/c/b/fPc+5yvbnzMz78++5+dyFXOFdqWUvapb183DrOLfcBy226OgiJIghBEQkQBF6ZxhYpm18KDc1LOINlLpSypermhOCEr1UcUJ6qWVHNUHLAFxUt70icapZSxSYqwBJySEqBCAUAeVmV+czHFVVVBVVUAAAAAAAAAABznOc5zgAAKqqgAA+/foAAAMAAAAVVVAAVc5znFQAAAAAAAAAAAAAAAAAAAKqqh8zMwAgqqqAAAAAAAqqqAABVVUAAFVVQAAAAAAAAAABVVUAAA5znOc5wAADmc5znOcAAAVVVAAAAAAAKqqgAAAAAAGWvPlVfqAAAzAAAAFVVQAAAAAACqqoAAH+AA6AAKqqgAAMwAAABVVUAAAAAAAqqqAAAAAB7mZgbFVVQAAGYAAAAqqqAAAAAAAVVVAAAAAFVVSqqoAADMAAAAVVVAAAAAAAKqqgH7B4AAAAAVVVAAAa+yUuQ6D6HJKXAZSllL6pfQ6DsOg9ByHIe/QZS9Bgyl69VLqiTVLVQfKlqE4Sv0UuQykl65+dfLs6AAAAAAAACqqoAAAKqqgAAAAADua1ma19+5mZu7u7uqrpCEnvtVVeQDzyqqqqq8gHnlK0nARAPGMY3ve94znObWSS1ADaSSSTg5z58Pu7vve73vqt0PfnOc+fAAN59+/fvvertVugAAbmZV3var3Oc59+gAAfPv3nOc+/fvve96qt0AADObu7VXardAAA3Myrve1W6AABnN3dqrtVugAAbmZV3var3Oc59+gAPnz58+fX2qu870AAAAAAAADM0AAAAAqqmj6AAAAAKr/c5znec5z5/r/VXbtVugAAbmZV3vardAAAzm7u1V2q3QAAN3d2qqq3QAAN3d2qqq9znOffoAAHz79+/fvve96qt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0c4c4c4c4cOHHN3d1VVV0A7Paqqqqqqqq8Ofr577+v3d1VQAAAAAAAAAAAABVVUAAAAAAazM+fAAH798AABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVXuc5z79Afj8fj59+/fv33ve9VW6B785znz4AH379+/fe9VVboAAG7u7VVVboAAG7u7VVVmAAAW7u/tVVXuc5zdAAA+Y5+c/OZmaz7+8/fu973oAAAAAAAAAAAAKqriqqAAAAAAO5rXPz7znOf7/e97Pe96qzAAAMzMqqqswAAC/N3d/aqqswAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqrMAAAzMyqqqzAAAMzMqqqvc5zm6AAB83d33ve96qzAAG22++FQn6paRDzCJ88Drvd9/ur+AAD9mZlfaqgAAABVVUAAVVVAAAAA9zMwNgAfOc5z3Oc53nOc+f73v33ve9VZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYA/DnA5w5z8OcZmZVVVe5znM5oAA+bu773ve9VZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZm22222222zv589eCuPOKl+Un0Pvve77f39/A/ZmZX2qpVVUAAAAKqqgACqqoAAAAAABX9mtZpnOcfnOfn5z8/3+/1VXqrMAAAzMyqqqzHOAAzMyqqq9znOboAAHzd3fe973u97+/oAAFzMyrnKu97+/oAAFmZVyrve/v6AABvLd2qu/ne9zAAALm7u1V9+/f39AAA7mZ3ve9+/fv7+gAAdzM73ve973uYAAPnz598/fLf3XznPP3sgKqriqqAAAAAqqqAAKqpo+gAAAKqqgFaSE/AGAHxIS73m659mZl3VVVVVVVVQMzM73+5z8qqswAAD7u7tbVVZgAAGZmVVVWYAAB93d2qu973MAAAzMzve973ve/3Oc5ugAAfPZx9+/fe973379/f0AAD9/bO973ve97mAAAZmZ3tVVZgAAGZmVcqqswAAD78/3ufv379z3r3qq73ve973oAAAAqqqVVVAAFVVQAAAABVVVVWAbJCfEhKJCNEhOc++v7+5/f39VZgAcPz7u7tbyqq9znOboAAHzv379++9vPe9VZgAAHvznOd+/fv33t573qrMAAA+7u7W8qqswAAD7u7tbyqqzAAAPu7u1vKqrMAAA+7u7W8qqswAHAfd3dqrve9zAAALnN3dqrve9zAAVVVVVw+AJ5393q7uqqqqqqqqoAqquKqoAAFVVxVVAAAAAAAVX9z8/Ofm/7/e973ve73vcwAAC/Pzm7u1V3ve+5znN0AAD5u7tVd73uYAABmZne973ve9zAAAMzM731VVmAAAZmZVVVZgAAGZmVVVXuc5zdAAA+bu773ve9VZgAAGZmVVVWYAABmZlVVVmAqqqqqqqqrzz0A+MALzMzdc1VczMzMyA+ZmYAQVVXFVUYAAKqqgAAAABVVVgCqqqtAHxJIBgBgB/v33sz3veqswAADMzKqqrMAAAzMyqqqzAAAMzMqqqvc5zm6AAB83d33ve96qzAAAMzMqqqswAADMzKqqrMA4AGZmVKqt3VVWwDzyqr7z9AP3lVVVXvvvv333yrnOgC27zAEtJJJS5gBkykklM3ve+973vec5zXVtwBLSSSUuYAlpJJG8brrd9Wv3Uvil5z88+fP3puN17549+RXrxFxUtUtUs1SzKWPWqXEpZsypZ73FSzVL775ueePTHP37zOWzL1hP252UvfT3x16qXr29qX2pcekMzS2JlLMpcPlS4lWqJiJ8itUtSlqllDSJwpaqYi7cVLhJJlS0Ib0GlLgqWUsFZS1Syl6qWUuKlqlqUtKWKWpSwVlSYpZS1S6qXCpcQFkVqoetKqnFS0papYq9VLSKuFS4FXElDwAQDgBgBwAqqIGc9X3vqqqgAAAABVVUAAAAAADnOc5znAAAVVVAABv9+++++ioAAKqqgAAqqqAACqqoAAAAAAAAAAAAAAABVVUABVbzMyq2AAFVVrMygAAAAAAOavlVUAACqqoAAKqqgAAqqqAACqqoAAOZrOc5znOAAAGVVVAAA5nOc5znAAAFVVQAAAAAACqqoAAAAAABmgAAAAAAAAVVVAAAAAAAKqqgAAf4ADoAAAAAAAAAABVVUAAAAAAAqqqAAAAAAAAAAAAAAAAqqqAAAAAAAVVVAbzMwHoAAAAAAAAAAAAAFVVQAAAAACquc4qoAAAAAAAAAADvvvvhUuA7D4HMOQylxUvhSyl8UtKXYfZS6ImUT2GSTipYqWUtKXXT+AtXOn6nQVVVAAAKqriqqMAAFVVQAAAAAACqqp3WszMz/D5HPP79+/fv37933335+xtS2lLYpfPm2wAB/ufnPzn5+ffv37/f39/e9VZgAAGZmVVVWYAABmZlVVV7nOc3QAAfN3d973r1VnM/H4ADMzKqqrMAAAzP2q73vazAAAP9mZVV3tZgAAGZ+1Xe97Xuc5zdAAA+bue971d76zAAAP9+35/t/d/arvaVVVAAAKqqgKsqqAFVU0fQAAAAAAKqqnGZme5mZvfj0QrMAAAzMyqqqzAAAMzMqqqswAADMzKqqr3Oc5ugAAfN3d973veqswAADMzKqrvf39AAAsZlVV3v7+gAAftmVVXe/v6AAB+2ZVVd7+/oAAH7ZlVVV7nOc3QAAPn7/uP38zM5z8/M1+zMz789973ve10qqqAAAVVVAVZVUAKqqgAAAAAAAAO5rRFwDcRBFKb3u2973nOc1qkkkkkkkklWtcqqqswAADMzKqqr9xx+PwAzMyqqqzD+/Oc58+AHz85znz4G7u+971VWYe/Oc58+AHz85znz4G973d3VVdAO9qvIB55VVVVVeQDzyqqvO7u+973vVWYe/Oc58+AHz85znz4G7u+971VWYe5+c58+AAG7u+971VWYAABmZlVVU5znMwAB8+fPnz7fvvn3769KgwAAAAKqqgGhgCqq4qqgAAAAAAAAMA2QCHnm7u7u6q3dVVVVVVUFXe97u+973vV7nOc3QAAPm7u+973vVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVf7nOcs+AAAczMyqqq9znOboAAHzd3fe973qrMAAAzMqu973tmAAAfMzKqu97ZhJJJJJJJJU3uIgi7vgAsUnG97vvZnLzkAAAfszMHgVVVAVZVUqqqAAAAAKqqqqqqq2AKvFoA+AK83fe9Xe97mAAAe3d2qu97395znPc5zm/AAAPjd3arve97mAAAZmZ3ve973vcwAADMzO976qrMAAAzMyqqqzAAAMzMqqqvc5zm6AAB83d33ve96qzAAAMzMqqqv3H4ABmZlVVVmAAAcze78/e71rWa+eefu96V0AAAABVVUBXtleVKqqgAAAAAAFVVQA9ADSQnQDnN3fd93VW7qqqqqqqqqqo3m7u1faqvc5zm6AAB83d33ve96qzPc5znz58+fAADd3fe96qrMAAAzMyqqqzAAAN5znN3dq+1VZgAAG83d2r7VV7nOc3QAAPm7u+973vVWY4AAMzMqqqswAADMzKqqrMAAA7z/e5+fnPzP785z857ee/3P7+7X8VVVAAAKqqgKsqqVV/Hdd7973vegAAAAAKqqgBzMzLMznvzn5+c/HOc5+/vv9nve96qzAAAMzMqqqvc5zm6AAB83d33ve96qzAAAMzMqqqswAADMzKqqrMAAA/ec5zGZVVVZgAAH7jMqqqvc5zm6AAB83d33ve96qzAAAMzM73ve973uYAABbu7VXe97WqSSSSSSSSTM0WiIIkyATgAssXtXvO9BVVUAKqqqqqgGDAFVVQAAAAAAAAKqq7ma1muZmZ547+1Xe97mAAAZmZ3ve973vcwAAD35u7tVd73uYAABmZne973ve9zAADhmZne973ve9zAAAMzM73ve979/f0AADuZ8zve973v1znOe5znMwAAD/f795n+qq+/fv7+gAAfv7+973ve973uYAABmZne973ve9zAAAPX2+5/u/7v37wBVVUAAAqqqDgVXOXFVUAAAAAAAAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

