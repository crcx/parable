#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if math.isnan(opcode):
            opcode == BC_NOP
        else:
            opcode = int(opcode)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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y88u/CqcpzzMHwojvt1eRqzRrV73V7m4XOcrMzlTRyGdoDsGw2tKEDkKuiEJCokmQpjLyH0gIoKagACI9igiCagIASXsvu9bNxNR1MvV2w3PTcDUdwERyxKVEf8/0SuWUAdgO4CJUaIUfeD6tkuempZqPDiIkiIkgon6T9+VWxVG4gSMgMgEgQVZFVneb7zgJ79+xAB0kkYgBFVgIDcRA1ap20QClkkkhJIiqSIqmCEqs1md9nn98qtCrOCqz65999z777yKISSJAADyhJJOB/cbhQm+NtpxcoANqr9UkhAiRhZ0VbVW0RflQCFUVUUAaYFV9v7nfvsVVzuZWYHEoQxJJJ84235t/RERFsCjAPRChfbVX6/vvvufe++/IifCichIieoRV6+/dX1d/d3ZoAFQAPP2hJJckAPP8X3rfm99G4oiIlRzecbeNvyiIgkAAPoiIaVXEVS5mZmezM8OhVYCphAjAkOlUCrJmazmZmIAYKsAAgiGRRAOCJFfXQhYqsQVTUvN5zMzyoH0RET5FUmgoACvvvvvvvP7ySUQkSAYBaqFERGAfWYA/xbu7u7u72PQTwAA1xERDbbbbAAAAAAAAAMzMzMzMzMzMzMzM0akADxOx8222+jADW+pQm3lN/Nttjnd9r4229Ua22m2222222wAABtttttgAAGYBVABtVVdShQm382AAfszMzMzMADQBAAABmZmZmZmAAAH6vMzMzMyYAH7Mkkk73MAAZdc5znMzMwAzMzMzLzMAAAPzWeZmZmZgAfszMzMzMAAABrbbbbYAABrbbbbYAAA1ENttttuW2222AAADbbbbbAAAHCbbbbbaht/NuFCbbbYAA22222wAABttttt622222AAAa28zMzMAAAAAADMxtttsAAAAAAPJQoTTXG222wAMzMzMzMwAAAAAAMzMzMzMwAAAyr/Xd1d5H6CyIxESCMgClTl39999z779mZgP2ZmZmZmAAAAAABmZmZmZmAAAH5mszMzMwAP2ZmZmZmAB6zWZmZ3MwAAcMzWa5qszPczMzMzMAAA93d3d3d0AAA1v8bbbYaAAbHfuQnrmbvzvd3btskkkltttu7u7u7oAbbbbbbf55vjYB73veYBrbbbbfiQAAAAJbQBmZmZmZmPe973veY22223C2d3d3d3dAAAG228zMwkkkkgB+zMzMzMztngD9mb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SSTt6sAADPar33mZmSSSqAAAd5uuczMzJJJVAAAXvd3JJJJJNa81dgAAc3vm/Nea5yS5JUkzWvNZzg1rVa1eta1OfX9d7795vncxgR54ASSSSSSSSQASSSSQAAAAAAAAAASSSTp73ve94ABrl8u6t2oSiG2xy22AG1qwGtA5vfOZmZkkkrVB3ewAN57evfbzMz77JKoAADVautXJJP36fb2AABnmrarOZmZk+yZjzWta65wAABXu689973veySTLsAADm+d973veyZkqgAAJyuNa81y5JPv0kqgAAM5Vc5mZmSSStUAABe93ckkkklUASSSSSSvX75VeMS6O+ParR77M+5zPVv3nwWgC0eZnMPYtAFtttAAAAAAAADYOGqAIoH1VdD0H1fvruz8idVKuLosJqWT6av3vcP2+34BD9f7mZmZkkkzWvNXYAAHN75zMzMkknbsAADm9853ve/ta813uVmZVAAAXvd3JJJJJWqAAAzlVzfMzMyfpJVAAAXvd7uSST9JKoAADvK1XOZmZkkk7rXmrsAADuq89u/fe973sk7mXYAADjd3mZmSSSqADutb3vzze99aNXar9d/fd3d2ZmZd913bdtVVUi2tVVWRC++XNzCreP4mZmV7En9VHdG2kwAAbQF5b7oAtAFttttttoAAAAAAAAAAAAPuZ7dXX3ff2v1VdfvrzHz3uzuzMzczMy+8a4VVWqW7u2qV+X77u7uzMzNCHnlLUILy2qLVK1VVf1V773ve9kmZl2AABze+853ve9zMkqgNABe93ckkkklUAABnKrnMzMySSVQAA0ve7uSSSSSqAAAve7uSSSSTNa81dgAAc3vnMzMySdzLsAADm93eZmZJJJdgAAdmnm9ea1r9fuSa3aALQBbbb3ctvVtBJIAAAAAAAAAAAAAAAZ529eaa15ppzm+Z7mfZmZmZJJKoAAC97u5JJJJKoAAC97u5JJJJKoAAC97u5JJJJKoAAC8quczMzMkkzzXmrsAADvtV773ve9kklUAABe93ckkkklUAAB3lVzmZmZJJKoAAC97u5JJJJKoAAC8quczMzMkkzzXmrsAADe91d+a5zl8zMzIALQBeZzLbbctttoAtAAAAAAAKAAAAAAAFeVV0zzd2zmZmZmTM7mZmVQAAF73d5mZkkkqgAAO8quczMzJJJd2AABve7uSSSSSqADNee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UP3qLiMFWAQgyMjIoSSCaRD1Aqmua17v79+xFU/fU/ffWImsz26rMzMzMzAAAAAAAAAAAAAAA9A+ACwAAZV1VecoggdKh36EPghX9/egQnnqE6u79u93d3uZmTl2AABze+ckkkkk5dgAAd9qvfczMySScuwAAOb3zkkkkknLsAADm985JJJJJmtea95wAAD3e/e/u973MzMnLsAADm985JJJJJy7AAA77Ve+5mZkkk5dgAAc3vnJJJJJOXYAAHN75ySSSSTPNea95wSSSSSSSS0WQ5et8Nwn5VZUTnO65rd3dsDYiIhttttsAAAAAAAAAAAAAAAAHgaHQgAKAkkkkgCJrXmq3VTuZmd7mZkkn3LsAADvtV77JJ99999y7AAA77Ve+5rzzMzJJJy7AAA5vfOffffSSSe3YGjwOb3zkk++++++zWvNe84AABmv1V+793vckk+5dgAAc3vnPvvvvvvvvuXYAAHfar33uvPMzMuTck95YAAHu985JPvvvpJ7zgAAHu63vMz3ve974E5vckkkkkkkkn2+/hV9RKrK8k52fu/vwe9PB8AAAAAAAAAAAAAAACNAASSSSQSSSZrV3d5zmZmd73veySfb5ewAAOb3zn333333333LsAADvtV773XnmZmSSTl2AANcb5z7777776Se815r17ywPe973t1KFPcULV7nvZ7d1gHrpQvkr5f1+973ve96bpQt+UZ9n2aohtsAJump2eTMxKUKeTxTSjvO/d3d3QAm62dmZiOz3Ott+973hKFlqFvxKiIjJ7KnPJd+v3mMAAAAAAAAPKq6AdAAAAAAAAA+HtUCgSSSSSNAcqrruXSXpiOpQp5KiFCc8cKEcDLzPdHu7u6AelXShXN1fve973vem6ULc5lrVENs973ndKFy+XYAe97xdKFc3fve73ve+aULLUJrvO930busA9KulCubr3vd73vfTdKFqzmXqiHu0N765md+u++wBfO85nvz3555baD1im9CV8HMgaDsXcGTKoVXQqsFWCrOirBVqr+0ABvaq6vtXYq5q1V+znb2qvRQDt9BVsVYSwgdO1oOnrVXmVzW5NXqpWtVV81qXVTs7oCqomaLmuF7jZziq2quxV17315eHtC5d+197Rd/WGUH5zt731fsqHh5KKGftDEQD4RIBwVbqu/t85v7PsQ1FkJEgIHVVkESKrAV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ALAAAAAAAAACubDj4AAAAABcUQnkKF8lClfQXT+xvzbbbAC6qYUylc8uwAAC6UJws5mY31N8cuXLfFDlKIyYtQsnMxtvdbbd0oVzd222ABdKFuczMbbYAXShXN3YAABdKFc3dgAADShZahZOZjbYAG5ahZOZvd3dbbZdKE7997Gjve/d+O9fRtttvMSSTckwEkn0PQABYAAA9A+AAAPQPgAAAkkkkg3VXWVtzme8zGNttgBdKE85mY22wCvlCL5d0AABXyhVNUAAANKFdKFucvd3dPe0LpQqvl2AHvBX0JRt8pttnvMr6FEVPwAe94C2rmZmVOzHEoU8nk9nve7u7oAXShXN3YAABdKFfSWl6VERFcv6I5sREQHuz+6uoOySSPV1ySTuZJJ4SScySTuYiIit3iiIjaiIiN3d3d3WAAAAeJAUAWAAAAAAAAAABQAJJJJIG6oiIkzMzexERHd5EREc9u7u7u6ADhQstQsnMxtsADctQrjOcze7u622zl0oXIvnLeNttts4rpQthJL5LPuZjbbAB/KYWWoX0LOcze7u622ziulCufrsAAAulCeczMbbYAcShXXJmVMqLnl2AAAculyUlc8uwAADjShZahaSoiIvlqru7nNzU/fp+/EAAAAAbBwAsDyqugHQAAAAAAAAAAAAABaUJq5lKFnEoXaSaUL6/e9bzdb3d3d0BBdKFc2rsAAAuklUrc59mNtsAPZauYSnOczDoAAXShXN3YAAA0oWWoW953vd3dYAXShXN3YAABdKFuczMbbYAXShXN3YAABdKFc3dgAADShZahPO9LiPKYc8UpREQpn6qFXnKABew9BVsVe0quxVkFW+d2HjkX1amgLqpGPZQqwrsuwAJE4EkkkjQn10j1VapZCSQhFJGKrwVYqrvvvc1Xr1foXfOWd92+xR7OtAPwduhRLNSNQKZGaMCKiaBEsFU9fea7mZ95FDUVEVyZmPpO1V3dzUgegAS6q7u6oAzERF0RBWMVV1DJmZne5mZmZmZhVACU0A3dXd3XampNySMu7q02228beVERESqshKElHK/R4dwAnzAAASrq7urv6rq61daleVbXjYJd1d1bQBKq6uq+uq1Q2BdXVXaqqqrVXVVWtAE8p4JOzVduqq6mpIPGkpJQk+Nttt+hQoUIkAAPKIiCQAJJJJIAASVJJJAAAAaAIy6urvMzMCSSYAAkkkkgAAAAABJJJJB9Q9AmXVXV1rWZmZmZkwAAAAFAEkkkkAAJJJJIA7GvAEaAAAd73ve96AAH1XfOc5wQAAXySeySQAAl1dXQAgAAkkkkgAAgBbbQAALbbbbbbaEkkAAG7kk3JIAAJJJJIAAJJJJIAAN3JJuSQAASSSSQAASSSSQAAbuSTckgAAkkkkgAAkkkkgAA3ckm5JAABJJJJAADLpqq1q6zMzMzMmAAG7kk3JIAAJJJJIAAJJJJIAAN3JJuSQAASSSSQOBsCSSSSPnTd+gDdySbkkAAEkkkkAB+EkkySYFABu+9773vegAA73ve970AAFgAAAJJJJIAAAfszMzMzMAAAAAAkkkkgAAAAAAJMqqoBmYAAy6rOPfqqyIKcREgokVD0UH6RAIg+rPUCYd+PUCJ372BV0oClkUT1NCJTIhAkmwAoESKL018CeBPIneAggdVFXQJdIirSAHa9SAHgTXFET75E8iYidRLBLBJzQJEANIkBOCA63vdwQDQKq+9yHl3dNjCQAA8BSiIjsJJKOSohBoRIADqIoHp72/c97MVXMzMzDM8AA8ByszWZmZ07zvfs/r8V7Sq3dCq37tir73QT9pVf0VX9/VKKu/1Cr3Mkk6iSSdQEIdz1Qkk7d3d3d3MzAHA2AAsAAAAAAAAA4GwAAAAAAAY+yszPoiIjJUREQ5UREOd1vd3d3QAM3JlTChTs8mJShTyee573vbu6AF1DShTs8mUoXOcXed73d3dAC6hpQp2eTMpdnve7u7oAXShXN3YAAA4ULLiFk5mNtga233FC7OZmNsAC6ULc5mY22wAulCubuwAAC6UK5u7AADKu6+5V15VT3yu773uYzAAAAAAAALAAAAAAAAAAA9AGAAAAAA1GKIXEoU3d033d17u7u6AF0oVzd2AAAXShbmZjbb8wLqIV3dgB4AulCu7sAPADhQstQsmMzG2wNbeWoWXdttngC6ULczMbbfmBdKFc3dgAAF0oVzd2AAANKFlq68k53mVzXldrVa1rx75x33mQ2AAAAAAACwAAjVAAGwcDYONg4K28D4QAA2G7po8zVNeau7rWuTc3LnM3d3d9u7oAXShXN3YAABdKFuczMbbYAXShXN3YAABdKFc3dgAADShZahZOZjb3W227rqnecXEoU8nkzznJU953vd3d0ALqEnnMzG22AF0oVzd2AAAXShXN3YAAA0oWWoXEoSE9AFQbiggXUhGHa73v32fZ+++++v7MzM+ADQBAAASSSQttoAttoEelttAFttkkkkgAAAndXX67u719997VXWPmPzbbbYa28tQsm73N3dbbZdKFc3e42222y6UK5u7AAALpQtzmZjbbAC6UK5u7AAALpQrm7sAAAulCubuwAAC6UJ5zMxttgA4ULLULJzMf332ZmZn7mxPygqGREVO1QCq7FWAKrRBVZckpFVNp7m/E9+/Z+zEAAAAAAAJJAWzM5lvsBhbbQBbbQJICSSTySB0AAOVV1n1VdC51KF5cShNKFdAX7rG222wAeWoWfczMbbbALpQrm7sAAAulCeczMbbwHN1dc1znAA5urrmuc4AGVVrLULJzMbbAA3LULJzMbbAA3LULPuZmNttgF0oVzd2AAAXShN95EREfTERETK1LtVXq93dwUREbu7Ubu7S3W6bbeZmYbBw4HOBwHaAk73ve97JJJJJJJJJJJJJJJJ1JPkkkkBczMzM973ve9xB5PyAGkSKIBzl8/ffd0e7u62AF0oVzd2AAAXSSubuwAABpQstQsnMxtsNbbylFTCmqbb8wC6ULc5mY22wAulCubuwAAC6UK55zgAc3V1zXOcADm6uua5zgAC6hzET5QsmZmZXSlzcsKhb43Xu7utvMwAAAAACSTve/fffeeeSRwAkkvACSS8B8E6ktyeSSAEkkk7WV7q6qqrt1da3VXXmvK2IiI73Prfu7r3d1tgBdKFc3dgAAF0oVzd2AAAXShXN3YAABdKFc3dgA5urrmuc4AGXV19yrp3zve5mJ73vblqFk5m9e7rbbLpQrm7sAAAulCeczMbbYAXShOe1mZ7q97M326Ut17SiN3fo3d3d1tgAAAAc6HADoAAFAASSUAkkoBJJbbaHe97JJAAEkkk77VXX6quqr9d3ETCqVCSSysp93d0AAALpQrm7sAAA+cKFnFHEpmJmNnkxyVye873u7u6AG/enFXUpWohD+f7+8/u7u7d3c987kqqKKpLs97fd3d1tsulCubvcbbbbZdKFc3dgAAF1EPOZmNtsALpQrm7sAAAulCubuwAAC6UJrNS+73tKFu7uvG23n1ZmZmZmYAB3w9BABJJACSSgEklAJJKASTqSQABJJJP3uquqqpque84+zMwAAAulCubuwAbbbt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uXrTzNb8AFoAtegEJJO971JIADwO1V0edAAAAAABqwCAAB7xaUK0oVpQuLEmohVxVfetvrAAAAulCubuwAACUoTShZahZOXjbYAE7lqFk5axtsAC6ULc5mY22wAuocxFZzPsbbYAXShXN3YAAA0oWWoWTmY22a228pKLm7ttsBAXShbnMzG22AF1EKb++Lv5J3nFERHcrrbIb4e8AtAFp76+2297zXvQkk0KAAAAAAAAAAAAASe/vpdXXdXV17dVVV3JM+wwcqroNjm6q+a5zgAe6EPkiTqGv5/v7+7u7u3d3fvOCV/MBaa5zkypmZmez3vd3d0ALpQnnMzG22AF0oVzd2QABChAXShErJzMuAAAPmlCzihPffe97I3dYAXUQjOZmXAAAF0oRvfu97kNtgBdKELjUJJdPe9vtzWYvu7u7u7ttoAtAFtttAAAAAAAAAAAAAAAk/RVXXtVde3VUlkqEkuJQqx9pdttsIAAAulCM5mZcAAANKFlqE99973sjd1gBdKEZzMwPdzMrqhe2Y4/c97zb7mZXVCubMzi+++y1BtD1+8b972OnWtfIntiV2uc57eta/e6JyZnu+y7rvVCubu932gAblqFql39neRERDmAq832elKFu8kWttvGxttnve9PpXveafSSSQAurPAHQAJJJJIAA/V9mZm8zMwOBsCgAAAAAAPQ5jnFCSSm7vYrEoWza3d12wAAN7ihdnvb71tttsMtQsnHmNsAYZNqFWczLAPe8BlqE+87mNs97zLpQrm7iwAAC6UJ5zLbbPe8wShNKF2chI9z3etne9fvb3FC7Pe77z3W22XShGczH3G222y6UKYvl3YAAADbbbbzA8Ad0AQCSSSSAAAAAAAAB8PQNAEAAdzNXVXVXX67u78urrve9259u6AAHvV8oWvPuZjbbD3q+UKpL4AXZzdXXNc5wBI5urrmvecAe9XyhCvnLsAA95pQrpQuXx5jbbD3tulCuXmNtgEINy1Cyd73u7utsC6UK5u3jbbbPV8oT33uJJJeu/LzYMNbxvV+/c/fv2ZmMu8zMzMzMNAEAkkkkgAAB5VXQDoAAAABrzXA2SAADl1dT4IfBD+mkACqAkKLrzz9f793f2936+7u1tnvV8oVTrzG22371fKFUlvG2224Zy6UK5+uwAAC6ULc5mY22w96vlCFfOc4Ak37V1vTnAEm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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
#        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
#    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

#    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

