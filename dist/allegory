#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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fvfFbu7utVVQAAVVWmdYPwB9zMxVGgAVVVAAAAAAA+SSbmSTJ8g1S/BpIeyVP6gaiiylkVpSylQylqllLQh31/d/33ue+++eeefQU/soU/qlqqX5g24cVxFI9+fKlyVLKWkgspaqLVLFSllLClMpYA/fv37++0/vf79+/fvKpV2m/aIL1SwVqlgrVLVS0VhE1Syl9+/fvv9/e/379+/eSiO00kj+yUu+++/fffPf379+8FLtMqpf1SzSloQxSyllSzUJgrUVlSyliJqlkQrKWVKtUskod999++9vfOFL3zzzzqSl7KWCp9TUpf2UJsgXJSwimUtUpYpaqg1S1UtUtAylqlopZUtUsKpqlpE0qpqU+/fv3+/u5/e/3nnnn1UvZqqo0q+pwSKOJS1S1SyomhDIhkQ1ImkrBWUtUtUtKWUtRV33337/d/2v73+9999+qEn9UsomUsJV9TCCuCloQ1SylU7777/v7+/vf7zzzz2qDtNSQ/pCZKWqWypapapd999/39/f3v95555/VL+qWqWKX1OKUuCJlS1S1SyVqlrapalLVLvOc1VVypmZoQgWRGXjWzOYSQo5iwgQmpGkk23rpRy/dPBmd73vemYAAAAAAqqtVVQAAACqqoAAAAAATOEJAg4JAihITveqqt1VTMzwSQsk1Kqdddde++/Z75777779lSncZVSfybacabTjbT5znPvvvvfAFpqqqgDAAtNfNtP5tp85zn3333vgC015NtO7u/e948AWmvm2n8204klznOffffe+ALTXlJmSTd3bbVDZk5znA8Bsyc5zgMAC011JJtJ2klyc5wOgGZ3ve96ZgAAAAAqqqAABVVUAAAAAB5JI6AB1JJskzJnXwOwGzJZJN63dttWjcksknXWZu7ttqhuHABthjGMc5zm+TM34ANjSYA3VZzm1fffe+ApL5JKSNVVe973s8BSa8klVV73vVRyZLznLbaobMnOc4HgNmTnOUAYAFpqmWqxtJNpprt7Vd1w6AZlVUAADmZmFcqqAqqqAFj4BVVUWddZ0+AAAAAAADZmZM7kk6kyTJM+/R32A2ZLJJu7ttqhsxeu7v3vePAFpqqqgDMzMpNF3dgBmZlJqqqszMzMzKTXkkru7ADMzKTRd3YFDZk5znA8Bsk5znA8BsydZjSbTS5Gm00kku673h3oABmZmZmYAACqqoCqq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AAAAAAAAAAAAAAAB00lAAAAL8mpE1ImpE1ImpE1IkNiGwphDEZYBnOaqqmuTM44IbEPJsmybJsmybJtTrrrr3333z3zzzzr1Nk2TZNk2TZNk2TZOuuuvffffPfPPPMHXqbJsmw3824hDENiGxDYi2cxmqqpqZmccENiGxNk2TZNibE666699998988884D1O8mybJsmybJsmybJx1xARjnOc3yd75jlMSbbGxJtuHAMIYhsQ2IbENiGxDYhtItnOaqqmt73OOJsmybJsmybJsmybJ1117777+9/fv3uDr1Nk2TZNk2TYKhwk024iBjY2wCHDGxtWzmKqqmt73WKobbbIiG22xw4YwBtREAQxDiakTUiakTUia5oTbbGktFAffAAegD0qqqAAAACySW2222gA/JJD4AAAAAAAAD5JJ1JFiSW9GwAAC/JqRNSJqRNSJqRNbJsmybJ11wHXXvvvvnvvvnnXqbJsmybJsmybJsf2zI444nffff9/f397/eeeedepsmybJsmybJsmybJ11117777575555g69TZNk2SRNSJqRNSJqRNSJrV3q/e948AX5NbJsmybL+ZOOOKtpxk2TZGxGc5zVVU1MzOOCGxDYhsQ2IbEPJsmybJ11wHXXvvvvnvvvnnXqbJsmybJsmybJsm1OuuuvffffPfPPPOvY39xXGTZNk2TZNk2TZO+++/7+/v7z+8888wdepsmybJsmybJsmybJx11x17777575+/fPU2TZNk2TZNq/txk2TZP7ff3PfnelMzP75nWfPvnvnu+f0AqqqFVVQAAAAAAAAAAAAAAAAAaSSEkt70AAGZXk1ImpE1ImpE1MmybJsmyfPeuQ699998998/fPE2TZNk2TZNk2TZNqfPeuvffffPfPLzzr1Nk2v43GTZNk2TZMxDYjOc5qqqane2AX4IbENiGxDYhsQ2IbENiGxEF+RjnOcnk73fghsmybJsmybJsm1/a4ydf3ff9/f395/eeeedepsmybJsmybJsmybJ111yHXvvvvnvvvvnXqbJsmybJSJqRNSJqRNSNq7u/e948AX5NSJrZNk2/tXGTZNk2TZO+++/7+/v7z+888869TZNk2T6pxrhNTjhNkNiGxEICIEQZznPOcnm973jghsQ2IbEcQEQIgiBDYhsQ2IbERrF41rm+++gKqqgAAAAAAAAAAAAA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slmptG1sbNq2mwzGxbNq22TZmqtotpbAYtSmLJYZslpYpK0sili0lDCxGLSqtLEalMpNtlshs2222trYv7+/vf7+/v7+8d5Nk2TZNk2TZNk2G9nCbbSG0C2qLbZTZTYiNqo2IsWoqrS0sWVFYsoTFpSMWSMWijCwsLEbEkNgjOc5qsgFVyuc5zG1TENtjcMXGxrjJsmybJsmybJtTvvvv+/v7+8/vPPPOvU2TZNk2TZNk2TZNk6666999989888869TZNk2TYhsQ2IbFTG4hQ2IbY1Dhg85zmqr+9/vPPPOv5Nk2TZNk2TZNk2I1ECIznOZnO53ve8SI0kogRCiBDYhttSNpyJqRNSJqRNeXe977iSXg8AX+TZNk2TZNo/tnHC4amzjOEwCGhQ0hxCRnOc85zfN73vEiGxDYiRNSJqRNSJNSJNXd2BhmZlsTbkU2TZNk2TZNk/u+++/ie+++e+eeedepsmybJsmz+xxk2TZNjXy0RJLySWkkte973fszMzM+50NbAAAAAAAAAAAAA88SSAPwAALJJbbbbaAAD5JJ1JIkkSSc+/fvn79+/fv37916mybJsmybJsmybJqRNXd2HEkjAAvqakTUiakTUiakTUiakTUiakbV3dgYZmZYmpEl9xwmybJsmybJsmyd999/39/f3n9555516mybJsmybJsmybJomru7973jwBfk1ImpE1ImpE1ImpBDYhsoGQxGc5zVVU1MzOOCGxDYjZNk2TZNk2TZOuuuvfffoe+e++++9fU2TZNk2TZNk2TZNG1d3fve8eAL8mpE1ImpE1Imp9pPUTZNk2Tvvvv+/v7+8/vPPPOvU2TZNk2TZNk2TZNk/B3333773757555516mybJsmybJsmybJsss6+b3c83et666zPm3L317VXoAAAAAAAAAD32T3333333332y2geeeUC22222222220AAFk+SSdZJ18ttttDbMmy/s4ybJsmybJsmybJ3333/f39/fg8/vfffeu02TZNk2TZNkpE1ImpG1d3fve8eAL8mpE1ImpE02IbENiGxDaphDEa1rWqqq5MzM44TZNk2TZNk2TZNk2Tvt3337777755555yHXqbJsmybJsmwhsQ2IbERsA1Gta5zXOTMzOOCGxDYhsQ2A6gCGIbENiGxE73ve6rVeB77777712mybJsmybJsmybJtTvvvvv33333zzzzzr1Nk2TZNk2TZNk2TZO++++/fffffPPPPOvU2P7HGTZNk2TZNk2TZPv379+/39/f3vnnnnnXqbJsmybJsmybJompE1cem1zfOc973gAIAAGAAAAAAAAAAAAFVVQAAAAAAMzMykksSS8ld3QHjMzM2kl7yakTWybJsmybJsNr+y4yc+B+4zM++78JJAB7iakTUiakTUiakTUiQ2IbENpGzWta1zmub3ve+cENiGxDabJsmybJsmyZO++++/ffff379+3wSRTECznOc85zm973uuCGxDYhsQ2TZVsnfXXXvvvv339999TZNk2TZNk2TZNk2T5733x377774H7zz970mz+y4ybJsmybJsmybU76/u/7+/v77/fvvvqbJsmybJsmybJsmydfPevffffvv7776mybJsmybENiG0DqAIYjBsA1qt1Wa1ve984IbTZNk2TZNk2TZNk/P3XKyZ99+aPx77fQAAAAAAAAbmZh9AAAAqqqAAAAAAKzM8t6APe9ngL8mpE1ImpE1ImpE1MmybJsnfXXXvvvvn73zzzr1Nk2TZNj+zjJsmybJsn3vvv+/v7+8/eB/e++99JsmybJsmybJsmyaNrl3fve8Z4C/JqRNSJqRNSJqRNSCGxDYhsRsA1nOeczyd8mZxwQ6gCGIbENiGxDYhsQ2IbETvWtVWa1W/3731Nk2TZNk2TZNk2TZN3111777799/fv3nqbJsmybJsmyG0qiBDYjOta1VVWt73vnBDYhsQ2I2TZNk2TZNk677779999++B555570mybJsmybJsmybJtTvrrr3333z9755516mybJsmz+xxk2SRNSJqRNb3vve959999mZmZmYAAAAAAAAAAAD22233330VVVAAAAAVWZnTMzWtZmYAAF+TUjaciakTUiamTZNk2TZO++++/fffffPPPPOvU2TZNqWybJsmybJsnfffffvvvvvnnnnnXo/uOE2TZNk2TZNk2Q2I1rWtVVVyZ4Ac5zNxDYhsQ2IbE2TZNk2TanfffffvvvvvnnnnnXqbJsmybJsmybT+zjJsn379+/f7+/v73zzzzzr1Nk2TZNk2TZNk2TZO++++/fffffPPPPOvU2TZNk2TZNk2TZNk77777999998888869TZNhDYh1AoYhsQ2IbENiNa1rVVVcmfPPOvU2TZNk2TZNk2TZNk77777999998889D33vlNk2TZNk2TUiakTUiakbUWJJfCSWwA++8ZmZVQAAAAAAAAAAAVVUzMx8AAAABVV7/ev7333zMzP2Zmb85z3333+/v7zzzzzr+X9nGTZNk2TZNk2Q2IbEa1rWqqq5MzM44CGxDYhsQ2TZNk2TZO++++/fffffPPPPOvU2TYhsQ2IbENiG1TCGIbEa1rWqqq5PnnnnXqbJsmybJsmybJsmyd9999++++++eeeedepsmybJsmybJsmybJ33333777775555516mybJmA6gCGIbENiGxDYjWta1VVXJmeA9975TZNk2TZNk2TZNk2p33333777775555516mybJsmybI2IbENiGxGc5znnOc5MzM44FMIYhsQ2IbENiGxDYhsQ2I1rWtVVVyZ88869TZNk2TZNk2TZNk2zrPK/czlV7777VVUAAAAAAAAAAAFVVQAAAVVXeZmav1VAMSS3vZQAABfk1ImpE1ImpE1IIbAbVMUMQ2I1rWtVVVyZmeAHMwI2TZNk2TZNk2TZNqd9999++++++eeeedepsmybJsmybJsjYhsRnOc55znOTMzOOCGxDYhsVRAhsQ2IbSE2IbEa1rWqqq5MzM44IbE2TalsmybJsmybJ333337555+/fv37rxNk2TZNk2TZNk2Q2I5rWta5znN73vgBOYKYoYhsQ2IbENiGxDYhsQ2ka1rWuUqrkzMzjgh5Nk2TZNk2TZNk2Tz79+/fvvvvv79+/fuvU2TZNk2TZNo39wIYhsRW973uqrm973vHBDYhsQ2IbESJqRNSJqRNSJrW7rmuVZ73szMzMzAAAAAAAAAAPc9999999999FVVQAAAVVWqqoOZmYzMznOfi2qrv3Os+ZNk2TZNk2TZNk2Tvvvvvz1777555556HeTZNk2P7PznhNk0TUiakTUjazMzPvvveAC/JqRNSJqMQ2IbENiGxDYhsROta1rnOc3ve949TZNk2TZNk2TZNk2TvnOcAMzMy/vJLUTUiakTUiakTUiajENiGxGta1rlAqrkzMzjghsQ2IbENiGxDYhsQ2IbESta1rXOc5ve974DvJsmybJsmybVrd9999+e+++gBbSznOc4AZmZltK7u7wAAC01rms6zP7++1bf39/f1VVQAAAAAAAAAttttto8888qoAAqqtVVQAHzMS+7W6973vezMzLTRznOcAMzMz5JLianOc88e+++g7zrLzzzzwKq7zrO++++6qqu00LnOc4AZmZlpq7u7zMzMzM8klxNTnOc4AZmZlpIaSi5znOAZmZmWmru7vPAAFJorS3q+Lvb3vl3muy9drO831NpppXHS4qXFS3ElLVLKqnGRDipfFLipflS5/OnB8+7nFL6pdc/Pn3nrruc4HUidtQnFS6dUK8DUlLmpYqXVS1QXBqUtUsiGoTSlqllKLwNInIZFc1LKE1SylqliRMpaK1S1FThqojfQwdB2H7ltRzeOfn7z7uhVVUO8q/VUAAAAAACqqoAAKqqgAA35183d3d0AAFb55543UAADMqqqAADcyBwAAAAAAAAAAACqqoAAKqqgAAAAAAAAAAfMzMAIAABVVUAAG7u7u6AACqqoAAAAAAAAAAAAAAAGXXWbu7u6gAAbu7u7oD5mZgBFnm/N3d1AAAqqqAAAAAAAVVVAAAAAAAeTvt9N0AAAGAAAAAAAABVVUAAAAAAB/WAFAAAAAAAAALOus6+voECqqoAAAqqqAAVVVAAAqqqAAAAAAAVVVAAAAAAAAAAAAwAAAAAAAAKqqgAAAAAAAAAAAAAAAAAAABVVUAAAAAAA3POuus68666zrVLVLVLsOg8Dmkr4HwMqXClilqllLKWqXYdoTwNUvuI+Sl0KyTRZnWfM66zM6yz+z53qvT2qqoAAqqqAAAAAAAAAAACqq1VVA8888888h7H+NNtmZjbJsbM0y1m2ltmWxmmY2ka0zCTRe96qqqqmZngUAgEmxAkNNtpiTGDaeREJQ85zmqqqqZmZ4AZEPOc5zbbQbMm7u6AGzJu7ugBsybu7oAbMm7u6AFkk7mTrvvvvu22g2ZN3d0ANmTd3dB5555ydY5zczM5zzczM880eVVVAAFVVQqqqAAAAAAAAVVWqqoAAA+SSXJJ19+2223zzzzkyN3dACySdzJ133333bbQbMm7u6AGzJu7ugBuZu7ugBsyXvvvvu22gskncydd9999220GzJu7ugBsybu72AHedZ37T3mfczM889999t99qqqAAAAFVVQfgPAAAAAAHMzMVcq1VVAAAH379AA7zrO++++wAskncydd9999220GzJu7ugBsybu7oAbMm7u6AGzJu7ugBZJO5k677777ttoOSSbMnU3d0AABaau7uwAAC01k820/k2nG3nXzrM66+1V/P7+qqqAAAAafT6A3rrAAAAAAAqqtVVQAAAAAJJfNNN8SS0kl5JLnOVXvezwAWmszMyqqq7znObz5xu7u973vaqz5oADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqu85znngAAH3zzzzzve97VW6AABu7u1VVW6AABu7u1VVW6ACSSSZulXybTBdaSDue9njMzMzMAAAAACqqoAAA/vfffffffffQAVu7vjdVQABVVVVTnOc38+/lW1VVugAAbu7tVVV3nOc854AAH3zzzzzve97VW6AAd+c5z79PPPPPO97VVboAAG83d2qvfffcwAAC3d2qqq3QAAN3fm7VVVd5znPPAAAPueeffnnne972qt0AAD93d2qvfat0AAD95zd3aq99q3QAAMd5z585x/JtOJtNtNqNtPWVmZ9999mZmZmYAAAAAKqqgAAAABVVaqqgAAAAAAAB8n8400knqq02vvvvvvvgA5wAAD95zd3aq99q7znOeeAAAffPN3ve1772t0AADdzKvfffat0AADd3dqqqt0AADd3dqqqt0AADd3dqqqu85znngAAH3+99999/v7+/v6qt0OHHHw3d3aqqrdAAA3d3aqqrdAAA7f3Pvx8ylzjnmhONURqlir0Pnvvvvv97/ZmY+VVVHQAAACqqoAAAAAVVWqqoAAAAAD7mZnuYliSUbaTWqr3ue97wAc5JJJJJJJJJu7u1VVXec5zzwAAD7/e++++/39/f39VW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVX9znOeeAAAff733333+/v7+/qq3QHx8fG7u7VVVboAAG7u7VUAc5JJJJJJJJJzv1eq/k2n8klE2nNfv7+/v63+9qqqOgAAAFVVQAAACqq1VVAAAAAAAGST58+CqqrdAAA3d3aqvfff7nOc3QAAPv9/evfff7+/v7+vffcwAADLd2qr333MAAAuc5zW7tVV8q3QAAM1u7VV777mAAAZbu1Ve++/3Oc5ugAAff7z+999/v7+/v6qt0AADd3dqqqt0AADOc5zW7tVVVukkkkkkkkl3nk2nlfcW98D4++zMzMzMMqqoAAKqqgAAAFVVqqqAB1mYAAAAALNkkskm7v223yg70AADd3dr3333333vOc554AAB9/v6r3+/u9888/vd0AAOPzd3fc7ne9zLfJJJJJJJaSXJy8weZmYHOSSAAGa3K88888993QAAN3nOZmZmZmfJJd7JJJJJJJJJr7MzM97774qt0AAP75znPv3zzzzzve1VW6AABnOc5rd2qqq3QAD58+fO/vP3vXXWdLM/fPLy9332qqpVVUAAFVVQAAKqrVVUAAAAAAAAADzSbEkqqvV73veADnJJJJJJJIN3d2qqq7znOeeAAAff733333+/v7+/qq3QAAN3d2qqq3QAAM5znNbu1VVW6OcAGa3dqqqt0AADd3dqqqv7nOc88AAA++eeeed73vaq3QAAN3d2qqq3QAAM5znNbu1VVW6AABn57k+89/cnfH7z9x31985/eYpYpapapdKXLmpcg2ylhWUspc/qlyROVS/cKXVcuOHDdbhypbbjqpcqXNS8brniUv1S4VLKpmqWqWoTKqmVL7UuJUuKllCaAuSJqlxwlLhS4RDVLSJqlpVTVLiqWlLEiapcEJ2pOFLmpc1LEQ4qX3iAW0InFSySc5KXEiY4qWqXCpcVSapcVLFLRS4UuJE4qWqWoTFS0DKllS1VNxUtQLKqnFSypZS44lLVLik4klxUsROFLIThUvKlyAuVLVLSJzKXM2nptNqVEkije+b7nTAAAAADMzKqAAAAAAAAAAA3d3d3QAKrd3VUAABm99999mgAASAAAAAAAAAAAAAAAAAKqqgAAqqqAAAAAAA3o+gAAAAAAAVVVAABu7u7ugAAqqqAACqqoAAAAAAAAAAAd999999gAAW7u7uoDwfgG51lnyqqAAAAAAAAAAAAqqqAAAAAAAus0+gQAAAAAAAAAAAAAAAAAAAB/hVVXvoAAAAAAFVVQAAKqqgAAAAAAFVVQAAAHeZmBwAAAAAAFVVqqqAAAAABVVUAAAAAAAAAAAAAAAAAAAAKqqgAAAAAAFVVQAAKqqgAAAAAAGzMyZ8kV1BW6D8HMIPipeKXYfg5DlS+Bql4hO1L9UuSl9DsOw+ErjiVZ8DJOUSaSaibacTTSahLrnc7gBG0AAFVVAAAAAAAKqrVVUAAAAAqqqqqqq/ufn5+d73ve9qrdAAA3d3aqnOc5VbgAAHN3d2qqq3QAAM5znNbu1VVXec5zzwAAD7vjzzzve97VW6AABu7u1VVW6AABu7u1VVW6AABu7u1VVW6AABnOc5rd2qqq7znOeeBwAD7vjzzzve97VW6AAEnPNNpxgklE3WwD3c8BtJIAQcMqqoAAAAAdl+qrVVUAAAAAAAAABfsknUknkknznLdttC3QAAN3d2qqq3QAAN3d2qqq3QAAM5znNbu1VV+c5zld5znPP0AADX55+eed72vfffe7oAAH3d3aq9999t0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqu85znngASSSSa94uvUrxJLvfer3O54AAAMzMzKgAAAAAVVWqqoAAAAAAAKqqqqc5zn19qqqq3QABxu7u1VVW6AABu7u1VVW6AAB+c5zm7v5tVVVugAAfm7v5tVVVugAAbu7tVVV3nOc88AAA++eeeed73vaq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAM/efd/N/dqqqoKqqgAAAAAVVVAAAAAAB3mZgcAAABzMzGZmc5z8EqrdAAA3d3aqqrdAAA3d3aqqrvOc554A+/XznOffpJJJrve9773veADnPNJa1JJIpHFO973vu9qqs+fNHN3d2qqq3QAAN3d2qqq3QAAN3d2qq99zAAALd+7tVV77mAAAZlu1VXvvec5zdAAA+vv77mZn7d97vd9AAAAAAAAAFVVT33333333330AAAAAAAAAZOc+/ftVVXvuYAABmW7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVd5znPPAAAPvnnnnne972qt0AADd3dqqqt0AAG85znMzO973vc5bZoAcKIUNwARERrWtaDDMzMOSSSdSS1rWtSSSaSS1rXe970O5ve97nLbbegCIiIbbbgAiIxvQ77tfe51CqqoAAAAAAAAAAAAAAzMwKqqgAAA5mZlmZnOUUAZmZhySTqSWta1qSSTSSWta1rve96VVVboec5zn379+/QA88888qqqu85znngAAH3zzzzzve97VW6AABu7u1VVW6AABnN3dqr3333MAAAy3dqqqt0AADd3dqqqt0AADd3dqqqu85znngAAH3zzzzzve97VW6AAA+++85zn777775e+1VPD7mZj4AAAqqqAAAAAAAAAAAAAAAB8kksknX37bfe94AL5IklIooooklIopznOcAwArd4ccABu7u1VVW6AABu7u1VVW6AABu7u1VVXec5zzwAAD7555553ve9qrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3fffffffffe85znngAAH3t9sPOc5zfyv2u9qqqqqoABVVUAAAAAAAAAAAAAAAAAAHUkt72ABmZmc5JJJJJIBu7u+++++++++7oAAG7u7777777777ugAAZmZV77VW6AABu7u1VVW85oAGZmVe+1V3nOc88AAA++c888873ve1VugAec5zn379+/Td3a999qrdAADvznOffu7u97333tVugAAbu7sAABzkkkkkkkkkmyebaf4CSbTjbTiTacbacTadAcM+++AAAAAAAAqqqAAAAAAPbbbbbQAAAAAAAdSSe5mTNkksknyTMmbzeW3t2qt0AADd3dqqqt0AADd3dqqqv7nOc88AAA+88888873ve1VugAAbu7tVVVugAAbu7tVVVugAAf3PPPPPO73ve973vd0ADhxu7u9r2qrd4+HwOA443d3aqqrN444AOON3dznOc2r9qq3Tjg5FJFFIrrybT+TbTvLzmffffAAAAAAAKqqgABmAAAAAAAAAA0kkAAdAAAANa0AAABziikicBxxu7u1VVXec5zzzjjjjjg45Nd73vfe97wAc5Io0lIpIoo+c5zgABVmgAA3d3aqqrdAAA3d3aqqrdAAA3d3aqqrvOc554AAB98888873ve1VugAAbu7tVVVugAAbu7tVVVugAAcz8/PPz89/PP388/fe15+4UT5iqOcK7UspdKluWNaNt1cbjjjLhSwl3lLzvzj9311zxHP2cqXPLQbKXxSypbt0+ET4pfQxUK7qOaE9D7UuFR8oTgMUvjAFzUsom1SylikxVgrlS0VDwPA+B6HofQ9D0SxJISS2bSSI9JJaSSkAOgAAAAqqqAAAAAAAd5mYHAAAO83fu7u6AACqqoAAHx2K2t3QBzMzAdjMAAAAOgAABVVUAAAVVVB+zMwDwFVVQAAAAAAAAAACqqtzMyfszM/AaAqqqAAAAAAA3d3d3QAAVV8zMyqCABVVUAAAAAAAAAAAGZmfKqrYAAHfnzzzzzwAAAZ866yqq2AAADczMPoB1mYAAAAAAqqqAAAAAAAy6/AeCSR0AAAAAAAAAAAAAAAAbmZh9AAAP8Kqq99AAAAAAAqqqAABVXeZmVfgAAAAAAFVVQAAAAAAAAAAAMAAAAAAAACqqoAAAAAAAAAqqqAAAAAD9mZgHgAAVVVAAAAAAAKqqg8wfgPuZmCryqgAAAAAAG5mZuZmczMzczM3MzNDkOCUvofQ8DwPA8DoO6KXAdh4HIleBipfVL8ocQ4qHwPgfFD8H4PNUvpKmqWqg7qWoTiLOSSe5MyZJJv1+O6UAAAAAAAACAAAAAAAAAAAAAAAHmmk3vXve973s8B5NNN97JJI3CAiGNtuEg6DQtNG973VVVb5O+AGcttttwgIhtttuBBzWgDVtc5znJmd4wAd+c5z79AM5u9873te1W6AABuZlXvvtVugAAZzd3aq9qt0AADczKvffarvOc554AAB9885znPPPO973tVboAAGc3d2qvardAAA3Myr332q3QAAMznnOc5+efv755XtVAD7JIB2AAAAAKqqgAAAAAAAAAAAfJJLJIkk5+fvf3ve977VboAAG5mVe+Xvvvec5zegAAfW+eeed73vnvvvuQAAG5mVe++1W6AABnN3dqr2q3QAAN3d2qqq3QAAN3d2qqq7znOeeAAAffPPPPO973tVboAAG7u7VVVboDnDnDnDnDhw5u7u1e1UW1ySSSSc76r7cEku7KOe74AAAAAAAAAAAqqqAAAAAAAAFVVVVVVffv2qqqrdAAA3d3aqqrvOc554AAB95555553ve9qrdAAA3d3aqqrdAAA3d3aqqrdAAA3d3aqqrdADvznOffoHnnnnne9qqu85znngAAH3zzzzzve97VW/N+PgA3d3aqqrdAAA3d3aqqrdAAA978+fOc5znzn333329vfQAAAAAAAAVVVAAAAAAAAAAABZmTOSSJznP397+d73vvaq3QAAN3d2qqq7znOeeAAAffPPPPO973tVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboAAG7u7VVVboA22223PHpUJ/VLEQ7widfrm39/f38AAAAAAAACqqoAAAAAAAAAAAMknXQVVVd5znPPAAAPvnnnnne972qt0AADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AHw5wOcbu7tVVVvOfNc4+AAbu7tVVVugAAbu7tVVV3nOc88AAA++eeeed73vaq3QAAN3d2qqq3QSSSSSSS/Jtp/JtNbyszPvvvgAAAAAAAAAAVVVAAAAAAAAAAFVV/ddddZmZuZmfvx737776DzwAADd3dqqqt0AADd3dqqqt0AADd3dqqqt0AAc3d3avaqu85znnPAAA++eeeed73vaq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2qqq3QAAN3d2ucqqrdAAAvzOe85zn777y81AAFb5mZm/N3VAAAABJgAAAAAAAAAKrzMzK+0VVXwA4JAcAKEhWvVYqiqqZmZzlttttsA9555555Ve++++7oAAFzzzzzyq999993QAAN3d333333333MAAA93d3999999999zAAAMzLzMzMzMu5JJJJJJJJNq7vMEmBmZVQAAHvzzdvMtqqv7nOc3QAAPu7u973ve1WYAAB5u7sAZmZdySSSSSSSSLO9r3Vs0trEkss743330HmZmV9qqVVVAAAAAAAAAAAAAAAKqrVVe9ddZ0zAoSFAJCve/KrnOb3veMNttttttjdGd3aq9999/eYAAMzM999999999zAAAMzM99qvffe85zmYffnOc+/QAD73m7ve953vffff39AAA23dreVe++/v6AABtu7W8qvlWYAAB5u7tbyr3339/QAANt3a3lXvvv7+gAAbbu1vKqq7kkkkkkkkk7uulfJJPgdzvsPABmZVUAAAAAAAAAAAAAAAABVVaqp1/Z11nXeZmMzM779/ee+57dqswBwAebu7W8qqswAADzd3a3lVVmAAAebu7VXvvvvec5zdAAA+95zzzzzve977777mAAAW7u1V7777mAAAXz5zd3aq9999zAAAMzM999999999zAAAMzM9999999997znOboAAH3d3a73varMAAAff7Oc88/d+++++gqqqAAAAFVVSqqoAAAAAAAKqrVVaqrrMz+zOuufOufOc585+fne53ve9qswAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqrMAAAzMyqqq7znOboAAH3d3e973varMADhJJd3YAABdySSSeaS1qSfa20lvUne979998ABdyT7XzSW9SSSTettJaW9yd73v333wAF3JPa+aS3qSSSb1tpLepOLVNtOk2nrB60d++998tnaviwNZzOXFW1eLeub+/ef3v3j3tu+efz7orhFqlqlqlmqWQylqVpSzZzwqXFqiY0kKIUNDsQiOOGZi7BIlvcczDbFL7319+CvnT6pflLj4hmtlLfdwpccuOf36pcyrKJiJxFapalLVLKWkThS1U0g6cVLiEOw0UXCpaEMqWKllLBWUtUspfKllLipapalLKWDVLFLJSwVqosUspapcqXCpcQFkVkhWqWlLKWKualiKuFS4ijiSnPwPzMzxz9ybAABVVUAAAAAAAAAABu7u7ugAAAAAAKZmYdddbu97u6AABmAAAAPzoHgAAAAAAAqqqAACqqoAAAAAAAVVVAAVVVAABVVUAAAAAABVVUAACqqoAAKqqgAAAAAAAAAADvvvvvvsAAAfMqqtgAAD5jAEAAAAAAAqqqAAAAAAAAAAAEwAAAAAAAACqqoAAAAAABVVUAAH+FVVe+gAAAAAAVVVAAAAAAAAAAABVVUAAAAAAAqqqAAAAAAAAAAAAAAAAAAAAFVVQAAAAAACqqoAAFVVTrMwAAAAAVVUqqoAAAAAAAAAAAPJJO5mZM2STqZLypcqXQZS4DB4HCl0HClwpYPA4Uvwch+D5KXiEwSapYqWUtKXn+DOuvPfL1T0AAAAAKqrVVUqqqAAAAAAACqq1VTq+VV711mZmdGgtbnKqqqpmZ5TBtITaEkMAYA2CQtabbbbbbbbbtZiEJa1rVVVVUzM5gAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVXec5zdAAA+7u73ve97VZgAA5mZlV7VWZ8fAAGZ+1XvvvtZgAAH5mZVV77WYAAB+fjznOZuZmc3e/CgKqqgD9mZgHgVVWqqpVVUAAAAAAVVWqq1V9zMyqGhEkvJJYkliSW6KoAzPHkkuckkkkAD7u53ve1772zAAAMzMqqqswAADMzKqqrMAAAzMyqqqzAAAMzMqqqu85zm6AAB93d3ve972qzAAAMzMqqqswAADMzKqqrMAAAzMyqqqzAAAOW3bvmc/ec+fOfN+efne9zt30FVVQAACqq1VVKqqgAAAAACqq1VTq+VVQHuddZ1/dddZ1+/f39/f39/f39VZgAAGZmVVVX9znOboAAH3d3e973varMOHHx8DMzKqqrMA785zn36AffnOc+/d3d73vaqswDvznOffoB9+c5z793d3ve9qqzAO/Oc59+gH35znPv3d3e972qrMA60lrUkkkmmkta5znPe94ADySXOSSSaXznPv0APu7u973ve1WYAABmZlVVVmAAAXxuZ+1e++1VVVAAAKqqgAAAAAAAFVVqqtVVQABrMzO8zM966zM6zvvnvnvvt2qzAAAMzMqqqnOc5mAAAfcz7lVVVmAAAZnd3ve973va7znOboAOcfd3d73ve9qswAADMzKqqrMAAAzMyqqqzAAAMzMqqq/Oc5yz6AABzMzKqqrvOc5ugAAfd3d73ve9vff39AACQrf3zbT1x3d9SS7N399997M8GZmZmZgAAAKqqgAwAAAAAAVVWqqdXyqqAAAAHEktaMrMzM6VUkkkkkkkkn39sqq98v39AAA/bMqqvff39AAA/bMqqqv3nOc/uc5zfoAAH1u7ve972qswAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqrvOc5unD4Afd3d73te+++5iSSSSSSSSezvPNtO9777nsMzwCAAAAABVVUBVlVQAAACqq1VWqqoAAAAAAaS8m09a973vBmZl3JJJJABmZnvvvvvvvvuYAAB3nOc3d4AGZmXcknkkta1rUkkkknl3ve+97oBXec5zdAAA+7u73ve97VZgAAGZmVVVWYAABmZlVVVmAAAbznObu7V5VVmAAAbzd3avKqu85zm6AAB93d3ve972qzAAAP39vzqbT+aTQkls4d++798g0AAAAAAALMzHwKqqgKsqqAf3vvvvvvvvvoBVVaqp1fKqoAAAA6kkGgiSXmm25r3ve973gC7knAAGZmVVVWYAABmZlVVVmAAAZmZVVVd5znN0AAD7u7ve973tVmAAAZmZVVVZgAAGZmVVVWYAAB+85zmMyqqqzAAAP3GZVVVd5znN0AAD7u7ve973tVmAAAcze/u/v5z58515nn7n7330r0AAAVVVVVVAOjxh+AAAKqrVVaqqgAABVVXmZme5nz5z45znPz8u/tV7777mAAAd3d2qvfffcwAADMzPffffffffcwAADMzPffffffffcwAAC+bu7VXvvvv7gAAMzM999999999zAAAMzM999999999zAAAPvMzPffczve1UkkkkkkkklVWZmZmZmaSS8klzgAAH5+b93aq9999zAAB8+fLOX7N/ee+eKhVVUAAAqqqAqyqoAAFVVqqnV8qqgAAAANzA2AcEAhgDBIVCQsYrFVVVve94w2AAGZme++++++++5gAAH9u7tVe+++5gAAGZmVVVWYAAA+c+czMz3Pffvr33339+YAAAuPnHHzjd3avb3333MAAEku7vMzMzMy7kkkkkjjl3dgGAB8lzm80AAPu7u973ve1WYAAA+c5zMzKr2qswAABz7y8m05diSW6baeJJVM53ns94AMzMzMzAAA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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

