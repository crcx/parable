#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if math.isnan(opcode):
                opcode == BC_NOP
            else:
                opcode = int(opcode)
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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RYSMZ+iUQigsO0VJCEkkhIxgVBohCRjGEKonx0JzxRWtStypZubknDYIsigs5UiIv6T7wK2CIFxAkZAZEJAgKyArO939zih++/YgqaSQACArAVS4oBgK70qWCvoIAUskkkJIREUkRFNCEqs1md9nn75FaBWcJKqueKvyvZJUkkOC8jyPF9UlVVV859dffHvvvvvj57BV2Kv1SSECJGFnQVsFbRR+UAIVRVQRUpgVX2378pKlVQAACVKqniqq+yVVYAWfAdklRySqp99VUqpHmyVKrsJVSq2KnqAFf1/v2/2d/fr9gqwADXcAVskkkv+nri9d3nZv0lVXJXnOFnDnwBJVVs++++zMywVpFcBFLqszPd933R0ArBFPECMCQwgCtTM1nMzMVXAVgKwBDIIAHFQivroQsBWIIpqXm85nuqgfQEBMBFJ8FCteKq9fe1UkqQ4AfAZLqSqoAw+Af5OTd3d3d3f1do54AALUqqVVVAAAAAAADMzMzMzMzMzFVQ5wAAObW3u7u7v50AAAVVVUAAQ8lHwHuAriu7u7u6qAAaqqqgB3ve+X3ve2H4N3MzO1UlVu77+/CSSSSMzMzMzMwANAEANXJJJOwZmZmZmZgAAB+niqq9QAADVVVX9+/fv379+AAAASrrNaqu973vcmZmZmZmZmAvs1JJ3vQA2bu7u7u7ve973ve9VVVUAO973ve96AGqqqve973ve91VVVAAAGVSqqq8VVVAAABVVVQAABqKqqrKVVVQAABVVfyqqqAqqquqqqp3ve973ujmZmZmASSSSQAASSSSYzFVUADve973vegHaqSqYzxVVQADMzMzMzMAAAAAAAAqqqoAAAAAAMrakqpCP0FkBigsVLjKoqAiwJLrmr+V+XmgAHTVVVWAAAAAAAUACSSSZGszMzMwAOngA0eKqqHe973vdBVVQADvfEAHczAAADMzMzMzMAbuSVLThw4L683d3d3d3QAADV/iqqGgH6+6upq6zPd5mZmAB6O773uSTFVQAABgAAH87r4qqgAd73QGZmRoAAAAAAScqR8VVUAAAVVVVqbzd3d3e7szMzMzN6vxRB/UhVHUTKvWFFQiXXYWT5QhI+tIIpBGo8UFgCtxs3Ako+po/HJEkSE7KIySo9i3JJEnJRIsHQQqitESyRkJEISQCQipIpIAQjIhISpULlSKsZEjGRZIQY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tIi0oLGd1Y0oblfcHFCrBFsFZ7gK2Ar4AVgCt6xNbr5Q0CLoRSAi8UPrUM1EhVCSSU2k03yvJtsbSy7jaUmTLupIQEHl3VACSSSHw9PLuqLu6qq90HXiA7AFNg+qq7q7us75V91XqbbzNPVJJq6a6nia5cvsmYAAAAAAAZd1V3mZmZmZgAAAAAAAAAAAB0ASAV1n8Zd1Xn487z9+++697V3JJ2u873368fcAAA7rX360ud73u6oAADn07377s5+7O973dUBNa1jWgDmtckkne97uqAAA/cqud53ve972ZzjH7OM4+5wAAD7WvpP072u97f29l41rWta1oAP2tfXcud73u6oAAD6fb39J+k73vd1QABVZFT279zMzP379+8zT325Fuy7VZAW1rTTWjWta+qvru7vve9mc4x+xnOPucABrWta1rdX7Vfb38/YwAAAADwJPpJJAAAAAAAAAAEaACSSSSAA6k1lV1trvQ6d732ZmswAm5J93nKqgAB9rXJOzve97uqAAA+v37nP132773vd1QGDDLO9a33vZJJJuqAAA3rW5J3ve97ec4x+zjOPucAAA+1r6XfbkqSe+3sAAxgyZ+1rl3cuSSbrFMYAHv329/Xd/ruSTdUAABvWtySSSSbqgAAN61uSSSSS85xj9jOcfc4AABuvr4fa2HejSvogOoKrfKH0RAez6PooH0A7FBciqDkVT6CB9AJNqQgTakgBNok2gJJtEk3ds3XdzMzMzAPRJySSQAAAAAAAAABGgASSSSQADE016m0ltJqkkmHDiaSznEYzjMYxjOcRm5eru7u7lST329gAAfa1y7uXJJN1QAAH3vt7+u77dySbqgAAN61uSSSSTdUAABvWtySSSSXnOMc3sAADmtcu7u5JJ7m9gAAc1rl3d3JJN1QAAHuVXLu7u5JN1QAAG9a3JJJJJuqAAA3rW5JJJJLznGOb2AAB85jmc6r7GOc8zMzufQjQAAJJJJIAAAAAAAAAAAAACSSTvUkk9u6r7L3jcn6dxjGM5tnEuru7u7kk9zewAAOa1ySTve97uqAAA977e/ru7vve93VAAAVjdVJJJ3va1oAAC842xVXd3d3ckvOMYxz2ucAAAr6q+973vekkvm9gAAc1rnve9713d3uqAAwYYxtrckn0kqTeqAABfKrl3d3ckm6oAADetb1nOMSSST9JuqAAA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B0kk73vUkgDLzMzMzMwAA0Dg9AAALuq3qpd1WsqrrPcz58AzMDftXXm/N+gBv2rret7ADLuqy5UzmYquAF1Km5cqZzM3d3dVWX7Kl8uwAACX7JPeRzz3FVQC+eypy/L9ADftXW9b2AG/auvN+b9ADe01z3NXM00/ue3370++kklSSfAQAAAA4GwSSd73qSQSSd73qRZ4AAAAAAAAAACG+1UmK9qpHPP34ABUAaqTLlTOZiqgBuXKmczN1UAL9lTc8zAAkk5tNZersxp5mYAc2mpersAJJObTSXK5ySSSYGm2r4kktffL3Pe+++n3wBzckkvl3qoAF+ypJfLvu1KALDwMuqlZ975XPd+czuZkkkkkwAAAAAEkkkkAJJO971JIAAAAA9A+AAD2qtdaaznW0toNQubkMzACSYXxNXV8AJJJzaaMVU+773M7lZWUUUGmkldPiavmYAagF+ypfLs2pSoAX7Km55mIBJML4mrq+AEkk5tNC8l3feh0JJMbS9201pLuu9DpJJPvdtNe9r3sz5p/YZmZnPaus9379ncv3v1t+fX932b5nQAYAAAAACSSSSAEknne96n0gAAAAAABYAey7qpleeOnfemZ2rppokk+TV8TRnt+8QPb9717TWLuruek973u3x8pqqV1qxz0kkmNpe7aa+9r1++aebwkk5tNc7q7kuSSTm01l6u/gCSTt8TWLuu9CBJJ2+Jq6u5PSSSc2mu3q7g0zwAHNpNEw+CMBW7pefgV7z9+/d/RPvArX02wkm6hJPAkmoSTenWEk97xCSd4Vd3+/fv379+/fsAARoKBJJJJAAAJJO971JIAAAAUAWAH6V+qru/M9zMztVd33PJKqvF3dVe973WSp9kqe/effKp3ve7lzSSEJcaUJXK5zf33332ZmavIhub3rPyPyqrfskm1JJnmYgHe96So/ZVVJ9z77d+++ADm0livV2AEknNprL1dgBJJzaa5XOTE2AB0L4mrrnACSSGNpdtNfepJtlpNsU002z5Jem7rmfBJ6SST4AADy7qgHdg4BVWeAeXdU6DoAJJO971JIbBwAACNAkkkkhd1WU1q6us8qpLuT9VSe3ivz+3d3dVe972/ZU2Z5mABJJzaa+vV2AEknNtrlc5MbQAB5F3Kmcyz4AAGqky5U37z753d1AL9lS+c5JJJJObTR9Xd97mZmSSc2muVzkkkkk1YmprXu973ve/KG9BqSEjk592y4nx9Tyb0UArIIrNUCu4gryAr9AQzV1aK2CsBXAVuqBXoUwCSQhUoFZWs1pFZ7vubm/RDeqR4CtdC1iVy2oQikjAVoFYArIX3M5qvXq/Qu+cs77t9+rtB6A597NIi90cYaUF0oLoEU3fua999995RDUFFFyB8JVVd20kkkkgCVd3V3VNbASqqqq79rV3dXer1d1d21JJ8AACUttKSbkgigAAtJptRFBySTFKlUACq4VKqrwlSqqp7/Us/P7qrySqAAAlXd3dXXururur+u7qtXdNGzpKu6uraAJV3VVX11qmjYIIC4isVWTMzMzM9RlZmZmeyHhUn7D0sPjppypVSU+Kqr2VVVUhwAAlVd20AABJJJJAAoJJJJIAAQARl1VXdZmZmZmYSSSSQAAAB4A6AA0AQAB97oejpKuqrLu6q7zzMzMzMAAAAAAAAAAABJJJJ014AAAAAB3ve973oAAb3vewAAEkkkkAl3VXeVrNZmZmZgAAAAAAAABJJJJAAAAAAAAAASSSSQAASSSSQAASSSSQAASSSSQAAAAAAAAAAAAAAAAAAAAAAASSSSQAASSSSQAxopKqfqzeZeZmYSSSSQAAACSSSSAAAAAAAAAAAAAAAAAAAAAAAB4PA6dAASSSST8AMAe0B8AAO973ve9AAB3ve973oAAAAAAEkkkkAAAfszMzMzMAAkkkkgAAZdXXEv27+qkgotAiwEXdKhIoPZEAiD71gl+5mUoL3PupUUESiAJ6mlQpkQgSTK4KsBFgilGvKH3QTvBVVOgArd9sAFdirUgq9UOCKJnyh1Q55Qgq9BIocQCq57d3d+XVXdV73ldNYz7BAAAmZmZmZ7MzWQFfKKlxEBpUIgtc1dVdVTRx8NLq7sBRLu6u6+q3mGazMzOned79n9fiu89ScBXe6AV1rdgr736wV/QFf6gAr99QK/fUCv0AVeVVVUi+PKkqq/iqqoAAAYAWAAkkkkgAAEkne96kkAADgbAUCSSSSKxmt3cns8VuSqp5JKqnklVTzTd3dV73vbb5yS+VM55gAd73t+yoZ5mBtKgF+ypfLsJJJJzaa5XOSSSSTEmr5ykqraTVfVql9Xn2727+/bme+GyBXtNSpAppo7+f7+7u7v3ve1fyh+oqMUJUqSTlc59999973vasTU1JJ73vTm01rmuST6e96Y01fE1rKfeaWlzvczl3VZrNZngAAAG2g2AASSSSQAACSTve9SLPAAAAACSSSSPbuqanaqS/PqqQsL/H7dp3zd3de973l+1XlX55ckn0klI2mvtbSvmrzMzJJKRtNaa5rXAAkkpG01yt8AAYBiTV8TV1d5mZkmhyqkblTOe2qve97w9lTc8vFVe97z32NCrfAAJFN7TRXFwACSY2lziazfO57uVSKVJVN89ztZ6YAAAEkkkkAAAABJJJJABGmgCE9knd96m5IcACg2DgJJJJOQ01K3ebdUy20tNpbmt80Vyu0e+M3d7u7ve999lT088sAA730lTeZzMVVO99Vdb1vYBPfKum/PNgEy7qt+1db1mKu6qe+Sp7xtVAO++SobyZ75iqoT3yrr3TYBPfKuvdNgEy7qt+3X6te1RShKlKopuACsgoK1ugUA2VJOzlVmefvt3e79qqqqd73ve970CwDgAAkkkkgAAAJJPu671JIAAAAEkkknTyv3Nkqq+8LPC6qTDz8D1VUNL92/POTnJWc3693d3VPfJU943qqqnvkqe8bAADvvkqbfjiqod98lT3hYAAd98qT3hYAAd98lT3hYAAd98lRvxxVUOsiasTU+399999mZ79qxPyACvYoCugVgCvO0gitRBFNBW/3ifv37ufsz2YAAcDYAAAVVngDo7d1R4D27qhQ+AAJJO971JIBsHnACSSSF3VZl1JxqpO5Oe1UnaqTJi/Y/hfFVUOt+yo5fvuKqp33yVPeFgGAB75Kjfn2KuYE3pNbrckkkgc2mt81wACQMbSviqZy1V73qblypnLVXvepuXKme+ZiqqBfsqXy7AAAL9lROSVVfsv2SqrnJ2TZLMwvTT4qVVO7t1u7tzdW1VVUHoHPhzgcBJJJJAAAAABJJ3vepJHA2AaMzMzPZmZmHvZpQ/CrihkoVbEiBJX3zn27vTd3d3VAL9lS+XYAABfsqXy7AAAGqky5UzmYqoarnsr3kmc8tVQAv2VNzzMVVAL9lS+XYAABv2rret7ADftXW9b2AG/aut63sAAF+yo+5UnfZ5ufvtupvf1VJu77u7uqu8wcAA9A+ABJJJJEkkkkAAACSTve9SSAA9oD4AGqytfeXd3f1Vdar9VXd5j9fy9Hd3dVAL9kl8uwAAC/ZUvl2ADftXW9b2AG/aut63sAN+1Uvl2AAAMlTLlTv3n3yqd73u5cqZzM1d3VVv2VL5dgAAF+yo55mKqgF+yo8Pz+/fjs/VA/ftPtLm67cqt3fa3d3d3MwASSTwGzoBJJJJAAAAABJJ3vepFnnoHwAAA+u6r9d3d/Tyv1Vd3q63vypVVTluI8dAAAC/ZUvl2AAAyVL9lRzzPVVANv2VL5bu7u6qt+ypfLvVVVW/ZUvl3qqqrfsqXy7AAALs0KqVU6mo0NUUU0/P33d3d2ZmeWdy8ryqk5555Oc5999u7u71C25zlSZmKq9Av2VPPmEn7ZPu/tuVPt/G778rFfoqqszAJJJqSQIAkkkkgAAAAABJJ3vepJAAAAP3Kq66u6r33VXd37qvXrgySTve9Qv2VL5V2AAqt1UmXKnkzMVV7urnsqZdqqdAv2VNzzMVVAL9lS+XYAABftVfLsAAAaqTLlTOZiqhqueypnLtVQAv2VNzzMVVAL9lS/37vWT6vuHCP4B2Ivtq7ubt+8nJO7u7u/v34TyST2T6HwAVV7PXTvp0A8u6oB0AjQAJJO971JIB4A6AC7qv1by7qu59zy7qt0Kt61aiAeUNbizX33Hyh71fZ99999gG/aut63sAN+1db1vYAObq6zmZgAADVSZcqeZ5mKqgG5cqZzMVUAL9lTc8zFVQC/ZUvl2AAAX7Kl8uwAADdqpPslTz37377d3d0Av2VNvVl/gVqgV3+C5IGQKgEQqUQInKBWJCEUCAVQK1AVkBXN/Z+73v7MqZq9gtyxGDzLBX3NcNa4dzewV0+quybr2gRTM4Ze++932a7r2zXMhuGgViSNkKIlE3ETRfe9nLzut9+vAVyTVdzVqBLiK5r19BXOorOUCtd1Xfvva6aq/pdyp9V1Sjc00g83Nc2c993qgtu/HpD0riTvuFGr1JZq9Bt2wj7iK9AAjIoAfVzfPez7EVwl4KAWwQCIJAEIBISSEAYEUGKKMBWTMtQzM7mYJ0FYqoSZ73pI02/KkmmpqAADXuBsDsnkm3SSaTU1JJAAAABokkkkE6TbSQ7KUUCwACACpFuZmZ3MxDyCsZEQCRVWCI5MzPe97PlQWgAMIoyKxgKxFYoBEV+BWAAUEiIEQSArIqSBIihIgrBVqfffd+++zwSKBAFdK0opoz+vvvvvd+++FWQRWKKwkBFICv1ZmZmbzLgK+BWArlbzMz2YmwVieIwBXbSouoggWoixQElUCAUMTKzO57MxFfMRFCEJEBQgKwFYkBWESQJCArEypMzMzMwVcRXKAQiSBAkhFFSRZCMAkUAkJAhAFSqzMzMzPAK3Srq7vWvQQqqqqlNAAAABVXV0AFVYAAB4A6aAICSSSSAAAAFAASSSSQAAlSSTkkbaAIAAAAauSSe/akmz4AAAAAAAAAAAAAAAAAAAAADve973vQAA3ve9gAAJJJJIAAAAAAAAAAAAAAAAAH7MzMzMzAAAAEkkkkAAEkkkkI0JJJJ1IBwAAkkkkgAAAAAAAAAAAAAAAAAAAAAAAAAAASSSSQD7ypUqucklVRVSVX58W16oAAAAAASSSSQAASSSSQAAAAAAN3JJuSQAAB74B1AAAAAAAKAAAAAfgBgDgbAAB3ve973oAAO973ve9AABYAAACSSSSAAAAAAAkkkkgAAc/VPJW+Q2KL3OwQCRBXUagGcUO+0eUFuAi7+50RWaFF2oeOKF/KEFQcegr9pVeAqz5QrfEBFgJ0E2iBk38KtCrOIKJ8c0KuKG/p1jaZg+HoAB4A6HkphlZmZlX3MQQPAikhAVkQAMrOcUO5l4YIAeBWAiBAViABzk5IcwAsCfp+/flfK8/nv79+uVVV+3d1+VzMzMwAZmYDM+HNySSSRd0eAOgAAAAB8PQBJJ3vepJAACvXP1fqq7tV15fklVW7e7+OebugHQAL25U5nmYqqAeWQ2QPX33d3d3MzPLmhCupqUEKafn77u7u7MzNhD3yIQrqalBCmkfr++7u7tAL9rZKnN55yp9z77d3d0Av2VHPMxVUN+1db1vYAb9q63rewAy7uubqp5nmYqqAblyoP7z7u1fZ+Pu3Uru66rmAAFABoCdkkkkkkkkAAAAAAAA9Kk973iSQAAJJJ8rxJqrAuzoYAAAF+1I55mKqgF+ypfLsAAAv2VL5dgAADJKy5U8meZiqoBuXKmb599u7uqBftVPfQA6AX7KjnmYqqAX7Kl8uwAAC/a/pyq37z77d3d0AaqTLlV5da7zPs1nauru/fqSdn8dT9+zMzAAAAHmgTskkkkkkkgAAAAAAAEkld73qSQAAO973uyqqn778r79sneSVVd7u7u7ugADlypnMxVQNXLlTOXaqgB3LlR+8++fyqAX7Kl8uwAAC/ZUc8zFVQBkqZcqZzMVUANy5U37z77d3dQD29CfIn7t97+9+/fv2Zmav6foxEqpKjERr6/vu7u7szM8vq6pQQWqalBBr67Lqp99u7pVSbrUk91V2t3dVVAIAAB4B9JJIsASAAAAAAAASSd73qRZ4AABqfpKnKlSSK2qqAAABfu83lcCC1TUqEH6/vu7u7szM6SHvnVdSggtU1KhBPr++7u7uzMzy9rqA+r77u7u7MzPPZUc8zFVQC/ZUvl2AAAX7JL5dgAADJUy5UzmYqoAblypnMxVQAv2VNzzMVVAL9lRqVVfv3h3O9jiCdjQAAegfDwD6SSSRVWeAOgA2qrp27qjzgAAAAAJJKrve9SSABd1Cqk+qpLKqS5kjUqfee+eWvVfwAAAF+ypfLsAAAaqTLlTOZiqgBuXKmczFVAC/ZU3PMxVUAv2VL5dgAAF+ypfLsAAAaqTLlTOZiqmqueypfLtVQAv2VNzzMVVAL9qpznnK+nM+1dXd+fcPunskmaAAAA95+zMznwkkmAAAAAAAAAAEkne96kkAF93315VSeyqqvLV+VQAAAL9lS+XYAAA1UmXKmczFVNVfJUy/LtVQA8lTb8u1VQDyVPee+gAAHkqe899AzMzMzZA98kQqjqGqfn77u7u7MzPOkPOYC00rVFVVVX1ffd3d3ZmZ5ZDfX33d3dQC/ZUR8lVVfr/fj8+L3QL1VfgAAADQBAEkkkkAAAAAAAAAAAAAAAm/uSqqvuVVVXKqRXHIqgAAAX7VXy7AAAGqky5U0k/e/v279uoB+y5U8meZgfAAH7LlTfZPvfvl+VAP0y5U8kzzMD4AA/ZcqZzMD8AAMlTLlTzPMxVUA/b9kqe/effbu/t1ValT9lyp7nmeh+AAJuXKmx8dv93fZKqufvKU+/fHd0IFmr+X8q/K+gB6cOAFgAAASSSSQACSSSSAAP1ZmZmZmYAAAAAeXmq1Uqqr98rbtfdqpN5uqqAAbnlypnM9xVVV/TLlT3kzmeq9VWL+y5UzmYH4AAv2VHPMxV+qpFPQkqX7JV8uwAADVebSvaazuu9WZMzAD2Npdq21Pav3sy173vdy5U9zzPdV3VV/ZcqZzMV6qsl1md5uqvvlfV799O9kkkMAGAbBzQBAEkkkkAAAAAAAAAAAAAAypJM5UlVVbJVV9JU3d3e7+5t6AYAAeXyVNzzMVVAL9lT9zOZgfAAF+1db1vYAb9q63rewA37V1vW9gAA1UmXUnmeZiqoBuXKmczFVADcuVM5v327u6qF+ypfLtVVVcrLlTfjPZKqjlyZ3se/kQ1V2KqAayKuZmZhoAgBVWeAOgAAeXdUA6AAAANXdUDXmvg2SABd1Xml3VLuq3fdJJPQhRJJaIQgntX/X9vu/u793f3d3dqoF+ypfNzFVVC/ZUvl2qqqt+ypfLsAAAv2VNzzMVVAL9lS+XYAA37V1vW9gBv2rret7ADftXW9XYAAA1UmXKmczFVADcuVP0+r3lRyAq6BXt6s+BXmuZlWb+nTt3dne3HUw5Xd3etVnNaK/bK7cUFilxEd+OHfMNdIbqjV3vW9SuCIugV+UA5r2bz773zlKilbhQqtqIWQVbYARS4kiIlArCgQKiIBQqxkaCRalDKlEYlRVAKRWQBWKq3AV9Ly8zmZmKgmArEAU4srMzeCcqru9XVLrQ4ACbu6qdu5d1VVCQFYCsQTYURspFaaAVoUq7v2ck6Lq7sAeAOhV3d81fljAVgRRAzMzmZmY7wBFLuszMzPIrgZmaUMzmZnNAr6gV3eCKmlEXSK0iKQRWIARpFaQAYtpt1+vMz0zIk2y6TWqklyTOJNsALMzJe8zM1nM9mgFcFUaRFJCYSZmczMzQKwFcEVkRVyIrUrMzmR97wCIRQDNlggXDMzM77M0CvgYeAYAdqHAAA2qkqskqqVXFW5KWIK4wgQJCREUmZmczMzMzMzMwAF1d36B8NAESmgAAAAADMzMzMzMJJJJIAASpN6kk5AACSSSSAAEkk895JPT7pi7qrvWeZmZmZgAAAAH3BtwAAAAAAAc0HAzMzMzMzAAAHe973vegABX11fOc5wQAAXySeySQDMzMzMzMAAAAAAAAAAAAAAAAAAAAAAAAAkkkkgAAAAAASSSSQAASSSSQAAAAAAN3J33ve9SAAAAAAAAAAAAAAAAAZdZmZmZmYAAAASSSSQAASSSSQAASSSSQAASSSSQAAB8PQAAAAAABQoAAAAD8AMAbnrwfEAAd73ve96AADq9SSSSAABYAAACSSSSUAAA/VeZmZmZmAASSSSQAAMq9q8q67PKq6u97Vfmrkm9APfbBOniZw7h5QsBWCO0VgcBFgUCsL7z1KHUV6ig3EEXihO9BFPAncVWSCrsUF2oX9OKERXdEKFWrKFXaIg7UKBV6hAS0AU97YJ1Q33etdvn332ZmZmAAAAF1d2uruqVdVd3q71VVd35flVV1V+A2aHAhuqu71egMALkqqZ3vbtzx8++uTJP59999+3d1A2pVV+X3atVVdAgAABgB9gFiqoSSTAAAAAARoAAAAAAb8rydaqrr9slVXJySqr29zfobu6/KqqpbcqZzMVVAL9lRyeZiqoBfsqXy7AAAL9lS+XYAAA1UmXKnmeZiqpque1N4APsa5z3ve9ckm6sB5rOcYYw+1997d3dAL9lS+XYAABfsqXy7AAAGqSvia9s8lz3svJkbSygAkkkgw0AAAHA2BJJJJAAAAAAegfAAAAABfNcu6qSc3JPoegB+5u6rmub9u7uqpftSdmeZhgAAdy5UfvPvvgDsk5tNZersAJJJdcTV1d8kkkkl8TV1znJJJJN+1db1vYAb9q63rewAjaV8fKbutWdAACYkn201pah7Wbnrr3OG+clVyTkqqk9vPz03dVVyAAAIAA9A+AEkkkkAAAAAAAAdPAHoB8AAAbVVJNkqq5JVVSqqugAAGrlyofeZjioAX7Km55mKqgF+ypfLsAAAv2VL5dgAADVSZcqZOZiqgBuXKmczFVAC/ZU3PMxVUAv2rret7ADftVe9b2AGXdVzdXXl/cqVKqfbUv9+3d3rviquUHgeSpIACuYAAjQAVVngDoAAAAAAAAAAAAAABJU2SbJVUquKuqqAAOXPeSTOZ6qoAblypnMxVQAv2VG898xVUA5VSX7KmZ5eAHQAv2VL5dgAAHKqRqpMupPc88xVQA3LkmczFVADfMuVM57i0qAF+yp236/fn6lUAv2VO95Ukn21L/ftvlc5U87vfDm75u6e7VKq/v1Sbu7u7u7oAAAAAAAHZJJJAAAAO3dUeAAABlZmZmZmYAADlS7qtXUfKEPAk+UVK5xEskQE3U1vPz8klR1VpAAL9lTueZhlAABySptVJlyofeZ85SoAb5lyofeX85SoAb5lyofeX85SoAX7KnvX67+fqVQC/ZU7nl2AEklc2mhK9cAJ73isbSvia5y96zOKne9Ny5UKk+8+Ve/v353LlTOZgqju/v379+/fv34AkkkkhwNqAEkmAzMzAAAAABQAAAAABSN/ru7u/1Vd3G0o2lffvvu9PvgZJJJJTaXNpr7d70AT3vHNprlcmSe970rm00XrlgBJJjaV8TXL1qwCSSfXxNXV2ASSTL4mrq7D4kklJNc20t0Z3fbzMzJJK5tNcrfJISSTm01sve7ACSTG0r4mrmTu+XJl5DAAZWarMzMzMyVJJJJgAASSSSQAAAAAAAACNAAAHmXW+XdUG/vugqqd7oGeypnLsAaADlVJftSbnl5mZhJJXNprlb5JJJJObTW+a1ySTJJMbkblTmeZiq90B9lTOXaq973p7Km55mZmZkkmbTXK5wACSb2mhVzgAEkxtS7lTy550v7lOfXnyqAbFVVUsAMAAAAkkkkgAAAAAAADp4AAAB+u7u9g5GmACT9vLuua5++3d3VO+sqXy7AAO922VM5mKqBQX7Km55mKqne+kqXy7AAO99JUvl2AAAX7Kl8uwAAC/ZUvluKqqjJUy5U2vfvfvt3d3Q1cuVPpyp9zMVegBYA4Dp4AAAAF1Z4A6AAAEkkkkAAAHTwjQAAr9QAwzMzMVW/ZUvl2qqqt+ypfLsAAAv2VHPMxVUAv2Tzkq+X6AAAX7Kl89ADveg1UmXUl55iqnehuXUmczFVAC/U193u+9zMzJJObTXK5ySQADm017NJ9rv1ZnczAAAAAaAIAkkkkgAAAAPLuqAdAAAAAABd1XcUMUKUPtIkkFXVSlDWO/q++79996AAANVJlypnMxVQO7fsqOeeZu7u6qe+Sp7xsAACUX7KjnmYqqHS/ZVb17sAnvlXSt+ebAJ75V17psAd98lT3g4qqrQySsuVNqfeffbu7qAasSa93L3AV1sFYCupM5WtgrsFdaRXpegV5lZs5vwK0hMIzmWCsBXdXd4qutjN0yclhIn7Jn2djvps1unX3eKC/VuN+yw7G832ZKOVcssC6y5CzVzWpOeft6+zvfZ4DyK4isRWhRFkQViisCpAiisBWIrIKsCEEkhAhCQjGRJEJEioQFYCsJFACKhJWZmZmZkQQgKwFYoEAVgAEmZmZmZmZhmerKzOiAGAo61q0FdxUDOZ7OZmYKgeJgK0KkgqrVUZmZmZm1DMzNZgq7u7AcF1dVV+1q7u7ungCW1mZl+975QWzzsFclTMz7v33sZEVjAQVwVEYNIikIQBWMVCK6SetfqzMzMyokklkkk9JlAAAJNtuJpJcG0q3rZJ2SJgk6paoOABBppV7Wrqrq6rwBqVV1dSSSdPAHQAADZVSq9knaXxV/KVUqqAAAAAAB27qjwAAAAalVV6rV1WtNAQAHTwBlU3mZmZmZgEkkkkAAAACS20rUk3uqupB4A6JPruqk8kkAAJJNfe+8k5NkOZd1WszM3mZmAAAAAcu6rYcfAAAAAAAAAAAAAA73ve973d3VA4ACqtdWqr33vfe970AAdXJ755PJJIdMqqqszMzMzMkkkkgAAB7d1XA2+AASSSSQAAAAAAAAAAAPLuqAdAAAAAAA4GwAAkkkkgAAkmruqkkkIABJJJJAABJPpPJIHa91Z4HQAAAACqugAAAAAAAAAO5NVfzezgwAAAAklVdSSSAACSSSSAACSSSSAACSSSSAAAclVddePdgAAAAAAPPWnduXdU278dboHAAAfgBgHfKrfl3Vb733XdG+b53sAAO973ve9AAA+HoAAAkkkkgAB9d1R5JJJIAAB+qszMzMzMADp5JJJz67qvpPXOAAN0J9nFCk79R5QzeKE5ihnlDygvVBd3ih92AuROQr63cXUJIEhcaj8aLKLiEkJSVItF2CfYoVXrBO6Aqd369UoVJxQvFCz4Oc3ih8b1ihyzqhKl9UN/a6bjxQuKGu7UJqgFZtQpBFNKHFC/lCIrc58odRQL8czkPpUycUOG+cJrXlDwq8UM2fKHlDWAkAV2od+VXnyq1rEFE8CfaoE2CdBIKvQ8CcKBOKG952oibh3gq8vyKp3uud5ulD7h5m1ClRSbUPq8Ku1C7kkihQq62ofWV73youa39WTnsucuVXfbea37V5WXs57Pcy6bSPBaAA9pze5EmpJueAzvcy88uKrIyIqwFcBWArQRRWKKpFFYqK7ZV5mZ0EvM8hdXXjw+EAB93L155JPWq5zvOd5zvCS7qs1Q+HoAAAcknskkBJJJJAfxmZmZmZgAAAKAAAAAAKHLusa1JJ9JJJJJJO1rHgGDN6crXLu7uye+Vde6bAJ75V17psAU1l3dc3VTZ95n27u6gF+ypfLsAAO++SprM98xVUO++Sp7wsAAO++Sp7wtVVXUaqT7JU9z73f2bu6iq/XKj+5zz777FQAAAHTwACSSSSAkkkkgAAAAAAAAAAkkkkgVd1r3yn7MzMmZmAABlyo/efffKqAGXVZzMwAAC/ZUvl2AAANVJlypnMxVQAKqTfslT7n33yqHwG/XKn3MzPlVVTLlTPfMz0AAC/ar3lOee4qqH4MuVM5d4AWAF+y6zdZ37k7d1U97z7uYNNAE0AABpJOSSbgJJJJIAAAAAAAAD4egSSSSQb8uSTknYAA37V05znoIN+3db3sCDftXW97Ag37V1vewIe+VdN+b9AHvlXXuvQA98q+6rF5x5jH1fe9+973pJLxjm8+UABjQxj6vvve973pJe60AABjHsYGccrnve973pJe60AABi2OVzd3d3ckkgDMzMzMzMA6eABJJPKupJB0AAAAAAAAAA8pdHgdOmt3dVJJuTuYx7OF+973ve96SS+b0AABjzH1ffe973vSSXzegAAMYxzXOXd3dySbqwAAOa5y7u7uSTdWAABnmucu7u7kk97HzgAAD7X33ve965JPc34AAD7X1fe973ru7m6swAAc1yuXd3d3dzdWAABzXK5d3d3d3N1YAAHNcrl3d3d3c3VgAAfv33O/Y633F39JJJJJAAAB2NeABJJJJACNAAAADt3VNNAAAAEkkkkGty7qsXdUu6pbSlpNXV17Xe+JG0jM2ABmZhzeVVVVUADmuVy7u7u7ubqwAAOa5y7u7uSTdWAABzXOXd3dySbqwAAOa5y7u7uSS84zjm9AAAYxjz6vvve973pJPc34AAD7X33ve965JN1YAAGOa5y7u7uSTdWAABzXOXd3dySbqwAAMc1zl3d3cvFve9WMZx9zQAAHKq7vWfV3led/c/fv34AAAoAeuBv4CTve971IAAP2ZmZmZmAAGgCAACSSSSSSTyy7u7u7kkkkkk9zfgAAPtffb973vXd3e6xeWMeaA+19973ve9JJurAAAxzXOXd3dySbqwAAOa5y7u7uSTdWAAA3u7u7lyS85xjm9AAAc1zl3d3cknub8AAA5z3ve9PSS+b0AABzOuc3d3d3d3e6sAABvdXd3cu7vdWAABzv78+xjf2/1325JJJJJAP2ZmZmZmAABJ3ve96kAAAAAAAAAAACSSSSAU5JIBNySSSAHN/VVUAAY5rnLu7u5JN1eDDLIHNc5d3d3JJurAAAxzXK5d3d3d3LxjGeb0AABzXOXd+9713d7rwAAHNc5v3vXd3d3urAAA5rnLu7u5JN1YAAGOa5y7u7uSTdWAABzXOXd3dySbqwAAOa5y7u7uSS8Yzjm9AAAbMSl85s1acQA/ArBQPQFa9ywBDsD0AQT36g/QVA8CsVQQ/RVAP0ERsFYgiP6IK/ogqfoAr+iI7VCAqL+gAKlArAD9FASIEkqEk6jqkknd1yBDqkO7u3d3NoAAAk73ve9SAAAAAAAAAACSST3vZmfKgNGAmZmZ0A/AKyArFWSjWEIEQklSQDK3u7u7u3MzO986qoAAfa++973vXJJfN6AAA5rlcu7u7u7m6sAADmtc5d3d3dybqwAAOa5y7u7uSTdWAABjmucu7u7kk3VgxjzQfa++973vekk3VgAAca5rPLu7u7u5eMYzzegAAM81zl3d3cknub8AAB9r773ve9ckl83oAADGtM45WAF/ArE1zn7RsBX9AV/ftIH779YK0CcBWhFT7761RT6Cr9wFaA++XKkqqySSScqVVbu3JVVu7u7quAFgACTve971IAAAAAAAAAAFgAeGrqfArUBXNKHFDQJeZnOqr3tH6X73Pe973ru7m6sAADmucu7u7kk3VgAAY5rnLu7u5JN1YAAHNc5d3d3JJurAAAxjmucu7u7kkvGM45vQAAHNc5d3d3JJ7m/AAAfa19973veu7k3VgYMhzXOXd3dySXzegAAONc5d3d3ck3VgAAc1zl3d3ckm6sAkkkkkFWRFeT0BW5cCGjVW/gViAoegqrz1AmgVgL6KK1EgKyoqgfv1Iq5AUNgrEFYqsUA/ffrAA0CsFgKwFCArAEICsFICsAgKxQH99QKr9CbUJCQ2ofBJKIG7u+HoSSgkm93d+/fv34AAAJO97353ve97JJAAAAJJq7qpJJCAAAAAAACdqpGQqpPkqpMySVVckqc5nOOZlVUk2SVVclVKqpN7r+Ve97oBdWAABzXOXd3dySbqwAAMYzjjGucu7u7uSXnm9AAAc1zl3d3cknfb8AAB+/V+/e773pJJ29gAAOa1zl/Xd3dybqwAAKxjlcq7u7uSTq/uaAAArGfq+q/13dySZ3VgAAYrOOVyru7u5JM7qwAANY5XOXd3fe97qwIfpUkhICu8o1Y/Q+5bfela1qs3lX3XQV5qatFaPpruyr1yWG/wK77UnN0T6OTczpVArJErksFb1fqkBFP8w/7Jn9EgKqABIoqqK6r9ShwylRXIi/1F/RUD+oFTcUkEQkEUJFUuADuKiIsigPYiOoqISIIbiDqKjIIBcARkERQAqAoHIIVER/kECogEhL1YhJZCEogCauyFkJUu5XbqPYT3L3EkqehyWaCq5KkOzk9VUVE08vldrl3snaCp3lHT3oS97/rS97VGPbqN3RK9ECy+Xz2Q3cnN5JDxBu53kKNGqCoMiQ727iXAqEgVOHuU7TUBuJuKIyCCUQALghe+Xc5tVangV4CugVoFfAroFbsN91fQFYCsBXgK0Cu3QK2ArVgrYK8gAGqpVc3cVX1gAX7fAV4CvQVoFbBXdywV1AV0itwEKlAhdXAViCtNAruAr4FdjUICyXYK6BWwVoFZICugV2CuAK2Ar0FcBWk3DWqRaQV6CtgrDQKy5U0CvARKgIdBWArQKwEU0CtIrYK6BWg0CuArNmjncs1CSEm8BWwVq6kRWRh0Ffb3Jec4QhXta96UCur6CvAVsFb6KsBWkVlXu8rgK6BWArq637dArq67ddBX2rydnt93oyt57XKna7chCTuydrIdlArwFeArsFfArYK0CsBFPArtFbBXelVueBWgVwFdgrvOgohaLddsQMBXYq5q/cBXwK+wFeErAVpFYCuwVgK9BWgVoFdGa8oHVA0dvW989yjYa4VNW7vvdIraK7BWlA17loK30FYAroFdArwFfArYK70HArLBXYK6AV4CurBWwVgKwFdArwFeArAFdArQK8BXoq87VSSe5dXXe6L1u5Ze69vl7JISSSEJIervprlKBW/cgK6BXwK0CsBXQK6RXNArSq8k9wFctFfArwFc8ivtArYK8oFb5dGUScial7NXWq2dou+Vd/yr4pVeL8vqqq/3v9XvlN35Z/FtB583rV2SdqVq+kLlSVVHjRD3vTnb5vc5qVyQrZwvdVvd3rdld1Je65LM9y2eN2nO3aSMSepk3Adbux3qpDUC5qdhU3FKhI6hUez7tSOgVh8CsPruXqWCvjV7+9mpUkkk3VRjynQah0Fb+zvZoo4WCsFXwKztUHY+urnIlweQKBXQK+BWwFdgroFfArsFegrtEU5pcp9s3y7IBuve927u7CI3ZyHpXJ2+572973veZm++z3odFr2XconQVhd88itYQ3JN8t8Ct1m3tcNStaCVuuArzuf8rDeuUd1TVGr+zRzTDlb0/Arz4dKBETRoFdgrQE6d/dpv7Nfevn6X8CsD6QMatrG/xzFfr+VnYBnOmhmtUrTMBWSqO1RqirBXYK1ub1LqnnL1+7feVKJD07po9EODJc1AqH3aQ3B2Qk/XU+r43rKwFbLCRnuPBiciqG9k3qPNj9xDepR+mArH2qqb5T+nsok5VPp1ga7y7ly9ArR9LlgrWgV4CukQhAFeArgKwFaBXZEV7OAroFdAK2CtgrpFYCtirewV6CvdgroFeKK0ArsFdAroFegr0EUq9au6M5/uf6/0n/3/zP/f+pP9/8v+P9K/2/2/0LP9n/ec/4/EvTD6/6P7lH9v/X/8xQVkmU1mN36wMBISu34BgAHAf//X/796rv///+2EWYD4AAAAAAAAAAAAAAAAABFOAAAAAB6AAAAAAAHoAAAAA0KAEgAAA6AAAAAAAAAAAAAAAAAAAAAADeAByAAKAFAARAHAAAAAgF1Y6EREbpgAMZNGCQJCoqqKkKCKjZrAAAAYAA0ABYMQAAARAAAAERqYg2K1IWmIbGCIIisAYAAAAJsbDCNjBEKpgBZYACywAFjAAbLAAWMAAA2AAAADIgAAAAAAAAAAAAAAAbLAAWWAAxDQDEABGwAGIABEABGwAWRWA7cAAAADgIjDEfWMBssDty4U7iwLuOBsY0WMBssCcAAXAAAACxjcCxgE2AxDSywLGGDLAYmg7jHR3HcC4HAAAABEW7E3LAYjR3HcDty4p3FgMbHS5YDGwLHcCABgAAAA7MbT14vMBsYDYvcFx3AsWFWMBGwpjsCx3AXAOAAAACIgcDuMAmwGNiljuAxsBiAjsDEzDs1gHtwAAAAXAxhCIFAoqQSFYjSzGpjFmjgSuAAAFaGgGAAAAASmhARATIAU9IJpqeSPKeYmEp5TehpT0eShlNMD/aqgAAAAAAAAAAAIlJvRv2qlKpVNGCMJphAaNMACZNGAJiA01J5HtSpVUjEYEwAjABDAAAAAqp//qqpR/v1TfqpUqqaYjEwAEYCYATTAAAAhUk2TFVSEE0ZMEwmgehGJiaYQZGTJjdv4cejlw49F73vyGODADMwMzAxzEx+v2tHu7f2PZ4Hr9i/cj3fD42t+2P84n9LabD3bF8M+/P7TocP6pO2nDdSCx9KNqRfptjO8xv/u+8Sy9caEP48OnUxxxQ/vx3Wsa2sZhtP42/XoW+v8vOt/F4/D8fVzr7OzTl79/m+PLn/v3+IxFqDi+fP+vHh2ePRpk86038c9VPz7vu37aIWznnWvyn1eovev9nsksiOKDPzOQxzQ6ZVq/0a0GN9c16KR106uylqqY3KPrZrCGZgPSmYZkmGG/H7BH8HYDfgJhiPwf7PSl6Svn9PotTOT8X2lR0qOvsILhUdZVHCIJkVH8qOQVwqOQ8/yIgnp6qOlRwqP4ENILCBALEQAuKMfjAGFRwqP5UfEBX8qMgrpUdAHPACnQqMKjCowq8lA+VHxBfNCIYVH9tUYRD5UfVRwIu0BAlRwqOVRwqOVR8Myo4BUZEEyqPgC+AqOBQyKj+RBMEKjKjtUZUfFR0qN6Ko6FRhUdCo+qjoVHwBdCo/hUfwqPuVRwKjhUfBUfFRlRyqPoqMqOFR8VHKoJ8qMCsqMKjgBfyo+qjIgkqOVRwqPqo/kQTio/KjCoyIJkVGQXSo6VHAqPmBUcnioyo/nF5qJUdKj8Kj6qOVR/Kj+VHIqMKj6qORUfyo+ArrKo+KjKjKjKjlUcqj4n4VH8qOBB0qOFRyqOlR8VH1UfFRwqOhUcCo4VGVTSo+ogn5UfFRyAc0qOFRz+FR+VHxUdqj+VGVHxUfFR8VHAqP0qPqo7VHCoyoyoyo4VHaoyo/kFyqP4VH5Ufyo8QWVH7BlBfFRxKj6qOAET3AiCYEX8Kj4eKjAC+Co4VGMYRBJUYBcKj+VHKo+qjKp+FR2qkqPqgJ4CHyo+iAJKj4KjgVHxUZUfyo+Kj+AOYVH31Ufyo4QTCo8VHgaVH94Kr4qPwqMKj+BUfFRwqMqMqPFR98VH8qPADhkVHxUZAJUb8qOFRwiuFR2oIG1RyqONKj9+VGQAHxUYFR8VHio6BUfyoyo/sIgnyo58AXUqOAUeKpkyqPoqMiCenwqPyC6VHxVHao7VH8qMqPyi6VHIqOVR/KjhUflR+FRsCon71UfgVHwyKjbVHKo/Co/hUcKjlUZUZUfcB+FCUQTCIJ4KjhUcEguFRwKjkAxzgBfjSo+IgkqMqOAF/KjgBQ9FRwqOgDP5UfwC5AXKoyo6UBJVHXqo4BUfVRwqP5UfBUfFRhEE3hUZBcCIJILKvEUJUfVRwKjEeKj+VH8qPqo/gVHCowqPgKyIJhUfcCowqP5UfVR88FRwArwA3lUcwqNz6RBOKj8Co7RBMqjKjKjYVGVHCIJKjYBUeAEAuBUdCIJ4Avqo/hUfyo+qjhUD78ARhUfyowqOVR/eKgnqC0gsqP5wqMoGCJUcKjAo4FRlFUyCjEXio+KjAL+BDAAvgqMALIgnio/YPEQTxUZUElRlRlRlRwCo+mD9AiH5UYUPyo4VH0VH8qP4VHxUfwqP4VHwBcKjKjCInio5ANfhUf0qPio4/IgkCo5VHxUcAC8ZUcIgmEF2qOAVHICh6qOFR/Co7VHao+GFR/KjolRiRBPTQKHgqPqqD+VH0VHKoyo5VH1UfyoA5FR8QXIqPAUfyIJ+VHCo/gBcqjoVGVH5UZUfNKjCo6FR2qOVR9VHxUdqjhUcogn4FTao+KjKjKjHgIgbAOb3r5UeKj+FRgRA0qPio+qj+MIAflRwbFRwgufyo+gC4VHwVHAqPFRwqPqo+Co4VH1UcIA4VGVHAqOzgBz8Kj+VH1UZUZUeKjgVHCo+KjhUcCo7VGEUE4cBUfyo+qj4ILgVHAqP5UcKjKjhEE9VHxUZUfgFRyqMKj6KjKj6qjgBYAX1UfUQTgqP4FR/KjCoyowCJxUcCA4VHIKjCo6AJV88sIoUiCQoeqjYFRz+weKjAKjtBMCo4BUebFRwKj4qMqPwiyIJXoCyo/YVH1UfFQTgAsqj4qORUYVGVH1UYVH2AVH8KjtUfFRlRlR9FRlRlRsKj6qOEAPyowKjKj6qOTHkRKjKBEqOMIgnEAlRn99o/IqPFRwCGAVGFRwiCYFRwguAgFKAX8gvio+qjgBcKj54fqIIMB+I1fqAX9KJtUcIJjKo+Kj+VHIC5AX1Ufyo/kQTSo6VHxUdKjlUdCo4VGlRgF+DxEElR+FRlR8EDxUYfhUdmDxBZUZEE2qMIgn75UcCoyo/KjoAWVG/Co/lR2qL4qPh4Av5UflR0qPio+Kj+VGRBPEQT8qPgqPgqOFR9VHSo7VHSo5QWESFRjYqMIDsFZVH5UfFRlR/Coyo+Kj8qP5UcKjj5UZUfFR9VH3xIBYFT8qMqPwK/CowqOEQSRUNCo2UQTIqOVR9VHKo/lRyqOlRwqMgDKj8AL6fKjtUflR/KjsVH5EE0qPio5VH8iCfAr6Kj8KjlEQNeIgmlRyiCfhUYBfFR/QKj6AeAhhUdxERSAyA/ufkQTnFRwqjxUcKC5VHgIgfKjgVHxUdoB6WSwEChlUW8VGRBPyIJChoVGVHao/lR/eeqjKjkEeQSozhUfhUfVR+AOeKjhBH7CARKjGCGeU+eJhwYUwAkGQDefACvx+/ZAD0yAKlQB5AFUATgAnALOQAJwBQAKABOAJwBOAJwBUAFIAsACoAKgAnAE4AnAFhwB0AKACwAUAYQMYAIvwKgKZzhQ9AKUAEnAMRABAA5LgDw+KWMDNbECve8lqvIgCivABOAClE7szOiwA9DMz559zMz3lb8d70AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrMwAAAAADnOc5z/j53oHQAAAAAAD93ve973vegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfM+/f76AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbzMwHgAAAAAAPPPPPPAAAAAAAHc73ve973vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOc5znOcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZmc+H0AAAAAAAAfM3vf3YAAADve973ve96AAAAAAAH4AdAAAAAAAAAAAAAAAAAAAAAAAAAD3Na/da1r+/va/q87OgAAAAAAAAAAAAAAAAAAAAAAAABvMzAeAAAAAAAAAAAAAAADv18+4ubvTfvb4My/XuZmd6fYqqbue/e/1c7x0AAAAAAAAAAAAAAczMw/gHe973ve970AAAAAAAAAAAAAAAAAAAAAADMZjMZjPv379AAAAAAAAAAAAAazMAAAAAAAAAAAAAAAAHe973ve970AAAAAAAAAD1r658y1rO/db5772ud6AAAAAAAAAAAAA/ADoAAAAAAAAAAAAAAAAAAAAAAAAAPPPPPPAAAAAAAAABvMzAeAAAAAAAAAAAAAAAB+73ve973vQAAAAAAAAAAAAA5znOc5wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9+/foAAAAAAGszAAAAAAAAAAAAAAAAB3ve973ve9AAAAAAAAAAAAAAAADzzzzzwAAAAAAAAAAAAAAAAAAAAAAAAAA/ADoAAAAAAAAAAAABznOc5zgAAA3mZgPAAAAAAAAAAAAAAAA/d73ve973oAAAAAAAAAAAAAAAAAAB9zPv36AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfczMSSSbJIAAAGrDDDCSTRJJAAAAkgADzzzzzwNZmAD7mZgHo73ve973vegAAAAAAAAAAB2zMzvf7ve973ve973ve970AAAAAALMzHwA73ve973vegAAAAf2ZmAOHe973ve970AAOc5znOcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+AHd5mYN695554XvAAAAAAAAAAAAP3mZmd73vfO970AAAAAAAAAAAAAAAAAAAAAAAAAAAPmazvj7vv3ve870AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAazMAAAAAAG81nd733ve9dAAAAAAAd73ve973vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB555554AAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeZmA8AAAAAAAAAA5znOc5wAAADqFSSpKkqVflu7u7u/tAAAAAAAAAAAAAAAAAALMzWZrMzT4AAAAAAAAAAAAAAAAAAAAB5Uvz4VS+3rz3ypX3O93dDQAAAAAAAAAAAAAAAAAAAAAAAADWZgAAAAAAAAAAAAAAAA73ve973veh9znzzNZ3zec+cd3y8495dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJC6qW5l9nVcX1r7q+4voiLmozF7flS6YklJz02e03d3d3d3QAAAAAAAADeZmA8AAAAAAAAAAAAAAADve973ve96AAAAAAAAAAAAAHnnnnngAfgB0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5znOc5wAAAAA1mYAAAAAAAAAAAAAAAAP3e973ve96AAAAAAAAAAAAAAAAAAB9+/foAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADzzzmZme++ngAAAAAAAAAAAAAAAd33zeZzAnSsLArUpklZIhJWHd3lrIkrYslAe59f333nvvIAAAAAAAAAAAAAAAAAAAAAAAABznOc5zgAAAAAAAAPwA6AAAAAAAAAAAAAAAAAAAAAAAAAAADWZgAAAHNb3vZ6AAAAAAAAAAfu973ve970AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPPPPPPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3mZgPAAAAAAAAAHOc5znOAAAAA785jM787973vegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOa3vez0AAAAAAAAAAAAAAAP+Squj70AAAAAAAAA1mYAAAAAAAAAAAAAAAHn733333ve96AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABznOc5zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG9a1mvGZmM+5mZ/fx54AAAOa3vez0AAAAAAAAADve973ve96AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB555554AAAAAAAAAAAAAAAAAAAAAAA/wAOgAAAAAAAAAAAAAAAAA5znOc5wAAAAWZmPgAAAAAAAAAAAAAAAB+73ve973vQAAAAAAAAAAAAAAAAAAA5re97PQAAAAAAAAAAAAAAAAAAAAAAAAAB3ne9+973vegAAAAAAAAAAAAABmZnvvvvvvoAAAAAAAAAAAAAAB3ve973ve9AAAAAAAAAAAAAAAADzMzA2Dve973ve96AAAAAHOc5znOAAAAAAAAAHMzMP4B3ve973ve9AAAAAAAAAAAAAAAAAD8AOgAAAAAAAAAHNb3vZ6AAAAAAAAAHMzMP4AAAAAAAAAAAAAAAB+73ve973vQAAAAAAAAAAAAAA888888AAAAAAAAAAAAAAAPR9AAAAAAAAAAAAAAAAAAAAAAAAAABznOc5zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+ZmYAQAAA5re97PQAAAAAAAAB3ve973ve9AAAAAAAAAAAAAAAAAAAAAAAAAAfgB0AAAeeeeeeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3mZgPAAAAAAAAAAOc5znOcAAAA/d73ve973oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOa3vez0AAAAAAAAAAAAAAAAAAAAAAAAABrMwAAAAAAAAAAAAAAAAd99999973vQAAAAAAAAAAAAAAAAAAAAAAAAAAA8zMwNg73ve973vegAAAAABrMwAO973ve973oDnOc5znH4AdAAAAAAAAAAAAAAAAAAG8zMB4AAAAAAAAAAAAAAAH77ne973ved6AAAHNb3vZ6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHnnnnngAAAAAAAAAAAAAAGszAAAAAAAAAAAAAAAAB3ve973ve9AAAAAAAAADnOc5znAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeqktN+SS6klfEkmupI/MgioeAHmBPwBjwAsewBjwAsngBjwAuKi+sgj+APPwBe+ABiALwAjxUeKjoUJUfyoyo4VHxUfFRkQTCo/KjKjhUcKj+VHxUfwqOVR9VHSoyoyo5VHYqPhlUeKjgVH8iCQqOVRlRzKj8qMqOMqIN6qP5UYRPyo5VHxUcCo+KjKj6qPFUcbVH1UcCr4Kj8Ac9ALf5vwiCegoYVGBXio4VHCi+AHuQCwAWAC8+PwB5+ALCo6VHR+AMgHvoBONfgDzwAvVR0qOfgCaACyALAAq3AHyAKABXYCoA5IApAFcAUACkAVWGBi9wCJwAY+ALCo+qjkA2AfsAEeKjsVHio4FRgQ4qPFR/Co/kQSVGVHKoyo4VH1UcKjgVGVHaiAfAGwDZkAvwBYALABaAL0AsAFYAMYAPwBg8yIifKjlUcKj5hUflRlRyqOBUdKjhUdqjKj4qOlRyyoyrpBHSo6FR8APtKj+VHKo5VHxUcqjxUfFR/Kj8qMqPFRyqMqPio6FR0qORUdqjhUcqjCo+qj+VH1UcqjhUfFR8VGMKjpUfVRwKjgVHSoGQDZ8KjxUflR4AuFRlR8AP2FR8AMRnKoyo+qgfvQC8VH4AxAFtUDSowqPyoHmwCNqjwAV4ARgAVwBUAMgDwAIcAVgBSAWACyqPio/lRyAfvwBYALYBYALABaVHxVXHgBfegH4A8/AFXAC9VH8AcAPPwBEqO1R8APPAC/AF8qP7Ko/ALgA/ZALCo5VH8qOADzCo8VGFRlR8APOKj4AsqOlR4gcVHQBklR2KHoKIn4A/cALIBfuAGNKj+VGVHwA88ALAopSo5VH5Udqj4AZAPdgEZVH5UdAHmgC0AXwBYVAsgFxUfwBsA8+AI8APsgEXAE4ArgEAD1qAOSAK9wB6gF4qOwBflR0CEqPiqDwVHao7VGMIgn5EEwognqo+HphUfFRlRyqPio+KjCo/jKggYVHao4FRzAo+CA68QSVGVHao4VH8Co/KjpUfVBA80CsqNKj6qNKjfAB7FBg0qMqPoKyo+oAenheCgn0qMov5UflRwqj8qP4A3KjtUZUeCo7QSBUdKpfhUYVHSo6VHABqVV+VGUTQqjCowqP4A9RBPEVHQqOgVhUfVR8VGVHCo+Coyo/lF/KjgVH8iCfgFhUZUfQVHxUfFFkWYZwCxZmYZbGZhmZhhhlz8OXcLqjyVVXvr9NXhHeqzW/lTu+pX/t5HzUkqkWTaaNrTZNlfbS9kRzYYO05c4XUhnYiTsjtie3srW1i1u29WYD/HV8vSMjH8eI97/hQDuPNqjhAFwAKkSB+MCo4JpUcQqOBFlRkVH+CoyIJhhQBlR/CowKAmFR/kAXAKPioyo+Con4VHBYFEDAi+KjKjKj/GAYwAAHio4VH8KjKCH8WPyo+KjKj/IqPooJgVHxBcAhCowikqMqsiIGFRoVGAUEwCoyo/yECo+Co+AL8ASKgKbkCP0b88+59w6AAAAAAFVVQAAAAAAAAAACqqoAAO5VVXegADfvv9554KgAAYAAAAaAAAAAAAAAAAABVVUAAFVVQAAAAAAFVVQAAAAA1mYAAAAACqqoAAHQB0AAVVVAAAAAAAAzWZmszWZrNABrM1mazM0ABnvvvvvvoAACqqoAADmc5znOcAAAAAAAAAAAAAAAAAAGmvnzPmZ8AAKqqgAAAAAAAAAAAq7mAd73oACqqr/3ADoAAAAAAAAB+zvegVdAAAAAAADzMzA2AABVVUAAAAAAAAAAADQAAABVVUAAAAAAAqqqAABVVUAAAAAAAqqqAABVVUAAAAAAAAAAAFVVQAAAAAAB/q5mZvNZrNa1mdIJ9FDAqMKj6qMqOFRkVJUeGFR/ZAPAD4A9UQDABwAyqPioyo6VGVHCoyIJACusqjxUZUfAUROeKjAH7So/jKCo5FDCo+Co+CIkqPcKj4om/39lQPM+LeqjkRUlR2j4kzMRMMxEVH6DyT0A8w+IKAPkgoPZUegCAp+MyZI0n4HHz36899/ABVVUAAAAAA7SVJVVKqpcaSSpVVUpOSSQkklFrT4AAAAAAqpJ4kkniSSeJJx118bXyb4nxc41x/Jqh8sYwViXyqrGPPMFUTWKxgmmaxYpmqmgsYcQ1Qh6oKLeElTNBVGE/WDz8YppkpnyasvEDqRDjjs4mQ7unHdndk7px0mhPCMYsBXmMVVWICg8qMWE9EBD8IlIFIFMRIqPh+pKSCgIqQmkkIpQmkaKoaUqIZImaChKQZaDE4CxjFThB3ZkzQnE7ymeROBIiXlSxInCUEKKO8zCZ0iHh0SmiXdO8wygdnhOOUclQk7u4DpncQiHASURCYdwcd0pUSETOMfjyLzzzGPxVeGBiqaampGChijzGDfmE9n28agzjGMYTElRlxVVfsYaKSfxEWF9/Hjhq9fCx+/X738zyOITJ3cSSRMOh4h0mdyXcYSITDpQ4JOOIYUBAoghkodwgSUp5dO7idgQhJpSdk7uS8yJ0lEM8DkDhImLHvv4iKD9+xVB+xgPxUMxX4xivIsYvMM3lGMNUxJjzGDzGI8CKxgwT5h8rGPLGMXlijGDF+/IL6iH0lgAzL8Z4PSTvVS93MhnvEA71UrWZgEhAeZrN/focQ8zWb3m9hA8zWb3vYQAYqV/fB0IGBipeSSzMwOkAA6qU73venSABipX98AeIBaSWKk7nPvOgH2QL7AINCOIRKTHn7y8z4+0weCIJA4ovMJiJo8wGCKqpSpgpxYJKxYiIIkoYgqlpoImgNTiZqiqgoKUqLEmJHBP7GDE+QnhBiKaKVHEqBSqBmBxAgBiRFxGCRAHBIitARA+QIJhCiEVCAGVKEASRxGIAoFlIQlKFSkACkUCMSFKUEfrCL4KSEqCY88ApfBU/AwoH797iPMGMePhTjDVgiCxOGyH4PHHjiDxUbEePgIY8H9GIiqLGMRRShYiw4agJKaamrwBce+Y8QFAR8/vL3nBVVcVVQAAAAABVVUWsx8AAAAAAAFVVxVXFXuZrWUqq0kmqSVKlXs+zJnYEAxUru7AIAGKld3YBAAxUr++APEAxUvvJJZzzw9QPM1nPPPPD1A8zWb+/Q4h5ms+7+b2EDzNZve9hA8zWb+/Q4m9wB6JeftIIqP0gv0KCYkVXM1/e3nvIVVXFVUAAAqqqAFVVRafAAAAAAAAAVVXFXutYqSV3dydgAGKld3YBAAxUr++D4PEOjSSxJP63ywCABipK7uwCABiSSv74A8QDFS+V3YBPSS1SMzMD4CTI0krVJ3fLkkkklqlf30knioBipfepVVKh1SqkqSdS5OyeAACUOSSZWsq+gAAKqqgBVVUWPgAAAAAAAAAAAABJJOpKqpVxJKJJcVVSrMvMnYSSWqV3dySSSfKlL+5J9J4h2klapOuL7gAQgWqX3AA8QCsVL63dgEALVL7gAeIFqlxffAfBCHRpJYqT+8kln2BhCAYqXsuww8QDFSPnEqpUm6VUlVKUkrknpAAAAQAAAAABVVcVVTeZmVW6oAAAAAAAAAAAAAABaSXqSSSq0knSpKl1JK0kuKkklXbXbDpAAxUru7AIAGKl9d2HwQh0aSWKk7fwB4gGKld0rs+qkMIGBipfK7sAhAOJJYqTV3YJDzNZv79DiHmaz7m97CQ8zWcSSy7DDxAMVLy537z7iSpUq61VJJUlrN78577wAAAAAAKqriqqMzQAAAAAAAAAAAAB5JJUqq/vgwCAcSSxUnd2AQgGVS3vewgeZrWb3vYQPNa3vewgYqV3dgEADiSWKk7d2AQAMVK7uwgeZrN73sIHmaze97CB5ms9VUqKdVSr5qqpVLkk9AAACSJSSSAAAVVXFVUT4AAAAAAAAAAAAB9zMzmtazXze9noD+zMzxUn5JLOZgdRAAxUvZmYHSABipXd7CB5ms3vewgeZrN73sIH9mJNJLFSfPUks5lh0gAYqXszMDpAAxUru7AIAGKld3YBAAxUr9SpUllmZnzNa1rWZbvKgABmAAAAKqriqqAAAAAAAAAAAAADms1may8888eegPM1m972EAYqV3dgEADFS8klmZgdIAGKl7PPPD1A8zWb3vYQPM1m972EDzNZve9hA8zWb3vYQPM1m972EDzMzKzWs1mtZrX23VegADMAAAAVVVACqqoAAAAAAAAAAAAAAD1UlSS4kkJJcVVVJLMvMOgAGVSXkkszMDpAAyqpezMwOkADKSq7uwCBxJID6qV3dgEADFWb3vYQPM1m972EDzNZve9hAYqV3dgEADFSu7sAgAYqR9FSVLWZq1mZur2gAqzKqgKqqhVVUAKq1mZVAAAAAAAAAABve973v8AfAHwCo+gEAugD0AwCpKq9frPdIAGKl7MsDx7xMVLhmYBD3iYqV3dyT0kkxUru7knpJJipXd3IIHmaze97CVbzWM3vYSreaz3MxGZgdISS1S6ZmB0hJLVK3bzvu8qqVUqNj3xEE15s3b5z73fQD7+CorQrS0qBSRKUohQihQqUANCCqtAI0gNIAFCtKKUg0itCAUqjSCIIFKq0KFC0olKUCMTFAQgFQBSBQBUwUKhQhSlURAFUAUBCFJStIFYYqiqiBxKYlUMQNYlcYwIhgCk6qMqPFRwqPvio4/gAuFRwqMKj+VGVHEAcNQeXgiouoUEGhUVSwYmoBMQFA/wlR0qPqo5x53uH00oK5CiiihiZop8KqhRpBDxQQJUYVGDGMyo+ILKjCAEqMAK4BXACJgBEkFlASFRlRlRlRgBfQCBFTCIJKjMqMqMKjAqMqMIAPio8APFR8BEIhUZUZUZBElQSFRkQSASFRhQhQSRBJUYUAPARAwKo4EQSEQSBRAgEQJUEhUYUECVRWVGVGVGVGFR1KjglRkQSFBPFRwKqMKjIADgVGVHCo4VHCKiEqMgsCowqMAqECAOFU94AQvf3vuf4c5+AAAAAABVVUAAAAAACqqoAAKqqgAA5znOc5wAADz2v7nOcc5y8zMwNgAqqqAACqqoAAAAAACqqoAAKqqgAAqqqAAAAAAA5o/gAAAAA8zMwNgAAAAAVVVAAAqqqAACqqoAAAAAAAAAAAWtZznOc5xAAA85z+5znOAAAeczzMzOfefec4AAAuc5znOIAAAAAAAAAAAAAAAAAEbbdNNI4AAAAAAAAAAAAAAAABVVUAAAAP/QAOgAAAAFVVQAAKqqgAAAAAAAAAAAqqqAAAAAAAAGszAAAFVW8zMqPAAAAAAAAAAADQAAABVVUAAAAAAAqqqAABVVUAAAAAAAqqqAABVVUAAAAAAAAAAA6+pJJKvqqlXE6qlXFQgkqMiCfQK+CgPwBvwA9AL8qMKjKjCoyowqMqMqMqMoLKjIgJhUYFR2AbAPgDIBlUfgD4AwKHgB8fCAJ4KjCIJgEQP4sQ+/19+goAP6MzM1ms156jr9ACrKqgKqqhVVUAKqqi1j4AAAAAAAAABve973vSgCJxBE/iVGVGVGEAGRBIFYVGAWBWAESRBJFUkQSFRznOe9+0ve95znNIKAdlEiIqKaQQ1QwBUWIFBKGCFFACVGAQEJUYUEVJUZRUc5znve6Q7zvOc5oVBBMhAFSQCCr0VGQRIFRhEEhUYBEhUYlRgUElRznOe978953nOc0Kj0VGVHQkio4RBIEQDYBKgOFRhUZUZVNa1rvftHed5znNCggZAgCr7CACdRBJVWVGBUda1rvfu87ve98REE6iCSoyo6QwAUqAJhEEhVQGFRlRiAQUhUZBYFRkQSERJEARznOe973nd73vgAIuRIVHqoyo5znPe97zu973xUcyBUEAdxiZQRDOc573vd93ve+IgmWAKhgFR6qMqCSowAKtCoKSIJEAoQqMqMIgkqMiCSoyCgZznPe97zu973xAUDMAVAQoqh1UZEEM5znve953e974qCB1UZEElRhVdUEAVQIgbFBMEqOIDWZrNZrH0H78ABVVUKqqhVVUAK5znOcUAAAAAAAAAAA3pEE/AEignFUR6gAQgoMqMoLCowiqBKjKjKjKCB5nOe9+0ne95znNKIgHVRkAXTAFQyqiG/FRwqoyowCgDKjKoMqMAioyowKCkqMgAGta13ved++++2IKuRgCgmVQB4qMALKjICyowAsgsIgkqMqOc5zzne87ve98EEQzAFdMAYQVBznOe973fd73vgKjkSFVHqoxCoyggQqMqMKjEiCQAsoLCoyoyIJKjKKAsqMAKsqMCqgZznPe57HeYVHvOc56AqPRUZQVNCSAouBUZVBSVGAVGFRhQQJUZVGVGQAlRlRgVGFRlRlRUlRhQSQAGUUznOe97pO87znOaFR6kgAJAroTAIioYFRlRlRgBEhUdgEiCYUECUECUQSVFgBZUZUZUZVGVGRBda1rvftPed5znNAiInVRlQSVGQRXQm8CqIVVKIiHgqMoIEqMgqprWtd793nd73viggZEkUQOiIJAqMqNCoyoyo5znPe97zu9731UeqjKjCo6EwCo4RBIVGVGAWQWVGaVGBUZUYAznOe973nd73vgCDkS9+VHwnWta1ms1f1urvQAKqqhVVUKqqgAAAAAAAAAAAAABve9CCIcRUeqjZznPe/d73e974KjkSAFU+AM5znnM6Tm+c5zmgAVMifYRAGmlR6KjCoyo61rXe/d53YGKld3YBAAxUv1VSr9VUqaSXe97+/fv3O73vfonOio5znve933777vonVR6qPmc9/fv37f0kMVL8kqpJZmbu7Nkm4qV3d0AQAMVLUkseZu7s0k3FS2UlVUlU+kku9AFc5znOKAACqqoCrKqgAAAAAAAAAAADmZrWs1/ZmISSzPvjAJIYqV3dgEADFSu7sAgAYqV3dgEADKS1JJtVSzMzd3TQDKWpJNtJ5mZu7poBmpJNp1TpJfu9739+/ft/AGJfkkm3SzMzd3ZoBipXd2AQAMVLUkszM3d00AxUt+23vtVJVVIDABCqK8hFQQ0AYAMcxvGec53oAFVVQAAVVVAfasryoPMzMWPjYAAWtazT4AAAAAAAN7/AGhUdgHoBgRBNAH2EAV+/Vx7yB5ms3vewgeZrN73sIHmUru7AIAGKlqSWZmbu6aAYqW5mZu966Hmaze97CB5ms3vewgeZrN7uwCABipaklmZm73dN3d3FSi7nrN5qqkqUaSpJJUln3tm+gAAABJJJJAA5mZh/AAANDAAWsfAAAAAAAAAAAHMzM1rM1ve9noDzNZve9hA8zWb3vYQPM1m972EAGKlqSWZmbu6aAYqW5mZu7poBirggUIFCBQgUge+++85zm+b3vfoq7uwCABipXd2AQAMpbSSappJZmZu7CSTFSHuRUqpJLHSSpKqSXryfdud6AK5znOcUAAFVVQFWVVAtPgAAAAAAAAAADmazNZrEld3Ydkkkykqu7uSEADKVXd2AQAMSV3dgEADFS1JLMzN3dNJLVLdx5m7umklql8XYBAAxUru7AIAGKld3YBAAxUtSSzMzd3TQDFS2Uqqh4SIJ+gAXBDyEAD6VRUPLWtZmtZrvO+d6gAAAAABVVUBVlVQAAAAAAAAAAAAD5JL1UlSSd3YdAAMVK7uwCABipXd2AQAMVK7uwCABipaklmZgEJJMVI3ve93dNkkxUru7KGqQQAMVKZmYBCSQ6lqSTaaTSSb/e97379+P0kmKl+X5JLve93dNkkxUjJVUqtpJVSzWXl5XO9AAAAAAKqqgKsqqAAAAAAAAAAAANJL1UlSSu7uZJJJMVK7u5J6SSYqV3dyT0kkxUru7AIAGKlqSWZmbu6aAYqW973vd3d0AMVLMzMAAAMVLMzMAAAMVLMzMAAAMVLUku973u7u6AGVW8USqlSSUSS+SSdySTd0AAJJKqAAAAAA7873ud73vegDWZgAAAAAAAAAAN5mZ9zMzmZrMsxLEkvJJdSStKkqXfe7hPAAGKlmdSS73oHQAMVLve970CAAYqWZmYAAAYqWpJd73vd3d0AMVLe973u7u6AGKs88888ADzNZ55554AHmazzzzzwAAxUtSS73ve7u7oAYqWrpeZDkcv1++35u3jGcG9/s/Hnn3PflUfBUYFRlRlQQJxhEEwqMoIEqMKoyCyoyoyo6VGAF9PMT5sx6fk8gFs+615+FR9VHZ8qOFUb+f/T8/fJoA2qOhUZEElR9FR/eCgnioyo4fAETCowqiGJVRvFRjxUYkF8FRgFcMqCRAC4AFlUcQAsMALgAXC4BUZlRwCoyo4ZUf3mP373nOd3ve973vYAAAACqqoAAAAAAFVVQAfQOYf1VQAANa1VVUAAHPPPPPDgAACqqoAAN1W6oAAKqqgAAqqqAACqqoAAKqqgAAAAAAAAAAAAAAAAAAAc5znOc4AABVVUAAFVVQAAAAAAAAAAA9999999AAAc5znOc4AABznL+/qqQAAKqqgAAAAAAAAAAAqqqNc1nw+gAAVVVAAAAAAAAAAAHuD6AAAAD/0gDoAAAABVVUAAAAAAAAAAAFVVQAAKqqgHo+gAAAAAAAAAqqqAAAAHo+gAAAAACqqoAAAAAAAAAAAGgAAACqqoAAAAAABVVUAACqqoAAAAAAAzP7WtZr7rWs18zNa0MqMgDoA2AQBgVHSo/KjsA0eKj8AYAMCo6AMio/Ign5L1VSr5cr0l0qVJJ37M7AAAkkkkgAAAAABwGBQAAAAAAAAAAABzNa1mv8jM1/kZmZrMzWs5znOfu773e973zpDEmqoCUNZznve9393e9+irzMwAIAYqWZmYAAAYqWpJd73vd3d0AMVLe973u7u6AGKlmZmAAAGKlmZmAAAGKlmZmAAAGKlqSXe973d3dADFS2VVKvnVUqvvFSVJUp2XO+3QFVVQAAAAABVlVQLWPgAAAAAAAAAADmZmZrWs88888OAPM1nnnnngAeZrPPPPPAAMVLMzMAAAMVLaSXe973d3dADeqk+973u7u6AGKlmZmAAAGUlmZmAAAGKlmZmAAAGKlqSXe973d3dADNQFQF02qCfpRQNyggXu973rvdga1oqrl8oAAAAAFe8+c5zigqqqAAAAAAAAAFmZnPffffXiAAYqWZmYAAAYqXe973oBJJN6qXe970DQAN6qX6kl73ve/bpJJN6qW/pJJ+/fve97379VLve96B73veBUu973oHve96Kltd73vQCpJJipflVV+dKk3VJe9z3vbuye97d1Ulyknf7G64YBnf0/ABJJJJAAAAAAAB/a1lVXvFVUAAAAAAAAAAPuZme+f3nni5znPbNZeeeffKkknrVan+5SS5Xe9327sknrVK7uZJJJJUxUv2pJe973t3dknrVIzMOmpVu6BLVL2Zh06AAGKlO973oBJJMVLMzMkkkkmKkLupJe9727ukkmV+Tqt7QqqlXmlmet/NZmevvr3v4CugO96AAAANSS3d3d3d0JPe73p7x4kkniS0llVsAAAAAAAAAAC0kvkkuJJd+y8wnpJJMVLMzMglQAAZSX78lxqlsnJJ+/ftCSZqpNpKEoEoEmFc5znO973999997sShKEoShKEoShKEoThrABrWtc5zm/vvvvdiUJQlL2xCUJQlCUJSmta1rnOb+++++92JQlCUJQlCUJQlCUJnOc533nOb3ve/eCUJQlCUJQlCUJQlHYOfffffd73v3333288EoShKEoShKEoShKExrWta5lTnOb3ve/eCUJQlCUJQlCUJQlCb1rwA1rXOc5vf333c8EoShKEpbGEMQlCUJQOrnuHeUpnfqX2KqpVeYe77fwAEnve97xIABVVUACquc4q4qriquKqoAAAAAAAAADSS7O97nQhJJP3fypNqk2qThKEoShKEoShNa1rXOc3999997sShKEoShKEoShKEoTprWta5znPvvvvu56YhxCUJQlCUJQlCUJQmta1rne95ve977nolCUJQlCUJQlCUJQmtYQNa13ve85ze99z0ShKEoShKWw2BKEpTWta13ve83ve9+8EoShKEoShKEoShKEznOc85znN73vfc9EoShKEoShKEoShKE1rWtd73vN73vfvBKErsLVFC1WLAQYhKEoShKEoTWta13ve83ve99z0ShKEoShKEoShKEoTWteAGtd73vOc5vfc9EoShKEoShKEoSkLC5VOm3YqqlWvT7ntvfb+gAEnve97xIAAqqqABXOe++uccVU1fKq4qriqqAAAAAAAAO5mZgEAA/d/caabT5zjabTeLEVVYsVVWLBRAFOMYXEJQlCUJrWta73veb3ve+56JQlCUJQjSlCUJQlCa1rWu973m973vueiUJQlCUJQlCUJQlCa1rWu973m973v3g9ogcQ4jEJQlCUJQlCUJQmta8ANa73vec5ze/eCUJQlCUJQlCUJQlKZznOec5zm973v3glCUJQlCUJSHSMQGJWjEJQmta1rve95ve9794JQlCUJQlCUJQlCUJnOc55znOb3ve/eCUJQlCUJQlCUJQlCZznOec5zm973v3glCUJT2cQlCUJQlCUJrWtfgDXe97znOc37wShKBKKqm1SbVJuqUSpUkhpFgat3gAAB9zWgePgACqqoAFVe8+cVcVVxVTV8qriquKqoAAAABZmZ555549APeCUJQlCUJQlCUJQlHYda1rXe973e9737wShKEoShKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKEznOc85znN73vfvBKEoShKQuhhMQlCUJQmta1+ANd73vOc5zfvBKEoShKEoShKEoSlM5znPOc5ze9737wShKEoShKEoShKEoTOc5zznOc3ve9+8Eu4HEJQlCUJQlCUJQmta1rve95ve9794JQlCUJQlCUJQlCUJnOc55znOb3ve/eCUJQlCUJQlIXcIYhKE1rWtegHe97znOc5AHvBKEoShKEoShKEoRtUuNkrPX92XM7s0AJJJJIAAAAVVTR/ABXOc5zilVVxVXFVNXyquKq4qqgAAAAu7uwAADNVJtUm1SbVJtUm1SoShKEoTOc5zznOc3ve9+8EoSkLuAMQlCUJQlCUJrWta73veb3ve/eCUJQlCUJQlCUJQlCZznOec5zm973v3glCUI0pQjSlCUJS3cIa1rWvQDve97znOcgD3gjSlCUJQlCUJQlCUpjOc+Z5znOb3ve+AGZShKEoShKEaUoShKEznOc85znN73vfvBGlKEoSh7GIShKEoShNa1rXe97ze9737wShKEoShKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKEznOc8yAc5znOc5yAPdjdTBYwJ8KYnAkpjAlCUJQmEDGBXFzlUr7YklOUkun2dP34ACTvk/e94kAAqqqABXOc5zigBVVc1mYqruZmXQd0+VVztVcVVQAA3mZn3MzP7MzP7f3ewA94JQlCaQMYEwYwJQlCUJQlCa1rWuc5zm973v3glCUJQlCUJQlJ0gaMYwOITWta13ve83ve9+8EoShKEoShKEoShKEznOc85znN73vfvBKEoShKEoShKEoShM5znPMgHOc5znOcgD3YlCUJQncWAaMQlCUJQlKea1rzXe97z77779wShKEoShKEoShKEoThnOc85znPvvvuCewlCUJQlCUJQlCUJzOc55znOffffYAP3E7YhKEoShKEoShKEoTzusa13ve8++++/cEoShKEoShKEoShKE5nOc85oA5znOc5yAPfhKEoShKEoSh7GIShKU8tfb19rXNajndavbaoyo+SYVGRBMSqOlRlRvBUcIgkqMKjKj5pUfFBA/Coyo+N7F+VHz1UfQFxmyKgbVH1Uf2BUfBByqP5UdHio4FRlRypk0KIBsAlBTRlUcKAjIgmBR+VHxVP3n34AsjqBL59aqmm/ZnQAAAAAAAAAAAAVVVAAAAAAAAAAAKqqgAA+a3rWc5z7znvAAAe73vY4AABVVUAAHutZX9VUAAFVVQAAAAAAFVVQAAAAAAAAAAAAAAHzMzACAAAAAAADnOc5znAAAPuawD0AABVVUAAAAAAAAAAAPvOc5vnOAAAXOc5znEAADmayz5VVAAAKqqgAAAAAAFVVQAAKqqjP74AgAAAAAAAAAKqqgAAAAAAAAKqqgAAAAAAAABgAAAAAAAABVVUAAAAAAAAAAD+zMwF7VVAAAqqqAAAAAAAAAAACqqoAAAAAAAAAAAKqqgAAAAAfczMA9AAAABoAAAAqqqAAAAAAAfcs1ma1vNa1mvjKj4AZAMKjpUYVHIKjCo5AIAwAfhQTSo/AH4A/AGQD+zWtZpmbufPrfvkgKqqgACqqoAFVVQAABznOc56VXFVNXyquKq4qqgb34Ad9x777zPQAShaShQaFShEpQWgAaBoKAAKABoRoFQpVUoAUoEpKApQCkEpVpQCgKUpQKAKGhpoQoAGloVpAKQCkAqlShSgKSgaBoFqIBpUKChVoKASmkRpSkUGlaBAoVCkKUIhWhRoQaVpBClQppaoBpQooGhChClRpKEKRKESIRClioKVKaQBoaVKFKUCmgUqgKASmlSlKVoKVaApQaUCigUaRCJWkGhEoRKRGlRKUoUaRShBpUoUKAKoFIlCkKUKaWkChGkoAoFiFaKRKoUaFGhWkGkBKEAoBooQaRKAWmZUGhEpWYCigASJpCgUaUQpApKClaWqUGhChAoUKUoRlIEKVAoFCqEAoUaWhCgBppWhAKaKUUpUCgUoRKUGihSgAGihKRoKCJEGkBKiBGkGkVaVWhaAUpAoUChSgUoRGgEaRVpAKFQoAAooQAlSAFpRaFWBhAlIAaQCkRCgElJAClAGBlSUCBUCRlFlJFQpUQgZQIGBlSQWBlEQgZUgYUCVJUgZUSAlGgCkQKRChAiBGBlFiBgBlSUlUWkUWBhZQIGUlIkBlIBZSBlJQJSVUCkGUhQCRlJSBlSBCUkRCUhUgZVAKopEQkZEJSEWBlAkYEIQIQJUkVZSRAoVFqmIQEgYAZGRSUhZGUkZUkYGAZEJSBlJSBlAgYUgGBAlJUgYUBCUkZSAFZSVJUhSAYGBgYGUCBlQYGQCBgYGVJSVQgYGgYUlShAApFCAZVIGFlJAYGFSUgFYGREgZASUhUgYEJSVIGAZSVIBlSBgYGFVlIBgYFJSBFgYRpFFgoJQiRZSQEKFFoUWBkQCJRYGAWUlQIGBQJSBgYAJSVgZRSUgYGEFlSVJSFAgZFKKJohVWlqqKREIGFCBkQlIVFlJBEgZUgZUQIGVIGAZSUFlJSBlSVSVIGUCECUCBlIGBVlIBgYEIGUlJUgZSRgmpKVRaEKhqiCopKSapkJIZUkYAZSBpEFlJQBJSEBIGAYGERZSREJSVIGVIGBlJUlSBlSVJSQRlAhUlJSVJFIGVQlIGVJBgZUgYVIGFSUgaoYpilqakAKURKpApKoqCImmaIKQkmGgiqKYmhhqlaqloKihQlJQUpREJSFAGBlASUhQWBlSgYUlUgZECBhAgYRYGAZSBRIGFIGUCUgGBlIlAIGUCVJBlSBlJQIGBgYUgYGAZQIGUCqpiqSiqSZiomIaCgQIgFaVGhCigKKGqoRiUpCmgopaSgIgpSilqhKIkWlSgaUWUgRJSAYCKQYGUFRgZEQYGAQAlSUCBhEWBgQgRJASqWkWiqqgpoHve973vfvYShKEoShKEoShKEpVDcqA0qDVIlClKoBQiFIqSkqKLAykDCojKQKIQMgoEDCgSkqgSpCkAwJQnYAMSJrWtZ73ve73vf7glCUJQlCUJQlCUJQnvvvvOc5zm973+4JQlJ1xGBKpxjAlUUjWMBgcQlCUJQmc5z3ve95ve9/uCUJQlCUJQlCUJQlCe+++85zQBznOc5zkAe/CUJQlCUJQlCUJQlKYznPmec5zm973v3glB2KjFihKiCxgMRiEoShKEoShNa0Gtd73vN73vfvBKEoShKEoShKEoShM5yGc85znN73vfvBKEoShKEoShKEoSgO0Qa1oNa73ve73ve/eHSUpxYZQxCYlKMSjQlCUJQlCUJrWg1rve/AHec5znIA90JQlCUJQlKk2qTapNqk3VLmebv33s9u6AEgABwAAAAAK5znOcUAABVVziq4q5mZl84qpqOSSeJJJ4kkkaSV3a+uAAAZqpNiUJQlCUJQlCUJR2D01rWu973v329794JQlCUJQlCUJQlCUJ+M5znnOc599ve/eCUJQlCUJQlCUJQlCZz77znOb++5vfvBKEoShKEpC7hDEJQlCa1nPe90Ad3vfecgD3QlCUJQlCUJQlCUJQmLOfPec5zf33N794JQlCUJQlCUJQlCaxgTGtZzznNb++5vfvBNK4wJhxgOhjAlCUJQlCUJQn33333e97ze9737wShKEoShKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKezrWta73vdgHec5zkAe5EoShKEoShKEopNqk2qXG8Z8lS46pKZOzs00AJPe97nHFVUAAABXOec5/cUD9+zP379+/fv379+7ne9Aq6F0C6ATQJNqOSSeJJJqrUknVZmZu+3dAN+8EoShKEoShKEoShKEznOc85znN73vfvBKEoShKEoS7gDEJQlCa1rWu973m973v3glCUJQlAlAkwJnOc55znOb3ve+CZhKEoShKEoShKEoTOc5zznObAOc5znPciUJQF3CGIShKEoShKU1rWtd73vN73vfvBKEoShKEoShKEoShM5znPOc5ze9737wShKEoShKEoShKEoOxrWta73ve73ve/eCUJQlCUJQlCUJQlCZznOec5zm973v3glCUJQlCUJQlCUJQmc5znnOc5wA5znOZyJQlCUJQlCV2XEJQlKcjWMR6fs1m/r62c/X4Fc5znOOKqoDzMzA2AArnOc5xQAAFVVQACqq4qriqmr5VXcP379+3vnOfffffc4JQlCUJQlCUJQlCUJnOc55znPvvvvucEoShKEoShKEoShKEznOc85zn33333OCUJSF3AGIShKEoShKEhNa97379+/SSTUqSrMzMABJIAN6qTapNiUJQlCUJQlCUnY1rWtd73v33333eCUJQlCUJQlCUJQlCZznOec5z77777nBKEoShKEoShKEoShM5znPOc599999zglCUJQlCUJR2HEJQlCa1rWu97377777nBKEoShKEoShKEoShPgDWta1zmufffffc4JQlCUJQlCUJQlCUJ8PmFR/fX4A7+/IGd739vvfwK5znOccVVQAAAFc5znOKAAAqqZmYPoAABVVcVVxVTXczM8zMz5nzzz3nNc5zfADnOcz6JQlCXcLiEoShKEoSlNa1rXe97ze9737wShKEoShKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKHuta1rve97ve9796JQlCUJQlCUJQlCUJnOc55znOb3ve/eCUJQlCUJQlCUJQlCfAGta1rnNc5ve9794JQlCUJQlCU9kxCUJQm/vvvvu913m+AHOc5n0ShKEoShKEoShKEpTOc5zznOc3ve9+8EoShKEoShKEoShKEznPvOc5v777m/eCUJQFPYcQlCUJQlCUJ+1rWu973n3329+8EoShKBKFaErNZ7X3b9v773ve/n4AAKqqgPMzMDYABrWFbqt0D93ve973veiqqoAAAAFUkniSSRJK7v6AEkDNVJtUm1SbVKhKEoShKEpfgDWtadc5rnN74Ac5zPfUMQlCUJQlCUJQlCUps+++13ue7+++7v3glCUJQlCUJQlCUJQmc595znN/ffc37wSlGhKEoShKDsGIShKE1rWtd73vN73vfvBKEoSlGhKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKEznOc85znN73vfvBKEpCnsmIShKEoShKE1rWtd73vN73wA5zPglCUJQlCUJQlCUJSmc5znnN7+++++92JQlCUJQlCUJQlCUBxA1rWtc5zn33333vegYhKEoShKEoShKEoTpv1PceVe/vyvwKqqgAAAAAVVVAAAVVVAAAAAAO/u973ve6zMt73+5zvOc3ve9+9EoShKEoShKEoShKEznOc85znN73vfvBKEoShKEoSk7OIShKE1o1rXe97ze9734Ae8EoShKEoShKEoShKExmznPOc5zf3337glCUJQlCUJQlCUJQnPgDWNa1zmuc39wA3v3wShKEp7BiEoShKEoSlPtd+++73Xeb3ve/eCUJQlCUJQlCUJQlCZznOec5zm973v3glCUJQlCUJQlCUJSGc5znnOc5ve97971cQlCUJQlCUJQlCUJrWta73veb3ve/AD3glCUJQlCUJQlCUJQmM2c55znOb3vfADmcCUJQlCUJQlD2MQlCUp+1zde73nfdd++3vYqqqAAAAAKq9r+gAABVVUAAAAAAAP7MzOZmZv+3s9De9794JQlCUJQlCUJQlCUJnOc55znOb3ve/eCUJQlCUJQlCUJQlCZznOec5zm973v3glCUJQdnEJQlCUJQlCa1rWu973m973v3glCUJQlCUJQlCUJQmc5znnOc5ve98AOZwJQlCUJQlCUJQlCUpnOc55znOb3ve/e9HEJQlCUJQlCUJQlCa1rWu973m973v3gJQlCUJQlCUJSjQmc5znnOc5ve9794JQlCUJSjQlL2xCUJQmta1rve95ve9794JQlCUJQlCUJQlCUJnOc55znOb3ve+AGYShKEoShKEoShKEpTxmsy3bq7dAKqqgAAAACqqoA7ne973ve96KqqgAAAAAAAaSX33PgAAAzVSbVJtUm6X5rjVJsShKEoShNa1rXe97ze9737wShKEoShKEoShKEoTOc5zznOc3ve9+8EoShKEoShKEoShKEznOc85znN73vfvOyYhKEoShKEoShKEoTWta13ve83ve98AMwlCUJQlCUJQlCUJSmc5znnOc5ve9794JQlCUJQlCUB3GBKEoTWta73vd/fffd94JQlCUJQlCUJQlCUJjOc55znOffffb94JQlCUJQlCUJQlCUJnOc85zm/vvvue8EoShKGHOc55znPvvvvucAMiW/fj8JISS/du2klu+3f379AACSSSSAAAAAFVVxVVAHe973ve970VVVAAAAAAAAA1JK0kvzzM/fv379+ADFSzMzAAADFSzMzAAADKrqdd73vQAADFSzMzAAAD8kl1Un3ve93d3QAxUszMwAB5ms88888ADzNZ55554AHmazzMzAAADUkuqk+uS6Vt9Ny87zb7ezbtnnn5FRDGcKj4qPio2AFRlRgRBJUdqjrxUfRUf3plLO/wZ9ZVHXv796Avn7zWfMh+1gAPwiCSo6Pi9cgiIH5UYVR/ALAIDgIFRlRlAQkQSFRgFkERYAgESVGEQSVGVGVGVEElRgFlRgRUwSqiFmAuAVAMAFwDAA4A4AOAFgS8kkJJQSSfySQmuJJcSSu7uwAAABVVUAAKqqgAeZmYGwAAAAAAADnOc5znAAAc5znOc4AbzMwHg++1/f3N85x7QAAFVVQAAf2ZVV7QAAVVfczMqHoAAAAAAAAAAAAAAA/szMAcAAAAAAAAAAAAAAAPmZmc5znOe85mZh/AAH9VV7QAAGawAAABVVUAGszAAAAADm+c595zgAABznOc5zgAAFnOc5znGszIAAFVVQAAAAAACqqoAAHMzMvlVUs99fTzwAAAAACqqoAAFVVQAOZmYfwAAAAAAf4AHQVVVAAAAAAAta1muZmY/n0AAAAAAKqqgAAAAAAAAAAAAAqqqAAAAAAAAAAACqqoAAFVVQAAAAAD7mZgHoAAABVVUAAAAAAAAAP7MzAHAVVVAAAAAAAAAAAb3ve30AgD0AyAZAMgGQD0A2AflR/KjKjKjKjsA2AaANgGQDYBoA0iCaAPADCoHgBjYBgVHxUYVGVGVGVGVHKo/AEKr6AfgD8gefAHgBhUcgGQDAB0A2AYBDQqOQFkEhEEhUfgCBUfADhzfxefft81vnN73sGAAAAACqq4qqgAAAAA/szMAcAAAAADusz/HzNfPnz5r4RBUhQURJDMVI1EtBEkQUpSDMkQLJ77773ve97ve974HQUBaUFJqmRiCm0JgB46973vfv379+ADFSzMzAAADFSzMzAAADElmZmAAAGpJdVJ973vd3d0AMVLMzMAAAMVLMzMAAAMVLMzMAAAMVLMzMAAANSS6qTfn73ve3dAAAAAA9zMwfQVVVrWQeBsAAAAAAAAAAAAd+ZmZ3MSzMu93d0AMVLMzMAAAMVLMzMAAAMVLMzMAAAMVLe973u7u6AGpJdVJ973vd3d0AMVLMzMAAAMVLMzMAqqvOfnPPPPPKqqrz85gBttqqgDUkvebbbbbbbbb5z638i8kkmzQAcvlVUAAABVVcVe1/QAAAAAAAAAAAAf2ZmczMzf9vZ6qqtgAANttVVVbAAAbbaqqq2AAA221VVVsAABttqu973vfuc5z70AAD9/ffffffvvvu973tgAANttV3ve97YAADbbVX5VVsAABttqu973vbAAAbbarve++/c5zn2ABzj9+1/VVSr9VUqdVSppKqPe53wft/AABJJJJAAABzNYAOKqoAAAAAAAAAAAANJIAAIH6lSqru73d3dCTMYAAPPLaqq73zwAADzy2qqr8rYAADbbVVXe+eAAAeeW1VV3v3Oc5sAAB+7fe+/ffffVVsAAB5555V3tVbAAAbbaqqq2AAA221VVVsAABnOc5+++++++++4Aa1VVVVVVjhr46qV3iepJP2bu4kkfp9AAAAMSALAAAAfD+zWVV5fOKq5AH7ve973ve9AAKqqgAAAAAAAB8klqSQklzMzd3dkknetgABttu973ve97sAABttu973ve97sAABe+++++c/OVVVbABwC57z3332q9999+5znNgAAP29999qu973uwAAG3e9kkkknetlJLnG222222/e9727oAVsAABttqqqrYAADbbVVVX3Oc576AAB++2/PeYUQeqjIACpCjoAz7jXe97y/AFVVQAAVVXFVcVVQAAAAAAAAAAAAfs1+18zWazTMw/AGBFAznzPe673u973vOaqqqqqtttVVVbAAAbbaqqq2AAA221VVVsAABvPPKu97Vfc5znvoAAH7/Pe973+fz+fz+dqtgAAN555V3varYHAAbzzyrve1WwAAHnNtqq7VbAAAbzzyrve1X84BrVVVVVVWO81+8/EzKj5BhEVJtJUqSaqlTSqqvMDwe2SSSfpJJJQAAVVXFVUAAAAAAADmZmH8AAAAAGszO6zNZrN/fve973t0e4AADeeeVd72q/vnOc2AAA/eeeeVd72q2AAA3nnlXe9qtgAAN555V3var7nOc99AAA/f53333+fz+ffd/lWwAAHm21VdqtgAAPNtqq7VbAAAbzzyrve1WwADbafe970CAAfkkurydNtttt8/Z9f61rWs1/fRx+/VVXaqqgAAAACqqoAAAAAAAAAAAAPHOc55555/dXaqtgAANttVVVbAAAbbaqqq2AAA221VVVsAABttoAAD8kl7zbbbbbbbbfP0kk/fv378AWwAAG22qqqtgAANttVVVbAAAbbaqqq2AAA221VVV/Oc5z30bbbbbbbb5+t1VKt+eWkk8AO+2SSSfqqqhVVUAAApmsH0NgAAAAAAAAAAADub3vfe973oPfQAANttVVVbAAAbbaqqq2AAHNttV2qrb8fgADbbVVVX3Oc576AAB+/zve97/P5/P5/Kq2AAA221VVVsAABttqqqrYAADbbVVVWwAAG22qqqv5znOe+gAAfv8/v+/6/Pz85V6klqSV/bu6SSNJKSSflPSSSQCSVVAAAKq8q+gAAAAAAAAAAAAAD5JLaSpISS993vd7uzQA71tsAA221VVVsAffnOc/f0A99999+++qqtgAANttVVVbAAAbbaq73ve/c5zm+ADh+fr333337777ve975AAAbbaq73ve+QAAG22qu973vkAABttqqqrYAADbvegABMxttttttttsPXpv3OVzl+noZq5Zfx3yPjk7Pvudxr76/RX7k9L7vuTY29fjz9qvMCo8FRlRlRtKjKjhAJUYBZUZUfyo4ARMCoyo/rOX8Rv7X4/ZAXH6819jPmHMe/lR8VHCo5P3ngqPFRwKjIqRKjKjIgkoAMKjlUcIqOFRhEEkAB8RBJUcYBUcKjhQQJUZEElRkABlRwqjCoyIgkqOBEEyKJhUfFR8VGVBAwqMAqD9CiCYVGURPIFRwqCQYVGVHAqOFUSVHCowqMCo4VHCIJhUZUZEEhVGQAhUYVGFUsKjKADIADhUYVGVHGBUZUcCJhQRwqMiCYVGRBMCo5VHxAAfFRhRkQTwVHxaVcqlVL5JIeHc73pAAAAAAAAAAAAAAAAAAAAAAAA5znOc5yqqoBVVUAACue+++ucQAAKqqgAAqqqAACqqoAAAAAAAAAAAAAAAAAAAFVVQAPmZmAHMzMn8AAAVVVAABVVUAACqqoAAFVVQAAVVVAABVVUAAFrWc5znOcQAAD5lVVyAAAZf2tZ8qq5AAAAAAAAAAABVVUAACqqpazj+fQAAAAACqqoAAFVVQAAAAAACqqp/gAdBVVUAAAAAAAAAAAFVVQAAAAAAAAAAAAAAAAAABVVUAAAAAAAAKqqgAAAAAAAAAAAqqqAABVVUAAAAAAAAAAAFVVQAAAAAAAAAAAAAAAcVVSqKkqr6kkqptUCEAfAHwB4gAP4VH8AeKgfAEqBkAgF+RBPFRgD8qPgqOwDwA+APyguvgVlEwQiCWa1rNfM1rWZrLXv3zlIAVVVCqqoczMw/gAFVVQAAAAAAAAAAAAAAH5fJJRJL3fu93fbNAmY222wAeeeWqqrv3Oc5sAAB+7b7377776rvngAAHnnlqqqrYAADbbVVVWwAAG22qqqtgAANttVVVfc5znvoAAH77777799999VWwAAG22qqqtgAAPve96AAAd622222265k1VVKsSSxzyrroBVVUKqpo/gAAKqqgAAAAAAB9zMwD0AAADvzOc5/f9/3/X333331VbAAAbbaqqq+5znPfQAAP33333377776qtgAANttd73ve97sAABe++++1Xe973YAADbbdvyqqtgAAO+++++1Xe973YAAC99999qu973v3Oc576AAB++++++1Xe973YAADbbd+5VVWwAAHP6fvBtvNVVVVVVVFVVQAACqqoAAAAAAAAAAAAAAA0ksu/rAIAB3qbbbbbYO+++++1Xe973YAADbbd73ve973YAADbbduc/Kqq+5znPfQAAP2/O973v3333e973YAADbbdqqq2AAA777777Vd73vdgAANtt2qqrYAADvvvvvtV3ve92AAAvffffarve97sAAB/f7+7f3t2qqqoAFVVQAAAAAAAAAAAAAAAAAZmZ755554IDuZnPfQAAP273ve/fffdc5zne97vAAAObbbve973ve7AAAXPffffarve97sAABttu973ve97sAABttu973ve97sAAB973vZJJJJ3rb3jpJc40222+Ukuc973vX31VV9znOe+gAAfvvvvvv33331VbAAAbbaqqq2AAbbb5iSXkkrv1+94AJJMSSjk5AAAAAAAAAADve973ve96AAAAAAAAAAAAD5JLUku8zM3d2aAHetsAAbbaqqq2AAA221VVV9znOe+gAAfvvvvvv33331V/fOc5b9AAA5ttqqqrYAADbbVVVWwHD8cc221VVV5z8w4bbaqqq2AAA221VVVsAABttqAADvW22222222/bJnFxcz76Sbuh7nOc5zgAAAAAAAAAAAAAACqqoAAAHMzMszM8888eeiqvuc5z30AAD999999+++++qrYAADbbVVVWwAAG22qqqtgAAPOc5zNtVVVbAAAefm21Vd73vngGSS5znONtt8SS5znT3vB4AA1JL3m224klznOcbbb4klznPpJJuzdADvW22/JJc5znG22+JJc5z3ve8HgADvW2/JJc5znG22+JJc5znOpJefveAAAO9bb8klznOcbbbbb7C7MA9AJJJJIAAAAAczMw/gAAAAAAAAAAAAAAAAAAA4kk0ksv67AIAB3rbAAG22qqqtgAANttVXe979znObAAA/fue+++/ffX3e975zz8fgAPOc5ybaqqq2AAA8zbVVVWwAAG22qqqtgAANttVVV9znObAAAfv3vvvv9/ffffVXngAAH985znjz88qqqrYAADzzf95557v3z0FVVQAAAAAAAAAAAAAAAAazMAAACvznOf1/X9fn9VVVVsAAB/X97f1qq72rYAAD++c22qrvavMcSTaaaaaSTaad97yqXegQADUkveRxwAHn9Pzc5znr3377777vatgAAPM88q73vatgAANvPKu972rYAADbbVVVWwAAG22qqqtgAAPOc5zNtVVVbAAAeNz78/Pzn5/9uCoyowqMqMqPv7979993vd7+++++++oAAAAAAABVVUA/d73ve973oAAAAAAAH7WazNZ755553ve3QfznOc99AAA/ee++++/ffffVVsAAH35znP3999999+++qqtgAAPOc5zNtVVVbAAAefznv7777vd3d3d3e9bbbbbbb8klznOc973vaAAVsAABttqqqrYAADbbVVVWwAAHnOc5m2qqqtgAAPM21VVV/OAa1VVVVUY6qMqO/2FRgD4Mz7mZnn1sfvwqqq+ZmYAQAAAAAAVVXFVUAAAAAAAAAAfJJaklqSXvu97m7s0AOrrbbbbbBttqqqrYAADbbVVVWwAAHnOc5m2qqqtgAAPM21VVV9znOe+gAAfvvvvvv33331VbAAAbbaqqq2AAA221VVVsAABttqqqrYAA4bbdAAANSS75NOm6bbTbbT56cl97j7zVg8P1Z+o/asqCIbVGVHwVG8IJjwlxVWiHCoz5Aj7ID7KjfvOeY/IftqjGEApUcqjKjqVHHp+RBPEUEX0UPADwUE/KjAoflBA/EIIDhUbMCo4FGFRIFYAX8qMAKBj3Gfd/a9/e638AAFVVQAAAAAAKqqgAAAAAAc5znOc4AACqqoAADN73vYAAAzKqqgAAqqpVVQAAAAAAAAAAAAAAAAAAAAAAVVVAABVVUAA8zMwfaqqAAD+5znOec4AAAAAAAe1/VVAABVVUAAFVVQAAbzWVW6oAAB7777776AAAM+VVXIAAAAAAAAAAAKqqgAAAAy19fwOAAAAAA0AAAAVVVAAAAAAAKqqn+AB0FVVQAAAAAACqqoAAFVVQAAAAAAAAAAAbzMyq3VAAAAAAAAAAAAAAAAAAAAAAAACqqoAAAqqqAAAAAAAAAAACqqoAA9wAVAAAAAAAAAAAB8zBUcAGgDAgqOVR0qOgDYBsA/ZAJUfQCAJUf35UciipKjIoBpUZEEwoufuoKgFn9+1O96VVVAAAAAAAAACqq4qqgAAAAAAAHMzM7ma1rHUpnOc859zfN73vfEUXWiIiqqosL+AnSSkkn79+38AHettpptpptp973vQu1VbHHBxwHG22q7VVscciIioznOc73ve973vfADRqqJAosIGMERjWta1znOc3ve9+8QLVVVhAxiqrWta1znN73ve95zxAxiqqsIGMVVe++++/ffVVWwAAG22qqqtgAANt5V3ve9r7nOc99ADbbbb5ZrSS2qrvd3ZoASSSSQAAAAAAADYazMeAAAVVXFVUAAAAAAAAAA+SSaSWcuwDxJA71tgADbeVd73va2AAA23lXe972tgAANttVVVbAAAbbaqqq+5znPfQAAP33333c5znv3339/VVsAAA221XaqtgBwBttqqqrYAADbbVVVWwAAG22qqqvuc5z30AAD957525/Z95z0850MqqqAAAAAAAAAAAAVVXFVUAAAAAN5znP65znPPP3zyq7VVsAABttqqqrYAADbbVVVWwAAG22rve973uwAAF773vAEkk1JL3m22222222+e973gCTve7AAAbbbvfvyqq2AAA221d73ve92AAA223e973333zwAADubbvarve/c5zmxVVVVhAxisXMAIq0iiHnmv2tc73pVVUAAAAAAAAAAAAAKqriqqAAAAd1rWaZmZ55mbm7ukkzG22222k2k2k2k8O96AFflW5nDj84Bttqqu9754AAB5baqrve+eAAAeW2qqqtgAANttVVVbAAAbbaqqq2AAA221VVVsAABttqqqr7nOc99AAA/ffffffvvvvqq2ABVVb4AiCdVGARA8hEE+ANSS+SS69vd3fwEkkkkADqSQHwAAAAAAAAAAAAACqq4qrzMzKNgAAAD5JLUktSS5mZe7u6AHettsABttqqqrYAADbbVVVWwAAG22qqqt+b8fgA221VVVsAABt3oEkkhqSXvNtttttttt8+973t3d2TvbYAADbbVVVWwAAG22qqqtgAANttW973ve95zVVVVVUe+a177wBfP2FR7mtZrPPPOD9+/FVVQAAAAAKqqgAAAAAAAAqquKqoAcwDqo+AEqOACFBPff3vOa5zm973vOQAANttVVVbAAAbbaqqq+5znPfQAAP33333377776qtgAANttVVVbAAAbbaqqq2AAA221VVVsAAD8NttV2qrfmHOHOfhzj8A221VVVsAABttqqqrYAADvPPWf2fdZmeeeXlUKqqiqqoAAAFVVQAAAAAAAAArnOc5xxVVOqjAHVR999/d73ve73ve85qqqqqpttqqqrYAADbbVVVWwAAG22qqqtgAANttVVVbAAAbbaqAA/JJe8222222223zF73vbu7skmYwAAeeW1VVVsAABttqqqrYAADbbVVUHettttttttuWtUvOSdmmhJJJJAAAAAAAAAAAAAAAAAAAAAJJJJ4EktSVV+qqVNVVKs+zP37+fz+fyqt+YAA221VVV9znOe+gAAfvvvvvv33331VbAAAbbaqqq2AAA221VVVsAABttqqqrYAADbbVVVWwAAG22qqqtgA+/Oc5+/oHvvvvv331VVsAABttqqqrYAAPnzzP2Zma+/eb5zne9KqqgACqqoAAAAAAAAAAAAAADWZgAEnySX6qpVe5m7u7oAd62222222xttqqqr7nOc99AAA/ffffffvvvvqq2AAA221VVVscPwA221VVVsAABttqqqrYAADbbVVVX3Oc576AAB++++++/ffffVVsAABttqqqrYAADzzzyrvQA71ttttttttvt8v8vJJRJL2euSboAA0AfMzMCrlVAAAAAAAAAAAAAAGszAAD7mYdUBDgBwAznP79znOc3ve85qqqqoPPPPKu9qrYAADc22qqqtgAAPPPPKvbve9+5znPvQAAP3922+++vu972wAAG22q73ve9sAABttqu973vbAA4DbbVVVWwAAG22qqu9+5znNgAAP3+fzvf3vf5/P5/O739977VVVVVUY9+z37Xv7qo+qjv7nMnfsZx5wBeCDKjKjKjSo0QASoyCwqNFCoxKjSowtNJVR5YSKIFIpUfvNY/e9/ZVH33Ko6VH8IHk0qNKjgsqjArKgkiCbQWVGBUZUZUCRBMKjKpIgHxhUcAoiQqMoIEqjIqMqMILKjKjKj4AsqOFRlRgVGFRhUZFRgBZVBhUZUZUcqjgVHAAAwgsKgLKjCoyoyi+KjKgrgVHAChgNZrWbsvu/LziAACqqoAAPcH0AAAVVVAAAAAAA5znOc5wAAAAAAADWtc5znOc4AABmAAAAGweAAAAAAAAAAAAAAAAAAAVVVAAAAKqqgAAqqqAAAAAAA5znOc5wAAFVVQAAAAAACqqoAAAAAAD3333330AABVVUAAAUz4AgAAAAAAAAAAAqqqAAAADNAAAAAAAVVVAAAAAAAAAAAA0AH+AB0FVVQAAAAAACqqoAAFVVQAAAAAACqqoAAFVVQAAAAAAAAAAAVVVAAAAAAA3mZgPAAAAAAAAAAAAAAAAAAAAAA5znOc5wAAAAAAAAAAAKqqgAAAAOKqpVxJISS8kkXVUq4kqqJUdAGgDIB+VH5UYVHQBnIqPyIJCgmACERMKjAqMqa+a1rWav8Zma13MzO9vp06AAaAAAAAAAAAAAAAAAAAAAAAAAbSpJL+A6SzMz9+/fv34JNX5pUI0ijSAutVVVVVVeKIvvfpP379uhJmNtttttttt7SS73fe3d3QA71t/ufqSX3G2239z6kl9xuSSfv34ADGQC1klo8MA5EJJJJ3hgIdJ73ve+c4xJJO9be82kl9xtttttv8AH78Ekk71sAANtt3ve973vdgAANtt3ve973vdgAANttVVVfc5znvoAAH77777799999VW3ADbbbbxc537vegAAAAEkkkkAAAAAAAAAAAAAAAAAAAqqc5zn9f1+/1VVVWwAAG22qqqtgAANttVVVbAAAbbaqqq+5znPfQAAP33333377776qtgAANttVVVbAAAbbaqqq2AAA221VVVsAABttqqqrYAADbbVVVX3OJe8222222223zOpcVVSq79ee9u6AAAqqqAAAAAAAAAAAAAAAAAAB3WtZr9rWs15vf79+/fv3f5VsAAB5ttVXarYAADbnOc21VVVsAAB5zbaqu1Wz8fj8Abzzyrve1WwAAHnNtqq7VfznOc99AAA/fdt999XfqtgAANuc5zbVVVWwAAH35znNz333377777tVsAffnOc/f0A/fznOe7b776u/VbA23tJLnG222+UkuiSTu59JNmgA6pACqqgAAAAAAAAAAAAAAAAAAf2ZmdzWszWfN733vd3YAd62223tJLnG222+UkvPve7ugbve+AGtVVVhAxiqqsKGda1rnOc59urYAADeeeVd72q2AAA85ttVXarYAA4bbaqqq834/AANttVVVfc5znvoAAH77777799999VWwAAG22qqqtgAANttVVVZzVVVVVV79d6qOHEAaAOAGtd87739+AAKqqg9zMwfQCqqoAAAAAAAAAAAADzMzA2BSS+SS/JJO7vd3d0AO9bbbbbbbbbbbVVVX3Oc576AAB++++++/ffffVVsAABttqqqrYAADbbVVVWwAAG22qqqtgAANttVVVfc5znvoAAH77777799999VWwAAG22qqqtgAANttQAAd6222222222u37Z28zmVVKr7nZ7d70ABVVUAAFVVQAAAAAAAAAAAAAA1mZ3WtZrd3e7u7oAdS62222233ve9AAANSS99AAA/ffffffvvvvqq2AAA221VVVsAABttqqqrYAADbbVVVWwAAG22qqqvuc5z30AAD573ve3d3QA1JL3uc42222222373ve3fqqrYAADbbVVVWwG2222239tVSr8kqV3JPT9+/AAAAEqqoAA4fx/AOa1gAAH7ve973ve9AAAAAAAAADuta1mvmZmb3v73ve96qtgAA4221Xe973v3Oc59+egAP17777799993ve98gAANttVVVbAAAbbaqqq2AAA221VVVsAABttqqq79znObAAAfv3vvv9e/ffffVd88AAA888tVVX9c5zlb+gAAObbaqqq2AAB85vutazXzN7q8u96AAAAqqqCqqoAAAAAAAAAAAAKqpIaqqlXhJLve93N9ugB3rbbbbbbbZttqqqrYAADbbVVVWwAAG22qqqtgAAPec5z33332vaqrznOcwAADnvPffffa9qqv3nOc2AAA/dv3dAAANSS95ttttttpt8te9727u7JO+eAAAeeeWqqqtgAAPec5z33332vaqrYAAD3l/X2quAAAAAAAqqqAAAAAAAAAAAAAAHdazNAdVHoBnOc/u973u973vOaqqqqqs7bVVVWwAAG22qqqtgAANttVVVbAAAbbaqqq2AAA221VVV/Oc5z30AAD999999+++++qrYAA4bbaqqq2AAA221VVVsAABttqqqrZqqqqqqxrio0AugDABkAz7eXl3oAAAAA+ZmYA5VVQAAAAAAAAAAAAANZmAPkktqqVdSSdVVVXMzN3dNADvW222ADbbVVVWwAAG22qqqtgAANttVVVbAAAbbaqqq2AAA221VVVsAABttqqqrYAADbbVVVWwAAG22rnKqq+5znPfQAAP33333377n331VbAAAd4/d59Xj+/3bZnu92T1VSrHVUq7VUquqpVdrl8yX3Z8vRUYUUfVRpUcqjKjgUEwqMCo4ERIVHSqSIJhUYRBPyo5AMAL4qMqMqP7Co+io+GBQBwqMIgmBEEwqB6qMqPiIJ4Co4VHCAjCoyo4VGRBJFRlR8VHxBJUfpUfEQTxEEwqMqOARVlQZUcIgmAFAxKjaAPgD38gYv2f17yAAAAAAAAAAAVVVAAAAAAA5znOc5wAAFVVQAAVXvvrnOcAAAzAAAAAAAAAAAAAAAAAFVVQAAAAAAFVVQAAVVVAABVVUAAAAAAF7me++++uAAAqqqAAAAAAAAAAAAAAAB7777776AAA9zWc+c5znOAAAMyz2v6qgAAAAAABVVUAACqqoAAAAPcH0AAAAAAqqqAAAAAAAA2DwAAKqqn+AB0AAAAAAAAAGgAAACqqoAAAAAABVVUAACqqoAAAAAABVVUAACqqoAAAAAAAAAAAKqqgAAAAAAAAAAAAAAAczMw/gAAAAAAAAAAAAFVVQAAP4VHxUfiVHQB8qOQD1EE2AbVH1UcgH4A8RBMAEKrAGACVGVH1EEoVGFBcqo9VFNneugAAAAACqqoAAAAAAAAAAAAAAf2ZmfwFR6KFINVVAUXvnvve65zm973v5OVIUDQpStCDECFBMKIUxDQURC0iJSI0CQSUMkFUJSUTE1Cn31VVVVVWPGaApmooiCooioqSKKpilOwmJDGMJQ0kRT8fnH45VX8/n8/ne973YAADbbd73ve973YAADbbd73ve973Yfj8fgNtt3ve973vbnOc99AAA/fffffb+c5+fffVVsAAB3333321VVbAB9+c5z9/QPfffffvvqqrYAADvvvvvtV3ve92AAA220kkkk1JL3m22222222+a/LiSV3Lku3QAAAAABVVUAAAAAAAAAAAAAAPmZmc3v7tVd73vdgAANtt3ve973vdgAANtt2qqrYA4cfjm22rlVVeYAAHfffffbcqqrYAADvvvvvtuVVVsAAB3333323Kqq2AAA777777blVVbAAAd99999tyqqv65znNgAAP3vv7777blVVfc5znvoAAH7Z/f99753v3fqqqqqqqoAAFVVQAAAAAAAAAAAAAAAAbVUq/VVKmqqlWZmfv35fv34AO9AAA777777blVVbAAAd99999qu973uwAAFznvvvvtV3ve92AAAvffffarve979znOe+gAAff05+c73ve/fffd73vdgAANtt3ve973vdgAANtt3ve+++++eAAAd5tt2q73vfPAAALbaqu9737nOc2AAA/ea1maz9rWs1zMzHnn7Y/X4AAAAAAAAAAA/d73ve973oAAAP7MzAHAAAAAAAAfqqlV3d7u7ulAHetJtgG22qrve988AAAt55V3vt3+/7AAA/rttuc5z+6v7u9rzwAAB55/dV73va88AAA88u0kgC5IH5JLvW22222222+c2ve96/vvu/VXngAAHnnnlVVV54AAB5555VVVeeABw/PPPPKgADMbbbbbbbbb9lflSqoklmTJN3QAAAAAD3MzB9AHo+gAAAAAAAAAAAABvMzN4B1EEyAdwqBAhwA/fffd973nd73v3wAADzzzzznOcqv7qr+c5zmwAAH7+7bffffd+qvPAAAPPPPKqqrzwAADzzzyqqq88AAA8888qqqvPAAAPPPPKqqrzwAADzzzyqqq+5znNgAAP3znOczb777776q88AAA/vx55VVVeeAAAc9/rnfv9+8++7H7v4AAAAAAAAAAAAAAAAAAAAADe9730VHqo4AOgGc5/fAHve9/d3ve/fYAADzzzyq7VXngAAHnnnlVVV54AAB5555VVVfznOc2AAA/dtvvvvvvqrzwAADzzzyqqq88AAA888885znKr+6q88AAHDzzzyq7VXngAAHnnnlVVV54AAB5555VVVfc5zmwAAH79/ffPO97ud6AAAAAVVVAAAAAAAAAAAAAAAA+ZmZ9+/30qqrzwAADzzzyvec5yv2qvPAAAHnnnlV2qvPAAAPPPPKqqrzwAADzzzyqqq+5znNgDgB+7bffffffVXngAAHnnnlVVV54AAB5555VVVeeAAAeeeVXe97288AAA/fPPKqu97fc5zmwAAH7v99+Xn2vb9+/AAAAAFVVQAAAAAAAAAAAAAAAP1VSq7u93d3QDMbbbbbbbbbzMwACq88AAA8888qqqvPAAAPPPPKqqrzwAADzzzyqqq88AAA8888qqqvPAAAPPPPKqqrzwAADzzzyqqq88AAA8888qqqvuc5zYAAD922++++++qvPAAA+fHmZmc3vm+c4AFVVQABVc5ziqAAAAAAAAAAAAAACv6/r+v6qqqvPAAAPPPPKqqrzwAADzzzyqqq88AAG28zMAAAMxtt06aWZmAEADFSu7sAgAakl1UnmZm7umgGKld3YBAeZrHnnnglV5ms3vewgeZrPtzWZn3nPPXFVCqqoAAqqqfMzMAIAAAAAAAAAAAAAB+APwB+APQDioHnmc85zm+b3vfADI2Zmbu6aAYkru7A9JJMVIdKlmZgdGOSS6qld3ck9JJMVK7u5J6SSYqV3dykDzNZve9hFbzWPmszN/29hFdSSxUm1e5m7uzSS1SvN2/N+whzOGv6/RegLhUdqjhUZUfyo68VHz8iuJHMqP5UdZ1v7MqMom7X3uz1UfUFlRwKCBCowqOFRhQSVGVGFRlRlRlRlRlRhUZUcCo4EUTCo4BUfgDwVUfPvwC+AKjKgD4iCYRBJUYFRwqOADCi0gAPkKj4AaEH8qMOQDQB8AcAMAGwDwAwAVAHAHAHAK5AMgGACQDUkhdSS4kl3vfrwAAAADEkgCwAAACqqoAAKqqgAAAAAbzMwHlVVQAAKqqgAA++Zvew4AABmAH3MzAPQAaAAAAAAAAAAAABVf2ZmVUcAAVVVAABVVUAAFVVQAAazMqqqAAAAAAAqqqAABVVUABrMwKqqgAAAAAAAqqqAAe++++++gGszAANVVVAAAZ5ZX2qgAAAAAABVzMzL5VAAAAAAAAAeBsAFVVQABzMzD+qqqAAAAAAAAAAACqqp/gHuZmD70AAAAAAAAB7mZgAqAAAAAAAAAAABoAAAAqqqAAAAAAAVVVAAAqqqAAAAAAAVVVAAAqqqAAAAAAAAAA/szMAcKqqgAAAAAAAAAAAAD5mZgBAAAAAAAAALSSuklaSVpJWkkJJHgquwCEQTYBsA2AflR2AQhAGwDIBsEdgHgqPwBvao7VHIAQB8ASo/ALoAgD0A9AJUcAGADCIJ++AMqjgA+AJUfwB4AbAPkQT5UflRkQSBRwCo0ILgVGRUfQDAqP7WMzM8nngqqFVVQAAAAAAAAAAAAAAAAAAAISSzMy8ACS0l+avczd3ZoBipXd3JPSSTFSHWOsdUswDCSTUku1SbzMwDxJJipXd3JPSSTFS2szMAhJJipXd3JPSSTFSu7uSekkmpJdVJ5mYBCSTM1na+1c4qqA1mYAVVVAAAAAVVVAAAAAAAAAAAH379+1VVeZrN73urlVeZrN73urlVYqV3dyT0kk1JLqpPe973d02ST5JLFSau7AIAGKld3ck9JJMVIpZmYBCSTFVK7u5J6SSZVXd2AQAMVLvlEkufauOVTD+KqqlVVQAAAAFVVxVVAAAAAAAAAAffv36AHmaze97CB5ms3vewgeZrN73sIHmaze97CB5ms3vewgeZrN73sIHmazzPPPPAA8zWb3vYQBipXd2AQAMVKDrFylSaqpcl+74lUKqqgAAAAB9A9VVXFVcVVQfACAAAAAADP7MzN7/t7AHmaze97CB5ms3vewgeZrN73sIHmaze97CB5ms3vewgeZrN73sIHmaze97CB5ms3vewgeKld3YBAAxUvvhUmypSSyT094kkgVVVAAAAAe5mYPoCqq4qriquKqoAAAAAAA3mZm8zM3mZl7mJakld+9vt00AxUru7AIAGKld3YCB5ms3vewgea1m972EDuZme4knmZm7umgGKl998AeADFSu7sAgAYqX33wB4AMVL7bvd3Zu6GpJdVJ9578++8/xrWs15/ee/fK/fvwBVVUAAAAAAAAqquKq4qriqqAAAAAA+/fv0APM1m972EDzNZve9hA8zWb3vYQPM1m972EDzNZve9gQAPySXVSeZmbu6aAYqV3dgEADFSu7sAgAYqV3dgEADKpdfe970AAYAAAAAAAAAB3ve970VXO1VxVXFVUAAAAH379+hVTWs3vewVTNZve9hA8zWb3vYQGpJdVJ5mZu7poBipXd2SeknrVIMznglc3ms+/bcIHmaze97CB5ms3+/ft73v7e973wAyJfSo9VGVVAkUIAWVGAEUlRgQAZUZURQlRkVUhUZRF3+3ve9973YAAAAAAAAAAB3Wd73ve973oVVXFVcVVxVVAAAHmZmftZrM1n7KpVVU6qlTqqVd73v79+/b+AMqru7AIAHmaze97CB5ms3vewgeZrN73sIHmaze97CB5ms3vewgeZrN73sCABqSXVSeZmbu6aAYqV3dgEAD1TfFR6Coyo8AMKjhBRZUaUFhUZUZUfEDnvOc5zXe73ve97AAAAAAAAMwAAAAAKqriquKq4qqgAO5rWs1/ZmZ/ZmZ3MzPqqlWZmZu7ugGKld3YBAAxUru7AIHmaze97CB5ms3vewgdzMz3NJ5mZu7poBipXd2AQAMVK7uwCABipX98AeIBipf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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

