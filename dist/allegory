#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':
            braces = braces + 1
        if t == ']':
            braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    emsg = "E__: "
    emsg = emsg + "Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice)
    report(emsg)
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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Z999km9gAAb5d85JJ999JdgAAbqmteauSSffvpM1rzW9gAAcqua5mZmSSS+t9qgAA9qud73vfvvuy7AAAZyr3mZmfffZLsAADNcc01rV/a3y+e5n7MgAAAAAAAAAAAAAAAAK+rPAAAVVQAAHvupKlz5e952eea88kkzMzMkkl2AABuq3uSe615qSXJM1rzW9gAAcquczMzJJJfWwNGmnm9cu3MzMz7999VAAAd3d5XMzMyfpJdgGVQBytVzmZmZJJLsAGtM15xd85mZmZJMx5rWtdc4AABder9973veySTN7AAA5Vc773ve9zMyXYAAG6re5JJJJVAAAZkrfu71rzzznta83ze+Z3MwAAAAB08AAAI0AAAOngAAAB2akkg8AAB+/Z2pU5zkqvtLz3ZUqRVxVQDe9a1rWta1rQC6q5JJJJKoAAMqt1W8zMzJJM1rzV2AABuq3mZmZJJ27AAA3Vbzve973MzKoKqgALqrySSSSVQBmtVVeeVVdaNXdVRdn3Ofbu7u5mYuu21VVSLa1VVZIXdX9b9u7u7mZi6qKrVLt3bVK1V/Xf27u7uZmaELq6hBdW1RapWqqqqy59zn3e973sk7l2dqgAD68a1+5z3vvfu9zVZmZmeazMwQAAAAAAAA+qroegAAAAAEkkkkAAA3lfa8/Z55rzTM937mZnczMySSqAAAzd3vMzMySSqAAA5rd3uST6SScuwAAK83d7kk+kkma15r3W9gAAd9u/czPs+++kuwAAO8u+873veyTeqoAAD7d3f33377777dUAEqgK3dySfT777dUAABdV9kk+kkA0eAbu6uSSeySTNa81Nakkkkkkkkk70Djx1R3l2WCfe+++5902dPAAKABdXQAAAAAAAAAAAD1JJyST3laDj4eAlVdNd85NWqffoifnxATe9xfgTpt1KNEKr9vk339My++97mZkk7l2NAAPeXe8zM+ySSqAAA7u73mZmZJJVAAAXVXJJJJJzV2AABnLvmZmTJJOXYAAG6rckn0kk5dgAAbzV3zMzJmSTNa817vYAAHfbv3ve9nZJOXYAAG6rckn0kkqgAAO+83vmZmfZJ9uoAABprNzT9vgqq1zzX6r5n7MzJAAAAAAACSSSSAAAAAAAAHA2Dp4AAPO+PuflVdfv09/f327m773vezP3HKqq8SC6tqrVVSEFv3et7973vc7k+zWvNcuspVUAAcquZmZM7mZlUAAB7u73mZn2SfbqAAAd5d8zMyZJ9uoAABuq3JJ9JJKoAADm81vfMzMmZJM1rzXu9gAAcquZmZ9kknfd7AAA5VczMz7JJKoAADvvN75mZn2SScuwAAOe/s15retfe19eZ+mZ8AAAAB08AAkkkkgAAAAAeAOmgCAAAAJltyqut3Lnsn0zMzMkk5dgAAbzV3zMzJmSTNa81N7AAA/Z5+3v9vM/Z99992fucAAAvHn7e/28z7Pvvvvte72AAB3eta93v3eZkySSaqwA8PeVfOST6SScvVgABvNXfMzMmZJM1rzWa15r9zgAAHtV7zMz7J99933OAAAPVe+5mfZPvvpYAAHf3u9++5mfZJ+k9zmwAAKquXryta9vfuqiAC+YraqAAAAAAAABJJJOzQAAAAAAAAAAAAN5UqVM1+kqb5ypXb2H6/B9mKqAHrvWta1rWgA5mr5v2szJmSTNa81dgAAe8u+ZmZ9kknc/c4AB3WqqvPKqvPKrln9znf6t3fbmZi1Xtu1bWqqkW1qr/u853d3f25mZnec9CC6ttLV3d1Sqqvv13++773OySVQAAE95muc99zMmZJM1rzXu9gAAcquZmZ9kknbsAADdVvMzMySSqAAA7u73mZmZJJzV2AAB7e/mT7Xnryta1rzxyAK5EEQ1AV0otKLQqLq+Zrf2snPt8q8zQK1ugFczlZoFbUWIiGr7agpWdsFEL341XuTPb96e5gK2CvgVgK2KLEFa573K5N4oveTNzuvbq6ZVGbvWkEUgK9zPgUfVkargYHaqB0Ak/HmQkl3nT7lsaFRS7KPKABqa9r3c994UVMgK3FRWoCrGAqxYosUWKCsUSCCLFJAJEQJFEIEAZFkGEAJGKCkYgEBWIISZncys9nkW2iSSdu6u7mpAJVXd+XVPAIXSKYABBVgKyCixiijIorGCrBICiQYArJmZmZmeUXCYCiXVXdtAEaAFtXoA8oi5mZmZmZiKxVVIisIkBXVVKrUqqqtfwqqrVVKkdAAAAABngcgisLWhBKmZmZns8iAZMzMzMzyu4CgZMzN5mZ5UXFFhkAUK5NVN62qvsdSSqo0AApKlR0qquSpVSru7VXUqfSVUko0FqiSpJI6AAAAAEkkkkAACSSSSACVl1d1eeZjueZm891Gg6AAJJJJIAAEkkkkAAAAAI0Ae18PT4AACSSSRJJJIBvmw586AAAAAAAAGZmZmZmYAAAAAAAAAAAGUururzWZmZmYCSSSSAAB08AAAAAAAAAAAAkkkkgD70bHZJJJIAPQPgAAAN0DgAAAAAACSSSSAAD332VK73777qQAAAAAASSSSQAAAAAAAAAAAAAZJKoqVUrVSVKrrxV8qAAAAAAEkkkkAAAAAAEkkkkegfAJJJJIAAAAHA2OfbHD4kgAAAAAAAD8A/Zn7MzPSSckmAAcDYFAACSSSSAADmg4AAAAAAAAAAAAAAAJJJPvvj6MmtR2qqoB+qfH6cnd7kqP7UqqiBevakZypEqAJUoIFSQakYz0okCECELAJElNBIBGoVRKrVFhAhLqA1KpoKj6FFkJJI1IRalMhSSMhR6wV1u9/VmduiZpEUewVHMzj9g7BWIrFFgKwFe7102MBRiEVRgqknar17BPAnlF2JBRdAlgloo8QQTQK+sBWgVgCsBWArAVgK/G7rAS4IqaBNomImKfAmbRRhgJd6E2ARU13iijqUKvs97XgTc0Ca4osr5vclT9vfV+/CFyVAD49s8G5utSqqgiKwQCSAARECRBEIwYAVeueBxEuru2nh8U9Lu7u7mjp4ZwDsA7F7PoegB9JPoK6ohv1bmt9t9+U6aFbivI6jpVVVAAD77777776AEkkkUeAAAAAAAA27VXR4401QDoAABuSp97dVU3993up3X33yqqAdbvWtaAAOXq75mZkzJJmteauwAAN1W8zMzJJP4XYAAG6reZmZn3329eeauwAAO3mt75mZmfv0+uwAAJVb3JJyfffVQAAEzV3vMzMz776a15q7AAA53u9+973s7JJVAAAXVXJ9999999VAAAdzm98zMzPvvvqoBo01yc9vea94/ZbbYWqqgAAKq8ihyAHJKgJwJJ2akk2DgA+HoAAABIo2CfDdg5QAYiTfy0bkwEsBskJN0RSrqlyZOz76c+zMkn333ygAAXVX99+/fv379Na81dgAAZrPd79zMz9+/fu3YAAG6rf333379+/VQAAHd3e/vuyffffVQAAF1V/ffa7JJJVAAAP2cvfMz9rMySTO+PNeaPN7AAAm/d7973vf379++uwAAJ533e9+5mZ999+qqqgAA7u739999PPPvvvt3aSSSSSSSSU4l+7T96ne4HQAda99zPsyQAkkkkgAAfD0CSSSSAAAA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AEdVV197v1w6AH8Zmc9roDR565zve97kkm781bzWcq+ZmZmSSb5Kl6uwAAC+SpersAAAZKnblTuu9u7QAzvJUz3z327u0AzvJU7rvX1VVeblTmucQuKq83Kl98727uKAe1KneSp5k7vvXPO9Nj0B08AXV17oDoACgAAAAAABuqugcAAAAAAAACpUJKhJUfSVrVa27kqK+qVG7u7Q8AO7lTmucD5QB3Kn3nd96vygR7V1vW9gBv2rret7DQH11dc3V1zXOBAc9q65zznASSb9q6c85w+AC+VIysmqnue9mZmYADU92VN5rWpP3P379mZrMAPVKj7sqft3rXX7312+T40AAAAAAAAAHA2D9mZmZmZgAAAAFAAAAADWlgV+qv11rWqv9+zMzMzFX6/eyp5JlTX2/vsxzMVb7yVDczVfr/fsz7MwAe3Km5U7vvVVQC+SpersA0AB6pU7cqM9v3l+VAP2ZX7XpU/a/fswzEAztyjUh2T9z9zM/fsACXyVN5qp3neKqgFXyVN1L3fAA0AFdqVO3Km6n3eu6rz6bfSZgADMzPMzMzM6AAAAAAAAAAAASSSSQAAAJL5+/frPvb++FVAD3blTuu9A+FVavkqfu771X8qqy+SpersAAAl8lS9XYBoD66uubq65rnDoDKmqq6+5V15V/td5+/ZhmYAZrtyp9z3PcXygBL5Kmd33qqoBfJUvV2AAAfqlTtypt7b7374vl/vfszsAAADQBAAAAAAAAAAACSSSSAAABJ7T7Pa8qrjNyVNrtt/fKqqi6mZlSpw1UqfvSpf7fuZn2YAEztyT72/ezM/Ziqy+SS9XYAB+Dd8lR7vvVVQCfpVTtyp3XewPwHADvJUvV2H4AAjJU7cqfe37y+UAmu83qtNaOge1773ve97JJnN0AABfL5eczMzMzM+815rm4AABO1UqvbNaPHcf2fvs2AZFVVUAAAASSSSQAAAAAAAAAJJJJIAAAD771So+kqfc+598gqqtqveOta1rWta1oByucz9mZkkn7zXnN4AABqfr/fs59mZcknLwAADlc5mfZmSSbvAAAPvb937mfszMzJmtTWvNPNea95QAAHte+5+zO97mZk5voAAHte+77+73MzMz95rzm8AAAn6/37OfZmXJJy8AAA1yuczPszJJN3gAAH3t++5nuZkkn2tea5vAAAJfP0r3Wr91rzVf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Sj3DKI9w9w5CR/pSR/o6FoWEjURqLIWqWwkaiMiWojIX716/m79u+t96QgSLCQREVFikCfoKrbVkSvLECZUyUGVMqgrKmVFddc5znOeOd9+JKld7XrLkSU/iFqIxlkLFKxStQMqenpznOd88c775KnKFoXk2mkLlVGQDQtKmVOuuc5znPHO++FB1lW2rKts0BwpWlTCaJXXXOc5znj+ffv6Ej+KRkWReXIbZaSRyiNJFZFpBMRaJiUxSskrSiV11znOc545334ihdZVtqtKnJTSq665znOc8et2QA6sjAFUJJJMzd3d27boQldMq20yRXFTKTKmSFaKrItCyiNCxI0GpJ11znOc545334QTqZVtmpVK4qalTrrnOc5zxzvvxQTipqQ0LIXmhthqlX7+fvX6SpUn3JJuSTd++3+LoAAAAKqqAAAqqqoBupIAD6ABaAAAAAMkncmZmTNwJcBWUJZU1SaVNVQgDAIwCMAiQADp73ve9ffet2EpX8hZQvGw1FV76hcIWhaBU0LSRsBFoNEVZUxB6enOc5zxz19e0E6lkSP0LEWhZFoWQtKYUrKmVOuvHjx45zxzvvwgnUsAEkMzd3d27boQCdIJJAJ6QIGiGlTKmEMVMlMVNC1EbRKpoWpCyLIlV11znOc547VOePHnCpyVMhHiaRU4haURoWVCyFhI2SjItpKtQsiyorSmpKyqqwnXXOc5znjnff6iJ/KLxOIoHKFqlqjUDVBhDJDVBrSplTKmVNKmVMkddc5znOeOd9/oiH8haiNC1EXiYggThAIwAAYBEAhA733ve97fW6UrpW2KDgpWJTJK0ppTrrnOc5zxzvvkpwTCaVPSXCFySNQsi0LUWhZBGSAR733ve97fW+JIE6Q6/v53vCBM/vJMkzJk+5JPPfd3bQAAAAAC2222gAABbbbbQAAAADmTMzJm5Mky4AhttvbdpWEBGSCYIiAgqm220134KiupakVyVNKaU665znOW7SoDGEkktpKoCyAiyAjObu7u3aVENCBMzd3d27bhPIJAniBGAd7713du0qIHABBVNttppUQYwkkltJUZOcAo7mT7JJMzJ3z54HoAAAAABbbbbQAAAttttoAAAABcgYEAiQPvvvvv599bcJsAXzyMA733ve96+tw2AKwYAq5m7u7t23CbAFmKpttvbSpwBMzMxFU223tpUQYwkkltJUQOAKptttNKiB1TbbaaVEGMIFHZk5wCjsycn3JJMySSfvmTJmST736PfQAAAAAC222ocAAAFttttALkkx8AAADkzMkmeZJPmZmVUoA8PQVuVMlSXeZmZji3KmXeZmZjTsyc4BR2ZOcAo7MnOAUlRA4ArUAZbbfCaVED1nLbb5TWIhYlJJLaWIhzGG223tpUQc8BARARGtaS/PQLbbbaAAAFttttAAAAAAAAWgACq7qpUqp2pJqSVKk9qSaqpKLOb3xvaSogcAVTbbaaVEDqm2200qIOcAo7MnOAUdmTnAKOzJuAVTbbaaVQOYJqm2200qIOCqSWktjsyc4BR2ZPl/TJMkyXnJJkmTJm5JLkkt9326uhbbbbQAAAttttoAAA9ySHAAAAFttttAySdyTJMknuQJAgCBKklwkkqIHAFU222mlRA+93d3dadmTnAKvJOz5MPnnAtXkdzAEk4AvN3d3e73ggcAOm22094IHvd3d3WnZk5wCjsyc4BR2ZN8+9/b8zMkySZPPffN3fQAAAAAAAAAAAAAAAFttttBzMkyS2239vaSogcAVTbbaaVRFzF5zd3d2rSqAxy223625DYAqGZu7u79tuwDqwMzW23tpUQOAKptttNKiB1Tbba3vBBl2qqhupzVS7AOgG81UnkqqqVUmqknm/Pu7u3QAAAAAAAAAAAAAAVVUAAYu1UqSXKkkk0AHoMW5UypJd5mZmIblRu1VUNypvYABp2ZOcAo7MnOAUdmTckne7u7u3bcJqyKQfcIHHvfe973r63CHOW2lHZk5wCjsyc+fcmZmZM8vyZJ59eHoAAAAAAAAAALbbbaAAAFoAAqpUkuqqV5Uk9qSMuqqVJxfPX1JJUQOAKptttNKiB1TbbaaVEGMIFHZk5wCjuf0+Zne7u7u7azJ/ZJO93d3d23cze93d3dadmTnAKJknZU1vSqorcqF8HnfdaPfPPXmuecXXee+z3kPNTd97z3ycmj3hbw7G+dNbeduNSpWpUixFkW2ojaqVe+QuKFkWkXrULmhaFoXSLnCXvjhmhes7ddd+de+QvWhd0706Rfev6v9f70haiNC8QuURzQuIXvQuQtVVdIuULiDSStUmENKmSGpKzJMznZ+/v7r+tv8AAAAAALbbbaAAAAAALbbbaAALbbbaAAAAAALbbbaAAAAAAAAAAHZbbfttAAAAAAFttttAAAAAAAAAAAP2SQdAAAAAABbbbbQAAAAABbbbbQABbbbbQAAAAABbbbbQAAAAAAAAAA7Lbb9toAAAAAAttttoAAAAAAAAAAAAAAAAAAPfffffffQAAAAABbbbbQABbbbbQAAAA/xgBtttttAAAAAAAAAADsttv22gAAAAAC2222j7kkDwAAAAAAAAAAAAAAAAAW2220AAAAC2222/QD5gESQCMAiQJ/YB/IDiF3C8heoaHIXyGheofIdQ9w7hdw9oXyiPaLkzJknufr5699AAAAAAAAAABbbbbQAAAttttoOTJM9ySfJkmfskn+LCH/3CQISAoEJv7f279u+t08JEGKs/EHiAiSB3vve972+twmiDmbu7utOzJzgFHZk5wCjsyc4BSVEDgCqbbbTSogdU222mlRBjCSSW0lRAyqbbbTSog3jiCIgIOIA44yuC2223ckg3d3d0AAW2220AAAABzJIA9AAAAAZJO5kkzJAPwLlTKkl3mZmCFyo5zmZmY4FypvYAdAuVN7ADoFysqSa1qrtVcMW5UypJVNttppUDJImqbbbTSogxhJJLaSogxhJJLaSogedcZkgIgOMYqSIAiszw93fbbbbbQAAAttttoAAAAttttoAAAAB+ySWZJeW22jsybkk73d3dxxbqs85zMzMcC5U3sAEVuSZNS7zMzMMW5U3tVOgXKjlSTnMzMxwLlRu1VELlTewDIitypvaqdAuVNnN87bS2222gAABbbbbQAAAAAAAAAAAAttvZk3JJ3obrTs2fJJ873d3d1p2ZOcAo7MnOAUVEGMJJJbSVEDgCqbbbTSogdU222mlRkkCqSSW9pKoGTBVNtt7aVEGpMkzzzwPVtttQ4AAALbbbaAAAAAAAAAAAPMkgPoDsybgFU222mlRA3nOG22mlRBxVJJLa3uoe8BxIKQUgpBSHv373ve9fffZpBSCkFIKQUgpBSCkFIZlt3du25pBSCkFIKQUgoQUnuckJ3vve9719bmkFIKQUgpBSCkFIKQWQzN3d3btuaQUgpBSCkFIKQUgpBSGZu7u7dtzSCkFIKeQ4kFIKQUgpBSHe+973vX1uaQUgpBSCkFIKQUgpBZkvsmSZ+/ft39vu22223QAAAAAAALbbbaAAAFttttAC5JPckny8tttHX5Nk2TZNk2TZNh/OcTZHWAd973vevtuaQUgpB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FIKQzN3d3d++3SCkFIKHkOJBSCkFIKQUhrAJv4/v957vve37766AAAAAAAAAAAAW23331bbQAttvYB99993777625pBSCkFIKQUgpBSCkFId73d3d3bbmkFIKQUgpBSCkFAU8k4kP37973ve9t2D9+76TZNk2TZNk2TZNkWQ73u7u7u23NIKQUgpBSCkFIKQUIPe93d3dtt0IdEnkIcSCkFIKQUh+/fve973ttuaQUgpBSCkFIKQUgpBSHe93d3d225pDZNk2TZNk2TZ/MuYrZPPP3ve97223NIKQUgpBSCkFIKQUgpDve7u7u7dgG73AkUgpBSCkFIKQUgpBZDve7u7u7bc0go384OZNk2TZNk2TZPvn8ie897/ff7+/tAAAFttttAAAC2222gABbbbbQAAB5kkB9Ad2ZPnyZPnyYKQUgpBSCkFIKQ73u7u7u23PybJsmybJsmx/M5k2TZH79+973ve225pBSCkFIKQUgpBSCkFId73d3d3bdgG94QUgpBSCkFIKQUgpBZDve7u7u7bc0hv5wcybJsmybJsmybJ555/Pe97223NIKQUgpBSCkFIKQUgpDve7u7u7bc0gpBSCkFIKT3OEFIKQUh+/fve973ttuaQUgpBSCkFIKQUgpBSHe93d3d225qbJsmybJsmybJsmyd993d3d227AOp5DiQUgpBSCkFIKQUgshfH82AbANgG93+e++++22gAAW2220AAALbbbaAAFtttrJI+AAttttuwDYBYA7zd3d3bbmkFIKQUgpBSCkFIKQUh3vd3d3dtvX5Nk2TZNh/OcTZNk2TZH79+973ve225pBSCkFIKQUgpBSCkFId73d3d3bbmkFIKQUgpBSCkFIKQUO97u7u7ttye9yT9+/eu7u0kqIKqkkkkknAGSCc5y2220lUyd70AOyTvegB3JO8+/f2/v3vu7t3QAAAttttoAAAW2220AALbbbaAAAP2SQdAHc2ZJ8mfJknzzzzd3d0NySeTJ8+z79+7u7t0dmTvegB2ZO96AHZk73oAdmTvegBOAMkE5zltttpKiCqpJJJJKiCqpIA7MjzzzoAAAAtttqHAAABbbbbQAAttttoAAA+5JA8AKIKqkkkkknAGSCc5y2220lRBVUkgHZk73oAdknk+TzzwAOzJ2qSSSSScAVAGSCcTnLbbbSVEFVSQB2ZO96AHZkt+/fr79AAAAW2220AAAAAAAD33333330AAAXJJ9ySOD6A7Mne9AG5JOzJ83zzm7u7unJk5wAOZJzgAc2ZJ8wGZzhtttJYIMYSSSSScAUQTVNtt7pyZOcADkyc4AHJk+fvnfn7nye+9166+efRC2IWRcRcJG0lXEWKVai0LuFoX0i6cQvULz31znzv3zwSPULt8KlXEWkpNC0oNRGRaJoCYTUStKZU0pqUkqalSVqSVKqVdzya8vvUFAAAVS2220AAW2220AAAAAAW2220AAAAAAAAAAOy22/baAAAAAALbbbaAAAAAAAAAAAAAAAAAAD5kktttvtAAAAAAFttttAAFttttAAAAAAFttttAAAAAAAAAADsttv22gAAAAAC2222gAAAAAAAAAAAAAAAAAAttttoAAAAAAttttoAAttttoAAAAAAttttoAAAAAAAAP8ABvZbbfttAAAAAAFttvuSTL8oAAAAAALbbbaAAAAAAAAAAW2220AAAAAAW2220AAW2220AAAAAAXJJlySZ8mSZ8zMmZF6h5DikeochyF2haFkLQtC0LQvCJofIfIfYeQ+IeoWh1DqHyHr2hdQtUtSRlEfPsPfrrr589+0AAALbbbaAAAAAAAAttttoAtttttvSAeA/wGCqIiCpBQUzTLWbaW2ZbGaZjaJrTWoxznOc9nOc5334OJSTYbVUytVGZtmVay2bqXkXlpddc5d3d2k4AogmqbbbbSwQYwkkkklzATsyfO9PAHJk5wAOTJzgAbkk7Mnzvd3d3d05MnOAByZOcAHySd+R+l8ySeffv7JI/KfgAAAAAAAAAAAABbbbbQAABkk2AJbbbbakglJJJJJOAKIJec4bbe6cmTnAA5MnOAByZOcADkyc4AG5JOzJ873d3d3dOSTnAA5kiZJ3vAAnZk+d39+n3z9+3d0AAAAAAAAAAAAAFtttQ4PMkgPoAfskn2Dx9A5MnOABuSTsyfO93d3d3Tkyc4ADsyd70AOzJ3vQF+TInAC7kk5Mnze7u7u7t+TI4AX5MjgAcmS/NyQi4AiYAjcAc1EBGeeb3dq2kkkkkkkAAAAAC2222gAABbbbbQAAD3JIcAHJk5wAP7JJ2ZPne7u7u7pwhzlttttvCHOW22228xVVVVVcy22223MVVVVVVzLbbbbdgHeqqqqqq873d3d3dtzFVVVVVcy22223MVVVV0gc4q97u7u7fvuVVVVVVUv89AJ3+H8+/vP7u/rt+ttoAAAAAAC2222gAABbbbbbbbbaAW/QD9AGAfyAXlvf1t++5VVVVVVcy222/fegGaqqqqqrzvd3d3d0tzFVVVBzLbbb99yqqqqqq4Zbbbf61VVVVVW5bbbbbmKqqqqq5lttttuwDvVVVVVVed7u7u7u25iqqqqquZbbbbbmKqqqqq5lttttuYqqqqqr/MOWRBBFwBEhEEQATEBGudXfO7u0kkkAFttttAAAAAAAAAAAAAFt8EADd3d3d3bcxVVVVVXMttttt2Ad6qqqqqrzvd3d3d23MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbdgHeqqqqqq873d3d2/fbiqqqqqrmW223764qiiMXMtttttzFVVVVVfQCfzwSAiMRARPMAZ55u7t3AClJZgBJJaSSC2222gAAAAAAAAAAAAAMgbAP5AEhCc3d3+bu7bmKqqqqq5lttttuwDvVVVVVVed7u7u7u25iqqqqquZbbbbbmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbsA71VVVVVXne7u7u7tuYqKqqquZbbbbWAXOKqqqqqmZbbbbbmKqqqzMzM1l55qyAI445u73aaSSSSSSSS3ve7baAAAAAAAAAAAAALfuSS29ttttzFVVVVVcy222230A71VVVVVXn9/ft3f27u25iqqqqquZbbfvvvsxVVVVVW97bbbfvsxVVVVVXM+++++++++zFVVVVVcz777777777YB3qqqqqqvO9ttu7tuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqq/egE/mfz+U3+83fttttoAW2220AAAAAAAAAAAAmSC23777777776228gGKqqqqqpmW2222+gHeqqqqqq873d3d3dtzFVVVVVcy22223MFNIDxVVXvd3d3bbcxVVVVVXMtttttzFVVVVVcy22223YB3qqqqqr+5zP37d3bb99mKqqqqq73tttt++zFVVVVVcz777777777MVVVVVVNITO884G7oAAAAAABbbbbQAAAttttoAAADZkmfckjJJvzd37s3dXMVVVVVVzLbfvvvvtgHeqqqrEed7bbfr99hiqqqqrmffffbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbdgHeqqqqqq873d3d3dtzFVVVVVfu9uW222/QDvVVVVVVed7cttttzFVVVVVf5n3P5f6ffc/r/O59/O3M/fEBZCyLIvIXIXKLQtC0LQukXKFwi0Lrjchc+9wuoXUL2yF8qXVFqqMi1EYUmovEXCRyF1DiiOSrlEaFiRoXIhpTJK0phDCeRUxVZFZFwheIuQuoXWSquQsVKMiyUmJHBLnELki3EWQtIXIXJI5Usi0UYi2oWosJZKrkUnIWotCyFyFlRZFiRyFoXEL6i6gp1C1FqqOkX3tF1UvsPPnv57+qAAFttttAAAAAAAAAAC2222gALbbbaAAFttttAAAAAAAAAAAAAAAAAABbbbbQAAAAABbbbbQABbbbbQAAAAABbbbbQAAAAAAAAAAttttoAAAAAAttttoAAAAAAAAAAAAAAAAAALbbbaAAAAAALbbbaAALbbbaAAAAAALbbbaAAAAAAAAAAFttttAAAAAAFttttD/AAaAAAAAAAAAAAAAAAAW2220AAAAAAW2220AAW2220AAAAFttttttttoAAAAAAAAAAWZJMuSTJncklwdw0Oko+w8hyKjIXqiPKI9QviL1DtC9Q+Q+w8SXVF8qXuGIXQlqiPOff3232gAAAAAAC2222gAABbbbbQLbbbbbbbbb+gFtvbbbbmKqqqqq5lttttuYqqqqqrmW22225iqqqqqv3e3LbbbfQCwD9+VVVVVV5n79vd3d3bcxVVVVVXMtv333332Yqqqqqre9tttv32YqqqqqrmfffW223MVVVVFX7vbltttuwCwD9+VVVVVVzP37c3d3dtzFVVVVVf7sgE/sA/sA7/f7u/b99ttzJIB+AAAAAC2222gAABbbbbQABbbbbbYBsAd3d3d3bcxVVVVVXMtttttzFVVVVVcy22223MVVVVVV+725bbbbsAsA/flVVVVVcz9+3N3d3bcxVVVVVXMtttttzFVVVVVcy22223MVVQVXMtttttzFVVVVVfu9uW222/QDvVVVVVVed7ctttt2Ad6qq61rWta1rWt985fvffO5mZ0xVVVVVVVAAAC222ocAAAFttttAAAAXJJ7kkcuW2225iqqqqquZb9999999mKqqqqq379+uW2377+wDvVVVVVVed79n3333332YqqqqqrmfffffffffZiqqqqquZ99bbbbsA71VVVVVXne7u7u7tuYqqqqqrmW22225iqqrpA5xVXvd3d3bbcxdIHOKqqqr3u7u7ttuYqqqqqr8Zc/ZnbQABbbbbQAAAttttoAAAAAAAtt++7APvvvu/fW22225iqqqqquZbbbbbmKqqqqq5lttttuwDvRRGKq873d3d3dtzFVVVVVcy22223MVVVVVV+72222/fZiqqqqqt72222/fZiqqqqquZ999999999mKqqqqq5n1LbbbcxVVVVVXMv33333332wDvVVVVVVebzu8/md83d3QALbbbaAAAFttttAAAAAAAqqoAByVJATgAF3rWta1rWta1rWtLmfW2223DFVVVVXMtttttzFVVVVVcy22223MVVVVVV+725bbbbsAsA/flVVVVVcz9+3N3d3bcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVX7vbltttv0A71VVV1rWta1rfZyX5t8fVVAAAVVVVVQAAAAAAAAAAAD33333337kk9HgDvVVVVVVcy22223MVVVVVVzLbbbbdgHeqqqqqq872222/fZiqqqqqu97bbbfvsxVVVVVXhltttv3OKqqqqqvLbbb9bcxVVVVVH7vbltv1t+gGTqqqqrzvbltttuwDvVVVVVVed7u7u7u25iqqqqqv9z9AM/Zb/Lfrbbbb9Aj4AAAAAAAAAAAAAAALbfvvqWAbAOQDm83d3d23MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLf0Att7bdgH79+VVVVVVc/ft3d3btuYqqxGOZbbbbbmKqqqqq5lttttuYqqqqqrmW22225iqqqqquW22/ffXMVVVVVV53ff37f3vnO7vu6AAAAAAAAAAABbbbbQAAAtttv7JJ7kkroFd78+fFVVVVcttt+++uwDvVVVVVVed3d3dt+3MVVVdIHOKq97u7u7bbmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbmKq7bbbbbc+d/kX9CFkWQsi1JM9n7z9/e/39/X+AAAAAAAAAAABbbbbQAAAtttvuSTcyTJHN3d3d09AO9VVVVVV53u7u7u7bmKqqKqrmW22225iqqqqqvLbbfvrcxVVVVVXMtttttzFVVVVVeW22/fW7AO9VVVVVV507u7u7u25iqqqqqvLbbfvrcxVVVVVXlttv31uYqqqqqrmW22225iqqqqqvPQCekAmfu+973vetttv331ttoAAAW2220AAAAAAAAAAkDsAttv6223YB3qoKqq873d3d3dtzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVdIHe7u7u7tuwDvVVV4QOcVVXkgd7u7u7u25iqq6QOcVVXhA73d3d3dtzFVVVVVcy22223MVVVVVVzLbbbbcxVVdttttnrnrnO9187589fPNzIi+5ReQtC9kWPsLKLjznfzrz2i8IvIWkj32SOQvUMlUvUMFD1Uu6I+Q/Q+IulS8ijkNJC5UspGotRbIXIWpRfYchofvkPIchsAsAsA2AWAWAcOQCwCwC2lAAAttttoAAAAAAH3JIHgAAOy22/baAAACZIAAFttttAAAeZJAfQAAAAAAAC2222gAAABbbe5JLbT8AAAAABbbbbQABbbbbQADmSQB7zJIA9AFttttAAAAAAAAAADsttv235kkoCgAAAALbbbaAAAAAAAATJAAAAAAAAAABbbbbQAAe5JDgBMkABbbbbQABbbbbQAAAAABbbbbQuSR8AAAAAAAAADsttv22gAAAAe5JDgFttttD/AAaAAAAAAAAAAAAH7JIOgAAW2220AAPuSQPAAALbbbaAALbbbaAAAAAALbbbaAAAAAAAAAC224ZAMgGQCwD+QCwCwCwDIHEovsPsPsPsPqH2HkPUQvUMoj3D1C6h7Qdw6onyGh1C+Q90HiiNUtVF9RaiOfwhdQ0qk+9fffz5taAttttoAAAW2220AAAAAAAAkkkkkktQBqAGAQQ23xw22k4CADvVVVVVVeT/AGQP373ve973rcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMttttt2Ad6qqqqqjzvd3d3btvDBiqqrmW22225iqqqqquZbbbbbmKqqqqq5lttttbvWta1rWta1rWta1rve9qSc71QBVVQC9ySW2n4AABbbbbQAAAAAAAAAW2wDYA7u7u7u27AO9VVVVVV53u7u7u7bmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqjmW22227AO9VVVVVV53u7u7u7bmKqqqqq5lttttuYqqqqqrmW22225iqqqqquZbbbbbmKqqqqukDnO/fPPfv39u7+3QC222ocAAAFttttAAAAAAAAAAPckhwAbkk88+Kqqqqrzvd3d3d23MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMtttttzFVVVVVcy22223MVVVVVVzLbbbbcxVVVVVXMttttt2Ad6qqqqqrzUkAgHP37u7u7tttt+++++++++AAAAAAAAW2220AAALbbbaNySZu7u7u7tuYqqqqKZlttttvMVVVVVXMtttttzFVVVVVcy22223MVVVVVV6d7bbf7bbmKqqqqq5lttttuYqqqqqrmW22227AO9VVVVVV53u7u7u7bmKqqqqq5lttttuYqqqqqrmW22225isRhsCEgHiBEhCSff32EgSTn637/f1/r/ALbbbaAcySAPQAAAABbbbbQAAAttttouST7kk+Pg+gdIc5bbb9bcOsiQFmZbbf79bcDFYd6BRuSTyZPne7u7utOzJzgFHZk5wCjsyc4BR2ZOcAo7IMYSSS2kqIJ4lMgCLICOedau93dpJIAAAAAAAAABbbbbQAAAtttto/smTMzd3d3d3Tsyc4BR2ZOcAo7MnvengpyZHPgFOTJ8AU5knwBRNySeTJ873d3d1rkyfAFOTJ8AUdmRPuST79++BQAC233JJfltAAAAAAAW221DgAAAtt3ve9pIgFADIALgCMXd3d3dpUQYwkFHZk5wCj+ySeTJ873d3d1p2ZPe9PBR2ZPe9PBR2ZPXnjwVb2ZO3a8VFbyVJqpDnMzmZhi3KnbteK0dmT3z77++7v9mZM9+vP7X9/fwAAAAAW2220AAALbbbaAAAAAD+ySZ/ZAjcAYIAi7vN3d3aSgDJBOzOaWUltb4gCiCRFJZSW1twBRBPLy3ltppUQe96eCjsye96eCjsye96eCjsydu14qK5Uk5KmjnMzmZji3KnbteK0dkntfLkk999+/fz0AAAAAC2222gAABbbbbQAAHckgH4Abkkz7kk3d3fu7unck9708FHZk9mSd6eCjsye96eCj3JJ5MnzvTwUbkk8mT53u7u7rTsyc4BR2ZOcAtvJkdtVVDcqb2AABlSS5U17z1szw8zz3uaW2220AAAAAAAAAAAAAAAAeZJNyZMzP2STd3fP27tvJkTJO5bbbdtyGkBgkDM3d3du25DSAwkgKptttN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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def get_tags_for(pat, textmate=False):
    tags = []
    matches = []
    for root, dir, filenames in os.walk('.'):
        for filename in fnmatch.filter(filenames, pat):
            matches.append(os.path.join(root, filename))
    for f in matches:
        print('Scanning ' + f + '...')
        s = open(f, 'r').readlines()
        i = 1
        for l in s:
#            if l.endswith('\' :\n'): tags.append(tag_for_colon(l, f, i, textmate))
#            if l.strip().startswith('\'') and l.endswith(' .\n'): tags.append(tag_for_dot(l, f, i, textmate))
            i = i + 1
    return tags

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()
