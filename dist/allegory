#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':
            braces = braces + 1
        if t == ']':
            braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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gqHESnJzQ681rXPZOubmpJJJJJVAAAXvXnmt3vVySSfpJW1AAAXvdXJJJJJWqANHhV1VXJJJJJVAAALbu5JJJJKoAa0L3u7kkkkkqgAAL3rXmt3ckkkjUm/KAAAve7uSSSaklUAABe9bu5JJJJKoAAC97u5JJJmZdySSSSSSSSRRCXy0QdQACw3SqA7vVoCBkzKTPUKie9T73rG7uDYAAAAJJJJIAAoAAEkkkkAcDYAAAAD77W6qrueeXVXV3RBTqhms2Igu+TmZJmZnfe9mZl36qkAAHN85PZJ2SSqAAK3stVySTsklUVvYABe9a81urkkkkkqgAAL3u7kkkkkrVVvYAAXvW6uSSSSSqAAAvet3ckkkklUAABe93ckkkklUAAAtu7kkkkkqgAAFt3ckkkklUAAA155rzzwRXkBV7CRBB5AGKEFVdRAB5zLMgq9iiIvogghkQQBcgoI5ERXIIpkRFTIIghkKqqpqru6qjxqquqqgSSSSQAAAAAAAACSSSSAAAAJJJJIAe17VKvQSAq95mb2DvKRFE5nrrMzMzMkkqgAAL3rXmt3ckkkklUAABe93ckkkiTdAAAXvW7uSSSSSqAAAvet3ckkkklUAABe93ckkkklUAAAtu7kkkkkqg0ABe93ckkkklUAABe93ckkkklUAABe93ckkkklUDQANft+aVyqRXJO0b73s5sO5m82oJmaz2cFXwbBJJ27qpqSAAAAAAAAJJJJIAAJd1TQAAAACquvF3Vaq743JL15555PZqL815rckkkkklaoAAC97u5JJJJK1QAAF72u5JJOySqAAAve7upJJPZJVAAAXvd3UkknskqgAAL3u7kkkkkqgAAFt3ckkkklUAABe93ckkkklUAABe/Nea3dySSSSVQAAF73dySSSSVqgAAK3rXW75Xmta155rm9vn1nl1d20PWqu7tqru7sNgDp4AADQBAAAACSSSSBGgAAAJJJJIAcu6r2/dVd3d+6uruw6ieBJJJJVAAALbu5JJJJKoAAC97u5JJJJKoAAC9615rd3JJJJJVAAAXvW7uSSSSSqAAAve7uSSSSSqAAAW3dySSSSVQAAF73dySSSSVQAAF73dySSSSVQAAF73dySSSSVQAAaICdiK+5QoEiqopqBzlICgZztiIBkcykVRMzLFBcgKoZKu7q7oN1dAAAAAAAAAABJJJJAAAAAJJJJIAc+3V3eruq1Qq+UIgqbFKyZ3YIIc7ns3XMzMySd7NV48ADV73dySSTvdwAAC97u5JJJJKoAABrVtbu+973ve97VAAAjXFOckk7+73tarx4AAqu973ve97VAAAXvWvNbu+973ve97VAAATze7uSSd73taoAAC/N7u+973v79+7QAADxVd73vf3792gAAHnnnnlc3rzXi3NY8tREQ1zdqrvMzTkciAgZMeVdtA4Dl3VUGwACSSSSAAAAASSSRZ4AB8PQDgbAAA8q6uvooKuZlgADqCImZ6573e97ne99ckAAF72881q1973ve9/doAAC963d973ve972qAAAve7vve973ve1qgAAL3u773vf379+rVAAAd1vW7vve9/fv36qAAA7vd33ve/v379WqAAA7vW7vve9753ve1QAAF73d973v79+/VqgAAO73rXve93ve3ckkkkkkkkkEuIruCr2AKn0PygqKfQVFUCRFE/RECT+hUJESaqpV00wB+gtwSRCQZEJEJFZEZESRCQVkWQQJEWRS7lEAA2itSGcFWtCrNQIKtV8Ksvk/fs7w2iuq1oVf6bRWHO73sVdnMRWxVurOReaKD81B1Z+IahIjDVQ3N2gFwNEJECSRkaqkoh1FYhcsiBBjGQZCBCEIn5FbRWjvv3f6ucQJIwkJGM9AJCr3alxGpUhKqiRghqNMIRC6RslUl2sBC4IrUUVlCrKUVhdKff3399pr9X9ua3/enOmiH9LEvdL2q97t/0QBB1AFdXvSYSQJNWoLoiqwVYKBBVgqwFkFUl57O9z7EEDDRTRmZmdzOormAAMAAkFWKrCVmZmZnhVxQCAAEVWZmZShmVmeVXJm8zM3mYKtmKoFGwZV5Q6Luq99993y7qvA578JV3dXdPvNBmZigGQECRVYisCEgqwVYirmZmZmYCq4ikVAYQRWEIjGJEQDFVlVmZmZmDiKwRWCgta1o1ISCSLFVYIkFWAKMBVIKrAVYrEBkiSMIjGBAYhBVYwRUiIEiSZnvd77o+gABAAIqqT3szMzMFA8gBIIA5BVqUCrREVYogyVmZmZmYAqQUVJmZmZmeFVQxgkUVkEACDAEGSRGAKkVBICCEiQgISQWERjAZIQiMAgCMEgqxAUCZmZmZmAGCrBViKxFYIrAiKsEVIAgxXFAioIEEEiCrVZmZmZgABiKyIr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XaQVkO3fe7u7uZmZd+IKkFSCpBUgqQVIKkFSCslb9T77dVd3fPrrtV7vfMmMAAAAAAABYAkkkkgAAAAAAASSSSfAAAAd7x88ySoquffvlVVADvWQVIKkFSCpBUgqQVIKkFSH139973vezPe96whziQVgLtwLtIKkFSCpBUgqQVIdu+93d3czMzec0gqQVIKkFSCpBUgqQVIKyHbvvd3d3MzMu/EFSCpBUgqQVIKwFVqkkD67++973vZmZl0AABe93ckkkklUAABeVXOZmZmSZmb81ry7AA0a3yq5zMzMkkn1WAAD7zXntV7799999JJKoAADOVXOZmZkkky7AA1rWtaNV5u67Ptb7nZn0kwPqu7senh5V3dg4AAAAsASSSSQAAADMzMzMzMAAkkkkgAGUurrUu6rtZvPd6zV/VmZmZmZkkkqgAAM5Vc5mZmSSTPPNauw3vYAG/NecquczMzJJJ9dgAAfe1Xvv33330kkqgAAze9685Vc5mZmSSSqAAAve7uSSSSSqAADPN73rXFVzmZmZkzWZleSG/fWRWXUu7u7qmQFuy7Y0qtM7de+/ffffSST67+1vYAAe737799999JJKoAADOVXOZmZkkkqhprwJyuVzn3kqqqrGVkk/cmc/Z+9VAV6gB6AKq6UqroAAAyszLzMzMw9kkyn1jMzMlNAAA600A6eD0HEmV4Bd1TWTPQPk+gEULtQsNKE+UNTf00ZHcDFC/Ifvz9lfvf3eVJUDqqqAHezlcrnOcnJF5Vc5mZmZJJnnnmrsAADm985mZmSST67AAA5vfOZmZkkkqgAAPuVXOZmZkkkqgAAL3u7kkkkkqgOb2AHMqvfczMzJJM881q7AAA5vfOZmZkkk+uwAAOb3zmZmZJJKoAAD7lVzmZmZJJKoAADN+a15rXrzUea8r37m635Vau+VXd+9hIARVVQAAFUGgCALAEkkkkAAAAAAADve973vQAfHAy/D3ffX0kqfuvc+353xVVADvecA0AXvd3MzMzMzMnnmtXYAAG+VXOZmZkkk+uwAAM817Ve+8zMySSS7AAA+9qvffczMkklUAABe93ckkkkk1rzV2AABzNVXvvuZ+zMzPvdffb815r730AAD8r33f3333ZJPrsAAPt7355rW/a73d3d/ZmZd1XpA27qrVWqqkILa3tf3Of393d3czMy78tVVItVVMgb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VOZmZnf350AAD66rN8zMzJ+73cAAAvet3ckkk73cAAAzXnFVzmZmZn7Ota1rXz74GgAVvXqvffvvvvp+/ZmAAAc3vn3v33332ZO7wAAC97u+973vf37fQAAMzN3+9rzXnnnv7lea9q6que+b53uZgAAAADs1JJJASSSSQAAAAAAAA6BJ3skkABv377L881rffr++v33Wtea19Pvskk739+30AAC97u8815JJJ3u4AAGlt3fe97JO9zzzWssAAHN75zMzO9/fvqgAAHx7Ve+/ffffd/ft9AABMKrWve173e9rckkkmBVUtVX6Ehd1VSXZ7nO92E3d3n6v7+v9rttVVUi2tVVXCF3V7b3u7u/39v79zmqiq1S7d21StVe3fe7u7+/fv370gcrlBBfLaotUrVVVVZvI/c5+/ffffd736S7AAA9795rvOfv333fsyqzMzM81mZggAAAABJJJJAD67qh6AAAAAAEkne96kkABvK+15deazMz3nuZmZJP379+/VQAAHZ7d++55rzMzve97VAAAXvd3+/fv3793vbsAADm93fe9nne973PPNauwAAM+frv9++++/fv0727AAA5vec5JO97+/VQAAF73d55rzve/SSSqAAAzlVzmZmZJJKoAAC97u+973ve97VAAATXKrnJJO973vyh9vckkkkkkkknfQDDz13RnbstSjJn2dNnTwAAAFVdAAAAAAAAAAAAnkkkn0k83WpJOT4eAloZO1yasU+BPnpFDWv0X5Q6bCFk1vb65f3szK+9yTv79++727AAAz2q5z7zXmZne972qB4eD7lVzkkzJJ3ewAAJdVV973ve9/b2AABNXVTkkne972qAAAve7vve973ve1QBo08avNVXOZ5rzMzMkkzzzWqsAAH3tV77mZne97367AAA3yq5yd7+/fv29gAAfZPec9knvvvu9gAAft6l4/aX6K3vXPNft1z9+mZkkkgAAAAAAAAAAAAAAACTYB6AfBoAVVVXXdP3MbuqzmHuH2Z7chM/fv7+/v5aqq/Qguraq1VUyAt/cLvne9/e++/d881rOb5tvewAD3e/ffJ9mfSSb2AAB9q6q5JP379+3sAAD7nnLvn7977777vYAAHbqr+zXnkk73vvaoAAC81VXJJ39+/Seea1dgAAc3vkzzMzve9+5dgAAfa9qvck7+/fv11QAAH3Krne9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ySKq7VV8qSpJAANgquSpd3aqKrkqXd2rwAMlRzMV485xyVNXdgcOc4ZKl3YDXEByql3auzUknOcLqpd3YHAAyVLu7ARVclS7u1UVXJU15ypUqV5qVJJUkut78zF4vKXwAvNalt/AAAC2222gAABY8AAAC2222gAAAAeySTUsknmpNSSfpJNSpUrwAN8FVyVOSSZmYu4iq5NTvOc4fKDk1N73sKDk1N73sKDk1N73sKDk1O6knOc4fKDk1O85zh8oOTU3vewoOTU3vewoOTU/b+7rWpNT95qSa1qTu/3enaCAAAAB09PQHdagBbbbbQAAAAAAAKqqgAAPlVJUkm5JMkk8kqVVQLMNgqXKjd+WqipcqvfW1UVLlVNySXbi7RUuSq3duLtFVyVJd3alByam972FByam972FByam93aqKrkqXd2qiq5KmvEqpVSVfvkkk1Eknmta1qa1NSW3lvegAAAAAW2220AW2220AAAAAAAAAgAAPkqVK5JJqVKlb1VSSVIelhsAcmp2STnOcPlByanec5w+UHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYVVclS7u1UVXJU9CVKlZqVKqrkkJJLe/UULbbbaAAALbbbaALb9JJb7bQAAFttttAAAAAAEkn7U1JAPgHJqd5znD5Qcmpve9iiq5Kl3dqoquSpd3YHAAyVGZmYqIBkqXd2BwAMlS7uwOABkqckkd73u5UdoquSomt73t2iAZKnN+c1epN68yVJJUmczmLxVQAAFVVQALbbbaDckgbttttAAAW2220AAAAFVVXyqqqk9ALznEAyqu7sDgAZKl3dqoquSpySTMzF2iq5KnMzMX5Qcmpve9hQcmpve9hQcmpve9hQcmpve9hQcmpve9hQcmp52ak1Na1NffffcOgA5IGwAACW+zUttt+fT0bCgAAABbbbbQAAAFVVVV3JJ7KlSiSTVVVVJckmqlSpJ4WBviANVLu7VUAZUu7tVQBNTe97Bbampve9hQcmpve9hQcmp2STnOcPlByanZOc5w+UHJqXd2qiq5Kl3dqoquSp5et8qpUrWpNSamtT3u+/unaFttttAAAFttttAAAAAALbba0egAAAAAPJVSSVQAGwVXJU5JJmZi7RVclTuuc5w+UHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYUN6kb3v8FDc1P378Cg5NTe97Cg5NTupEATOXiN4m6LK1ze53zJXYAENoEkm1RTZQ2imyzS2JNqSbUWxLaUVWwltC2gNlW1KbRbSrZBtVLaIkNpNqjapbU2RZrNhgbA2wbBtDbWtlRmRtTbZmDbarYaG02q2h/hZts22zS4ycYqcbjVcccCOI2+KWkvsl/h8kvklvJLcSWkskvslhHjf3Bx7x+442+cahQ+aKlG1Sp8fNtxUfMmxW+mhCzaEK0IWzGa7dbNPSaZFgCSsbNmzZZrWzY+7KW1Q+JBpLJLHHH7riS+1LSWQNJaUr8VcITiUtUsRMktJfA4kuJLFLB6HCSnEE0lrSWksksSWUtJU+yXElxCMySylpLUJkJklgTRNSWqMksylgTSWAOEg4UlwqoyqjJQYkGgmSWpQaVK0lpLSWktVRmktVRkJwpcQpYpZVRwkspcSXElwksGqpWktUtJLJLVSNITiqdhzDsPmDoP4MH8HAch/gHofg7DoO+MHQnOb5zgAAckkDYAAAAAAAHJbf1ttAADmtTvfe973oANySA4H0753ve96AABDskh6AAAW2220AAAAfpJAPgAAAABbbbbQAAAAAAW222+ySUDoAACySPAAAAAAAAAAAW23ySS20KAAAAAAW2220AAAAAABqSAAAAGtTve973vQAAPPO973ve9AAA+J77rU8ttt7QGpIAAAAAAAAW2220ttttoAAAAskjwAAttttoAAvnnnnmvJ5I9AAAALbbbaAAAOySHoAAAAAAAttttoAA/9AAwAAPpJF9tttoAAAAAAAAAAAttttoAAAAAAAAAAAsltttoAAAAAAC2222gAAfSSD8AAALbbbaAAAAAAAAAAALbbbaAAAAAAAtSSAOgAAAAAAAAAAHZJOySdkk7JJ2ak/g38H2Kp9kvjSXECaS1VH9ir44DRD6GFdh97D52HYdfwfA66DpS4ktJaS0lqS0lpLSWVLSWpUfpLEl+DgPil9DVHIPwfXUVH1Jaqo4SD4HHcl+KkCSAJAGhJJEtAhIFrnOTy96z+FttttAAAFttttAAAC6jwAAttttoAAAAAB7JNamp2STya1UfwfwcKCeUJ/7FLSWksBNVRirJLVLUrEJqqNKpqqMkvOuuvPP39Xnnvnnnnv4oGyTMzbNrapf0wbYzjQJtQqrSWgoaS1IKaSyVTrrrr333+j3z3zzzz+USjraMqFXqS1CYUsQmSWQmSWaSxQaS6666999/Xvnvnnnn8kvUlpL+TSS4gmVRNJZJaS1U6666999/nvnvnnnn9RB1obYwe8ca0VHFVGpLKWqo666699998977778VVHtVGktJf1wG2WCo4qoxUqaSylmUpMktUtJLVUZRNCRdddde++++e9999+VIXWDbDJL2S0h111177775733335IdbVg22oI555588887877778qo6sG2WpVPZLUJpLVCraEjVUZpI1JaSyqjSWqo0liQ666699998977778VQdLBsayoo9ksUHXXXXvvvvnvfffflEHslqqNJZJf2DbhwOIg+ffOvClzklxpKlSVPJJOySd7nD5TqoAACqqgFttAAAALbfZJLbadAAttttoAAAADvvvvvvvsPhJchig8VKewGQi0lgrJLSSGktJaS1IPffff739/T333zzzz+KA9ktSl/JqRHfyS4qS0lgFNilpLJFlLUUlpLSFNJZKr+/v7+99989/fv37sFXSZSqeSWKWksqWksUtUsqo0lpLrrrrzz33z3vvvvygjpNShc888+eeed+d999+El0mCl7JZklogyS0lklmqoxS0KyS0lqqMpYKS0lqqVpLEkOuuuvfff575xJe+eeecxJepLRKfyYoVwkspSaSwkskskllLUlpLAaSyliSyS0loVNJYE1IMlOuuuvfff6e+e+eeefyS9mqlGKv5OEpI4SWUspZQmiDRBogwE1FZUtJaS0lqS0llSuuuuvefd7r3z3zzzz+VUj2S0E0lqqV/JopS4SWpBpLUKnXXXXvvvvnvfffflVHSYqD1VRpJaS2SWktJdddde++++e9999+yXqllLJL+TgkuKqMktJZS0VpLW0liSyl111177775733337EXSdecfu81UqVx15JUklSskk5bi9OqoAACgW2220AAAAAAAAAAAAAttttoA91qSTUmakk1P7U1NeZmZmXM/jvvykuk1JU5555888/p5355555/VRTpNRS9SWpLSXXXXXvvvvnvffffKl3dqoquST6pUr6pUrMz7775++VyVL6kueefPPPO/PO+++U9kvZLBzzz7777376OTUzU1NSTe95mZcwcmpub3sKDkqe++qvFVyqnKqSqqZqSVKlb83va8VVttttAAAAAAAAAAAAAAAVVUAABVVUkk9kqVKADAVu8C4ANiaaAqq5znN85d3g4ANtDAmtTWru+rxQMlMkmtfeV9ve/vvuffAZ9JJrWpJd29rved6rkqF3avFAyVLeySb3vverznLlQ7ve9qvOc5cqe++87A4quSpd3aqKrkqXyVJKlSVN+b3teKqABbQAAAAACTgbACx4BbbbbS6mpp4AAAAAAB7qTU1Nbkk81qTUqrAN7BAMlTskmZmKiAZKjmZj2Su9equSoVmZiogGSpd3YqKrkqGZmKiAZKnZJM5JJve3vdvVXJU7x5znO949AMlRzMxUQDJUu7sVFVyqSVKkqT3UqSqqpVZOc85m3iqgABQAAAAACAAC6jwC2222gAAAAAAB7NTU1qdkk8k1Na1PpJPJKqsLMNggGSp2STMzHFFVyVDs3ve+969AMlS7uwOABlTtVJNalSTWpUk1qVJNaqSazMxXiAZKl3dgcADJUSSc5zjMxgckzUk8mvOc5zMzGByam7u1UVXJUu7tVFVyVPfOSSqlSbmgEkkGmJIBJHACACJN53rnNb5d3dgAAAAAB09hbbbbQLpZJPXoW2220AAAAAAAEkn7WpNSak/a7JJ7qampJo/D7oHJqZJJznOZmYwOTUznOczMxgcmpve9hQcmpve9hQcmpve9hQcmpkknOc5mZjA5NTOc5zMzGByam972FB5JJyanm9+7d99/u+++++U86/vn7rSiPuKtipQ1u7mdAAAAAAAAC2222gAFtttaPQAAAAAAB7rWtakttt+tByamSSc5zmZmMDk1M5znMzMYHJqb3vYUHkknNTJJPPJ5J7znvMzMvVXskm9feVJve9/fffHyrkqfSSZmZ3vevQ5qTOc5zMzGByam972FB5JJyamrvy1UVXJU5UlVUlTUkm973tRVVAAAAAAAFttttAALbbbaAAAAAAAHutTUklttv1oOTUySTnOczMxgcmpnOc5mZjA5NTe97Cg8kk5NTze/dhQcmpve9hQcmpkknOc5mZjA5NTOc5zMzGByam972KKrqSTJU1d+Wqiq5JXKkqqqq3ve/joAAAAAAAAbtt3baAAW2220AAAAAAALJJ+1NSckk1JUlTwDDYIFyo9kk1mZ3vevQLlTuc5zMzGW3c1G97Cmh5JJyanm9+7Crbuaje9hVt3NTJJM5zmZmMDk1M5znMzMYHJqb3vYUHsknsknJqe+798tVFVyVLfOa1oOc925ol2zy+XyGannutVnBQ9zuLe96LnFa25vFiSFIhCYkIspaqlfdJcNVRpLJBql+4Fc4E+VLSWktJfpJiSFijM6zh08TM7Mg9VKEKMCELBIku3Cl18KXD/K/x/vv73ycKX8ktVRpL6kvnwE+KWkuL4hOJLIkcapLfJLPklmqXxJaSvPlxBMxS+SlhS4WKXBS4rgktaS4qo0lxaQ8kk/u739z+v8AALbbbaAAAAAAC2222gABbbbbQAA9tt39873vQAAW2220AALbbbaAAAAAAAAAAAttttoAAAAAALbbbaAAAAAAAH0kg/AAAAAAALbbbaAAFttttAAAAAAAAAAAAAAAC/fffffOgAAve973vVAAB2ahPQAAAAAAAAAAAALbbbaAAAAAAAAAAAa7qePbbbbQAttttoAAALbbbaAAAAAD6D8FttttAAH+QAMAAAAAAAW2220AAAAAABbbbbQAAAAOSSBsAAfD8AALbbbaAAAAAAAAAAALy2/rbQAAAAAAFttttAAAAAAAW36SS322gAAAAAAAAAAC2222gAAAAADvvvvg+qXMliS0lkLgPgcJL+kv0l9dhwHyS/BpL6H4P4Pkl8D+SX6qjg4/pLT3Xmtampr7686vQAAAAAAAAttttoAAAAAAC2222gAA9kv4MpdB/iq/xVEpec+c+efvPPe++750MTGjTbYDEgznOeuuur6u7vAjmMYxzMxgckm972FB5JJyanm9+7Cg5NTe97Cg5NTJJOc5zMzGByamc5zmZmMDk1N73t7BR15JJyank3v3YCq5KmveSpUq9VJJJU53Ukgb3zvU6qMkkzMzMzMwAAAAAzMyTWZmZmAF1HgeySAOgAAAttttoAAPYkk81Nak1qAfAOTUySTnOczMxgcmpnOc5mZjA5NTe97Cg5NTe97Cg5NZJJ555rnOczMy4HJqZqSc5zmZmMDNfTU85znMzMYHJqb3vYUHJqb3vZd7u7u8COZ1umhIAppJClMSFUQIRJPb3uZ91biAAAAAAAAAAF73ve96oAAAAAAAAfSSW+0AFVyVPvpJN73v7777vyrkqd+o5znPvvu/AGSpd3YCKrkqXd2qiq5Kl3dqoquSp9KqvtVKmtVUm973999935Vz76VJ5Umt7re/vvvn5VyVPb1V2qiq5K7PtVJPKze9/fffHwrkk9k90b3e3FQVVVUABbbbbQAAAALbbbaAAAAAAAABe973751byajOeSSfe61PfvszHqhkqeuqzMVHgGSpfvodp4iuSpfvqmzgGSpd3YHAAyVOySZmYvevVXJ9NST7e97++++flXJUu7tVFVyVLu7RQcmp2ampq9nfvnF71baAAAttttoABu23dtoFttttAAAAAAAAA3JJbbu20HJqZJJznOZmYwOTUznOczMxgcmpve9hQckmT+81PfJNk6666999979777758TZNk2TZNk2TZNk2TnnnnzzzzvzvvvvnxNk2TZNk2TZNk2TZLnnnnzzzzvzvvvvnxNk2vdcZNk2TZNk2TanXXXXvvvvfvffffPibJsmybJsmybJsmyc888+eeed+d/v33xNk2TZNk2TZNp7rjJsnvW669999797/fvvibJsmybJsmybJsmydz9U1Nd73vB3uW2gAALbbbaAAW2220C222tHoAAAAAAAALJJ2SD3G973vd3vdcENiGxDYhsQ2IbEPJsmyfcHnPPnnnnfnn7998TZNq3tuE2TZNk2TanPvXXvvvvfvffffPibJsmybJsmybJsmyc888+eeed+d9998+JsmybJsmybJsmwOmJNxEDYk22POc5666651d3eOLpKGIeTZNk2TZNk2TZOuufffff3v7973z4mxNk2TZNk2TZNk+c8Q558888787/ed8+JsmybJbU2vWlEKG2xkRA22xxBDGxuIhsbbbznHXvvvfv7973z57mbMG44uNcZNk2TZNk2TZNk6659999/e/v3vfPibJsmybJsmybJsmyc888+eeed+d9998+JsmyfynGuE1OOE2TavdmHGTjfIfOE4ccJz/fu0lsHIdeZJN8zuf3e224GZmZgAC2222iAAAgB2SRV73ve9AAAeSSL4gAfSSD8AAAAAEkn0kg/ABzJqeeTU88mp3Uk99ThxwmybJsmybJ11wHXXnnnffnnnffPibJsmybJsmybJsmaRjGMc5zl8u7vHBDYhtLoYiIhJNhDTZNk2TZNk6666999979777758TZNk2TZNk2TZNk2TnnnnzzzzvzvvvvnxNk2TZNk2TZNk2G94HXXXXvvvvnvffffPibJsmybJsmybJsmyc88Bzz5555355533z4mybJsmybJsmybJtTnnnnzzzzvzvvvvnxNk2TZNj3HGTZNk2TZOuuuvfffe/e++++fE2TZNk2TZNk2TZNk5555888878777758TZNk2TZNk2TZNk2jr5/d99MSXnkk1rzyScFyltttNAAAFVVVAAAQAAFVQAAFVAAAAAAAAfAG9xve973d3d46DoUMQ2IbENiGxGybJsmydddfA6999979888758TZNk2TZNk2TZNk2pzzzz5555353333z4mybJsmybL3jhNk2TZOuuuvfffe/e++++fE2TZNk2TZNk2TZNk5555888878777758TZNk2TZNk2TZNk2Tlzzz55553533338DnxNnuXGTZNk2TZNk2TZPjrr4HXvvvvfvnnnfPibJsmybJsmybJsm1OeeefPPPO/O++++fE2TZNk2TZNo3vA4yW1Ouuuvfffe/e++++fEtqbJsmybJsltTZNk5558888/efv37znxNk2TZNk2S2qqa1KmtSprUqeekAM33vOgAC0qqgAAAttttoAAAAAAAW2220AAqqqqBznOcQHOyprUqVrUn2q81KmtJsmyW1Nk2Trrrr6HvvvvfvnnnnwOfE2TZNibE1qrhzzz5555353333z4mybJsmybJsmyb3gcZOuuuvfffe/e++++fE2TZNk2TZNk2TZNk5555888878777758TZNk2TZNk2TZNk2TnnnnzzzzvzvvvvnxGxDYhtJ9IgiIQbmBERAiElECIUQI1rWqAOuurvrnOcxwQ2IbENiGxDabJsmybU5555888878777758TZNk2TZNk2TZNk2Tnnnnzzz93+/fv3Pd6xbOOOBxk2TZNk2TZNhDYjrWta666vre97xwQ2IbENiGxDZU1qVNalTWpU1qVO9ADO8QADoAAAAAAttttpOBsAAAAAAW2220AAqqqrySTJJDwLDiAZ2VNalTWpU2TZNk2nrFxxxXGTZOuuuvOQ88/ed9998/k2TZNk2TZNk2TZNqc888999+9+d9998+JsmybJsmybJsmybJzzzz5555353333z4mybVveI4ybJsmybJsnXXXXvvvvfvffffPibJsmybJsmybJsmyc888+eeed+d9998+JsmybJsmybJsm091xk666695D333v3zzzzntNk2TZNk2TZNk2TanPPPPnnnnfnffffPibJsmybJsmybJsmyc4xjnOcvl3d44IbENiGxDfQQ4ENtpcZxk22bONTjYxxk2Trrrr3333v3vvvvnxNk2TZNk2TZNk2TYRXNbDdZh8eFEXnmhoQmhCphCEJpVHXzikupLSW+yXzSXyqjSWktJfZLgkvqS0l964vslzJcyXX918/uPv3nzn9EOJL5JZJcIv0l8kuFLJLSX1P1Er6H4OCJw5kuCotVRxVK3KqV7VVU841KntX55ic4qqqqqgW22gAAAAAAttttoAAWS2220AAPffQAAAttttoAAe61LbbfrQAAAAAAW2220AAAAAAAAAAAAAAAAAAALbbbaAAAAAADve973vQAAW2220AAAAAAAAAAAAAAAN91qfe/fffFAAD7777774AAATt8tttoAAAAAAAAAAAttttoAAAAAAAAAABPfFktt7bQAAAAAAFttttAAAAAAAW2220AAW2220AAAAAAAttttogAAAAAAW2220AAAAAAAAAAAW2220AAAAAAAAABuSQHCyW222gAAAAAALbbbaAAAAAAAttttoAAAAAAAAAAAttttoAAAAA77777777776cIrqktaQ6DkOJLuSyS+Elkl9DsOw/g+ySeySSp7UqV5KlStSSckwN5ziAADbbbbQAAAABAFttttABbbbbQAAAAAAfwOf0kk1PPJrXnmp55Nai2VNkm1FbUltKWwTZTZQbSJtSTa2G0VtQ2S2Stq2jYG0tlstmwbVJtW1LZVsq2VbbKbE2GxsmxbUtapsRsbUra2UbWyLZNkFtVsBtEbRtRmK2JbBbK2RNotrattpNqNmxbQ2hspbG0NibRMwjZZtjaTa2lTatqm0m0GzaU22G0jZsLam1Wxsq2W1Fshs2iWyGYNotomwm0lsSbU2ktqTaFtU2I2DbYpmRtG0NrZbI2S2mwbUsxWzaTbZS2ktqWyWwTYDYWzaFtJspbWsRbJNqtYbNpUZraNhLYo2htNjZW1bbBbUbIbKNqbRarIbVDakbbUG1S2rZG1U2tqNhbCbTalNojak2SbUWzaTYq2UGzaNobGYS2hNsylsLaVW0q2RtUm0NlDaTaqbRLZRbANoNijagbNiDStVLalbUjK0rVYLYG1EbBarRGwFqtK0pqiNVkjVZUm1SNVqVpWpW1WVhUZWlarJGlagYaltVtIbSNgZirVZKzVaVaVqtJG1UtoBqs0pqtGq1aVarJGqytVlWq1JG1LVapGDVarVZVlTVZBarSmqwobbbKJgypqsUYNKYNKsU0rKsSNVqUzbUlbMzWUpqtKsGKtVoYNVgyrI1WqtVNVlWq1Wq0rK1WKwlqtK1WUTNSlarBqtUo1WVaVpTFarVZWq0rVYgytKZWVqsq1WSmq0rKsRtANlU1WpWVmq0q1WlWq1KMrKlqsimVimqyrVZWqyrSsrVYrKyE1WVZWKtVlZWFWVqjZJWy22sxZqGq0kbKmyS2SjBqRmqprUjK1WalarVJqtRGq1WVqpqtUysKtVlarEjKsq1WimqyDZrZkqtq222bJJlaq1WqmqxKNVipZWlarSE1WVarFarQTVarVaVirStVpTFMU1WqysRNVlWqxTVarVaVlarBhrbTYpWyMttmNs2m01ttaNMtK1WlWqytkBqsolqsqLVZVlaINVpRarKsrStVqtVlWVarStK1WkGKalarVaVqVlaJarVaVlWq0rKxVqslarVbbRtmzRtrbAbRJtsGxts2xma2tbMbRprLYzbZtZrZZbbUbbbVsbZsqarQLYgtVqKrVaFNVpKNVlWysq1K1WSmqxTVZIytK1WlS1WVZWpNVpWqwbJTVYppWVaVlarFMrVarKsrVZVqTVZU222rNtjbZttM1m2ZmWxtQZhVtJbQ22GzZbbbJZqbRtbGzatpsMxtVs2rbZNmahtK2DZI1WimqysM2BqsiQytJBqtFEyrSmq0iMrSmQtUW2y2Q2bbbbW1sXnnnnvvvvvfWTZNk2TZNk2TZNk2VHmoLaottotlNoUbVU2irVaFIytVqtIhqtAWqyFNVhTVakmVZVlWqbKmxOuuuvfeg998988885/JsmybXuba444ybZjbjXGuMmybJtTrrrr3333v3vvvvnxNk2TZNk2ptS2TZNk5555888878777758TZNk2TZNk2TYhsQ2IxjGOc5y+Xe64IbDpsYoghIbNbjFbjim04ybJsmybJ711x177773733+++JsmybJsmybJsjYhsRoAxjmec0Aa5fOc5zGxDYhsQ8mybJsmybJtT8uuuuvPOvO/O++++fJ7uMmybJsmybJsmybJ111177773733334nWVbJsmybJsmyc888+eeed+d9998+JsmybJsmybRveI4ybJ/fngbwOQ4D75555/O3zWpbfwNhbbQAAAAPBAVbbbbQAWpJAHQAAySTMzMzMzAAAHffffffffffffffPibJsmybJsmybJsmyc888+eefwed+eeeec/ybJsmybJsmybJsm1Pwddddeeded+d9998+JsmybemuMmybJsmwhsReta111nq+ru7xwQ2IbENiGxDabJsmybJzzzz5555353333z4mybJsmybJsmybJtXPPPPnnnnfnffffPvscZNk2TZNk2TZNk2Trrrr333+D3v3zzzzn+TZNk2TZNk2TZNk2pzzzz5555353333z4mybJsmybJt7q4ybJsnYf39/f3vvXvfvffffPibJsmybJsmybJsmyfnXXXXnnXnfnffffPibJsmybJsjYhsQ2IbEaeo3eCqWEkGwCbi75e1ttty2222gAAAAtsAAQAD76TvfvvvvvvvuzveqqgdVVzMzMzMzMzMzMzMwAttuSWSTydkk4AQlN1V3d3y7u8cENiGxdOGIbENpsmybJsnXXXXvvvv4O/fPPPOek2TZNk2TZNk2TZNqc888+eeed+d9998+JsmybJsmybJsm0b3iuuuuvffffPe++++fE2TZNk2TZNk2TZNk5555888878777758TZNk2TZNk2TZNk2TnnnnzzzzvzvvvvnxNk2TZNk2vdOMmybJslgGta1zHNAG+Xd3jIhsQ2IbENiGxDYhsQ2IbSNnWta1zPL5ve944IbEPJsmybJsmybJsnPPPPfff7v9+/fue02G94jjJsmybJsmybJ1111555+8/fv37ntNk2TZNk2TZTWpU1qVNalTz28ub1hyVLzfN/d6AACAAAqqqqgAAKqgQABAC1o9AC2222gAAAAAttqSTJBsMttzJqeeTU88k2TZNk2TZNvdOMnYf39/f3vvXv4Pe+++/Ok2TZNk2TZNk2TZNqfuuuuvPOvPP379+88TZNk2TZNk2TZNk2TJzzzz55555+/fv3kp7pLnnnnzzzzz9+/fvfE2TZNibJsmybJsnPPPPnnnnn79+/eeJsmybJsmybJsmybJzzzz5555+DzvvvvzpN7xXGTZNk2TZNk2TanXXXXvvvvv79+/eeJsmybJsmybJsmybJzzzz55555+/fv3nibJsmybJsmybXuuMmydddde++++/v37954mybJsmybJsmybJsnGkuevfnHz+/t/fd6AAfAAAKqqqoAACqrRtA4W2220AFttttAAAAABbbdySZLbnAzvvvvnxNk2TZNk2TZNk2TMRhAYxjlc5y+Yu7xwQ2IbENpdOGIeTZNk2TZOnXXXvvvvfvgeeeedcpsmybJsmybJsmybU5555888878777758TZNk2TZNk2TZNhDaDGMY5znOb3vfOLpohiGxDYhsQ2mybJsmybrrrr333339+/fu/E2TZNk2TZNk2TZNk5hzzz5555353333z4mybJsmybJtPdxk2pbJ0666999979777758TZNk2TZNk2TZNk2TnnnnzzzzvzwPPPPOuaWybJsmybJsmybJtTnnnnzzzzvzvvvvnxNk2je8Rxk2TZNk2VNalT43JJ3fq48+++AAOqqqqqqqqAAAqqBAAEAA+Xve973vRbbbbQAAAAAW3e6ANa1db3vd3d3jghsQ2IbENiGxNk2TZNk5hzzz5555353333z4mybJsmybJsmybJse66ddde++++e99998+JsmybJsmybJsmybJzzzz55553534HnnnX1Nk2TZNk2TZNk2TanPPPPnnnnfnffffPibJsmybJtW94jjJsmydddde+++9+99998+JsmybJsmybJsmybJzDnnnzzzzvzvvvvnxNk2TZNk2TZNk2TZOXPPPnnnnfnffffPibJt7q4ybJsmybJsmydddde+++9+999/fE2TZNk2TZNk2TZNk8555+eeeed+d9+B5zwmybJsmybJmIbENi6cNI5VvccQDANcAK5zXV3r+tttuAAAAttttoFtlttoAAAW221JJfLbbaAAAADP7+/v7+3JJ/SSZJJ/e8e+++++++d99/fU2TZNk2TYmxDTEUgKrnOc5fLu+AjDENiGxGSIE2TZNk2Tny3XXzzzzvvzvvv74mybJsm0b3iuMmybJsnPPPvvvvvfvfff3xNk2TZNk2TZNk2TZKquc5zl8u7rghsQ2IbENiGxDYhsQ2IbEVVc5znL5d3XBDa6aIYhsQ2mybJsmybJzDnn33333v3vvwPOeE2TZNk2TZNk2TZNqUVXOc5y+Xd1wQ2IbENiGxDYhsQ8N7xHGTnnn33333v3vvv74mybJsmwhsQ2IbENiGxFVXOc5y+Xd1wQ2JsmybJsmybJsmyc/f7+/c9dftfT33tzGLbbaAAABbbbbQLbLbbQAAAtttvVtttAAAAAH0kl1JLG973vd3d1wQ2IbSE2Ib6aIYhsQ2m1LZOem6699999877778DnJsmyNiGxDYhsQ2IbENpFVXOc5y+Xd1xNk2TZNk2TZNk2TZPv37555553533398nuuMmybJsmybJsmybJ1111777775333398TZNk2TZNk2TZNk2T6HO558888887777++JsmybJsmybJveK4ybJz1uuvfffffO+++/A5ybJsmybJsmybJsm1OeeefPPPPPO+++/vibJsmybJsmybJsmyc888+eeeeed999/fE2TZNr3XGTZNk2TZNk66669999987777++JsmybJsmybJsm8mp55NT3k5z9mYW223AAAAW2220BC2222gZMzMzMzMFttttAAAAAAByH4O9339777777777++JsmybJsmybJsmybV7uet1177777733334HOTZNk2TZNk2TZNk2pzzzz555555333398TZNk2TZNk2TZNk2Tnnnnzzzzzzvvvv74mybJsmybak8815rnOczMzAbmpve9gBuam972AGSSbkk5NTz3ze8zMxcN61+3vYArcqXckl2qqq3Knrkn33l85v77775UAAAALbbbaHQtt722gZmZmZmZgttttoAAAAAALJJ/eZmZmZmUbmpv9+BaP6STk1PNznOZmZmUbmpv9+BaNzU3uSTewA3mpJ5qTc5zmZmYo3Kl++qqCvZJMlTVzMzve970VuVL99VUQ9lRvV2qqh7Kns3b5FfDDPd8qhHGkuJLiS3Pyqj5og+SWERlLSXMlpLtJfOp1w2qzShIQtVOEITxGtayGc4kAKEkkGkun5Ug4kspL8pYqpwaSWktKDVUaSylqpBlLVVGktJaSwoPuEAiEITEISJGCAQbvRsxetazre9220AttttoAAttttoAA73ve970AAAAAABv773ya1fvvm17QAAttttoAAfrbby2gAAAAAAttttoAAAAAAAAAAAAAAAPZJAHQABbbbbQAAAAAAe973ved6AAAAAAA5bf1ttAAAAAAAttttoAAfpqc57znAAAB5Lbbb2gAA1DQAAABbbbbQAAAAAAFttttAAAAAAAAAAAWffP13u220AAAAAAAAAAAW2220AAAAAAD/FtttuYAAAAAABbbbbRdTU08AAAAAAAttttoAFttttAAAAAAAW2220AAAAAAAAAAAW2220AAAAAAAAAAAW2220AAAAAABbbbbQAAAAAAFttttAAAAAAAc1NTXNTU15KWUtJfA7Diqj6HAcSX1JaSyS0lpLSWkv1UmD+D8H0Pv4P7iS/ByHIfQ+kfyS+KWSZVRqqjp5/TuSSedz9S5g6egAAALbbbaLe9+++d6tAAAAAAAAALbbbaG5JHkf4abbMzG2TY2ZplrNtLbMtjNMxtI1pmKy9888688889/fvJ6ChslTW21lZja2BELDRMR1nPXXXXXW1y74AYEPGMY5znOc3vf6aje9gW39NRvewA3NTe97ADc1N73sAMkk5NTznOczMzMDc1N73sANzU3vewA3NTdn6e6h7qJJPpJPakkWj4AAAAAtttto3b3999871aAAAAAAAAAW2220EkmaknmZmZmZgbmpve9gBkknJqec5zmZmZgbmpve9gBvUm972JAG5qb3vYgDc1OzPvvvszMy21JJyamuze9773vegFypd3YAAFypd3YAAXc1N53u/033vTMzAAAAAFttttFtt91qd71b9aAAAAAG5JAcAAC220BV3JIr6oABcqXd2DJSqr2STk1PL9999mfZmBuam972AG5qd5znBUAuVLu7AAAuVGZmYqoB2STJU1mZiqgFypd3YdVVblS7u1Yq3d0I1qZjiELpCE0IWACECU73vfXW9ffKqqqoAACqqgAAKhzm9/O9WgAAAAAAAAFttttD+1NTWrJJme5mZMzA3NTvOc4fQBkknJqeX7777M+mZgbmp3nOcPoA3NTvOc4fQBuanec5w+gDc1O85zh9AGSScmp5fvvvsz6Znar3NPgAH3e97qrnOczAAO/Na154Hda+/fv3ve1znOZgAAP6vn9qamvrL9+5ncYAAttttoBbbbbRbbbbQAP7MzMzMzBbbbbVttttAAAAAskn2ta1l/VlVznOZrPj4AC+fNb3vdVc5znda1rewAAPN73uquc5zMAAAzMznOc5znOZgAAGazM5ztXOc99AAAszKqqrMAAAzMyqqq7rWtb2AAB5ve9973ve1WYAABmZlVVVmAAAZmZVVVZgABtt973Hgi9ktJJHeJK4qThf7+f38AAAAAttttot73ve9WgAABbbbbQAAAAAAf01/a8mpqa+mtaa18181rX79+/ft/v379VZgAAGZmVVVXda1rewAAPN73vve972qzAAAMzMqqqswAADMzKqqrMAAAzMyqqqzAAAPNa1rMz+qquc7rWtZgAAH9/fv319z9+/fv365z30AAD2zKqrnPfQAAPbMqquc99222222222/vPWtaK0E2IjVVUrVVKokkuSQ+X5++kkdK3JIquAAAAAAW2220AAAAAAAAAAAAEkmSSfSSea1JNT3MzPu972qzAAAMzMqqqu61rW9gAAefvv379/fv379+qsw0fADMzKqqrMAAAzMyqqqzAAAMzMqqqswAADMzKqqr9rWtb2ANaHn779+/f379+/fqrMAAAzMyqqa1rVWegAAazMyqqqzAAAM3+9c3/amprnmpqa9+H8/u/38AAAAAttttot73ve9WgAAAAAAAAAACq791rWu97/d73ve1WYAABmZlVVV+1rWt7AAA8/ffv37+/fv379VZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVX7Wta3sAADz99+/fv79+/fv1VmAAAZmZVVVZgAAGZmVVVWYAAB57rvzXzXxr85zzm/3799/fqqqqgAAFttttFve973q0AAAAAABqSAFttttAAyZmZmZmYP0kjnvnnnnnnnngA1mZlVVV3Wta3sAADz99+/fv79+/fv1VmAAAZmZVVVZgH75rWvPAA3ve+972qrMAAAzMyqqqzAAAMzMqqqu61rW9gAAefvv3f79+/d7zn6zANAB/ZmVVc5WYAABme1XOc5WYAABr98181883ve+973nQAAAAFttttFttttAAAAAAAAAttttoAGa1qa5JJmGwtyzAAAMzMqqqu61rW9gAAefvv379/fv379+qswAAGZmVXKqzAAAMzMqqqswAADMzKqqrMAAAzMyrnOc5z9rWtb2AAB5379+/e973vOc5mAAAZmZznOc5znMwAADMzOc5znOc5mAAAfeOb5n9z+z+/vvX3+47dZJZJaS0l9kuJLiDSWUtJaS+SXEE4SWkLCgbNOUIU3jVZzjEFwhCwhClCFFnL79SXSlxSWKmZS0lqqNJU1JfFLhSXEl8DhVRwlU4qo0lxxVRxJcRBpLVUZS0lTKXFJZJYQmkuCS5knEl8kvilpIOJLKlT+1VUcSWqJ8xJcQTHEllLhJcJJlLiSySxJcSXFVHClpLAmFLAZJaku3EqcfFLVKmoqcSWpLKXHCS0lxScIlxJaqjiS0lwku5L4Sp8ktUtBPlJfJLhTWp2SRJJ95P0/d39v77oAALbbbaAALbbbaAAO973ve9AABbbbbQLbfbba59b3veu97QAAttttoAAAAAAAAAAAAAAAAAAAW2220AAAAAAFttttAAC2222gAAAAAA73ve970AAFttttAAC2222gAAAAAAW2220AAL2d73veqAAD7777774AABLLbbbQAALbbbaAAAAAAAttttoAAAAAAAAAAC6nXvttttoAAAAAAAAAAAsltttoAAAAAAH+LbbbcwAAAAAAC2222gAAAAAAAAAAC2222gAAAAAALbbbaAAAAW2220AAAAAW2220AAAAAAAAAAAWS2220AAAAAABbbbbQAAAAAAFttttAAAAAAAcmpqXCK5pS34Og/Bg+1Q/B0HBBZJdyX8GpLqqj+kvkl0H1JdB+D+7DpFcfSrFP4PjgktSWQT5xz1z+/f39332AAAAAAAt73ve9WgAAAAAAAC2222gAf0+kkzMzeZmYHOeAAAzMyqqqzAAAMzMqqqswAADMzKqqruta1vYAAHm9733ve97VZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVXda1rewAAPN73vve972qzAAALuvmvmvlrWtf2pIkkC5e4P0kgHwAAAAAGtQtcDZ0AAAAAAAAttttoFVXe61rTWtad73ve972qzAAAMzKrnOc5ZgAAHmZlVXOXvoGj401ZnmVVVzuta17r5g0eZnd973ve1WYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVd1rWt7fHx8Aed87vdeTYZ3rC2222gAAAAAttttoABbbbbQAAAAAAAFkk7rWtXl/VVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVd1rWt7AAA83ve+973varMAAAzMyqqqzAB3x81rXngG9733ve1VZh35rWvPAADe9773vaqswAADz31b8/vfaqrnOc5znOVVVVQAAC3ve971aAAW2220AAADkkgbAAVVVVVVVZgAAGZmVVVWYAABmZlVVV3Wta3sAADze97qrnOczAAAO7znN3d3ve94xkAhw4httuACIiIbbznOd73ve973jGQCIiIbbbgAiIiG285zne973ve94xkAiIiG224AIiIhtu1rWtXd3e973kAzmIhttuACIiIbbbznOd73ve973kAzmIhttttsbYA3nOc73vW973vgBnIxmpJNampqamtea7znOX3veqgAAKqqoAAAW973verQBmZmZmZmAAAAAAAAqqvda1r61rWq/r3nOc5znPc0AADMzOc5znOc5mAAAZmZznOc5znMwAADMzOc5znOc5mAAAZmZznOc5znO61rW9gAAed+/fv3ve97znOZgAD5mZlVyqswAADMzOc5znOc5mAAAXzW973VXOc5mAAAZmZznOc5znMwABrWtaJk3re3FVAAAVVQAAFVAALbbbaAAAAAAAW2220AABySSq9qqqzAAAMzMqqqswAADMzKrnOc53Wta7sAADzze9773ve85zlgAAGZmVVVWYAAB7rMyqrnOe+gAAe2ZVVVZgAAGZmVVVWYAABmZlVVV3Wta3sAADze9773ve9qswAAGmea8kk3JJySTXOc2vFX0AuSQ0AqLbbbaAAFttttAAAAAAAC2222gAACSTJJEknue5mZmYHOeeeeeeeAAzMyqqqzAAAMzMqqqswAADMzKqqrMN61rXnnnngAG973mta1Ve1V3Wta3sAAB5ve9973t2qzDRppp8PgzMyqqr3XoaaaaaaFmZ/VVVe+hpoGmh777VVVf3uhpoaaGnvvtVcqr5mBpoaaaaZvv9/e77/a8+eec/XeZlFttttAttttoAAW2220AAAAAAALbbbaAAAfSSD8Ar+90NNA0+a1o0999qqqu61rWZpprQB5rMzve973tVmNAO/Na154Bve9973tVWYAABmZlVVVmAAAf4Gt73vvd973ve97mAAAZmZ3tVVZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAHn98/fNfNfPSS0lklpLSXtX79z199999977/W222gW2220AAAAAAAD+zMzMzMwAAttttoAADskn9qamr5NTU0/fgrtV+1rWt7AAA83ve+973varMAAAzMyqqqzAAAMzMqqqswAADMzLnOc5znMwAAC3ve6q5znO61rW9gAAeb3vd3ve9qswAADMzKqqrMAAAzMyqqqzAAAMzMqqqswAACz9818lfVKley/JVSvDAv7777qgAAKqqqAAALbbbaAAAAAAAFttttPZJAHaqqv7Wta5znOZznKq7rWtb2AAB5ve9973ve1WYAABmZlVVVmAAAPmvmszMrdeSq9+YAAA+fNZmZVcqrMAAA781rW9733ve97Vd1rWt7APPmta88AOBBnOc85znOXd3jDbbbfEBENsGwbBwgM5znnOc5y7u8BhjY2NDbbQGMYxd1yqswHx8fA1mZlVyqswANttts2Rh7xURe9XThiliQhLTEhZRL9xJfElvrGtG2207xxJapdfOFFufnyPv9JfOHyDaS/pLJLq433+5qo5kuw0ih9DRVH9UfUJ2HgdyXxUcgnAZJcvnCiplLQTaSylhJ5xSuFS+yWKQ/uw+Bg4D6DkPAwMH8HYeSSJJEkj2SR5PdST2ST7777774AAAAAAAAAADkkh73ve970AAFttttAADUkfrz3nOPgAAFttttG5JAcAAAAAAAALbbbaAAAAAH6SQD4AttttoAAAAAALbbbaAAHsklttv3skloOgAAAAAttttoAALbbbaAAFt8kktttKAAttttoAAAAAAHv3332/vgAA1JBfbbbfqAAB2d73ve9AAAW2220AAA7JIegGpIAAAAAAW2220AAAAAAEuvz22363skl8AAAAAAAAAAAFttttAAAdkkPQAAD/AAwAALbbbaAAAAAAAtttSSD8AAAAAABdySW27toAAAAAAAAAAAttttoAAAAAAC2222gAAAAAAAABbbbbVttttAAAB+kkA+AAAAAAFttttAAAAAD6D8DySS2229oAAOySdkk3JJ0P4P4PgcUkv4P4Ow7DsHYch0JLoMBP4OpL4H9IfaPik/Bg+SX4P4P7SXVJTKWpB3JaqjgV7Jqamv0knmtamprU9dtztzBAAAAAAAW2220AW2220AAAAAAAAA3JJuSTNa1rU0H3wwMmprWtb2AAB58/wNNfNa+/fv39+/fv36qzAAAMzMqqqswAAB8x8x8+azKrdVZgAADWZmVXKqzAAAMzMqqqu61rW9gAAeb3vfe973nOc96AABrMzKq5znPYAADMzKq5znPYAADMzKqvlVmAAAD3nm5JEkg++t6AAfpJAPgAAAFttttAFttttAAAAAAAAqqrmta13WtaVVVznOWta1nQAAPNb3vfe973nOc96AABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAAB8zMyqqq7rWtb2AAB5ve9973ve1WYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAAHfmta8839999+en37973vaqqgAAAAAFttttAAAAAAAAAAAAH0klvtttoMkk++888AAHm9733ve97VZgAAHvvtVzlVmAAPhrQa1mZlVyqvc1r4a0+AB777Vc5VZgAAPffar7yqz5gABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVXfADOW222222224pgACDOZzznOc4W2220AAAAAa1AcDYAAAAAAAAAAABmpqaAGFZgAAGZmVVVWYAAB7rWtYzKqqrMAAA9xmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVXda1rewAAPN73vve972qzAAAMzMqqqswAADMzKqqrMAAAu/Na+fPnz5J9UqVqSpUkm9Sqqqk0Hhv77775eGgAKAB7JIA6Fttt6tttoAAAAABbbbbQAAAB2STckl9tvLaDnPPPPAADMzKqqrMAAAzMyqqqzAAAMzMqqqu61rW9gAAeb3vfe973tVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAGjWZmVVXd3WG22222223W3xCFeoQhR0hCLxj8c+++UAABVVVQAAFQADi222gAAAAAFttttAAAAH9NTUkgA7VZgAAGZmVVVWYDQAM99quc5VmAAAe5mVVcqzAAAM99quc5V5mAAAZ/ZlVVVmAAAZ77Vc5yruta1vYAAHmfN733ve97yrMAAA9+ZmVVcq8zAAAMzKrnOVZgAAH9e+fPP7Wta+61Jzmb2vFUAAAA5JIaAQAAFbbbb1bbbQAAAAAVQAAFVVUA3JIHggAckk7Wvmta/fNfNfPP2u973ve/qrMAAAzMyqqqzAAAMzMqqqv2ta1vYAAHm8zve9rnazAAAPdZmVVXOe+gAAWvfarnLnPfQAAPfdLKquff7+AAA5e1XOXOe+9+a1rzwAAO71vfe97VVmAAAZmZVVVZgAAGtt/3fPvmvPPv3ve9u1znNa5znOcqqgttttotttvVtttAAAAAALbbbaAAAtADsqpX1SpXJJPJUqUvq/d735xdSSZgAAHmZ5lVVVmAAAZmZVVVd1rWt7AAA83md73tc7WYAAB7rMyqrlWYGgAMzMqqqswAADMzKqqrMAAAz32q5zlXda1rewB8fGvM23vve9u1WYAABmZlVVVmAAAefta1r5z5rWvv37ne/ZmCCQAAFtttaPezUAFoAttttoAAAAP0kgHwAABbbbf7U1Ne61rXuta1znOe83y52swAAD3GZVVVZgAAGZmVVVWYAABnvtVznKswAAD3GZVVVd1rWt7AAA83ve+973varMAAAz32q5zlWYAAB7jMqqqswAADMzKqqrMAAAz32q5zlXda1rewAAPP2+du/P39vXu/37e/vP36qrWqqqqVVAAAVAAOIAAgAAKqgAAAAAAAAAA1mSSfVJUknkknqt7V6K5mta1oABmZlVVVmHfmta88H7z++a1r+8bbbcxKA1rWuuuuuuXd3jDbbb6jpAQEy2224iUBrOeuuuuXvq7xhttt9R0gJhtts39ffv79+/VVd1rWt7AAA83ve+973varMAAAz32q5zlWYAAB7rMyqrlWYAABnvtVznKswAAD3GZVVVd1rWt7bbbbbbGyOc6QhShCxzoiOt7N3zoxuMJz0m+N4mcb83t3rPNe+9ztme+Tl+91rr5zvlUuUWUspaSzSWQ0lj+ylwks3XDhJa0lmkv75++usZJwymoqXJLUExA8PbQZaQF4hvMCQpicarL1oBLUaM2hCtCFORAMabQlmkuH9z04kvpVkJqqPgrKWklpLSWBOJLVTEHbiS4FEyS1INSWklpLKlpLSWkvilpLiSyliS1JZJf3BJcFLFFklpLSXElwkuKVTVS1SpaSyS0lqV8ksKVXkqVK99qVKk9qSVUd+cfM48BVVVUAAAAAAAADve973vQAA73ve970AAH2972OgAASW2220AANAAAALbbbaAAAAAAC2222gABbbbbQAAAAAAd73ve96AHZJD0AAAAAAAADve973vQAAW2220AALbbbaAAFttttAAAAAAA+++++++AAAd73ve96OSSBsAOzve973oAAC2222gAAAAAAAAAAC2222gAAAAAAmi2222gAAAAAAAAAAC2222gAAAAAAf4AGAABZLbbbQAAAAAAFttttAAAAAAAW2220AAAAAAAAAAAW2220AAAAAABbbbbQAAAAAAAAAABbbbbQAAAAAAAAAABZLbbbQAW2220AAALbbbaAO++++++++UlxpLtS7SrSXQdByHQfQ7ksku6S7ktITSWJLSWpLv7/hUvwfv37zr9+78VAkAAVVVUAABUAA4sqOGzjYAAAAAAAAAAFttt+kkzUkkn+PJC5u7u75vq750wbSE2CQmwSFpaTbbAH9rWvmvnzevv37+/fv3e8qzAAAPczKquV/a1rVngAAGs99quc5VmAAAZmsyuc5znOd1rWt7a0ADzv379+973vec5zMAAA9zM5znOfec5mAAAZ77znPv37znMwAADM+azOf3z5riqsr3WtawAAB6ZmVVcqzAAAP68+61rXe878WV6BAAA/SSAfALbbb1bbbQAAAAAAAAAAHkkltttuta1a1rXda1p5VVd5V3Wta3sAADzeZ3ve1ztZgAAHuszKquVZgAAGe+1XOcqzAAAM99quc5VmAAAZ77Vc5yrMAAAzMyqqq7rWtb2AAHnzWteeeb3vfe973tVmAd+a1rzwA8+a1rzze9773vaqswDvzWteeAHnzQRGc5zznOXd3d4w223xARDbbbcICIM/u95455yamprP2zf2GAttttoAAAALbbbaAAAABbbbbQAAAABd8QhaAOkIXOTznOc51e91TbbfSAiG2HmvGvmteed23vve9q5z30AAD3vd773ve97V3Wta3sAADze9773ve9qswAADMzKqqrMAAAzMyqqq81rWswA0fDzGZVVVZgAAGZmVVVXda1rewAAPN73vve972qzAAAMzMqqqswAAD+5qta1rnM5m/gW973verQAAAAW2220AAAAC2222gAAAAA8kkySSagC3arMAGgGZmVVVWYAABmZlVVV3Wta3sAADze9773ve9qswAADMzKqqrMAAA3rWtb3vdX2qrMAAA3re97q+1VZgAAGZmVVVXda1rewAAPN73vve972qzAAAMzMqqqswAADfPvqlSvoe633vvfnvwHO85znOIKqqqoAAW2220AAAAC2222gAALbbbaB5Na1znOc5z7yqswAADet73ur7VVmAAAZmZVVVfta1rewAAPN7zve9rnO2YAAB/ZmVVc5WYAABmZlVVVmAB3Wta88888De9773vaqswAADMzKqqruta1vYAAHm9733ve97VZgAAGZmVVVWYBrWta1rWta0+5OyqlXUk57zO970D0OhgAUAAAAHoDoAAAABbbbbQAAFAABVWpJ2pUq5JFVxXqrma1rWgAGZmVVVWZoAAMzMqqqu61rW9gAAeb3vfe973tVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVVmAAPj5mZlVVV3Wta382AAeb3vfe973tVmAAAZmZVVVZgAAHHnfmvmvn75rXzVrWte1X9n9f4C2222gAWSR4AAAAAA/szMzMzMAAAAAAW2220OySCSTEhC2AMA2ATzmK5zfN73vGG222222w7ve91VznOZgAAGZmc5yqqzAAAMzMqqqswAADMzKqqrMAAAzMquc5zlmAAAeZmVVc5yzAAAMzKrnOc5d1rWt7AAA83ve/ne973tVmAAAZmVXOc5yzAbbbbbbbMXWuZxCEKjM73W+c5y7ve9a1rXVoBbbbbQAAAAAAAAAAAACAANKqvZUqVuSRPAA6B3M1rWtaAAzMyqqqzAAAMzMqqqswAADMzKqqrMAAAzMyqque+gAAWZ5lVVc99AAA99sqqrnda1rMANGnxrz+1md73ve95znz+9AAB777VVVz30AAD32zNa1qq9q576AAAteZn9lVVVVVUAAAAAAAAAAAAAAAAAAACqvalSvJJNSVKlfVKld73ve9e/VWYAABmZma1rVV7VWYAAAzMyq5VWYAABmZlVVVmA1oBmZlVVVmAAAZmZVVVZgAAGZmVVVWYAABmZma1rVV7VWYAAAzMyq5VWYAABmZlVVV+1rWt7AAA8+vnzXya973vczGAAAANSQLbbbaAAAAAAAAAAAALbbbaBkkk+aqqq7VZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAHfmta88A3ve+972qruta1vYAAHm973vWta73vfe1WYAAAzMyq5VWYAABmZlVVVmAAAZmZVVVZgAbbbbcQ3c5xneWJCoxCELaEKUIVM3z9+73O/XOktJfQ1BP6S2kuJLSXCE4ksKXBVsksku6poJxJZBPsllLiS0llL5xJfUl8cKg4kvgcETjVUdZ9VUfJLmS0l8qo+SS4kuCiySylxJaqjSS0l8kviTJLiqjiS4ktJcKKtIspcVUcQknvmpqa95uSTn6a1vUk733v1WgAAAAAAAAAAd73ve96AAHe973vegAAtvve9719aAABIAAAAe+TzQDoAALbbbaAAAAAAC2222gABbbbbQAAAAAAW2220AAAAAAAAAAB9rvne973oAAG5qA4ttttoByalt/W20AALbbbaAAAAAAB+l8tt3bQAACW2220AAF73ve96oAAAAAAC2222gAAAAAALbbbaAAAAAAD6D8AAABbbbbQAAAAAAFttttAGwcAAAAH+ABgAAW2220AAAAAAAAAAAW2220AAAAB+kkA+BbbbbQAAAA5JIGwAttttoAAAAAAAAAAAttttoAAAAAAC2222gAAAAAAAAAAC2222gAAAAAAAAAADc1Na1zU1NezzU1NcB2oaqjgP0l3IYOw0l8D6HFVH8Gkvkl8ku4JsktVS6D+SXsl/Q7+ff3ff7vBbbbbQAAttttoAAAAABbbbbQAAAAOSSBsA7JJ/iampr+1rUG0CbbbbAbHyec5zXOc65znNo6GNpNlsptVsizUNjWojazLY2ZlbIm1FtRjTZYzQa+aNaNPjT4NfPmtffoAAHj5Y2jZm2bMxtmzNs20zZttZtJtG02Wxmba01n9/f39+/fv379VZgAAGZmZrWtc5z+5znOZgaPgC3ve6uXOc5mAAAZmZfJr5qqqswAADm973VXOc5b2AABve91c5znOZgAAFre97vuta1XlznOZgAADMzOc595znOZgAAGZmc5znOc5zMAAaGszPv3WtazMz7XOVVVVVVQDUkAP0kgHwAAAAAC2222gAAAAAAEkiST2STJJOySfszM727znOd1rWt7AAA83ve+973varMAAAzMyqqqzAAAMzMqqqswAADMzKrnOc5YAAAzMyquc5zuta13YAAHm9733ve3Oc53AAAMzMqr5VWYAABmZlVznOcsAAAzMyq5znOWAAAa8u85uefeW25gAAAAAAAAAAAAC2222gAALbbbaAAZqamv7U1r418181873ve973v6q7rWtb2AAB5ve9973ve1WYAABmZlVVVmAAAZmZVVVZgAAGZmVVVWYAABmZlVVVmAAAZmZVVVd1rWt7AAA83ve+973varMAADTMzKrlVe4AADMzKqqrMANa1rWta1o7VVVSfSqlegHx998qAAAqAAAAAAAAP7MzMzMzLbbbaAAAttttoAB5JJ/amprckgOKwOc88888AAZmZVVVZgAAGZmVVVfta1rMAAA87ve/7ve972rzWta99AAA8177VVVe+gAAe++1VVXvoAAPffaq4Dk5rySc5zgUHJqb3vYUGSSfTU85znMzMYHJqfXf9JNatu7ncYAAAAAABbbbbQAAAAAAAALaAAqqqqu5JPqqqqT7VSpWpKk72+9V+AMlT7MzFRAMlS7uwOABkqXd2BwAMlRrMzFRAPpJNyprMzFRAMlS7uwOABkqXd2BwAMlS7uwOABkqXd2BwAMlTvt/c57fO873qqqqgAAAALbbbaAAAAAAAABbbbWj0AB2ST+mpqa/tTU1n7Mwf1tvZJNyprMzH6Su9equSoZmY4oquSoZmYqIBlU5mYqIBlVd3YqKr2STcqa073vfe9OgGVUczMVEAypKu7sVFVypRmZiogGSp7ySTkknOXzg2hbbbbQAAAFkkeAAAAAAAAAAAW2220AASSRJJkkmu971VAGSTcqa7N73vvevQDJUu7sDgAZKl3djJSiq5KhmszFRQMlS7uwOABkqMzMxUQDJUu7sDgAZKl3dioquSoZmYqIA9kk5KmuQ9LZPD6c97ffvj74AABAAAVXUkiAoAAAAAAAAAAALbbbaAAv1SpVqrlVFequSoZmYqIBkqOZmKnOc5cqOZmAHOc5cqMu7A4c5y5Uu7vgAAXKl3dgAqvZJNyprMzO9716HJqb3vYUHJqb3vYUHJqec4993vMVQAAEAABVVVVQAAAAAALbbbaAAAAAAAAPJJLbbb2g5Jqb3vYUGSSfak85znMzMYHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYUHJqb3vYUHJqOc5wVbbyam972FBkkn01PO+973vczBrWi229vnVtttAAAAAAAAttttoAAAAAAAA+kk+kkzU1NdkkOc2GByam972FByam972FByam972FByam972FBkkn01POc5zMzGByam972FByam972FByam972FByam972FBkkn01PPs5zyMns83OHUu5jGtcnAkJoQtIQoQhNCFpCFAkKRIUjRGjGqQuNCFtCFe51i6El9ifzdnclxUtJcUQZJZJcSWgmktSWktJaSylklpLhJcKqOJLgkuEUuP74pfBJalU+VUcAmksSXClhXGqqOdJfclNJqTW5rU15J9r31v918AAAAAAAAAAAW2220AAGtattttoAAW9++++d6oAAJAAAAH6228toAAW2220AAAAAAFttttAAAAAAAAAAAW32SS2210AAAAAAW2220AAO973ve9AABbbbbQAAttttoAAW2220AAAACqqqrN73ve9qqAAAqgAAKAAFjy2222gAAAAAALbbbaAAAAAAAttttoAAAAAAcDYAAAFttttAAAAAAAW2220AAAAAAD/AAwAALbbbaAAAAAAAAAAALJbbbaAAAAAAAttttoAAAAAAC2222gAAAAAAAAAAC2222gAAAP0kgHwALbbbaAAAAAAAAAAALbbbaAAAAAAAAAA77777777/XXQkvil0G5DngOw4D7I/g/kl19ku5LkOQ7DoPsl2pdSX0NVR84ktJcBwH2qT7JdSWqoypcEibEkKBCE0IQmIQtYd3O961u971rWtddW220AAAAAAAC2222gAALbbbaAAAHZJL5bbbQckn95Oc5zMzLgcmpve9hQcmpve9hQcmpve9hQZJJ9NTznOczMxgcmpve9hQc1qTe97Cg5JN73sKDk1N73sqKrkqe75JJqSTnL5xQQAAFVQAAAB+kkA+AAAW2220AABbbbbQAAASSJJMkk+kk9zMzmZmByVLu7VRVdSSZKmrvy1UVXJUu72FByam972fij55JJyanm9+7Cg5NTe97Cg5NTe97Cg5NTe97FFVyVLu7X1RXbqSTJU1hzuDNa3XiszuLbbbaAAAAAAAAAAAAAAFttttAAAC2222g5NTe97Cg5NTe97Cg5NTe97Cg5NTe97PxR88kk5NTzU3v3YUHJqb3vYUHJqb3vYUHJqb3vYVQuVGXdr6omGpJLlTXtSpb57iqhzne96tAAAAAPQHQAAAAA2DgLbba0egAADs9kkvttt7Qcmpve9hQcmpve9hQc1re97Cg5NTe97PxR88kk5NTze/dhQZJJ9NTznOczMxgcmpve9hQcmpve9hQcmpve9hQcmp9uam/Pvvf3woP01oHHgAAAAAAAAAAAAAAttttoAAAfSSckkuNuBmDckmSSfTU89++++zMzAcmpve9hQcmpve9hQcmpve9hQcmpve9hQaknJqeb3v8FBkkn01POc5zMzGByam972FByam972FB7JJyannNvwKlSvpcN7OffffAAAKqqqqqqoAAAAAAAAAAFttttAAADskm5JDw9ABVclS7u1UVXJUu7tVQcmpve9hQcmpve9hQeySZJJ9NT33nvOZmYwOTU3vewoOTU3vewoOTU3vewoOak3vewoPZJOTU898ySTskne779mZct73ve9WgAHskgDoACySPAAW23AzMzMAAAAAAAALbJJdSS22gGSSfTU85znMzMYHJqb3vYUHJqb3vYUHJqb3vYUHsknJqeb83sKDk1N73sIquSpdyXaqKrkqXcl2pwAOyQyIfM5DOec5fN73uADAh4icc1jVcnCELqS1UhqoxS0lhUmktEqZS1KkaSxKmSWpVSVWe4+n3z34Oc5znEFQAAFVVAAAAFttzUDMzMwAAAAAAAAtz+1VGkVaS0l32d999++ee99998p9+t7Cg5NT9N72FUcmp+m97CqOTU3+/B1Ryam/34OqMkk+mp5ze8zMuXDk1N/vwdUcmpve9hQcmpve99999/u+++++U/Q8kvSSy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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(tag[2], TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

